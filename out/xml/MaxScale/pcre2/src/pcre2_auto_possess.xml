<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/pcre2/src/pcre2_auto_possess.c"><comment type="block" format="doxygen">/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/</comment>

<comment type="block">/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
     Original API code Copyright (c) 1997-2012 University of Cambridge
          New API code Copyright (c) 2016-2020 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/</comment>

<comment type="block">/* This module contains functions that scan a compiled pattern and change
repeats into possessive repeats where possible. */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_internal.h"</cpp:file></cpp:include>


<comment type="block" format="doxygen">/*************************************************
*        Tables for auto-possessification        *
*************************************************/</comment>

<comment type="block">/* This table is used to check whether auto-possessification is possible
between adjacent character-type opcodes. The left-hand (repeated) opcode is
used to select the row, and the right-hand opcode is use to select the column.
A value of 1 means that auto-possessification is OK. For example, the second
value in the first row means that \D+\d can be turned into \D++\d.

The Unicode property types (\P and \p) have to be present to fill out the table
because of what their opcode values are, but the table values should always be
zero because property types are handled separately in the code. The last four
columns apply to items that cannot be repeated, so there is no need to have
rows for them. Note that OP_DIGIT etc. are generated only when PCRE_UCP is
*not* set. When it is set, \d etc. are converted into OP_(NOT_)PROP codes. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APTROWS</name></cpp:macro> <cpp:value>(LAST_AUTOTAB_LEFT_OP - FIRST_AUTOTAB_OP + 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APTCOLS</name></cpp:macro> <cpp:value>(LAST_AUTOTAB_RIGHT_OP - FIRST_AUTOTAB_OP + 1)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>autoposstab</name><index>[<expr><name>APTROWS</name></expr>]</index><index>[<expr><name>APTCOLS</name></expr>]</index></name> <init>= <expr><block>{
<comment type="block">/* \D \d \S \s \W \w  . .+ \C \P \p \R \H \h \V \v \X \Z \z  $ $M */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* \D */</comment>
  <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr> }</block></expr>,  <comment type="block">/* \d */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr> }</block></expr>,  <comment type="block">/* \S */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* \s */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* \W */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr> }</block></expr>,  <comment type="block">/* \w */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* .  */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* .+ */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* \C */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* \P */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* \p */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* \R */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* \H */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* \h */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* \V */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* \v */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>   <comment type="block">/* \X */</comment>
}</block></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<comment type="block">/* This table is used to check whether auto-possessification is possible
between adjacent Unicode property opcodes (OP_PROP and OP_NOTPROP). The
left-hand (repeated) opcode is used to select the row, and the right-hand
opcode is used to select the column. The values are as follows:

  0   Always return FALSE (never auto-possessify)
  1   Character groups are distinct (possessify if both are OP_PROP)
  2   Check character categories in the same group (general or particular)
  3   TRUE if the two opcodes are not the same (PROP vs NOTPROP)

  4   Check left general category vs right particular category
  5   Check right general category vs left particular category

  6   Left alphanum vs right general category
  7   Left space vs right general category
  8   Left word vs right general category

  9   Right alphanum vs left general category
 10   Right space vs left general category
 11   Right word vs left general category

 12   Left alphanum vs right particular category
 13   Left space vs right particular category
 14   Left word vs right particular category

 15   Right alphanum vs left particular category
 16   Right space vs left particular category
 17   Right word vs left particular category
*/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>propposstab</name><index>[<expr><name>PT_TABSIZE</name></expr>]</index><index>[<expr><name>PT_TABSIZE</name></expr>]</index></name> <init>= <expr><block>{
<comment type="block">/* ANY LAMP GC  PC  SC ALNUM SPACE PXSPACE WORD CLIST UCNC */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* PT_ANY */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">3</literal></expr>,    <expr><literal type="number">1</literal></expr>,      <expr><literal type="number">1</literal></expr>,   <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* PT_LAMP */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">4</literal></expr>,  <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">9</literal></expr>,   <expr><literal type="number">10</literal></expr>,     <expr><literal type="number">10</literal></expr>,  <expr><literal type="number">11</literal></expr>,    <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* PT_GC */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">5</literal></expr>,  <expr><literal type="number">2</literal></expr>,  <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">15</literal></expr>,   <expr><literal type="number">16</literal></expr>,     <expr><literal type="number">16</literal></expr>,  <expr><literal type="number">17</literal></expr>,    <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* PT_PC */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">2</literal></expr>,    <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* PT_SC */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">3</literal></expr>,  <expr><literal type="number">6</literal></expr>, <expr><literal type="number">12</literal></expr>,  <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">3</literal></expr>,    <expr><literal type="number">1</literal></expr>,      <expr><literal type="number">1</literal></expr>,   <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* PT_ALNUM */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">7</literal></expr>, <expr><literal type="number">13</literal></expr>,  <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">1</literal></expr>,    <expr><literal type="number">3</literal></expr>,      <expr><literal type="number">3</literal></expr>,   <expr><literal type="number">1</literal></expr>,    <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* PT_SPACE */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">1</literal></expr>,  <expr><literal type="number">7</literal></expr>, <expr><literal type="number">13</literal></expr>,  <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">1</literal></expr>,    <expr><literal type="number">3</literal></expr>,      <expr><literal type="number">3</literal></expr>,   <expr><literal type="number">1</literal></expr>,    <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* PT_PXSPACE */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">8</literal></expr>, <expr><literal type="number">14</literal></expr>,  <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">1</literal></expr>,      <expr><literal type="number">1</literal></expr>,   <expr><literal type="number">3</literal></expr>,    <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* PT_WORD */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* PT_CLIST */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,  <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">0</literal></expr>,   <expr><literal type="number">3</literal></expr> }</block></expr>   <comment type="block">/* PT_UCNC */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* This table is used to check whether auto-possessification is possible
between adjacent Unicode property opcodes (OP_PROP and OP_NOTPROP) when one
specifies a general category and the other specifies a particular category. The
row is selected by the general category and the column by the particular
category. The value is 1 if the particular category is not part of the general
category. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>catposstab</name><index>[<expr><literal type="number">7</literal></expr>]</index><index>[<expr><literal type="number">30</literal></expr>]</index></name> <init>= <expr><block>{
<comment type="block">/* Cc Cf Cn Co Cs Ll Lm Lo Lt Lu Mc Me Mn Nd Nl No Pc Pd Pe Pf Pi Po Ps Sc Sk Sm So Zl Zp Zs */</comment>
  <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr> }</block></expr>,  <comment type="block">/* C */</comment>
  <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr> }</block></expr>,  <comment type="block">/* L */</comment>
  <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr> }</block></expr>,  <comment type="block">/* M */</comment>
  <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr> }</block></expr>,  <comment type="block">/* N */</comment>
  <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr> }</block></expr>,  <comment type="block">/* P */</comment>
  <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr> }</block></expr>,  <comment type="block">/* S */</comment>
  <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>   <comment type="block">/* Z */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* This table is used when checking ALNUM, (PX)SPACE, SPACE, and WORD against
a general or particular category. The properties in each row are those
that apply to the character set in question. Duplication means that a little
unnecessary work is done when checking, but this keeps things much simpler
because they can all use the same code. For more details see the comment where
this table is used.

Note: SPACE and PXSPACE used to be different because Perl excluded VT from
"space", but from Perl 5.18 it's included, so both categories are treated the
same here. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>posspropstab</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{
  <expr><block>{ <expr><name>ucp_L</name></expr>, <expr><name>ucp_N</name></expr>, <expr><name>ucp_N</name></expr>, <expr><name>ucp_Nl</name></expr> }</block></expr>,  <comment type="block">/* ALNUM, 3rd and 4th values redundant */</comment>
  <expr><block>{ <expr><name>ucp_Z</name></expr>, <expr><name>ucp_Z</name></expr>, <expr><name>ucp_C</name></expr>, <expr><name>ucp_Cc</name></expr> }</block></expr>,  <comment type="block">/* SPACE and PXSPACE, 2nd value redundant */</comment>
  <expr><block>{ <expr><name>ucp_L</name></expr>, <expr><name>ucp_N</name></expr>, <expr><name>ucp_P</name></expr>, <expr><name>ucp_Po</name></expr> }</block></expr>   <comment type="block">/* WORD */</comment>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>



<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<comment type="block" format="doxygen">/*************************************************
*        Check a character and a property        *
*************************************************/</comment>

<comment type="block">/* This function is called by compare_opcodes() when a property item is
adjacent to a fixed character.

Arguments:
  c            the character
  ptype        the property type
  pdata        the data for the type
  negated      TRUE if it's a negated property (\P or \p{^)

Returns:       TRUE if auto-possessifying is OK
*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>check_char_prop</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>ptype</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pdata</name></decl></parameter>,
  <parameter><decl><type><name>BOOL</name></type> <name>negated</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ucd_record</name> <modifier>*</modifier></type><name>prop</name> <init>= <expr><call><name>GET_UCD</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch<condition>(<expr><name>ptype</name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><name>PT_LAMP</name></expr>:</case>
  <return>return <expr><operator>(</operator><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name>ucp_Lu</name> <operator>||</operator>
          <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name>ucp_Ll</name> <operator>||</operator>
          <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name> <operator>==</operator> <name>ucp_Lt</name><operator>)</operator> <operator>==</operator> <name>negated</name></expr>;</return>

  <case>case <expr><name>PT_GC</name></expr>:</case>
  <return>return <expr><operator>(</operator><name>pdata</name> <operator>==</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index><operator>)</operator> <operator>==</operator> <name>negated</name></expr>;</return>

  <case>case <expr><name>PT_PC</name></expr>:</case>
  <return>return <expr><operator>(</operator><name>pdata</name> <operator>==</operator> <name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name><operator>)</operator> <operator>==</operator> <name>negated</name></expr>;</return>

  <case>case <expr><name>PT_SC</name></expr>:</case>
  <return>return <expr><operator>(</operator><name>pdata</name> <operator>==</operator> <name><name>prop</name><operator>-&gt;</operator><name>script</name></name><operator>)</operator> <operator>==</operator> <name>negated</name></expr>;</return>

  <comment type="block">/* These are specials */</comment>

  <case>case <expr><name>PT_ALNUM</name></expr>:</case>
  <return>return <expr><operator>(</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_L</name> <operator>||</operator>
          <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_N</name><operator>)</operator> <operator>==</operator> <name>negated</name></expr>;</return>

  <comment type="block">/* Perl space used to exclude VT, but from Perl 5.18 it is included, which
  means that Perl space and POSIX space are now identical. PCRE was changed
  at release 8.34. */</comment>

  <case>case <expr><name>PT_SPACE</name></expr>:</case>    <comment type="block">/* Perl space */</comment>
  <case>case <expr><name>PT_PXSPACE</name></expr>:</case>  <comment type="block">/* POSIX space */</comment>
  <switch>switch<condition>(<expr><name>c</name></expr>)</condition>
    <block>{<block_content>
    <label><name>HSPACE_CASES</name>:</label>
    <label><name>VSPACE_CASES</name>:</label>
    <return>return <expr><name>negated</name></expr>;</return>

    <default>default:</default>
    <return>return <expr><operator>(</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_Z</name><operator>)</operator> <operator>==</operator> <name>negated</name></expr>;</return>
    </block_content>}</block></switch>
  <break>break;</break>  <comment type="block">/* Control never reaches here */</comment>

  <case>case <expr><name>PT_WORD</name></expr>:</case>
  <return>return <expr><operator>(</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_L</name> <operator>||</operator>
          <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name><name>prop</name><operator>-&gt;</operator><name>chartype</name></name></expr>]</index> <operator>==</operator> <name>ucp_N</name> <operator>||</operator>
          <name>c</name> <operator>==</operator> <name>CHAR_UNDERSCORE</name><operator>)</operator> <operator>==</operator> <name>negated</name></expr>;</return>

  <case>case <expr><name>PT_CLIST</name></expr>:</case>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_caseless_sets</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>prop</name><operator>-&gt;</operator><name>caseset</name></name></expr>;</expr_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>!</operator><name>negated</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>negated</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  <break>break;</break>  <comment type="block">/* Control never reaches here */</comment>
  </block_content>}</block></switch>

<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>



<comment type="block" format="doxygen">/*************************************************
*        Base opcode of repeated opcodes         *
*************************************************/</comment>

<comment type="block">/* Returns the base opcode for repeated single character type opcodes. If the
opcode is not a repeated character type, it returns with the original value.

Arguments:  c opcode
Returns:    base opcode for the type
*/</comment>

<function><type><specifier>static</specifier> <name>PCRE2_UCHAR</name></type>
<name>get_repeat_base</name><parameter_list>(<parameter><decl><type><name>PCRE2_UCHAR</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>c</name> <operator>&gt;</operator> <name>OP_TYPEPOSUPTO</name><operator>)</operator></expr>?</condition><then> <expr><name>c</name></expr> </then><else>:
       <expr><ternary><condition><expr><operator>(</operator><name>c</name> <operator>&gt;=</operator> <name>OP_TYPESTAR</name><operator>)</operator></expr>?</condition><then>   <expr><name>OP_TYPESTAR</name></expr> </then><else>:
       <expr><ternary><condition><expr><operator>(</operator><name>c</name> <operator>&gt;=</operator> <name>OP_NOTSTARI</name><operator>)</operator></expr>?</condition><then>   <expr><name>OP_NOTSTARI</name></expr> </then><else>:
       <expr><ternary><condition><expr><operator>(</operator><name>c</name> <operator>&gt;=</operator> <name>OP_NOTSTAR</name><operator>)</operator></expr>?</condition><then>    <expr><name>OP_NOTSTAR</name></expr> </then><else>:
       <expr><ternary><condition><expr><operator>(</operator><name>c</name> <operator>&gt;=</operator> <name>OP_STARI</name><operator>)</operator></expr>?</condition><then>      <expr><name>OP_STARI</name></expr> </then><else>:
                             <expr><name>OP_STAR</name></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*        Fill the character property list        *
*************************************************/</comment>

<comment type="block">/* Checks whether the code points to an opcode that can take part in auto-
possessification, and if so, fills a list with its properties.

Arguments:
  code        points to start of expression
  utf         TRUE if in UTF mode
  ucp         TRUE if in UCP mode
  fcc         points to the case-flipping table
  list        points to output list
              list[0] will be filled with the opcode
              list[1] will be non-zero if this opcode
                can match an empty character string
              list[2..7] depends on the opcode

Returns:      points to the start of the next opcode if *code is accepted
              NULL if *code is not accepted
*/</comment>

<function><type><specifier>static</specifier> <name>PCRE2_SPTR</name></type>
<name>get_chr_property_list</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>utf</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>ucp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>fcc</name></decl></parameter>,
  <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>code</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>chr</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>clist_dest</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>clist_src</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>utf</name></expr>;</expr_stmt>    <comment type="block">/* Suppress "unused parameter" compiler warnings */</comment>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>ucp</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>code</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <name>OP_STAR</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <name>OP_TYPEPOSUPTO</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>get_repeat_base</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>c</name> <operator>-=</operator> <operator>(</operator><name>base</name> <operator>-</operator> <name>OP_STAR</name><operator>)</operator></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>OP_UPTO</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>OP_MINUPTO</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>OP_EXACT</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>OP_POSUPTO</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>code</name> <operator>+=</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>!=</operator> <name>OP_PLUS</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>OP_MINPLUS</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>OP_EXACT</name> <operator>&amp;&amp;</operator>
             <name>c</name> <operator>!=</operator> <name>OP_POSPLUS</name><operator>)</operator></expr>;</expr_stmt>

  <switch>switch<condition>(<expr><name>base</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>OP_STAR</name></expr>:</case>
    <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>OP_CHAR</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_STARI</name></expr>:</case>
    <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>OP_CHARI</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_NOTSTAR</name></expr>:</case>
    <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>OP_NOT</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_NOTSTARI</name></expr>:</case>
    <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>OP_NOTI</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_TYPESTAR</name></expr>:</case>
    <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>code</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>code</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></switch>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<switch>switch<condition>(<expr><name>c</name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><name>OP_NOT_DIGIT</name></expr>:</case>
  <case>case <expr><name>OP_DIGIT</name></expr>:</case>
  <case>case <expr><name>OP_NOT_WHITESPACE</name></expr>:</case>
  <case>case <expr><name>OP_WHITESPACE</name></expr>:</case>
  <case>case <expr><name>OP_NOT_WORDCHAR</name></expr>:</case>
  <case>case <expr><name>OP_WORDCHAR</name></expr>:</case>
  <case>case <expr><name>OP_ANY</name></expr>:</case>
  <case>case <expr><name>OP_ALLANY</name></expr>:</case>
  <case>case <expr><name>OP_ANYNL</name></expr>:</case>
  <case>case <expr><name>OP_NOT_HSPACE</name></expr>:</case>
  <case>case <expr><name>OP_HSPACE</name></expr>:</case>
  <case>case <expr><name>OP_NOT_VSPACE</name></expr>:</case>
  <case>case <expr><name>OP_VSPACE</name></expr>:</case>
  <case>case <expr><name>OP_EXTUNI</name></expr>:</case>
  <case>case <expr><name>OP_EODN</name></expr>:</case>
  <case>case <expr><name>OP_EOD</name></expr>:</case>
  <case>case <expr><name>OP_DOLL</name></expr>:</case>
  <case>case <expr><name>OP_DOLLM</name></expr>:</case>
  <return>return <expr><name>code</name></expr>;</return>

  <case>case <expr><name>OP_CHAR</name></expr>:</case>
  <case>case <expr><name>OP_NOT</name></expr>:</case>
  <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>chr</name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>chr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>NOTACHAR</name></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>

  <case>case <expr><name>OP_CHARI</name></expr>:</case>
  <case>case <expr><name>OP_NOTI</name></expr>:</case>
  <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>c</name> <operator>==</operator> <name>OP_CHARI</name><operator>)</operator></expr> ?</condition><then> <expr><name>OP_CHAR</name></expr> </then><else>: <expr><name>OP_NOT</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>chr</name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>chr</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>chr</name> <operator>&lt;</operator> <literal type="number">128</literal> <operator>||</operator> <operator>(</operator><name>chr</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>utf</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>ucp</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>fcc</name><index>[<expr><name>chr</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>chr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>SUPPORT_WIDE_CHARS</name></expr></cpp:elif>
  <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>chr</name> <operator>&lt;</operator> <literal type="number">256</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>fcc</name><index>[<expr><name>chr</name></expr>]</index></name></expr> </then><else>: <expr><name>chr</name></expr></else></ternary></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>fcc</name><index>[<expr><name>chr</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* The othercase might be the same value. */</comment>

  <if_stmt><if>if <condition>(<expr><name>chr</name> <operator>==</operator> <name><name>list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>NOTACHAR</name></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>NOTACHAR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <return>return <expr><name>code</name></expr>;</return>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <case>case <expr><name>OP_PROP</name></expr>:</case>
  <case>case <expr><name>OP_NOTPROP</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>PT_CLIST</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <return>return <expr><name>code</name> <operator>+</operator> <literal type="number">2</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Convert only if we have enough space. */</comment>

  <expr_stmt><expr><name>clist_src</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_caseless_sets</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>clist_dest</name> <operator>=</operator> <name>list</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>code</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

  <do>do <block>{<block_content>
     <if_stmt><if>if <condition>(<expr><name>clist_dest</name> <operator>&gt;=</operator> <name>list</name> <operator>+</operator> <literal type="number">8</literal></expr>)</condition>
       <block>{<block_content>
       <comment type="block">/* Early return if there is not enough space. This should never
       happen, since all clists are shorter than 5 character now. */</comment>
       <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
       <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
       <return>return <expr><name>code</name></expr>;</return>
       </block_content>}</block></if></if_stmt>
     <expr_stmt><expr><operator>*</operator><name>clist_dest</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>clist_src</name></expr>;</expr_stmt>
     </block_content>}</block>
  while<condition>(<expr><operator>*</operator><name>clist_src</name><operator>++</operator> <operator>!=</operator> <name>NOTACHAR</name></expr>)</condition>;</do>

  <comment type="block">/* All characters are stored. The terminating NOTACHAR is copied from the
  clist itself. */</comment>

  <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>c</name> <operator>==</operator> <name>OP_PROP</name><operator>)</operator></expr> ?</condition><then> <expr><name>OP_CHAR</name></expr> </then><else>: <expr><name>OP_NOT</name></expr></else></ternary></expr>;</expr_stmt>
  <return>return <expr><name>code</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <case>case <expr><name>OP_NCLASS</name></expr>:</case>
  <case>case <expr><name>OP_CLASS</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_WIDE_CHARS</name></cpp:ifdef>
  <case>case <expr><name>OP_XCLASS</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>OP_XCLASS</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>end</name> <operator>=</operator> <name>code</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>end</name> <operator>=</operator> <name>code</name> <operator>+</operator> <literal type="number">32</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <switch>switch<condition>(<expr><operator>*</operator><name>end</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>OP_CRSTAR</name></expr>:</case>
    <case>case <expr><name>OP_CRMINSTAR</name></expr>:</case>
    <case>case <expr><name>OP_CRQUERY</name></expr>:</case>
    <case>case <expr><name>OP_CRMINQUERY</name></expr>:</case>
    <case>case <expr><name>OP_CRPOSSTAR</name></expr>:</case>
    <case>case <expr><name>OP_CRPOSQUERY</name></expr>:</case>
    <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CRPLUS</name></expr>:</case>
    <case>case <expr><name>OP_CRMINPLUS</name></expr>:</case>
    <case>case <expr><name>OP_CRPOSPLUS</name></expr>:</case>
    <expr_stmt><expr><name>end</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CRRANGE</name></expr>:</case>
    <case>case <expr><name>OP_CRMINRANGE</name></expr>:</case>
    <case>case <expr><name>OP_CRPOSRANGE</name></expr>:</case>
    <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><call><name>GET2</name><argument_list>(<argument><expr><name>end</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></switch>
  <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>end</name> <operator>-</operator> <name>code</name><operator>)</operator></expr>;</expr_stmt>
  <return>return <expr><name>end</name></expr>;</return>
  </block_content>}</block></switch>
<return>return <expr><name>NULL</name></expr>;</return>    <comment type="block">/* Opcode not accepted */</comment>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*    Scan further character sets for match       *
*************************************************/</comment>

<comment type="block">/* Checks whether the base and the current opcode have a common character, in
which case the base cannot be possessified.

Arguments:
  code        points to the byte code
  utf         TRUE in UTF mode
  ucp         TRUE in UCP mode
  cb          compile data block
  base_list   the data list of the base opcode
  base_end    the end of the base opcode
  rec_limit   points to recursion depth counter

Returns:      TRUE if the auto-possessification is possible
*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>compare_opcodes</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>utf</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>ucp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>base_list</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>base_end</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>rec_limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name><name>list</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>chr_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>ochr_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>list_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>next_code</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_WIDE_CHARS</name></cpp:ifdef>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>xclass_flags</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>class_bitset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>set1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>set2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>set_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>chr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>accepted</name></decl>, <decl><type ref="prev"/><name>invert_bits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>entered_a_group</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>--</operator><operator>(</operator><operator>*</operator><name>rec_limit</name><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Recursion has gone too deep */</comment>

<comment type="block">/* Note: the base_list[1] contains whether the current opcode has a greedy
(represented by a non-zero value) quantifier. This is a different from
other character type lists, which store here that the character iterator
matches to an empty string (also represented by a non-zero value). */</comment>

<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <comment type="block">/* All operations move the code pointer forward.
  Therefore infinite recursions are not possible. */</comment>

  <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>code</name></expr>;</expr_stmt>

  <comment type="block">/* Skip over callouts */</comment>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>OP_CALLOUT</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><name>c</name></expr>]</index></expr>;</expr_stmt>
    <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>OP_CALLOUT_STR</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* At the end of a branch, skip to the end of the group. */</comment>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>
    <block>{<block_content>
    <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>code</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Inspect the next opcode. */</comment>

  <switch>switch<condition>(<expr><name>c</name></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* We can always possessify a greedy iterator at the end of the pattern,
    which is reached after skipping over the final OP_KET. A non-greedy
    iterator must never be possessified. */</comment>

    <case>case <expr><name>OP_END</name></expr>:</case>
    <return>return <expr><name><name>base_list</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>

    <comment type="block">/* When an iterator is at the end of certain kinds of group we can inspect
    what follows the group by skipping over the closing ket. Note that this
    does not apply to OP_KETRMAX or OP_KETRMIN because what follows any given
    iteration is variable (could be another iteration or could be the next
    item). As these two opcodes are not listed in the next switch, they will
    end up as the next code to inspect, and return FALSE by virtue of being
    unsupported. */</comment>

    <case>case <expr><name>OP_KET</name></expr>:</case>
    <case>case <expr><name>OP_KETRPOS</name></expr>:</case>
    <comment type="block">/* The non-greedy case cannot be converted to a possessive form. */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>base_list</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If the bracket is capturing it might be referenced by an OP_RECURSE
    so its last iterator can never be possessified if the pattern contains
    recursions. (This could be improved by keeping a list of group numbers that
    are called by recursion.) */</comment>

    <switch>switch<condition>(<expr><operator>*</operator><operator>(</operator><name>code</name> <operator>-</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>OP_CBRA</name></expr>:</case>
      <case>case <expr><name>OP_SCBRA</name></expr>:</case>
      <case>case <expr><name>OP_CBRAPOS</name></expr>:</case>
      <case>case <expr><name>OP_SCBRAPOS</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>had_recurse</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/* A script run might have to backtrack if the iterated item can match
      characters from more than one script. So give up unless repeating an
      explicit character. */</comment>

      <case>case <expr><name>OP_SCRIPT_RUN</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name><name>base_list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>OP_CHAR</name> <operator>&amp;&amp;</operator> <name><name>base_list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>OP_CHARI</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <break>break;</break>

      <comment type="block">/* Atomic sub-patterns and assertions can always auto-possessify their
      last iterator. However, if the group was entered as a result of checking
      a previous iterator, this is not possible. */</comment>

      <case>case <expr><name>OP_ASSERT</name></expr>:</case>
      <case>case <expr><name>OP_ASSERT_NOT</name></expr>:</case>
      <case>case <expr><name>OP_ASSERTBACK</name></expr>:</case>
      <case>case <expr><name>OP_ASSERTBACK_NOT</name></expr>:</case>
      <case>case <expr><name>OP_ONCE</name></expr>:</case>
      <return>return <expr><operator>!</operator><name>entered_a_group</name></expr>;</return>

      <comment type="block">/* Non-atomic assertions - don't possessify last iterator. This needs
      more thought. */</comment>

      <case>case <expr><name>OP_ASSERT_NA</name></expr>:</case>
      <case>case <expr><name>OP_ASSERTBACK_NA</name></expr>:</case>
      <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></switch>

    <comment type="block">/* Skip over the bracket and inspect what comes next. */</comment>

    <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><name>c</name></expr>]</index></expr>;</expr_stmt>
    <continue>continue;</continue>

    <comment type="block">/* Handle cases where the next item is a group. */</comment>

    <case>case <expr><name>OP_ONCE</name></expr>:</case>
    <case>case <expr><name>OP_BRA</name></expr>:</case>
    <case>case <expr><name>OP_CBRA</name></expr>:</case>
    <expr_stmt><expr><name>next_code</name> <operator>=</operator> <name>code</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><name>c</name></expr>]</index></expr>;</expr_stmt>

    <comment type="block">/* Check each branch. We have to recurse a level for all but the last
    branch. */</comment>

    <while>while <condition>(<expr><operator>*</operator><name>next_code</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>compare_opcodes</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>ucp</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>base_list</name></expr></argument>, <argument><expr><name>base_end</name></expr></argument>, <argument><expr><name>rec_limit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>next_code</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>next_code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>next_code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>

    <expr_stmt><expr><name>entered_a_group</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <continue>continue;</continue>

    <case>case <expr><name>OP_BRAZERO</name></expr>:</case>
    <case>case <expr><name>OP_BRAMINZERO</name></expr>:</case>

    <expr_stmt><expr><name>next_code</name> <operator>=</operator> <name>code</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>next_code</name> <operator>!=</operator> <name>OP_BRA</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>next_code</name> <operator>!=</operator> <name>OP_CBRA</name> <operator>&amp;&amp;</operator>
        <operator>*</operator><name>next_code</name> <operator>!=</operator> <name>OP_ONCE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

    <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>next_code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>next_code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>next_code</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>

    <comment type="block">/* The bracket content will be checked by the OP_BRA/OP_CBRA case above. */</comment>

    <expr_stmt><expr><name>next_code</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>compare_opcodes</name><argument_list>(<argument><expr><name>next_code</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>ucp</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>base_list</name></expr></argument>, <argument><expr><name>base_end</name></expr></argument>,
         <argument><expr><name>rec_limit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><name>c</name></expr>]</index></expr>;</expr_stmt>
    <continue>continue;</continue>

    <comment type="block">/* The next opcode does not need special handling; fall through and use it
    to see if the base can be possessified. */</comment>

    <default>default:</default>
    <break>break;</break>
    </block_content>}</block></switch>

  <comment type="block">/* We now have the next appropriate opcode to compare with the base. Check
  for a supported opcode, and load its properties. */</comment>

  <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>get_chr_property_list</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>ucp</name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>fcc</name></name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>code</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* Unsupported */</comment>

  <comment type="block">/* If either opcode is a small character list, set pointers for comparing
  characters from that list with another list, or with a property. */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>base_list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>OP_CHAR</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>chr_ptr</name> <operator>=</operator> <name>base_list</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>list_ptr</name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>OP_CHAR</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>chr_ptr</name> <operator>=</operator> <name>list</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>list_ptr</name> <operator>=</operator> <name>base_list</name></expr>;</expr_stmt>
    </block_content>}</block></if>

  <comment type="block">/* Character bitsets can also be compared to certain opcodes. */</comment>

  <if type="elseif">else if <condition>(<expr><name><name>base_list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>OP_CLASS</name> <operator>||</operator> <name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>OP_CLASS</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
      <comment type="block">/* In 8 bit, non-UTF mode, OP_CLASS and OP_NCLASS are the same. */</comment>
      <operator>||</operator> <operator>(</operator><operator>!</operator><name>utf</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>base_list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>OP_NCLASS</name> <operator>||</operator> <name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>OP_NCLASS</name><operator>)</operator><operator>)</operator></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      )</condition>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>base_list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>OP_CLASS</name> <operator>||</operator> <operator>(</operator><operator>!</operator><name>utf</name> <operator>&amp;&amp;</operator> <name><name>base_list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>OP_NCLASS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name><name>base_list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>OP_CLASS</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <block>{<block_content>
      <expr_stmt><expr><name>set1</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>base_end</name> <operator>-</operator> <name><name>base_list</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>list_ptr</name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><name>set1</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>code</name> <operator>-</operator> <name><name>list</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>list_ptr</name> <operator>=</operator> <name>base_list</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>invert_bits</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <switch>switch<condition>(<expr><name><name>list_ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>OP_CLASS</name></expr>:</case>
      <case>case <expr><name>OP_NCLASS</name></expr>:</case>
      <expr_stmt><expr><name>set2</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator>
        <operator>(</operator><operator>(</operator><ternary><condition><expr><name>list_ptr</name> <operator>==</operator> <name>list</name></expr> ?</condition><then> <expr><name>code</name></expr> </then><else>: <expr><name>base_end</name></expr></else></ternary><operator>)</operator> <operator>-</operator> <name><name>list_ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_WIDE_CHARS</name></cpp:ifdef>
      <case>case <expr><name>OP_XCLASS</name></expr>:</case>
      <expr_stmt><expr><name>xclass_flags</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>list_ptr</name> <operator>==</operator> <name>list</name></expr> ?</condition><then> <expr><name>code</name></expr> </then><else>: <expr><name>base_end</name></expr></else></ternary><operator>)</operator> <operator>-</operator> <name><name>list_ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>xclass_flags</name> <operator>&amp;</operator> <name>XCL_HASPROP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>xclass_flags</name> <operator>&amp;</operator> <name>XCL_MAP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <comment type="block">/* No bits are set for characters &lt; 256. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>list</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><operator>*</operator><name>xclass_flags</name> <operator>&amp;</operator> <name>XCL_NOT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <comment type="block">/* Might be an empty repeat. */</comment>
        <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>set2</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>xclass_flags</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <case>case <expr><name>OP_NOT_DIGIT</name></expr>:</case>
      <expr_stmt><expr><name>invert_bits</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through */</comment>
      <case>case <expr><name>OP_DIGIT</name></expr>:</case>
      <expr_stmt><expr><name>set2</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>cbits</name></name> <operator>+</operator> <name>cbit_digit</name><operator>)</operator></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_NOT_WHITESPACE</name></expr>:</case>
      <expr_stmt><expr><name>invert_bits</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through */</comment>
      <case>case <expr><name>OP_WHITESPACE</name></expr>:</case>
      <expr_stmt><expr><name>set2</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>cbits</name></name> <operator>+</operator> <name>cbit_space</name><operator>)</operator></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_NOT_WORDCHAR</name></expr>:</case>
      <expr_stmt><expr><name>invert_bits</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <comment type="block">/* Fall through */</comment>
      <case>case <expr><name>OP_WORDCHAR</name></expr>:</case>
      <expr_stmt><expr><name>set2</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>cbits</name></name> <operator>+</operator> <name>cbit_word</name><operator>)</operator></expr>;</expr_stmt>
      <break>break;</break>

      <default>default:</default>
      <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></switch>

    <comment type="block">/* Because the bit sets are unaligned bytes, we need to perform byte
    comparison here. */</comment>

    <expr_stmt><expr><name>set_end</name> <operator>=</operator> <name>set1</name> <operator>+</operator> <literal type="number">32</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>invert_bits</name></expr>)</condition>
      <block>{<block_content>
      <do>do
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>set1</name><operator>++</operator> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><operator>*</operator><name>set2</name><operator>++</operator><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block>
      while <condition>(<expr><name>set1</name> <operator>&lt;</operator> <name>set_end</name></expr>)</condition>;</do>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <do>do
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>set1</name><operator>++</operator> <operator>&amp;</operator> <operator>*</operator><name>set2</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block>
      while <condition>(<expr><name>set1</name> <operator>&lt;</operator> <name>set_end</name></expr>)</condition>;</do>
      </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>list</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Might be an empty repeat. */</comment>
    <continue>continue;</continue>
    </block_content>}</block></if>

  <comment type="block">/* Some property combinations also acceptable. Unicode property opcodes are
  processed specially; the rest can be handled with a lookup table. */</comment>

  <else>else
    <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>leftop</name></decl>, <decl><type ref="prev"/><name>rightop</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>leftop</name> <operator>=</operator> <name><name>base_list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rightop</name> <operator>=</operator> <name><name>list</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <expr_stmt><expr><name>accepted</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt> <comment type="block">/* Always set in non-unicode case. */</comment>
    <if_stmt><if>if <condition>(<expr><name>leftop</name> <operator>==</operator> <name>OP_PROP</name> <operator>||</operator> <name>leftop</name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>rightop</name> <operator>==</operator> <name>OP_EOD</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>accepted</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name>rightop</name> <operator>==</operator> <name>OP_PROP</name> <operator>||</operator> <name>rightop</name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>same</name> <init>= <expr><name>leftop</name> <operator>==</operator> <name>rightop</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>lisprop</name> <init>= <expr><name>leftop</name> <operator>==</operator> <name>OP_PROP</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>risprop</name> <init>= <expr><name>rightop</name> <operator>==</operator> <name>OP_PROP</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>bothprop</name> <init>= <expr><name>lisprop</name> <operator>&amp;&amp;</operator> <name>risprop</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* There's a table that specifies how each combination is to be
        processed:
          0   Always return FALSE (never auto-possessify)
          1   Character groups are distinct (possessify if both are OP_PROP)
          2   Check character categories in the same group (general or particular)
          3   Return TRUE if the two opcodes are not the same
          ... see comments below
        */</comment>

        <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>propposstab</name><index>[<expr><name><name>base_list</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index><index>[<expr><name><name>list</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
        <switch>switch<condition>(<expr><name>n</name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><literal type="number">0</literal></expr>:</case> <break>break;</break>
          <case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>accepted</name> <operator>=</operator> <name>bothprop</name></expr>;</expr_stmt> <break>break;</break>
          <case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>accepted</name> <operator>=</operator> <operator>(</operator><name><name>base_list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <name><name>list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator> <operator>!=</operator> <name>same</name></expr>;</expr_stmt> <break>break;</break>
          <case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>accepted</name> <operator>=</operator> <operator>!</operator><name>same</name></expr>;</expr_stmt> <break>break;</break>

          <case>case <expr><literal type="number">4</literal></expr>:</case>  <comment type="block">/* Left general category, right particular category */</comment>
          <expr_stmt><expr><name>accepted</name> <operator>=</operator> <name>risprop</name> <operator>&amp;&amp;</operator> <name><name>catposstab</name><index>[<expr><name><name>base_list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>]</index><index>[<expr><name><name>list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>]</index></name> <operator>==</operator> <name>same</name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><literal type="number">5</literal></expr>:</case>  <comment type="block">/* Right general category, left particular category */</comment>
          <expr_stmt><expr><name>accepted</name> <operator>=</operator> <name>lisprop</name> <operator>&amp;&amp;</operator> <name><name>catposstab</name><index>[<expr><name><name>list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>]</index><index>[<expr><name><name>base_list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>]</index></name> <operator>==</operator> <name>same</name></expr>;</expr_stmt>
          <break>break;</break>

          <comment type="block">/* This code is logically tricky. Think hard before fiddling with it.
          The posspropstab table has four entries per row. Each row relates to
          one of PCRE's special properties such as ALNUM or SPACE or WORD.
          Only WORD actually needs all four entries, but using repeats for the
          others means they can all use the same code below.

          The first two entries in each row are Unicode general categories, and
          apply always, because all the characters they include are part of the
          PCRE character set. The third and fourth entries are a general and a
          particular category, respectively, that include one or more relevant
          characters. One or the other is used, depending on whether the check
          is for a general or a particular category. However, in both cases the
          category contains more characters than the specials that are defined
          for the property being tested against. Therefore, it cannot be used
          in a NOTPROP case.

          Example: the row for WORD contains ucp_L, ucp_N, ucp_P, ucp_Po.
          Underscore is covered by ucp_P or ucp_Po. */</comment>

          <case>case <expr><literal type="number">6</literal></expr>:</case>  <comment type="block">/* Left alphanum vs right general category */</comment>
          <case>case <expr><literal type="number">7</literal></expr>:</case>  <comment type="block">/* Left space vs right general category */</comment>
          <case>case <expr><literal type="number">8</literal></expr>:</case>  <comment type="block">/* Left word vs right general category */</comment>
          <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>posspropstab</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">6</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>accepted</name> <operator>=</operator> <name>risprop</name> <operator>&amp;&amp;</operator> <name>lisprop</name> <operator>==</operator>
            <operator>(</operator><name><name>list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>!=</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
             <name><name>list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>!=</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>!=</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>||</operator> <operator>!</operator><name>lisprop</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><literal type="number">9</literal></expr>:</case>   <comment type="block">/* Right alphanum vs left general category */</comment>
          <case>case <expr><literal type="number">10</literal></expr>:</case>  <comment type="block">/* Right space vs left general category */</comment>
          <case>case <expr><literal type="number">11</literal></expr>:</case>  <comment type="block">/* Right word vs left general category */</comment>
          <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>posspropstab</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">9</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>accepted</name> <operator>=</operator> <name>lisprop</name> <operator>&amp;&amp;</operator> <name>risprop</name> <operator>==</operator>
            <operator>(</operator><name><name>base_list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>!=</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
             <name><name>base_list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>!=</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>base_list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>!=</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>||</operator> <operator>!</operator><name>risprop</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><literal type="number">12</literal></expr>:</case>  <comment type="block">/* Left alphanum vs right particular category */</comment>
          <case>case <expr><literal type="number">13</literal></expr>:</case>  <comment type="block">/* Left space vs right particular category */</comment>
          <case>case <expr><literal type="number">14</literal></expr>:</case>  <comment type="block">/* Left word vs right particular category */</comment>
          <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>posspropstab</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">12</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>accepted</name> <operator>=</operator> <name>risprop</name> <operator>&amp;&amp;</operator> <name>lisprop</name> <operator>==</operator>
            <operator>(</operator><name><name>catposstab</name><index>[<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index><index>[<expr><name><name>list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>]</index></name> <operator>&amp;&amp;</operator>
             <name><name>catposstab</name><index>[<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index><index>[<expr><name><name>list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>]</index></name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>!=</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>||</operator> <operator>!</operator><name>lisprop</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><literal type="number">15</literal></expr>:</case>  <comment type="block">/* Right alphanum vs left particular category */</comment>
          <case>case <expr><literal type="number">16</literal></expr>:</case>  <comment type="block">/* Right space vs left particular category */</comment>
          <case>case <expr><literal type="number">17</literal></expr>:</case>  <comment type="block">/* Right word vs left particular category */</comment>
          <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>posspropstab</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">15</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>accepted</name> <operator>=</operator> <name>lisprop</name> <operator>&amp;&amp;</operator> <name>risprop</name> <operator>==</operator>
            <operator>(</operator><name><name>catposstab</name><index>[<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index><index>[<expr><name><name>base_list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>]</index></name> <operator>&amp;&amp;</operator>
             <name><name>catposstab</name><index>[<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index><index>[<expr><name><name>base_list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>]</index></name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>base_list</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>!=</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>||</operator> <operator>!</operator><name>risprop</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
          <break>break;</break>
          </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if>

    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

    <expr_stmt><expr><name>accepted</name> <operator>=</operator> <name>leftop</name> <operator>&gt;=</operator> <name>FIRST_AUTOTAB_OP</name> <operator>&amp;&amp;</operator> <name>leftop</name> <operator>&lt;=</operator> <name>LAST_AUTOTAB_LEFT_OP</name> <operator>&amp;&amp;</operator>
           <name>rightop</name> <operator>&gt;=</operator> <name>FIRST_AUTOTAB_OP</name> <operator>&amp;&amp;</operator> <name>rightop</name> <operator>&lt;=</operator> <name>LAST_AUTOTAB_RIGHT_OP</name> <operator>&amp;&amp;</operator>
           <name><name>autoposstab</name><index>[<expr><name>leftop</name> <operator>-</operator> <name>FIRST_AUTOTAB_OP</name></expr>]</index><index>[<expr><name>rightop</name> <operator>-</operator> <name>FIRST_AUTOTAB_OP</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>accepted</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>list</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Might be an empty repeat. */</comment>
    <continue>continue;</continue>
    </block_content>}</block></else></if_stmt>

  <comment type="block">/* Control reaches here only if one of the items is a small character list.
  All characters are checked against the other side. */</comment>

  <do>do
    <block>{<block_content>
    <expr_stmt><expr><name>chr</name> <operator>=</operator> <operator>*</operator><name>chr_ptr</name></expr>;</expr_stmt>

    <switch>switch<condition>(<expr><name><name>list_ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>OP_CHAR</name></expr>:</case>
      <expr_stmt><expr><name>ochr_ptr</name> <operator>=</operator> <name>list_ptr</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <do>do
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>chr</name> <operator>==</operator> <operator>*</operator><name>ochr_ptr</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>ochr_ptr</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block>
      while<condition>(<expr><operator>*</operator><name>ochr_ptr</name> <operator>!=</operator> <name>NOTACHAR</name></expr>)</condition>;</do>
      <break>break;</break>

      <case>case <expr><name>OP_NOT</name></expr>:</case>
      <expr_stmt><expr><name>ochr_ptr</name> <operator>=</operator> <name>list_ptr</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <do>do
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>chr</name> <operator>==</operator> <operator>*</operator><name>ochr_ptr</name></expr>)</condition><block type="pseudo"><block_content>
          <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>ochr_ptr</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block>
      while<condition>(<expr><operator>*</operator><name>ochr_ptr</name> <operator>!=</operator> <name>NOTACHAR</name></expr>)</condition>;</do>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ochr_ptr</name> <operator>==</operator> <name>NOTACHAR</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* Not found */</comment>
      <break>break;</break>

      <comment type="block">/* Note that OP_DIGIT etc. are generated only when PCRE2_UCP is *not*
      set. When it is set, \d etc. are converted into OP_(NOT_)PROP codes. */</comment>

      <case>case <expr><name>OP_DIGIT</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>chr</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>chr</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_digit</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_NOT_DIGIT</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>chr</name> <operator>&gt;</operator> <literal type="number">255</literal> <operator>||</operator> <operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>chr</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_digit</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_WHITESPACE</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>chr</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>chr</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_space</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_NOT_WHITESPACE</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>chr</name> <operator>&gt;</operator> <literal type="number">255</literal> <operator>||</operator> <operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>chr</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_space</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_WORDCHAR</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>chr</name> <operator>&lt;</operator> <literal type="number">255</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>chr</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_NOT_WORDCHAR</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>chr</name> <operator>&gt;</operator> <literal type="number">255</literal> <operator>||</operator> <operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>chr</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_HSPACE</name></expr>:</case>
      <switch>switch<condition>(<expr><name>chr</name></expr>)</condition>
        <block>{<block_content>
        <label><name>HSPACE_CASES</name>:</label> <return>return <expr><name>FALSE</name></expr>;</return>
        <default>default:</default> <break>break;</break>
        </block_content>}</block></switch>
      <break>break;</break>

      <case>case <expr><name>OP_NOT_HSPACE</name></expr>:</case>
      <switch>switch<condition>(<expr><name>chr</name></expr>)</condition>
        <block>{<block_content>
        <label><name>HSPACE_CASES</name>:</label> <break>break;</break>
        <default>default:</default> <return>return <expr><name>FALSE</name></expr>;</return>
        </block_content>}</block></switch>
      <break>break;</break>

      <case>case <expr><name>OP_ANYNL</name></expr>:</case>
      <case>case <expr><name>OP_VSPACE</name></expr>:</case>
      <switch>switch<condition>(<expr><name>chr</name></expr>)</condition>
        <block>{<block_content>
        <label><name>VSPACE_CASES</name>:</label> <return>return <expr><name>FALSE</name></expr>;</return>
        <default>default:</default> <break>break;</break>
        </block_content>}</block></switch>
      <break>break;</break>

      <case>case <expr><name>OP_NOT_VSPACE</name></expr>:</case>
      <switch>switch<condition>(<expr><name>chr</name></expr>)</condition>
        <block>{<block_content>
        <label><name>VSPACE_CASES</name>:</label> <break>break;</break>
        <default>default:</default> <return>return <expr><name>FALSE</name></expr>;</return>
        </block_content>}</block></switch>
      <break>break;</break>

      <case>case <expr><name>OP_DOLL</name></expr>:</case>
      <case>case <expr><name>OP_EODN</name></expr>:</case>
      <switch>switch <condition>(<expr><name>chr</name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>CHAR_CR</name></expr>:</case>
        <case>case <expr><name>CHAR_LF</name></expr>:</case>
        <case>case <expr><name>CHAR_VT</name></expr>:</case>
        <case>case <expr><name>CHAR_FF</name></expr>:</case>
        <case>case <expr><name>CHAR_NEL</name></expr>:</case>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EBCDIC</name></cpp:ifndef>
        <case>case <expr><literal type="number">0x2028</literal></expr>:</case>
        <case>case <expr><literal type="number">0x2029</literal></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* Not EBCDIC */</comment>
        <return>return <expr><name>FALSE</name></expr>;</return>
        </block_content>}</block></switch>
      <break>break;</break>

      <case>case <expr><name>OP_EOD</name></expr>:</case>    <comment type="block">/* Can always possessify before \z */</comment>
      <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <case>case <expr><name>OP_PROP</name></expr>:</case>
      <case>case <expr><name>OP_NOTPROP</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_char_prop</name><argument_list>(<argument><expr><name>chr</name></expr></argument>, <argument><expr><name><name>list_ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>list_ptr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,
            <argument><expr><name><name>list_ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>OP_NOTPROP</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <case>case <expr><name>OP_NCLASS</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>chr</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <comment type="block">/* Fall through */</comment>

      <case>case <expr><name>OP_CLASS</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>chr</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>class_bitset</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator>
        <operator>(</operator><operator>(</operator><ternary><condition><expr><name>list_ptr</name> <operator>==</operator> <name>list</name></expr> ?</condition><then> <expr><name>code</name></expr> </then><else>: <expr><name>base_end</name></expr></else></ternary><operator>)</operator> <operator>-</operator> <name><name>list_ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>class_bitset</name><index>[<expr><name>chr</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>chr</name> <operator>&amp;</operator> <literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_WIDE_CHARS</name></cpp:ifdef>
      <case>case <expr><name>OP_XCLASS</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><call><name>PRIV</name><argument_list>(<argument><expr><name>xclass</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>chr</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>list_ptr</name> <operator>==</operator> <name>list</name></expr> ?</condition><then> <expr><name>code</name></expr> </then><else>: <expr><name>base_end</name></expr></else></ternary><operator>)</operator> <operator>-</operator>
          <name><name>list_ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <default>default:</default>
      <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></switch>

    <expr_stmt><expr><name>chr_ptr</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>
  while<condition>(<expr><operator>*</operator><name>chr_ptr</name> <operator>!=</operator> <name>NOTACHAR</name></expr>)</condition>;</do>

  <comment type="block">/* At least one character must be matched from this opcode. */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>list</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>

<comment type="block">/* Control never reaches here. There used to be a fail-save return FALSE; here,
but some compilers complain about an unreachable statement. */</comment>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*    Scan compiled regex for auto-possession     *
*************************************************/</comment>

<comment type="block">/* Replaces single character iterations with their possessive alternatives
if appropriate. This function modifies the compiled opcode! Hitting a
non-existent opcode may indicate a bug in PCRE2, but it can also be caused if a
bad UTF string was compiled with PCRE2_NO_UTF_CHECK. The rec_limit catches
overly complicated or large patterns. In these cases, the check just stops,
leaving the remainder of the pattern unpossessified.

Arguments:
  code        points to start of the byte code
  cb          compile data block

Returns:      0 for success
              -1 if a non-existant opcode is encountered
*/</comment>

<function><type><name>int</name>
<name>PRIV</name></type>(<name>auto_possessify</name>)<parameter_list>(<parameter><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>code</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>repeat_opcode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name><name>list</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rec_limit</name> <init>= <expr><literal type="number">1000</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Was 10,000 but clang+ASAN uses a lot of stack. */</comment>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name> <init>= <expr><operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>external_options</name></name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>ucp</name> <init>= <expr><operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>external_options</name></name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>code</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <name>OP_TABLE_LENGTH</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* Something gone wrong */</comment>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <name>OP_STAR</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <name>OP_TYPEPOSUPTO</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>-=</operator> <call><name>get_repeat_base</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>OP_STAR</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <name>OP_MINUPTO</name><operator>)</operator></expr> ?</condition><then>
      <expr><call><name>get_chr_property_list</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>ucp</name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>fcc</name></name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>c</name> <operator>==</operator> <name>OP_STAR</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>OP_PLUS</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>OP_QUERY</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>OP_UPTO</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>end</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>compare_opcodes</name><argument_list>(<argument><expr><name>end</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>ucp</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>end</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>rec_limit</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <switch>switch<condition>(<expr><name>c</name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>OP_STAR</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>code</name> <operator>+=</operator> <name>OP_POSSTAR</name> <operator>-</operator> <name>OP_STAR</name></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>OP_MINSTAR</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>code</name> <operator>+=</operator> <name>OP_POSSTAR</name> <operator>-</operator> <name>OP_MINSTAR</name></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>OP_PLUS</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>code</name> <operator>+=</operator> <name>OP_POSPLUS</name> <operator>-</operator> <name>OP_PLUS</name></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>OP_MINPLUS</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>code</name> <operator>+=</operator> <name>OP_POSPLUS</name> <operator>-</operator> <name>OP_MINPLUS</name></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>OP_QUERY</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>code</name> <operator>+=</operator> <name>OP_POSQUERY</name> <operator>-</operator> <name>OP_QUERY</name></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>OP_MINQUERY</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>code</name> <operator>+=</operator> <name>OP_POSQUERY</name> <operator>-</operator> <name>OP_MINQUERY</name></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>OP_UPTO</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>code</name> <operator>+=</operator> <name>OP_POSUPTO</name> <operator>-</operator> <name>OP_UPTO</name></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>OP_MINUPTO</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>code</name> <operator>+=</operator> <name>OP_POSUPTO</name> <operator>-</operator> <name>OP_MINUPTO</name></expr>;</expr_stmt>
        <break>break;</break>
        </block_content>}</block></switch>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>code</name></expr>;</expr_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <name>OP_CLASS</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>OP_NCLASS</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>OP_XCLASS</name></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_WIDE_CHARS</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>OP_XCLASS</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>repeat_opcode</name> <operator>=</operator> <name>code</name> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>repeat_opcode</name> <operator>=</operator> <name>code</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><literal type="number">32</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>repeat_opcode</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <name>OP_CRSTAR</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <name>OP_CRMINRANGE</name></expr>)</condition>
      <block>{<block_content>
      <comment type="block">/* end must not be NULL. */</comment>
      <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>get_chr_property_list</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>ucp</name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>fcc</name></name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>list</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><call><name>compare_opcodes</name><argument_list>(<argument><expr><name>end</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>ucp</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rec_limit</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
        <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>OP_CRSTAR</name></expr>:</case>
          <case>case <expr><name>OP_CRMINSTAR</name></expr>:</case>
          <expr_stmt><expr><operator>*</operator><name>repeat_opcode</name> <operator>=</operator> <name>OP_CRPOSSTAR</name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>OP_CRPLUS</name></expr>:</case>
          <case>case <expr><name>OP_CRMINPLUS</name></expr>:</case>
          <expr_stmt><expr><operator>*</operator><name>repeat_opcode</name> <operator>=</operator> <name>OP_CRPOSPLUS</name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>OP_CRQUERY</name></expr>:</case>
          <case>case <expr><name>OP_CRMINQUERY</name></expr>:</case>
          <expr_stmt><expr><operator>*</operator><name>repeat_opcode</name> <operator>=</operator> <name>OP_CRPOSQUERY</name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>OP_CRRANGE</name></expr>:</case>
          <case>case <expr><name>OP_CRMINRANGE</name></expr>:</case>
          <expr_stmt><expr><operator>*</operator><name>repeat_opcode</name> <operator>=</operator> <name>OP_CRPOSRANGE</name></expr>;</expr_stmt>
          <break>break;</break>
          </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>code</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <switch>switch<condition>(<expr><name>c</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>OP_END</name></expr>:</case>
    <return>return <expr><literal type="number">0</literal></expr>;</return>

    <case>case <expr><name>OP_TYPESTAR</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINSTAR</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPLUS</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINPLUS</name></expr>:</case>
    <case>case <expr><name>OP_TYPEQUERY</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINQUERY</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSSTAR</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSPLUS</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSQUERY</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>OP_PROP</name> <operator>||</operator> <name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>code</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_TYPEUPTO</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINUPTO</name></expr>:</case>
    <case>case <expr><name>OP_TYPEEXACT</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSUPTO</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>code</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>]</index></name> <operator>==</operator> <name>OP_PROP</name> <operator>||</operator> <name><name>code</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>]</index></name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>code</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CALLOUT_STR</name></expr>:</case>
    <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_WIDE_CHARS</name></cpp:ifdef>
    <case>case <expr><name>OP_XCLASS</name></expr>:</case>
    <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <case>case <expr><name>OP_MARK</name></expr>:</case>
    <case>case <expr><name>OP_COMMIT_ARG</name></expr>:</case>
    <case>case <expr><name>OP_PRUNE_ARG</name></expr>:</case>
    <case>case <expr><name>OP_SKIP_ARG</name></expr>:</case>
    <case>case <expr><name>OP_THEN_ARG</name></expr>:</case>
    <expr_stmt><expr><name>code</name> <operator>+=</operator> <name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></switch>

  <comment type="block">/* Add in the fixed length from the table */</comment>

  <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><name>c</name></expr>]</index></expr>;</expr_stmt>

  <comment type="block">/* In UTF-8 and UTF-16 modes, opcodes that are followed by a character may be
  followed by a multi-byte character. The length in the table is a minimum, so
  we have to arrange to skip the extra code units. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MAYBE_UTF_MULTI</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <switch>switch<condition>(<expr><name>c</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>OP_CHAR</name></expr>:</case>
    <case>case <expr><name>OP_CHARI</name></expr>:</case>
    <case>case <expr><name>OP_NOT</name></expr>:</case>
    <case>case <expr><name>OP_NOTI</name></expr>:</case>
    <case>case <expr><name>OP_STAR</name></expr>:</case>
    <case>case <expr><name>OP_MINSTAR</name></expr>:</case>
    <case>case <expr><name>OP_PLUS</name></expr>:</case>
    <case>case <expr><name>OP_MINPLUS</name></expr>:</case>
    <case>case <expr><name>OP_QUERY</name></expr>:</case>
    <case>case <expr><name>OP_MINQUERY</name></expr>:</case>
    <case>case <expr><name>OP_UPTO</name></expr>:</case>
    <case>case <expr><name>OP_MINUPTO</name></expr>:</case>
    <case>case <expr><name>OP_EXACT</name></expr>:</case>
    <case>case <expr><name>OP_POSSTAR</name></expr>:</case>
    <case>case <expr><name>OP_POSPLUS</name></expr>:</case>
    <case>case <expr><name>OP_POSQUERY</name></expr>:</case>
    <case>case <expr><name>OP_POSUPTO</name></expr>:</case>
    <case>case <expr><name>OP_STARI</name></expr>:</case>
    <case>case <expr><name>OP_MINSTARI</name></expr>:</case>
    <case>case <expr><name>OP_PLUSI</name></expr>:</case>
    <case>case <expr><name>OP_MINPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_QUERYI</name></expr>:</case>
    <case>case <expr><name>OP_MINQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_UPTOI</name></expr>:</case>
    <case>case <expr><name>OP_MINUPTOI</name></expr>:</case>
    <case>case <expr><name>OP_EXACTI</name></expr>:</case>
    <case>case <expr><name>OP_POSSTARI</name></expr>:</case>
    <case>case <expr><name>OP_POSPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_POSQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_POSUPTOI</name></expr>:</case>
    <case>case <expr><name>OP_NOTSTAR</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINSTAR</name></expr>:</case>
    <case>case <expr><name>OP_NOTPLUS</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINPLUS</name></expr>:</case>
    <case>case <expr><name>OP_NOTQUERY</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINQUERY</name></expr>:</case>
    <case>case <expr><name>OP_NOTUPTO</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINUPTO</name></expr>:</case>
    <case>case <expr><name>OP_NOTEXACT</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSSTAR</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSPLUS</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSQUERY</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSUPTO</name></expr>:</case>
    <case>case <expr><name>OP_NOTSTARI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINSTARI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_NOTQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_NOTUPTOI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINUPTOI</name></expr>:</case>
    <case>case <expr><name>OP_NOTEXACTI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSSTARI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSUPTOI</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><name><name>code</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><name><name>code</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <break>break;</break>
    </block_content>}</block></switch></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>utf</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Keep compiler happy by referencing function argument */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_WIDE_CHARS */</comment>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* End of pcre2_auto_possess.c */</comment>
</unit>
