<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/pcre2/src/pcre2_convert.c"><comment type="block" format="doxygen">/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/</comment>

<comment type="block">/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
     Original API code Copyright (c) 1997-2012 University of Cambridge
          New API code Copyright (c) 2016-2018 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_internal.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TYPE_OPTIONS</name></cpp:macro> <cpp:value>(PCRE2_CONVERT_GLOB| \
  PCRE2_CONVERT_POSIX_BASIC|PCRE2_CONVERT_POSIX_EXTENDED)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALL_OPTIONS</name></cpp:macro> <cpp:value>(PCRE2_CONVERT_UTF|PCRE2_CONVERT_NO_UTF_CHECK| \
  PCRE2_CONVERT_GLOB_NO_WILD_SEPARATOR| \
  PCRE2_CONVERT_GLOB_NO_STARSTAR| \
  TYPE_OPTIONS)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_BUFFER_SIZE</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

<comment type="block">/* Generated pattern fragments */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_BACKSLASH_A</name></cpp:macro> <cpp:value>STR_BACKSLASH STR_A</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_BACKSLASH_z</name></cpp:macro> <cpp:value>STR_BACKSLASH STR_z</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_COLON_RIGHT_SQUARE_BRACKET</name></cpp:macro> <cpp:value>STR_COLON STR_RIGHT_SQUARE_BRACKET</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_DOT_STAR_LOOKBEHIND</name></cpp:macro> <cpp:value>STR_DOT STR_ASTERISK STR_LEFT_PARENTHESIS STR_QUESTION_MARK STR_LESS_THAN_SIGN STR_EQUALS_SIGN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_LOOKAHEAD_NOT_DOT</name></cpp:macro> <cpp:value>STR_LEFT_PARENTHESIS STR_QUESTION_MARK STR_EXCLAMATION_MARK STR_BACKSLASH STR_DOT STR_RIGHT_PARENTHESIS</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_QUERY_s</name></cpp:macro> <cpp:value>STR_LEFT_PARENTHESIS STR_QUESTION_MARK STR_s STR_RIGHT_PARENTHESIS</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_STAR_NUL</name></cpp:macro> <cpp:value>STR_LEFT_PARENTHESIS STR_ASTERISK STR_N STR_U STR_L STR_RIGHT_PARENTHESIS</cpp:value></cpp:define>

<comment type="block">/* States for range and POSIX processing */</comment>

<enum>enum <block>{ <decl><name>RANGE_NOT_STARTED</name></decl>, <decl><name>RANGE_STARTING</name></decl>, <decl><name>RANGE_STARTED</name></decl> }</block>;</enum>
<enum>enum <block>{ <decl><name>POSIX_START_REGEX</name></decl>, <decl><name>POSIX_ANCHORED</name></decl>, <decl><name>POSIX_NOT_BRACKET</name></decl>,
       <decl><name>POSIX_CLASS_NOT_STARTED</name></decl>, <decl><name>POSIX_CLASS_STARTING</name></decl>, <decl><name>POSIX_CLASS_STARTED</name></decl> }</block>;</enum>

<comment type="block">/* Macro to add a character string to the output buffer, checking for overflow. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUTCHARS</name><parameter_list>(<parameter><type><name>string</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>{ \
  for (s = (char *)(string); *s != 0; s++) \
    { \
    if (p &gt;= endp) return PCRE2_ERROR_NOMEMORY; \
    *p++ = *s; \
    } \
  }</cpp:value></cpp:define>

<comment type="block">/* Literals that must be escaped: \ ? * + | . ^ $ { } [ ] ( ) */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pcre2_escaped_literals</name> <init>=
  <expr><name>STR_BACKSLASH</name> <name>STR_QUESTION_MARK</name> <name>STR_ASTERISK</name> <name>STR_PLUS</name>
  <name>STR_VERTICAL_LINE</name> <name>STR_DOT</name> <name>STR_CIRCUMFLEX_ACCENT</name> <name>STR_DOLLAR_SIGN</name>
  <name>STR_LEFT_CURLY_BRACKET</name> <name>STR_RIGHT_CURLY_BRACKET</name>
  <name>STR_LEFT_SQUARE_BRACKET</name> <name>STR_RIGHT_SQUARE_BRACKET</name>
  <name>STR_LEFT_PARENTHESIS</name> <name>STR_RIGHT_PARENTHESIS</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Recognized escaped metacharacters in POSIX basic patterns. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>posix_meta_escapes</name> <init>=
  <expr><name>STR_LEFT_PARENTHESIS</name> <name>STR_RIGHT_PARENTHESIS</name>
  <name>STR_LEFT_CURLY_BRACKET</name> <name>STR_RIGHT_CURLY_BRACKET</name>
  <name>STR_1</name> <name>STR_2</name> <name>STR_3</name> <name>STR_4</name> <name>STR_5</name> <name>STR_6</name> <name>STR_7</name> <name>STR_8</name> <name>STR_9</name></expr></init></decl>;</decl_stmt>



<comment type="block" format="doxygen">/*************************************************
*           Convert a POSIX pattern              *
*************************************************/</comment>

<comment type="block">/* This function handles both basic and extended POSIX patterns.

Arguments:
  pattype        the pattern type
  pattern        the pattern
  plength        length in code units
  utf            TRUE if UTF
  use_buffer     where to put the output
  use_length     length of use_buffer
  bufflenptr     where to put the used length
  dummyrun       TRUE if a dummy run
  ccontext       the convert context

Returns:         0 =&gt; success
                !0 =&gt; error code
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>convert_posix</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>pattype</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>pattern</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>plength</name></decl></parameter>,
  <parameter><decl><type><name>BOOL</name></type> <name>utf</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>use_buffer</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>use_length</name></decl></parameter>,
  <parameter><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>bufflenptr</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>dummyrun</name></decl></parameter>, <parameter><decl><type><name>pcre2_convert_context</name> <modifier>*</modifier></type><name>ccontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>posix</name> <init>= <expr><name>pattern</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>use_buffer</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>pp</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>endp</name> <init>= <expr><name>p</name> <operator>+</operator> <name>use_length</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Allow for trailing zero */</comment>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>convlength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>bracount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>posix_state</name> <init>= <expr><name>POSIX_START_REGEX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>lastspecial</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>extended</name> <init>= <expr><operator>(</operator><name>pattype</name> <operator>&amp;</operator> <name>PCRE2_CONVERT_POSIX_EXTENDED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>nextisliteral</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>utf</name></expr>;</expr_stmt>       <comment type="block">/* Not used when Unicode not supported */</comment>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>ccontext</name></expr>;</expr_stmt>  <comment type="block">/* Not currently used */</comment>

<comment type="block">/* Initialize default for error offset as end of input. */</comment>

<expr_stmt><expr><operator>*</operator><name>bufflenptr</name> <operator>=</operator> <name>plength</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PUTCHARS</name><argument_list>(<argument><expr><name>STR_STAR_NUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Now scan the input. */</comment>

<while>while <condition>(<expr><name>plength</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>sc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>clength</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Add in the length of the last item, then, if in the dummy run, pull the
  pointer back to the start of the (temporary) buffer and then remember the
  start of the next item. */</comment>

  <expr_stmt><expr><name>convlength</name> <operator>+=</operator> <name>p</name> <operator>-</operator> <name>pp</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>dummyrun</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <name>use_buffer</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

  <comment type="block">/* Pick up the next character */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifndef>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>posix</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>GETCHARLENTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>posix</name></expr></argument>, <argument><expr><name>clength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>posix</name> <operator>+=</operator> <name>clength</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>plength</name> <operator>-=</operator> <name>clength</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>sc</name> <operator>=</operator> <ternary><condition><expr><name>nextisliteral</name></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>c</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name>nextisliteral</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

  <comment type="block">/* Handle a character within a class. */</comment>

  <if_stmt><if>if <condition>(<expr><name>posix_state</name> <operator>&gt;=</operator> <name>POSIX_CLASS_NOT_STARTED</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_RIGHT_SQUARE_BRACKET</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>PUTCHARS</name><argument_list>(<argument><expr><name>STR_RIGHT_SQUARE_BRACKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>posix_state</name> <operator>=</operator> <name>POSIX_NOT_BRACKET</name></expr>;</expr_stmt>
      </block_content>}</block></if>

    <comment type="block">/* Not the end of the class */</comment>

    <else>else
      <block>{<block_content>
      <switch>switch <condition>(<expr><name>posix_state</name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>POSIX_CLASS_STARTED</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator> <call><name>islower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* Remain in started state */</comment>
        <expr_stmt><expr><name>posix_state</name> <operator>=</operator> <name>POSIX_CLASS_NOT_STARTED</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_COLON</name>  <operator>&amp;&amp;</operator> <name>plength</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <operator>*</operator><name>posix</name> <operator>==</operator> <name>CHAR_RIGHT_SQUARE_BRACKET</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>PUTCHARS</name><argument_list>(<argument><expr><name>STR_COLON_RIGHT_SQUARE_BRACKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>plength</name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>posix</name><operator>++</operator></expr>;</expr_stmt>
          <continue>continue;</continue>    <comment type="block">/* With next character after :] */</comment>
          </block_content>}</block></if></if_stmt>
        <comment type="block">/* Fall through */</comment>

        <case>case <expr><name>POSIX_CLASS_NOT_STARTED</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_LEFT_SQUARE_BRACKET</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>posix_state</name> <operator>=</operator> <name>POSIX_CLASS_STARTING</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>

        <case>case <expr><name>POSIX_CLASS_STARTING</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_COLON</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>posix_state</name> <operator>=</operator> <name>POSIX_CLASS_STARTED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>
        </block_content>}</block></switch>

      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_BACKSLASH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>PUTCHARS</name><argument_list>(<argument><expr><name>STR_BACKSLASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <name>clength</name> <operator>&gt;</operator> <name>endp</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>posix</name> <operator>-</operator> <name>clength</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>clength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>clength</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>

  <comment type="block">/* Handle a character not within a class. */</comment>

  <else>else<block type="pseudo"><block_content> <switch>switch<condition>(<expr><name>sc</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>CHAR_LEFT_SQUARE_BRACKET</name></expr>:</case>
    <expr_stmt><expr><call><name>PUTCHARS</name><argument_list>(<argument><expr><name>STR_LEFT_SQUARE_BRACKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NEVER</name></cpp:ifdef>
    <comment type="block">/* We could handle special cases [[:&lt;:]] and [[:&gt;:]] (which PCRE does
    support) but they are not part of POSIX 1003.1. */</comment>

    <if_stmt><if>if <condition>(<expr><name>plength</name> <operator>&gt;=</operator> <literal type="number">6</literal></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>posix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_LEFT_SQUARE_BRACKET</name> <operator>&amp;&amp;</operator>
          <name><name>posix</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_COLON</name> <operator>&amp;&amp;</operator>
          <operator>(</operator><name><name>posix</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_LESS_THAN_SIGN</name> <operator>||</operator>
           <name><name>posix</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_GREATER_THAN_SIGN</name><operator>)</operator> <operator>&amp;&amp;</operator>
          <name><name>posix</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_COLON</name> <operator>&amp;&amp;</operator>
          <name><name>posix</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_RIGHT_SQUARE_BRACKET</name> <operator>&amp;&amp;</operator>
          <name><name>posix</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_RIGHT_SQUARE_BRACKET</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <literal type="number">6</literal> <operator>&gt;</operator> <name>endp</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>posix</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>posix</name> <operator>+=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>plength</name> <operator>-=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
        <continue>continue;</continue>  <comment type="block">/* With next character */</comment>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Handle start of "normal" character classes */</comment>

    <expr_stmt><expr><name>posix_state</name> <operator>=</operator> <name>POSIX_CLASS_NOT_STARTED</name></expr>;</expr_stmt>

    <comment type="block">/* Handle ^ and ] as first characters */</comment>

    <if_stmt><if>if <condition>(<expr><name>plength</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>posix</name> <operator>==</operator> <name>CHAR_CIRCUMFLEX_ACCENT</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>posix</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>plength</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PUTCHARS</name><argument_list>(<argument><expr><name>STR_CIRCUMFLEX_ACCENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>plength</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>posix</name> <operator>==</operator> <name>CHAR_RIGHT_SQUARE_BRACKET</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>posix</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>plength</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PUTCHARS</name><argument_list>(<argument><expr><name>STR_RIGHT_SQUARE_BRACKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    <break>break;</break>

    <case>case <expr><name>CHAR_BACKSLASH</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>plength</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_END_BACKSLASH</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>extended</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nextisliteral</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if> <else>else
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>posix</name> <operator>&lt;</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>posix_meta_escapes</name></expr></argument>, <argument><expr><operator>*</operator><name>posix</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>posix</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>PUTCHARS</name><argument_list>(<argument><expr><name>STR_BACKSLASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>endp</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>lastspecial</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>posix</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>plength</name><operator>--</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>nextisliteral</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    <break>break;</break>

    <case>case <expr><name>CHAR_RIGHT_PARENTHESIS</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>extended</name> <operator>||</operator> <name>bracount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>ESCAPE_LITERAL</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>bracount</name><operator>--</operator></expr>;</expr_stmt>
    <goto>goto <name>COPY_SPECIAL</name>;</goto>

    <case>case <expr><name>CHAR_LEFT_PARENTHESIS</name></expr>:</case>
    <expr_stmt><expr><name>bracount</name><operator>++</operator></expr>;</expr_stmt>
    <comment type="block">/* Fall through */</comment>

    <case>case <expr><name>CHAR_QUESTION_MARK</name></expr>:</case>
    <case>case <expr><name>CHAR_PLUS</name></expr>:</case>
    <case>case <expr><name>CHAR_LEFT_CURLY_BRACKET</name></expr>:</case>
    <case>case <expr><name>CHAR_RIGHT_CURLY_BRACKET</name></expr>:</case>
    <case>case <expr><name>CHAR_VERTICAL_LINE</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>extended</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>ESCAPE_LITERAL</name>;</goto></block_content></block></if></if_stmt>
    <comment type="block">/* Fall through */</comment>

    <case>case <expr><name>CHAR_DOT</name></expr>:</case>
    <case>case <expr><name>CHAR_DOLLAR_SIGN</name></expr>:</case>
    <expr_stmt><expr><name>posix_state</name> <operator>=</operator> <name>POSIX_NOT_BRACKET</name></expr>;</expr_stmt>
    <label><name>COPY_SPECIAL</name>:</label>
    <expr_stmt><expr><name>lastspecial</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>endp</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>CHAR_ASTERISK</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>lastspecial</name> <operator>!=</operator> <name>CHAR_ASTERISK</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>extended</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>posix_state</name> <operator>&lt;</operator> <name>POSIX_NOT_BRACKET</name> <operator>||</operator>
          <name>lastspecial</name> <operator>==</operator> <name>CHAR_LEFT_PARENTHESIS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>ESCAPE_LITERAL</name>;</goto></block_content></block></if></if_stmt>
      <goto>goto <name>COPY_SPECIAL</name>;</goto>
      </block_content>}</block></if></if_stmt>
    <break>break;</break>   <comment type="block">/* Ignore second and subsequent asterisks */</comment>

    <case>case <expr><name>CHAR_CIRCUMFLEX_ACCENT</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>extended</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>COPY_SPECIAL</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>posix_state</name> <operator>==</operator> <name>POSIX_START_REGEX</name> <operator>||</operator>
        <name>lastspecial</name> <operator>==</operator> <name>CHAR_LEFT_PARENTHESIS</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>posix_state</name> <operator>=</operator> <name>POSIX_ANCHORED</name></expr>;</expr_stmt>
      <goto>goto <name>COPY_SPECIAL</name>;</goto>
      </block_content>}</block></if></if_stmt>
    <comment type="block">/* Fall through */</comment>

    <default>default:</default>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">128</literal> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>pcre2_escaped_literals</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
      <label><name>ESCAPE_LITERAL</name>:</label>
      <expr_stmt><expr><call><name>PUTCHARS</name><argument_list>(<argument><expr><name>STR_BACKSLASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>lastspecial</name> <operator>=</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>  <comment type="block">/* Indicates nothing special */</comment>
    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <name>clength</name> <operator>&gt;</operator> <name>endp</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>posix</name> <operator>-</operator> <name>clength</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>clength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>clength</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>posix_state</name> <operator>=</operator> <name>POSIX_NOT_BRACKET</name></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></switch></block_content></block></else></if_stmt>
  </block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>posix_state</name> <operator>&gt;=</operator> <name>POSIX_CLASS_NOT_STARTED</name></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>PCRE2_ERROR_MISSING_SQUARE_BRACKET</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>convlength</name> <operator>+=</operator> <name>p</name> <operator>-</operator> <name>pp</name></expr>;</expr_stmt>        <comment type="block">/* Final segment */</comment>
<expr_stmt><expr><operator>*</operator><name>bufflenptr</name> <operator>=</operator> <name>convlength</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*           Convert a glob pattern               *
*************************************************/</comment>

<comment type="block">/* Context for writing the output into a buffer. */</comment>

<typedef>typedef <type><struct>struct <name>pcre2_output_context</name> <block>{
  <decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>output</name></decl>;</decl_stmt>                  <comment type="block">/* current output position */</comment>
  <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>output_end</name></decl>;</decl_stmt>                <comment type="block">/* output end */</comment>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>output_size</name></decl>;</decl_stmt>               <comment type="block">/* size of the output */</comment>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>out_str</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>                   <comment type="block">/* string copied to the output */</comment>
}</block></struct></type> <name>pcre2_output_context</name>;</typedef>


<comment type="block">/* Write a character into the output.

Arguments:
  out            output context
  chr            the next character
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>convert_glob_write</name><parameter_list>(<parameter><decl><type><name>pcre2_output_context</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name></type> <name>chr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>output_size</name></name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>out</name><operator>-&gt;</operator><name>output</name></name> <operator>&lt;</operator> <name><name>out</name><operator>-&gt;</operator><name>output_end</name></name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><operator>*</operator><name><name>out</name><operator>-&gt;</operator><name>output</name></name><operator>++</operator> <operator>=</operator> <name>chr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* Write a string into the output.

Arguments:
  out            output context
  length         length of out-&gt;out_str
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>convert_glob_write_str</name><parameter_list>(<parameter><decl><type><name>pcre2_output_context</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>out_str</name> <init>= <expr><name><name>out</name><operator>-&gt;</operator><name>out_str</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><name><name>out</name><operator>-&gt;</operator><name>output</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>output_end</name> <init>= <expr><name><name>out</name><operator>-&gt;</operator><name>output_end</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>output_size</name> <init>= <expr><name><name>out</name><operator>-&gt;</operator><name>output_size</name></name></expr></init></decl>;</decl_stmt>

<do>do
  <block>{<block_content>
  <expr_stmt><expr><name>output_size</name><operator>++</operator></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>output</name> <operator>&lt;</operator> <name>output_end</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>output</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>out_str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block>
while <condition>(<expr><operator>--</operator><name>length</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>output</name></name> <operator>=</operator> <name>output</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>output_size</name></name> <operator>=</operator> <name>output_size</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Prints the separator into the output.

Arguments:
  out            output context
  separator      glob separator
  with_escape    backslash is needed before separator
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>convert_glob_print_separator</name><parameter_list>(<parameter><decl><type><name>pcre2_output_context</name> <modifier>*</modifier></type><name>out</name></decl></parameter>,
  <parameter><decl><type><name>PCRE2_UCHAR</name></type> <name>separator</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>with_escape</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>with_escape</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>convert_glob_write</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>CHAR_BACKSLASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>convert_glob_write</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Prints a wildcard into the output.

Arguments:
  out            output context
  separator      glob separator
  with_escape    backslash is needed before separator
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>convert_glob_print_wildcard</name><parameter_list>(<parameter><decl><type><name>pcre2_output_context</name> <modifier>*</modifier></type><name>out</name></decl></parameter>,
  <parameter><decl><type><name>PCRE2_UCHAR</name></type> <name>separator</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>with_escape</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>out_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_LEFT_SQUARE_BRACKET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>out_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_CIRCUMFLEX_ACCENT</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>convert_glob_write_str</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>convert_glob_print_separator</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><name>with_escape</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>convert_glob_write</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>CHAR_RIGHT_SQUARE_BRACKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Parse a posix class.

Arguments:
  from           starting point of scanning the range
  pattern_end    end of pattern
  out            output context

Returns:  &gt;0 =&gt; class index
          0  =&gt; malformed class
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>convert_glob_parse_class</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>pattern_end</name></decl></parameter>,
  <parameter><decl><type><name>pcre2_output_context</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>posix_classes</name> <init>= <expr><literal type="string">"alnum:alpha:ascii:blank:cntrl:digit:"</literal>
  <literal type="string">"graph:lower:print:punct:space:upper:word:xdigit:"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>start</name> <init>= <expr><operator>*</operator><name>from</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>pattern</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>class_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>class_index</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>TRUE</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>pattern</name> <operator>&gt;=</operator> <name>pattern_end</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>pattern</name><operator>++</operator></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>c</name> <argument_list type="generic">&lt; <argument><expr><name>CHAR_a</name> <operator>||</operator> <name>c</name></expr></argument> &gt;</argument_list></name> <name>CHAR_z</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>CHAR_COLON</name> <operator>||</operator> <name>pattern</name> <operator>&gt;=</operator> <name>pattern_end</name> <operator>||</operator>
    <operator>*</operator><name>pattern</name> <operator>!=</operator> <name>CHAR_RIGHT_SQUARE_BRACKET</name></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>class_ptr</name> <operator>=</operator> <name>posix_classes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>class_index</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>TRUE</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>class_ptr</name> <operator>==</operator> <name>CHAR_NUL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>pattern</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>

  <while>while <condition>(<expr><operator>*</operator><name>pattern</name> <operator>==</operator> <operator>(</operator><name>PCRE2_UCHAR</name><operator>)</operator> <operator>*</operator><name>class_ptr</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pattern</name> <operator>==</operator> <name>CHAR_COLON</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>pattern</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>start</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

      <do>do<block type="pseudo"><block_content> <expr_stmt><expr><call><name>convert_glob_write</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>*</operator><name>start</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><name>start</name> <operator>&lt;</operator> <name>pattern</name></expr>)</condition>;</do>

      <expr_stmt><expr><operator>*</operator><name>from</name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
      <return>return <expr><name>class_index</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pattern</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>class_ptr</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

  <while>while <condition>(<expr><operator>*</operator><name>class_ptr</name> <operator>!=</operator> <name>CHAR_COLON</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>class_ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><name>class_ptr</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>class_index</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Checks whether the character is in the class.

Arguments:
  class_index    class index
  c              character

Returns:   !0 =&gt; character is found in the class
            0 =&gt; otherwise
*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>convert_glob_char_in_class</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>class_index</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>class_index</name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><call><name>isalnum</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><call><name>isalpha</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><literal type="number">3</literal></expr>:</case> <return>return <expr><literal type="number">1</literal></expr>;</return>
  <case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><name>c</name> <operator>==</operator> <name>CHAR_HT</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>CHAR_SPACE</name></expr>;</return>
  <case>case <expr><literal type="number">5</literal></expr>:</case> <return>return <expr><call><name>iscntrl</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><literal type="number">6</literal></expr>:</case> <return>return <expr><call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><literal type="number">7</literal></expr>:</case> <return>return <expr><call><name>isgraph</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><literal type="number">8</literal></expr>:</case> <return>return <expr><call><name>islower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><literal type="number">9</literal></expr>:</case> <return>return <expr><call><name>isprint</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><literal type="number">10</literal></expr>:</case> <return>return <expr><call><name>ispunct</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><literal type="number">11</literal></expr>:</case> <return>return <expr><call><name>isspace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><literal type="number">12</literal></expr>:</case> <return>return <expr><call><name>isupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
  <case>case <expr><literal type="number">13</literal></expr>:</case> <return>return <expr><call><name>isalnum</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>c</name> <operator>==</operator> <name>CHAR_UNDERSCORE</name></expr>;</return>
  <default>default:</default> <return>return <expr><call><name>isxdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* Parse a range of characters.

Arguments:
  from           starting point of scanning the range
  pattern_end    end of pattern
  out            output context
  separator      glob separator
  with_escape    backslash is needed before separator

Returns:         0 =&gt; success
                !0 =&gt; error code
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>convert_glob_parse_range</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>pattern_end</name></decl></parameter>,
  <parameter><decl><type><name>pcre2_output_context</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>utf</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name></type> <name>separator</name></decl></parameter>,
  <parameter><decl><type><name>BOOL</name></type> <name>with_escape</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name></type> <name>escape</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>no_wildsep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BOOL</name></type> <name>is_negative</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>separator_seen</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>has_prev_c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>pattern</name> <init>= <expr><operator>*</operator><name>from</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>char_start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>prev_c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>class_index</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>utf</name></expr>;</expr_stmt> <comment type="block">/* Avoid compiler warning. */</comment>

<if_stmt><if>if <condition>(<expr><name>pattern</name> <operator>&gt;=</operator> <name>pattern_end</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>from</name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
  <return>return <expr><name>PCRE2_ERROR_MISSING_SQUARE_BRACKET</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pattern</name> <operator>==</operator> <name>CHAR_EXCLAMATION_MARK</name>
    <operator>||</operator> <operator>*</operator><name>pattern</name> <operator>==</operator> <name>CHAR_CIRCUMFLEX_ACCENT</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>pattern</name><operator>++</operator></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>pattern</name> <operator>&gt;=</operator> <name>pattern_end</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>from</name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
    <return>return <expr><name>PCRE2_ERROR_MISSING_SQUARE_BRACKET</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>is_negative</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>out_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_LEFT_SQUARE_BRACKET</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>out_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_CIRCUMFLEX_ACCENT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>no_wildsep</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>with_escape</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>out_str</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>CHAR_BACKSLASH</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>out_str</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator> <name>separator</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>convert_glob_write_str</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>convert_glob_write</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>CHAR_LEFT_SQUARE_BRACKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>has_prev_c</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prev_c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pattern</name> <operator>==</operator> <name>CHAR_RIGHT_SQUARE_BRACKET</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>out_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_BACKSLASH</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>out_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_RIGHT_SQUARE_BRACKET</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>convert_glob_write_str</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>has_prev_c</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>prev_c</name> <operator>=</operator> <name>CHAR_RIGHT_SQUARE_BRACKET</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pattern</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>pattern</name> <operator>&lt;</operator> <name>pattern_end</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>char_start</name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_RIGHT_SQUARE_BRACKET</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>convert_glob_write</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_negative</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>no_wildsep</name> <operator>&amp;&amp;</operator> <name>separator_seen</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>out_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_LEFT_PARENTHESIS</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>out_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_QUESTION_MARK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>out_str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_LESS_THAN_SIGN</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>out_str</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_EXCLAMATION_MARK</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>convert_glob_write_str</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>convert_glob_print_separator</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><name>with_escape</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>convert_glob_write</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>CHAR_RIGHT_PARENTHESIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>from</name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>pattern</name> <operator>&gt;=</operator> <name>pattern_end</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_LEFT_SQUARE_BRACKET</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pattern</name> <operator>==</operator> <name>CHAR_COLON</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>from</name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>class_index</name> <operator>=</operator> <call><name>convert_glob_parse_class</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>pattern_end</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>class_index</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>pattern</name> <operator>=</operator> <operator>*</operator><name>from</name></expr>;</expr_stmt>

      <expr_stmt><expr><name>has_prev_c</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>prev_c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_negative</name> <operator>&amp;&amp;</operator>
          <call><name>convert_glob_char_in_class</name> <argument_list>(<argument><expr><name>class_index</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>separator_seen</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_MINUS</name> <operator>&amp;&amp;</operator> <name>has_prev_c</name> <operator>&amp;&amp;</operator>
           <operator>*</operator><name>pattern</name> <operator>!=</operator> <name>CHAR_RIGHT_SQUARE_BRACKET</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>convert_glob_write</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>CHAR_MINUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>char_start</name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>pattern</name> <operator>&gt;=</operator> <name>pattern_end</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>escape</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <name>escape</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>char_start</name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_LEFT_SQUARE_BRACKET</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pattern</name> <operator>==</operator> <name>CHAR_COLON</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>from</name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
      <return>return <expr><name>PCRE2_ERROR_CONVERT_SYNTAX</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>prev_c</name> <operator>&gt;</operator> <name>c</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>from</name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
      <return>return <expr><name>PCRE2_ERROR_CONVERT_SYNTAX</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>prev_c</name> <operator>&lt;</operator> <name>separator</name> <operator>&amp;&amp;</operator> <name>separator</name> <operator>&lt;</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>separator_seen</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>has_prev_c</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>prev_c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>escape</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <name>escape</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>char_start</name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>pattern</name> <operator>&gt;=</operator> <name>pattern_end</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>has_prev_c</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>prev_c</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_LEFT_SQUARE_BRACKET</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>CHAR_RIGHT_SQUARE_BRACKET</name> <operator>||</operator>
      <name>c</name> <operator>==</operator> <name>CHAR_BACKSLASH</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>CHAR_MINUS</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>convert_glob_write</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>CHAR_BACKSLASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>separator</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>separator_seen</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <do>do<block type="pseudo"><block_content> <expr_stmt><expr><call><name>convert_glob_write</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>*</operator><name>char_start</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><name>char_start</name> <operator>&lt;</operator> <name>pattern</name></expr>)</condition>;</do>
  </block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>from</name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
<return>return <expr><name>PCRE2_ERROR_MISSING_SQUARE_BRACKET</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Prints a (*COMMIT) into the output.

Arguments:
  out            output context
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>convert_glob_print_commit</name><parameter_list>(<parameter><decl><type><name>pcre2_output_context</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>out_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_LEFT_PARENTHESIS</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>out_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_ASTERISK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>out_str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_C</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>out_str</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_O</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>out_str</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_M</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>out_str</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_M</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>out_str</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_I</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>out_str</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_T</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>convert_glob_write_str</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>convert_glob_write</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>CHAR_RIGHT_PARENTHESIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Bash glob converter.

Arguments:
  pattype        the pattern type
  pattern        the pattern
  plength        length in code units
  utf            TRUE if UTF
  use_buffer     where to put the output
  use_length     length of use_buffer
  bufflenptr     where to put the used length
  dummyrun       TRUE if a dummy run
  ccontext       the convert context

Returns:         0 =&gt; success
                !0 =&gt; error code
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>convert_glob</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>pattern</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>plength</name></decl></parameter>,
  <parameter><decl><type><name>BOOL</name></type> <name>utf</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>use_buffer</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>use_length</name></decl></parameter>,
  <parameter><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>bufflenptr</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>dummyrun</name></decl></parameter>, <parameter><decl><type><name>pcre2_convert_context</name> <modifier>*</modifier></type><name>ccontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pcre2_output_context</name></type> <name>out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>pattern_start</name> <init>= <expr><name>pattern</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>pattern_end</name> <init>= <expr><name>pattern</name> <operator>+</operator> <name>plength</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>separator</name> <init>= <expr><name><name>ccontext</name><operator>-&gt;</operator><name>glob_separator</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>escape</name> <init>= <expr><name><name>ccontext</name><operator>-&gt;</operator><name>glob_escape</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>no_wildsep</name> <init>= <expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_CONVERT_GLOB_NO_WILD_SEPARATOR</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>no_starstar</name> <init>= <expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_CONVERT_GLOB_NO_STARSTAR</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>in_atomic</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>after_starstar</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>no_slash_z</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>with_escape</name></decl>, <decl><type ref="prev"/><name>is_start</name></decl>, <decl><type ref="prev"/><name>after_separator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>utf</name></expr>;</expr_stmt> <comment type="block">/* Avoid compiler warning. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>separator</name> <operator>&gt;=</operator> <literal type="number">128</literal> <operator>||</operator> <name>escape</name> <operator>&gt;=</operator> <literal type="number">128</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
  <comment type="block">/* Currently only ASCII characters are supported. */</comment>
  <expr_stmt><expr><operator>*</operator><name>bufflenptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>PCRE2_ERROR_CONVERT_SYNTAX</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>with_escape</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>pcre2_escaped_literals</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>

<comment type="block">/* Initialize default for error offset as end of input. */</comment>
<expr_stmt><expr><name><name>out</name><operator>.</operator><name>output</name></name> <operator>=</operator> <name>use_buffer</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>.</operator><name>output_end</name></name> <operator>=</operator> <name>use_buffer</name> <operator>+</operator> <name>use_length</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>.</operator><name>output_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_LEFT_PARENTHESIS</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_QUESTION_MARK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_RIGHT_PARENTHESIS</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>convert_glob_write_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>is_start</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pattern</name> <operator>&lt;</operator> <name>pattern_end</name> <operator>&amp;&amp;</operator> <name><name>pattern</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_ASTERISK</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>no_wildsep</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>is_start</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><operator>!</operator><name>no_starstar</name> <operator>&amp;&amp;</operator> <name>pattern</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>pattern_end</name> <operator>&amp;&amp;</operator>
           <name><name>pattern</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_ASTERISK</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>is_start</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_start</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_BACKSLASH</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_A</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>convert_glob_write_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>pattern</name> <operator>&lt;</operator> <name>pattern_end</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>pattern</name><operator>++</operator></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_ASTERISK</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>is_start</name> <operator>=</operator> <name>pattern</name> <operator>==</operator> <name>pattern_start</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>in_atomic</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>convert_glob_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>CHAR_RIGHT_PARENTHESIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>in_atomic</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>no_starstar</name> <operator>&amp;&amp;</operator> <name>pattern</name> <operator>&lt;</operator> <name>pattern_end</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pattern</name> <operator>==</operator> <name>CHAR_ASTERISK</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>after_separator</name> <operator>=</operator> <name>is_start</name> <operator>||</operator> <operator>(</operator><name><name>pattern</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>separator</name><operator>)</operator></expr>;</expr_stmt>

      <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>pattern</name><operator>++</operator></expr>;</expr_stmt></block_content></block> while <condition>(<expr><name>pattern</name> <operator>&lt;</operator> <name>pattern_end</name> <operator>&amp;&amp;</operator>
                           <operator>*</operator><name>pattern</name> <operator>==</operator> <name>CHAR_ASTERISK</name></expr>)</condition>;</do>

      <if_stmt><if>if <condition>(<expr><name>pattern</name> <operator>&gt;=</operator> <name>pattern_end</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>no_slash_z</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
        </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>after_starstar</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>after_separator</name> <operator>&amp;&amp;</operator> <name>escape</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>pattern</name> <operator>==</operator> <name>escape</name> <operator>&amp;&amp;</operator>
          <name>pattern</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>pattern_end</name> <operator>&amp;&amp;</operator> <name><name>pattern</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>separator</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>pattern</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>is_start</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pattern</name> <operator>!=</operator> <name>separator</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_LEFT_PARENTHESIS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_QUESTION_MARK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_COLON</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_BACKSLASH</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_A</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_VERTICAL_LINE</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>convert_glob_write_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>convert_glob_print_separator</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><name>with_escape</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>convert_glob_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>CHAR_RIGHT_PARENTHESIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>pattern</name><operator>++</operator></expr>;</expr_stmt>
        <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><call><name>convert_glob_print_commit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>after_separator</name> <operator>||</operator> <operator>*</operator><name>pattern</name> <operator>!=</operator> <name>separator</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_DOT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_ASTERISK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_QUESTION_MARK</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>convert_glob_write_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_LEFT_PARENTHESIS</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_QUESTION_MARK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_COLON</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_DOT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_ASTERISK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_QUESTION_MARK</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>convert_glob_write_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>convert_glob_print_separator</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><name>with_escape</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_RIGHT_PARENTHESIS</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_QUESTION_MARK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_QUESTION_MARK</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>convert_glob_write_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>pattern</name><operator>++</operator></expr>;</expr_stmt>
      <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>pattern</name> <operator>&lt;</operator> <name>pattern_end</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pattern</name> <operator>==</operator> <name>CHAR_ASTERISK</name></expr>)</condition>
      <block>{<block_content>
      <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>pattern</name><operator>++</operator></expr>;</expr_stmt></block_content></block> while <condition>(<expr><name>pattern</name> <operator>&lt;</operator> <name>pattern_end</name> <operator>&amp;&amp;</operator>
                           <operator>*</operator><name>pattern</name> <operator>==</operator> <name>CHAR_ASTERISK</name></expr>)</condition>;</do>
      </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>no_wildsep</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>pattern</name> <operator>&gt;=</operator> <name>pattern_end</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>no_slash_z</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Start check must be after the end check. */</comment>
      <if_stmt><if>if <condition>(<expr><name>is_start</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_start</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>after_starstar</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_LEFT_PARENTHESIS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_QUESTION_MARK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_GREATER_THAN_SIGN</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>convert_glob_write_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>in_atomic</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>convert_glob_print_commit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>no_wildsep</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>convert_glob_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>CHAR_DOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>convert_glob_print_wildcard</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><name>with_escape</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_ASTERISK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_QUESTION_MARK</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>pattern</name> <operator>&gt;=</operator> <name>pattern_end</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_PLUS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>convert_glob_write_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_QUESTION_MARK</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>no_wildsep</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>convert_glob_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>CHAR_DOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>convert_glob_print_wildcard</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><name>with_escape</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_LEFT_SQUARE_BRACKET</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>convert_glob_parse_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pattern</name></expr></argument>, <argument><expr><name>pattern_end</name></expr></argument>,
      <argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><name>with_escape</name></expr></argument>, <argument><expr><name>escape</name></expr></argument>, <argument><expr><name>no_wildsep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>escape</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <name>escape</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>pattern</name> <operator>&gt;=</operator> <name>pattern_end</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <name>PCRE2_ERROR_CONVERT_SYNTAX</name></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>pattern</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">128</literal> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>pcre2_escaped_literals</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>convert_glob_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>CHAR_BACKSLASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>convert_glob_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>no_slash_z</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_BACKSLASH</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>out</name><operator>.</operator><name>out_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_z</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>convert_glob_write_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>in_atomic</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>convert_glob_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>CHAR_RIGHT_PARENTHESIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>convert_glob_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name>out</name></expr></argument>, <argument><expr><name>CHAR_NUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dummyrun</name> <operator>&amp;&amp;</operator> <name><name>out</name><operator>.</operator><name>output_size</name></name> <operator>!=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator> <operator>(</operator><name><name>out</name><operator>.</operator><name>output</name></name> <operator>-</operator> <name>use_buffer</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>PCRE2_ERROR_NOMEMORY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>bufflenptr</name> <operator>=</operator> <name>pattern</name> <operator>-</operator> <name>pattern_start</name></expr>;</expr_stmt>
  <return>return <expr><name>result</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>bufflenptr</name> <operator>=</operator> <name><name>out</name><operator>.</operator><name>output_size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*                Convert pattern                 *
*************************************************/</comment>

<comment type="block">/* This is the external-facing function for converting other forms of pattern
into PCRE2 regular expression patterns. On error, the bufflenptr argument is
used to return an offset in the original pattern.

Arguments:
  pattern     the input pattern
  plength     length of input, or PCRE2_ZERO_TERMINATED
  options     options bits
  buffptr     pointer to pointer to output buffer
  bufflenptr  pointer to length of output buffer
  ccontext    convert context or NULL

Returns:      0 for success, else an error code (+ve or -ve)
*/</comment>

<function><type><name>PCRE2_EXP_DEFN</name> <name>int</name> <name>PCRE2_CALL_CONVENTION</name></type>
<name>pcre2_pattern_convert</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>pattern</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>plength</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>options</name></decl></parameter>,
  <parameter><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier><modifier>*</modifier></type><name>buffptr</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>bufflenptr</name></decl></parameter>,
  <parameter><decl><type><name>pcre2_convert_context</name> <modifier>*</modifier></type><name>ccontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name><name>dummy_buffer</name><index>[<expr><name>DUMMY_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>use_buffer</name> <init>= <expr><name>dummy_buffer</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>use_length</name> <init>= <expr><name>DUMMY_BUFFER_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name> <init>= <expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_CONVERT_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>pattype</name> <init>= <expr><name>options</name> <operator>&amp;</operator> <name>TYPE_OPTIONS</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pattern</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>bufflenptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <operator>~</operator><name>ALL_OPTIONS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>        <comment type="block">/* Undefined bit set */</comment>
    <operator>(</operator><name>pattype</name> <operator>&amp;</operator> <operator>(</operator><operator>~</operator><name>pattype</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>!=</operator> <name>pattype</name> <operator>||</operator>  <comment type="block">/* More than one type set */</comment>
    <name>pattype</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>                           <comment type="block">/* No type set */</comment>
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>bufflenptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                          <comment type="block">/* Error offset */</comment>
  <return>return <expr><name>PCRE2_ERROR_BADOPTION</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>plength</name> <operator>==</operator> <name>PCRE2_ZERO_TERMINATED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>plength</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>strlen</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ccontext</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ccontext</name> <operator>=</operator>
  <operator>(</operator><name>pcre2_convert_context</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>default_convert_context</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* Check UTF if required. */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifndef>
<if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>bufflenptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Error offset */</comment>
  <return>return <expr><name>PCRE2_ERROR_UNICODE_NOT_SUPPORTED</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_CONVERT_NO_UTF_CHECK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>erroroffset</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>valid_utf</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>plength</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>erroroffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>bufflenptr</name> <operator>=</operator> <name>erroroffset</name></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* If buffptr is not NULL, and what it points to is not NULL, we are being
provided with a buffer and a length, so set them as the buffer to use. */</comment>

<if_stmt><if>if <condition>(<expr><name>buffptr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>buffptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>use_buffer</name> <operator>=</operator> <operator>*</operator><name>buffptr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>use_length</name> <operator>=</operator> <operator>*</operator><name>bufflenptr</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Call an individual converter, either just once (if a buffer was provided or
just the length is needed), or twice (if a memory allocation is required). */</comment>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>allocated</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>dummyrun</name> <init>= <expr><name>buffptr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>buffptr</name> <operator>==</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>

  <switch>switch<condition>(<expr><name>pattype</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>PCRE2_CONVERT_GLOB</name></expr>:</case>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>convert_glob</name><argument_list>(<argument><expr><name>options</name> <operator>&amp;</operator> <operator>~</operator><name>PCRE2_CONVERT_GLOB</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>plength</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>,
      <argument><expr><name>use_buffer</name></expr></argument>, <argument><expr><name>use_length</name></expr></argument>, <argument><expr><name>bufflenptr</name></expr></argument>, <argument><expr><name>dummyrun</name></expr></argument>, <argument><expr><name>ccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>PCRE2_CONVERT_POSIX_BASIC</name></expr>:</case>
    <case>case <expr><name>PCRE2_CONVERT_POSIX_EXTENDED</name></expr>:</case>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>convert_posix</name><argument_list>(<argument><expr><name>pattype</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>plength</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>use_buffer</name></expr></argument>, <argument><expr><name>use_length</name></expr></argument>,
      <argument><expr><name>bufflenptr</name></expr></argument>, <argument><expr><name>dummyrun</name></expr></argument>, <argument><expr><name>ccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <default>default:</default>
    <expr_stmt><expr><operator>*</operator><name>bufflenptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Error offset */</comment>
    <return>return <expr><name>PCRE2_ERROR_INTERNAL</name></expr>;</return>
    </block_content>}</block></switch>

  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>           <comment type="block">/* Error */</comment>
      <name>buffptr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>   <comment type="block">/* Just the length is required */</comment>
      <operator>*</operator><name>buffptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* Buffer was provided or allocated */</comment>
    <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Allocate memory for the buffer, with hidden space for an allocator at
  the start. The next time round the loop runs the conversion for real. */</comment>

  <expr_stmt><expr><name>allocated</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>memctl_malloc</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pcre2_memctl</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
    <operator>(</operator><operator>*</operator><name>bufflenptr</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>*</operator><name>PCRE2_CODE_UNIT_WIDTH</name></expr></argument>, <argument><expr><operator>(</operator><name>pcre2_memctl</name> <operator>*</operator><operator>)</operator><name>ccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>allocated</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>buffptr</name> <operator>=</operator> <operator>(</operator><name>PCRE2_UCHAR</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>allocated</name><operator>)</operator> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pcre2_memctl</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

  <expr_stmt><expr><name>use_buffer</name> <operator>=</operator> <operator>*</operator><name>buffptr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>use_length</name> <operator>=</operator> <operator>*</operator><name>bufflenptr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></for>

<comment type="block">/* Control should never get here. */</comment>

<return>return <expr><name>PCRE2_ERROR_INTERNAL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*            Free converted pattern              *
*************************************************/</comment>

<comment type="block">/* This frees a converted pattern that was put in newly-allocated memory.

Argument:   the converted pattern
Returns:    nothing
*/</comment>

<function><type><name>PCRE2_EXP_DEFN</name> <name>void</name> <name>PCRE2_CALL_CONVENTION</name></type>
<name>pcre2_converted_pattern_free</name><parameter_list>(<parameter><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>converted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>converted</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>pcre2_memctl</name> <modifier>*</modifier></type><name>memctl</name> <init>=
    <expr><operator>(</operator><name>pcre2_memctl</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>converted</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pcre2_memctl</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name><name>memctl</name><operator>-&gt;</operator><name>free</name></name><argument_list>(<argument><expr><name>memctl</name></expr></argument>, <argument><expr><name><name>memctl</name><operator>-&gt;</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* End of pcre2_convert.c */</comment>
</unit>
