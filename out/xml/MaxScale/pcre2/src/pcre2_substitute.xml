<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/pcre2/src/pcre2_substitute.c"><comment type="block" format="doxygen">/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/</comment>

<comment type="block">/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
     Original API code Copyright (c) 1997-2012 University of Cambridge
          New API code Copyright (c) 2016-2020 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_internal.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PTR_STACK_SIZE</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUBSTITUTE_OPTIONS</name></cpp:macro> \
  <cpp:value>(PCRE2_SUBSTITUTE_EXTENDED|PCRE2_SUBSTITUTE_GLOBAL| \
   PCRE2_SUBSTITUTE_LITERAL|PCRE2_SUBSTITUTE_MATCHED| \
   PCRE2_SUBSTITUTE_OVERFLOW_LENGTH|PCRE2_SUBSTITUTE_REPLACEMENT_ONLY| \
   PCRE2_SUBSTITUTE_UNKNOWN_UNSET|PCRE2_SUBSTITUTE_UNSET_EMPTY)</cpp:value></cpp:define>



<comment type="block" format="doxygen">/*************************************************
*           Find end of substitute text          *
*************************************************/</comment>

<comment type="block">/* In extended mode, we recognize ${name:+set text:unset text} and similar
constructions. This requires the identification of unescaped : and }
characters. This function scans for such. It must deal with nested ${
constructions. The pointer to the text is updated, either to the required end
character, or to where an error was detected.

Arguments:
  code      points to the compiled expression (for options)
  ptrptr    points to the pointer to the start of the text (updated)
  ptrend    end of the whole string
  last      TRUE if the last expected string (only } recognized)

Returns:    0 on success
            negative error code on failure
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>find_text_end</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pcre2_code</name> <modifier>*</modifier></type><name>code</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name> <modifier>*</modifier></type><name>ptrptr</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ptrend</name></decl></parameter>,
  <parameter><decl><type><name>BOOL</name></type> <name>last</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>nestlevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>literal</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ptr</name> <init>= <expr><operator>*</operator><name>ptrptr</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>literal</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_BACKSLASH</name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_E</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>literal</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>

  <if type="elseif">else if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_RIGHT_CURLY_BRACKET</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>nestlevel</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>EXIT</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nestlevel</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></if>

  <if type="elseif">else if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_COLON</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>last</name> <operator>&amp;&amp;</operator> <name>nestlevel</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>EXIT</name>;</goto></block_content></block></if>

  <if type="elseif">else if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_DOLLAR_SIGN</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_LEFT_CURLY_BRACKET</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>nestlevel</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>

  <if type="elseif">else if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_BACKSLASH</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>erc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>errorcode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>ch</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <switch>switch <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>CHAR_L</name></expr>:</case>
      <case>case <expr><name>CHAR_l</name></expr>:</case>
      <case>case <expr><name>CHAR_U</name></expr>:</case>
      <case>case <expr><name>CHAR_u</name></expr>:</case>
      <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <continue>continue;</continue>
      </block_content>}</block></switch></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Must point after \ */</comment>
    <expr_stmt><expr><name>erc</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>check_escape</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>,
      <argument><expr><name><name>code</name><operator>-&gt;</operator><name>overall_options</name></name></expr></argument>, <argument><expr><name><name>code</name><operator>-&gt;</operator><name>extra_options</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Back to last code unit of escape */</comment>
    <if_stmt><if>if <condition>(<expr><name>errorcode</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>errorcode</name></expr>;</expr_stmt>
      <goto>goto <name>EXIT</name>;</goto>
      </block_content>}</block></if></if_stmt>

    <switch>switch<condition>(<expr><name>erc</name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><literal type="number">0</literal></expr>:</case>      <comment type="block">/* Data character */</comment>
      <case>case <expr><name>ESC_E</name></expr>:</case>  <comment type="block">/* Isolated \E is ignored */</comment>
      <break>break;</break>

      <case>case <expr><name>ESC_Q</name></expr>:</case>
      <expr_stmt><expr><name>literal</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <break>break;</break>

      <default>default:</default>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PCRE2_ERROR_BADREPESCAPE</name></expr>;</expr_stmt>
      <goto>goto <name>EXIT</name>;</goto>
      </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PCRE2_ERROR_REPMISSINGBRACE</name></expr>;</expr_stmt>   <comment type="block">/* Terminator not found */</comment>

<label><name>EXIT</name>:</label>
<expr_stmt><expr><operator>*</operator><name>ptrptr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*              Match and substitute              *
*************************************************/</comment>

<comment type="block">/* This function applies a compiled re to a subject string and creates a new
string with substitutions. The first 7 arguments are the same as for
pcre2_match(). Either string length may be PCRE2_ZERO_TERMINATED.

Arguments:
  code            points to the compiled expression
  subject         points to the subject string
  length          length of subject string (may contain binary zeros)
  start_offset    where to start in the subject string
  options         option bits
  match_data      points to a match_data block, or is NULL
  context         points a PCRE2 context
  replacement     points to the replacement string
  rlength         length of replacement string
  buffer          where to put the substituted string
  blength         points to length of buffer; updated to length of string

Returns:          &gt;= 0 number of substitutions made
                  &lt; 0 an error code
                  PCRE2_ERROR_BADREPLACEMENT means invalid use of $
*/</comment>

<comment type="block">/* This macro checks for space in the buffer before copying into it. On
overflow, either give an error immediately, or keep on, accumulating the
length. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECKMEMCPY</name><parameter_list>(<parameter><type><name>from</name></type></parameter>,<parameter><type><name>length</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>{ \
  if (!overflowed &amp;&amp; lengthleft &lt; length) \
    { \
    if ((suboptions &amp; PCRE2_SUBSTITUTE_OVERFLOW_LENGTH) == 0) goto NOROOM; \
    overflowed = TRUE; \
    extra_needed = length - lengthleft; \
    } \
  else if (overflowed) \
    { \
    extra_needed += length; \
    }  \
  else \
    {  \
    memcpy(buffer + buff_offset, from, CU2BYTES(length)); \
    buff_offset += length; \
    lengthleft -= length; \
    } \
  }</cpp:value></cpp:define>

<comment type="block">/* Here's the function */</comment>

<function><type><name>PCRE2_EXP_DEFN</name> <name>int</name> <name>PCRE2_CALL_CONVENTION</name></type>
<name>pcre2_substitute</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pcre2_code</name> <modifier>*</modifier></type><name>code</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>subject</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>length</name></decl></parameter>,
  <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>start_offset</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>pcre2_match_data</name> <modifier>*</modifier></type><name>match_data</name></decl></parameter>,
  <parameter><decl><type><name>pcre2_match_context</name> <modifier>*</modifier></type><name>mcontext</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>replacement</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>rlength</name></decl></parameter>,
  <parameter><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>blength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>subs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>forcecase</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>forcecasereset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>ovector_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>goptions</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>suboptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pcre2_match_data</name> <modifier>*</modifier></type><name>internal_match_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>escaped_literal</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>overflowed</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>use_existing_match</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>replacement_only</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name> <init>= <expr><operator>(</operator><name><name>code</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>ucp</name> <init>= <expr><operator>(</operator><name><name>code</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name><name>temp</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>repend</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>extra_needed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>buff_offset</name></decl>, <decl><type ref="prev"/><name>buff_length</name></decl>, <decl><type ref="prev"/><name>lengthleft</name></decl>, <decl><type ref="prev"/><name>fraglength</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>ovector</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name><name>ovecsave</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pcre2_substitute_callout_block</name></type> <name>scb</name></decl>;</decl_stmt>

<comment type="block">/* General initialization */</comment>

<expr_stmt><expr><name>buff_offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>lengthleft</name> <operator>=</operator> <name>buff_length</name> <operator>=</operator> <operator>*</operator><name>blength</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>blength</name> <operator>=</operator> <name>PCRE2_UNSET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ovecsave</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ovecsave</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>ovecsave</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>PCRE2_UNSET</name></expr>;</expr_stmt>

<comment type="block">/* Partial matching is not valid. This must come after setting *blength to
PCRE2_UNSET, so as not to imply an offset in the replacement. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_PARTIAL_HARD</name><operator>|</operator><name>PCRE2_PARTIAL_SOFT</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>PCRE2_ERROR_BADOPTION</name></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* Check for using a match that has already happened. Note that the subject
pointer in the match data may be NULL after a no-match. */</comment>

<expr_stmt><expr><name>use_existing_match</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_SUBSTITUTE_MATCHED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>replacement_only</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_SUBSTITUTE_REPLACEMENT_ONLY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

<comment type="block">/* If starting from an existing match, there must be an externally provided
match data block. We create an internal match_data block in two cases: (a) an
external one is not supplied (and we are not starting from an existing match);
(b) an existing match is to be used for the first substitution. In the latter
case, we copy the existing match into the internal block. This ensures that no
changes are made to the existing match data block. */</comment>

<if_stmt><if>if <condition>(<expr><name>match_data</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>pcre2_general_context</name> <modifier>*</modifier></type><name>gcontext</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>use_existing_match</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_NULL</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>gcontext</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>mcontext</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then>
    <expr><operator>(</operator><name>pcre2_general_context</name> <operator>*</operator><operator>)</operator><name>code</name></expr> </then><else>:
    <expr><operator>(</operator><name>pcre2_general_context</name> <operator>*</operator><operator>)</operator><name>mcontext</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name>match_data</name> <operator>=</operator> <name>internal_match_data</name> <operator>=</operator>
    <call><name>pcre2_match_data_create_from_pattern</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>gcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>internal_match_data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>use_existing_match</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>pcre2_general_context</name> <modifier>*</modifier></type><name>gcontext</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>mcontext</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then>
    <expr><operator>(</operator><name>pcre2_general_context</name> <operator>*</operator><operator>)</operator><name>code</name></expr> </then><else>:
    <expr><operator>(</operator><name>pcre2_general_context</name> <operator>*</operator><operator>)</operator><name>mcontext</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pairs</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>code</name><operator>-&gt;</operator><name>top_bracket</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>match_data</name><operator>-&gt;</operator><name>oveccount</name></name><operator>)</operator></expr>?</condition><then>
    <expr><name><name>code</name><operator>-&gt;</operator><name>top_bracket</name></name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name><name>match_data</name><operator>-&gt;</operator><name>oveccount</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>internal_match_data</name> <operator>=</operator> <call><name>pcre2_match_data_create</name><argument_list>(<argument><expr><name><name>match_data</name><operator>-&gt;</operator><name>oveccount</name></name></expr></argument>,
    <argument><expr><name>gcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>internal_match_data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>internal_match_data</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>pcre2_match_data</name></expr></argument>, <argument><expr><name>ovector</name></expr></argument>)</argument_list></call>
    <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>pairs</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_SIZE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>match_data</name> <operator>=</operator> <name>internal_match_data</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Remember ovector details */</comment>

<expr_stmt><expr><name>ovector</name> <operator>=</operator> <call><name>pcre2_get_ovector_pointer</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ovector_count</name> <operator>=</operator> <call><name>pcre2_get_ovector_count</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Fixed things in the callout block */</comment>

<expr_stmt><expr><name><name>scb</name><operator>.</operator><name>version</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>scb</name><operator>.</operator><name>input</name></name> <operator>=</operator> <name>subject</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>scb</name><operator>.</operator><name>output</name></name> <operator>=</operator> <operator>(</operator><name>PCRE2_SPTR</name><operator>)</operator><name>buffer</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>scb</name><operator>.</operator><name>ovector</name></name> <operator>=</operator> <name>ovector</name></expr>;</expr_stmt>

<comment type="block">/* Find lengths of zero-terminated strings and the end of the replacement. */</comment>

<if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <name>PCRE2_ZERO_TERMINATED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>length</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>strlen</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>subject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rlength</name> <operator>==</operator> <name>PCRE2_ZERO_TERMINATED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rlength</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>strlen</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>replacement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>repend</name> <operator>=</operator> <name>replacement</name> <operator>+</operator> <name>rlength</name></expr>;</expr_stmt>

<comment type="block">/* Check UTF replacement string if necessary. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NO_UTF_CHECK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>valid_utf</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>replacement</name></expr></argument>, <argument><expr><name>rlength</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>match_data</name><operator>-&gt;</operator><name>startchar</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>leftchar</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <goto>goto <name>EXIT</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

<comment type="block">/* Save the substitute options and remove them from the match options. */</comment>

<expr_stmt><expr><name>suboptions</name> <operator>=</operator> <name>options</name> <operator>&amp;</operator> <name>SUBSTITUTE_OPTIONS</name></expr>;</expr_stmt>
<expr_stmt><expr><name>options</name> <operator>&amp;=</operator> <operator>~</operator><name>SUBSTITUTE_OPTIONS</name></expr>;</expr_stmt>

<comment type="block">/* Error if the start match offset is greater than the length of the subject. */</comment>

<if_stmt><if>if <condition>(<expr><name>start_offset</name> <operator>&gt;</operator> <name>length</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>leftchar</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PCRE2_ERROR_BADOFFSET</name></expr>;</expr_stmt>
  <goto>goto <name>EXIT</name>;</goto>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Copy up to the start offset, unless only the replacement is required. */</comment>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>replacement_only</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>CHECKMEMCPY</name><argument_list>(<argument><expr><name>subject</name></expr></argument>, <argument><expr><name>start_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* Loop for global substituting. If PCRE2_SUBSTITUTE_MATCHED is set, the first
match is taken from the match_data that was passed in. */</comment>

<expr_stmt><expr><name>subs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<do>do
  <block>{<block_content>
  <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name><name>ptrstack</name><index>[<expr><name>PTR_STACK_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>ptrstackptr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>use_existing_match</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>match_data</name><operator>-&gt;</operator><name>rc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>use_existing_match</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pcre2_match</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>subject</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>start_offset</name></expr></argument>, <argument><expr><name>options</name><operator>|</operator><name>goptions</name></expr></argument>,
    <argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>mcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_NO_UTF_CHECK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Only need to check once */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Any error other than no match returns the error code. No match when not
  doing the special after-empty-match global rematch, or when at the end of the
  subject, breaks the global loop. Otherwise, advance the starting point by one
  character, copying it to the output, and try again. */</comment>

  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>save_start</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PCRE2_ERROR_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>EXIT</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>goptions</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>start_offset</name> <operator>&gt;=</operator> <name>length</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

    <comment type="block">/* Advance by one code point. Then, if CRLF is a valid newline sequence and
    we have advanced into the middle of it, advance one more code point. In
    other words, do not start in the middle of CRLF, even if CR and LF on their
    own are valid newlines. */</comment>

    <expr_stmt><expr><name>save_start</name> <operator>=</operator> <name>start_offset</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>subject</name><index>[<expr><name>start_offset</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_CR</name> <operator>&amp;&amp;</operator>
        <name><name>code</name><operator>-&gt;</operator><name>newline_convention</name></name> <operator>!=</operator> <name>PCRE2_NEWLINE_CR</name> <operator>&amp;&amp;</operator>
        <name><name>code</name><operator>-&gt;</operator><name>newline_convention</name></name> <operator>!=</operator> <name>PCRE2_NEWLINE_LF</name> <operator>&amp;&amp;</operator>
        <name>start_offset</name> <operator>&lt;</operator> <name>length</name> <operator>&amp;&amp;</operator>
        <name><name>subject</name><index>[<expr><name>start_offset</name></expr>]</index></name> <operator>==</operator> <name>CHAR_LF</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>start_offset</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>

    <comment type="block">/* Otherwise, in UTF mode, advance past any secondary code points. */</comment>

    <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>code</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
      <while>while <condition>(<expr><name>start_offset</name> <operator>&lt;</operator> <name>length</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>subject</name><index>[<expr><name>start_offset</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>start_offset</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:elif>
      <while>while <condition>(<expr><name>start_offset</name> <operator>&lt;</operator> <name>length</name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>subject</name><index>[<expr><name>start_offset</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xfc00</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xdc00</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>start_offset</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Copy what we have advanced past (unless not required), reset the special
    global options, and continue to the next match. */</comment>

    <expr_stmt><expr><name>fraglength</name> <operator>=</operator> <name>start_offset</name> <operator>-</operator> <name>save_start</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>replacement_only</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>CHECKMEMCPY</name><argument_list>(<argument><expr><name>subject</name> <operator>+</operator> <name>save_start</name></expr></argument>, <argument><expr><name>fraglength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>goptions</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Handle a successful match. Matches that use \K to end before they start
  or start before the current point in the subject are not supported. */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <name>start_offset</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PCRE2_ERROR_BADSUBSPATTERN</name></expr>;</expr_stmt>
    <goto>goto <name>EXIT</name>;</goto>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check for the same match as previous. This is legitimate after matching an
  empty string that starts after the initial match offset. We have tried again
  at the match point in case the pattern is one like /(?&lt;=\G.)/ which can never
  match at its starting point, so running the match achieves the bumpalong. If
  we do get the same (null) match at the original match point, it isn't such a
  pattern, so we now do the empty string magic. In all other cases, a repeat
  match should never occur. */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>ovecsave</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>ovecsave</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>ovecsave</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <name>start_offset</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>goptions</name> <operator>=</operator> <name>PCRE2_NOTEMPTY_ATSTART</name> <operator>|</operator> <name>PCRE2_ANCHORED</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ovecsave</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>start_offset</name></expr>;</expr_stmt>
      <continue>continue;</continue>    <comment type="block">/* Back to the top of the loop */</comment>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PCRE2_ERROR_INTERNAL_DUPMATCH</name></expr>;</expr_stmt>
    <goto>goto <name>EXIT</name>;</goto>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Count substitutions with a paranoid check for integer overflow; surely no
  real call to this function would ever hit this! */</comment>

  <if_stmt><if>if <condition>(<expr><name>subs</name> <operator>==</operator> <name>INT_MAX</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PCRE2_ERROR_TOOMANYREPLACE</name></expr>;</expr_stmt>
    <goto>goto <name>EXIT</name>;</goto>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>subs</name><operator>++</operator></expr>;</expr_stmt>

  <comment type="block">/* Copy the text leading up to the match (unless not required), and remember
  where the insert begins and how many ovector pairs are set. */</comment>

  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>ovector_count</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>fraglength</name> <operator>=</operator> <name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name>start_offset</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>replacement_only</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>CHECKMEMCPY</name><argument_list>(<argument><expr><name>subject</name> <operator>+</operator> <name>start_offset</name></expr></argument>, <argument><expr><name>fraglength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>scb</name><operator>.</operator><name>output_offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>buff_offset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>scb</name><operator>.</operator><name>oveccount</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt>

  <comment type="block">/* Process the replacement string. If the entire replacement is literal, just
  copy it with length check. */</comment>

  <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>replacement</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>suboptions</name> <operator>&amp;</operator> <name>PCRE2_SUBSTITUTE_LITERAL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>CHECKMEMCPY</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>rlength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>

  <comment type="block">/* Within a non-literal replacement, which must be scanned character by
  character, local literal mode can be set by \Q, but only in extended mode
  when backslashes are being interpreted. In extended mode we must handle
  nested substrings that are to be reprocessed. */</comment>

  <else>else<block type="pseudo"><block_content> <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>ch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>chlen</name></decl>;</decl_stmt>

    <comment type="block">/* If at the end of a nested substring, pop the stack. */</comment>

    <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>repend</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>ptrstackptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>       <comment type="block">/* End of replacement string */</comment>
      <expr_stmt><expr><name>repend</name> <operator>=</operator> <name><name>ptrstack</name><index>[<expr><operator>--</operator><name>ptrstackptr</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>ptrstack</name><index>[<expr><operator>--</operator><name>ptrstackptr</name></expr>]</index></name></expr>;</expr_stmt>
      <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Handle the next character */</comment>

    <if_stmt><if>if <condition>(<expr><name>escaped_literal</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_BACKSLASH</name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>&lt;</operator> <name>repend</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_E</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>escaped_literal</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
      <goto>goto <name>LOADLITERAL</name>;</goto>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Not in literal mode. */</comment>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_DOLLAR_SIGN</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>group</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>special</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BOOL</name></type> <name>inparens</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BOOL</name></type> <name>star</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>sublength</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>text1_start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>text1_end</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>text2_start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>text2_end</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>next</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name><name>name</name><index>[<expr><literal type="number">33</literal></expr>]</index></name></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><operator>++</operator><name>ptr</name> <operator>&gt;=</operator> <name>repend</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>BAD</name>;</goto></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>next</name> <operator>=</operator> <operator>*</operator><name>ptr</name><operator>)</operator> <operator>==</operator> <name>CHAR_DOLLAR_SIGN</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>LOADLITERAL</name>;</goto></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>group</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>inparens</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>star</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>next</name> <operator>==</operator> <name>CHAR_LEFT_CURLY_BRACKET</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>++</operator><name>ptr</name> <operator>&gt;=</operator> <name>repend</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>BAD</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>next</name> <operator>=</operator> <operator>*</operator><name>ptr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>inparens</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>next</name> <operator>==</operator> <name>CHAR_ASTERISK</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>++</operator><name>ptr</name> <operator>&gt;=</operator> <name>repend</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>BAD</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>next</name> <operator>=</operator> <operator>*</operator><name>ptr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>star</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>star</name> <operator>&amp;&amp;</operator> <name>next</name> <operator>&gt;=</operator> <name>CHAR_0</name> <operator>&amp;&amp;</operator> <name>next</name> <operator>&lt;=</operator> <name>CHAR_9</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>group</name> <operator>=</operator> <name>next</name> <operator>-</operator> <name>CHAR_0</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>++</operator><name>ptr</name> <operator>&lt;</operator> <name>repend</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>next</name> <operator>=</operator> <operator>*</operator><name>ptr</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name><name>next</name> <argument_list type="generic">&lt; <argument><expr><name>CHAR_0</name> <operator>||</operator> <name>next</name></expr></argument> &gt;</argument_list></name> <name>CHAR_9</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>group</name> <operator>=</operator> <name>group</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <name>next</name> <operator>-</operator> <name>CHAR_0</name></expr>;</expr_stmt>

          <comment type="block">/* A check for a number greater than the hightest captured group
          is sufficient here; no need for a separate overflow check. If unknown
          groups are to be treated as unset, just skip over any remaining
          digits and carry on. */</comment>

          <if_stmt><if>if <condition>(<expr><name>group</name> <operator>&gt;</operator> <name><name>code</name><operator>-&gt;</operator><name>top_bracket</name></name></expr>)</condition>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>suboptions</name> <operator>&amp;</operator> <name>PCRE2_SUBSTITUTE_UNKNOWN_UNSET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
              <block>{<block_content>
              <while>while <condition>(<expr><operator>++</operator><name>ptr</name> <operator>&lt;</operator> <name>repend</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>&gt;=</operator> <name>CHAR_0</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>&lt;=</operator> <name>CHAR_9</name></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>
              <break>break;</break>
              </block_content>}</block></if>
            <else>else
              <block>{<block_content>
              <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PCRE2_ERROR_NOSUBSTRING</name></expr>;</expr_stmt>
              <goto>goto <name>PTREXIT</name>;</goto>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></while>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>ctypes</name> <init>= <expr><name><name>code</name><operator>-&gt;</operator><name>tables</name></name> <operator>+</operator> <name>ctypes_offset</name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name>MAX_255</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ctypes</name><index>[<expr><name>next</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name><name>name</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>BAD</name>;</goto></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><operator>++</operator><name>ptr</name> <operator>&gt;=</operator> <name>repend</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>next</name> <operator>=</operator> <operator>*</operator><name>ptr</name></expr>;</expr_stmt>
          </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>BAD</name>;</goto></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>name</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

      <comment type="block">/* In extended mode we recognize ${name:+set text:unset text} and
      ${name:-default text}. */</comment>

      <if_stmt><if>if <condition>(<expr><name>inparens</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>suboptions</name> <operator>&amp;</operator> <name>PCRE2_SUBSTITUTE_EXTENDED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
             <operator>!</operator><name>star</name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>&lt;</operator> <name>repend</name> <operator>-</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>next</name> <operator>==</operator> <name>CHAR_COLON</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>special</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>++</operator><name>ptr</name><operator>)</operator></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>special</name> <operator>!=</operator> <name>CHAR_PLUS</name> <operator>&amp;&amp;</operator> <name>special</name> <operator>!=</operator> <name>CHAR_MINUS</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PCRE2_ERROR_BADSUBSTITUTION</name></expr>;</expr_stmt>
            <goto>goto <name>PTREXIT</name>;</goto>
            </block_content>}</block></if></if_stmt>

          <expr_stmt><expr><name>text1_start</name> <operator>=</operator> <operator>++</operator><name>ptr</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>find_text_end</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>repend</name></expr></argument>, <argument><expr><name>special</name> <operator>==</operator> <name>CHAR_MINUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>PTREXIT</name>;</goto></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>text1_end</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

          <if_stmt><if>if <condition>(<expr><name>special</name> <operator>==</operator> <name>CHAR_PLUS</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_COLON</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>text2_start</name> <operator>=</operator> <operator>++</operator><name>ptr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>find_text_end</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>repend</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>PTREXIT</name>;</goto></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>text2_end</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if>

        <else>else
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>repend</name> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_RIGHT_CURLY_BRACKET</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PCRE2_ERROR_REPMISSINGBRACE</name></expr>;</expr_stmt>
            <goto>goto <name>PTREXIT</name>;</goto>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Have found a syntactically correct group number or name, or *name.
      Only *MARK is currently recognized. */</comment>

      <if_stmt><if>if <condition>(<expr><name>star</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><call><name>PRIV</name><argument_list>(<argument><expr><name>strcmp_c8</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>STRING_MARK</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>mark</name> <init>= <expr><call><name>pcre2_get_mark</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>mark</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
            <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>mark_start</name> <init>= <expr><name>mark</name></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><operator>*</operator><name>mark</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mark</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
            <expr_stmt><expr><name>fraglength</name> <operator>=</operator> <name>mark</name> <operator>-</operator> <name>mark_start</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CHECKMEMCPY</name><argument_list>(<argument><expr><name>mark_start</name></expr></argument>, <argument><expr><name>fraglength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content> <goto>goto <name>BAD</name>;</goto></block_content></block></else></if_stmt>
        </block_content>}</block></if>

      <comment type="block">/* Substitute the contents of a group. We don't use substring_copy
      functions any more, in order to support case forcing. */</comment>

      <else>else
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>subptr</name></decl>, <decl><type ref="prev"/><name>subptrend</name></decl>;</decl_stmt>

        <comment type="block">/* Find a number for a named group. In case there are duplicate names,
        search for the first one that is set. If the name is not found when
        PCRE2_SUBSTITUTE_UNKNOWN_EMPTY is set, set the group number to a
        non-existent group. */</comment>

        <if_stmt><if>if <condition>(<expr><name>group</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>first</name></decl>, <decl><type ref="prev"/><name>last</name></decl>, <decl><type ref="prev"/><name>entry</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pcre2_substring_nametable_scan</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>first</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PCRE2_ERROR_NOSUBSTRING</name> <operator>&amp;&amp;</operator>
              <operator>(</operator><name>suboptions</name> <operator>&amp;</operator> <name>PCRE2_SUBSTITUTE_UNKNOWN_UNSET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>group</name> <operator>=</operator> <name><name>code</name><operator>-&gt;</operator><name>top_bracket</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if>
          <else>else
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>PTREXIT</name>;</goto></block_content></block></if></if_stmt>
            <for>for <control>(<init><expr><name>entry</name> <operator>=</operator> <name>first</name></expr>;</init> <condition><expr><name>entry</name> <operator>&lt;=</operator> <name>last</name></expr>;</condition> <incr><expr><name>entry</name> <operator>+=</operator> <name>rc</name></expr></incr>)</control>
              <block>{<block_content>
              <decl_stmt><decl><type><name>uint32_t</name></type> <name>ng</name> <init>= <expr><call><name>GET2</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <if_stmt><if>if <condition>(<expr><name>ng</name> <operator>&lt;</operator> <name>ovector_count</name></expr>)</condition>
                <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>group</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>group</name> <operator>=</operator> <name>ng</name></expr>;</expr_stmt></block_content></block></if></if_stmt>          <comment type="block">/* First in ovector */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>ovector</name><index>[<expr><name>ng</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <name>PCRE2_UNSET</name></expr>)</condition>
                  <block>{<block_content>
                  <expr_stmt><expr><name>group</name> <operator>=</operator> <name>ng</name></expr>;</expr_stmt>                       <comment type="block">/* First that is set */</comment>
                  <break>break;</break>
                  </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
              </block_content>}</block></for>

            <comment type="block">/* If group is still negative, it means we did not find a group
            that is in the ovector. Just set the first group. */</comment>

            <if_stmt><if>if <condition>(<expr><name>group</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>first</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if></if_stmt>

        <comment type="block">/* We now have a group that is identified by number. Find the length of
        the captured string. If a group in a non-special substitution is unset
        when PCRE2_SUBSTITUTE_UNSET_EMPTY is set, substitute nothing. */</comment>

        <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pcre2_substring_length_bynumber</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>group</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sublength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PCRE2_ERROR_NOSUBSTRING</name> <operator>&amp;&amp;</operator>
              <operator>(</operator><name>suboptions</name> <operator>&amp;</operator> <name>PCRE2_SUBSTITUTE_UNKNOWN_UNSET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PCRE2_ERROR_UNSET</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>PCRE2_ERROR_UNSET</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>PTREXIT</name>;</goto></block_content></block></if></if_stmt>  <comment type="block">/* Non-unset errors */</comment>
          <if_stmt><if>if <condition>(<expr><name>special</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>                           <comment type="block">/* Plain substitution */</comment>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>suboptions</name> <operator>&amp;</operator> <name>PCRE2_SUBSTITUTE_UNSET_EMPTY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
            <goto>goto <name>PTREXIT</name>;</goto>                             <comment type="block">/* Else error */</comment>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>

        <comment type="block">/* If special is '+' we have a 'set' and possibly an 'unset' text,
        both of which are reprocessed when used. If special is '-' we have a
        default text for when the group is unset; it must be reprocessed. */</comment>

        <if_stmt><if>if <condition>(<expr><name>special</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>special</name> <operator>==</operator> <name>CHAR_MINUS</name></expr>)</condition>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>LITERAL_SUBSTITUTE</name>;</goto></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>text2_start</name> <operator>=</operator> <name>text1_start</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>text2_end</name> <operator>=</operator> <name>text1_end</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

          <if_stmt><if>if <condition>(<expr><name>ptrstackptr</name> <operator>&gt;=</operator> <name>PTR_STACK_SIZE</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>BAD</name>;</goto></block_content></block></if></if_stmt>
          <expr_stmt><expr><name><name>ptrstack</name><index>[<expr><name>ptrstackptr</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>ptrstack</name><index>[<expr><name>ptrstackptr</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>repend</name></expr>;</expr_stmt>

          <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>text1_start</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>repend</name> <operator>=</operator> <name>text1_end</name></expr>;</expr_stmt>
            </block_content>}</block></if>
          <else>else
            <block>{<block_content>
            <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>text2_start</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>repend</name> <operator>=</operator> <name>text2_end</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          <continue>continue;</continue>
          </block_content>}</block></if></if_stmt>

        <comment type="block">/* Otherwise we have a literal substitution of a group's contents. */</comment>

        <label><name>LITERAL_SUBSTITUTE</name>:</label>
        <expr_stmt><expr><name>subptr</name> <operator>=</operator> <name>subject</name> <operator>+</operator> <name><name>ovector</name><index>[<expr><name>group</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>subptrend</name> <operator>=</operator> <name>subject</name> <operator>+</operator> <name><name>ovector</name><index>[<expr><name>group</name><operator>*</operator><literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

        <comment type="block">/* Substitute a literal string, possibly forcing alphabetic case. */</comment>

        <while>while <condition>(<expr><name>subptr</name> <operator>&lt;</operator> <name>subptrend</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>subptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>forcecase</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>||</operator> <name>ucp</name></expr>)</condition>
              <block>{<block_content>
              <decl_stmt><decl><type><name>uint32_t</name></type> <name>type</name> <init>= <expr><call><name>UCD_CHARTYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <if_stmt><if>if <condition>(<expr><call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name>type</name></expr>]</index> <operator>==</operator> <name>ucp_L</name> <operator>&amp;&amp;</operator>
                  <name>type</name> <operator>!=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>forcecase</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name>ucp_Lu</name></expr> </then><else>: <expr><name>ucp_Ll</name></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
              </block_content>}</block></if>
            <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
              <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>code</name><operator>-&gt;</operator><name>tables</name></name> <operator>+</operator> <name>cbits_offset</name> <operator>+</operator>
                  <operator>(</operator><ternary><condition><expr><operator>(</operator><name>forcecase</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name>cbit_upper</name></expr></then><else>:<expr><name>cbit_lower</name></expr></else></ternary><operator>)</operator>
                  <operator>)</operator><index>[<expr><name>ch</name><operator>/</operator><literal type="number">8</literal></expr>]</index> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>ch</name><operator>%</operator><literal type="number">8</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>(</operator><name><name>code</name><operator>-&gt;</operator><name>tables</name></name> <operator>+</operator> <name>fcc_offset</name><operator>)</operator><index>[<expr><name>ch</name></expr>]</index></expr>;</expr_stmt></block_content></block></if></if_stmt>
              </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>forcecase</name> <operator>=</operator> <name>forcecasereset</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
          <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>chlen</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>ord2utf</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <block>{<block_content>
            <expr_stmt><expr><name><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>chlen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><call><name>CHECKMEMCPY</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>chlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></while>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if>

    <comment type="block">/* Handle an escape sequence in extended mode. We can use check_escape()
    to process \Q, \E, \c, \o, \x and \ followed by non-alphanumerics, but
    the case-forcing escapes are not supported in pcre2_compile() so must be
    recognized here. */</comment>

    <if type="elseif">else if <condition>(<expr><operator>(</operator><name>suboptions</name> <operator>&amp;</operator> <name>PCRE2_SUBSTITUTE_EXTENDED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
              <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_BACKSLASH</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>errorcode</name></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>repend</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <switch>switch <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>CHAR_L</name></expr>:</case>
        <expr_stmt><expr><name>forcecase</name> <operator>=</operator> <name>forcecasereset</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <continue>continue;</continue>

        <case>case <expr><name>CHAR_l</name></expr>:</case>
        <expr_stmt><expr><name>forcecase</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>forcecasereset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <continue>continue;</continue>

        <case>case <expr><name>CHAR_U</name></expr>:</case>
        <expr_stmt><expr><name>forcecase</name> <operator>=</operator> <name>forcecasereset</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <continue>continue;</continue>

        <case>case <expr><name>CHAR_u</name></expr>:</case>
        <expr_stmt><expr><name>forcecase</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>forcecasereset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <continue>continue;</continue>

        <default>default:</default>
        <break>break;</break>
        </block_content>}</block></switch></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* Point after \ */</comment>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>check_escape</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>repend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>,
        <argument><expr><name><name>code</name><operator>-&gt;</operator><name>overall_options</name></name></expr></argument>, <argument><expr><name><name>code</name><operator>-&gt;</operator><name>extra_options</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>errorcode</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>BADESCAPE</name>;</goto></block_content></block></if></if_stmt>

      <switch>switch<condition>(<expr><name>rc</name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>ESC_E</name></expr>:</case>
        <expr_stmt><expr><name>forcecase</name> <operator>=</operator> <name>forcecasereset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <continue>continue;</continue>

        <case>case <expr><name>ESC_Q</name></expr>:</case>
        <expr_stmt><expr><name>escaped_literal</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
        <continue>continue;</continue>

        <case>case <expr><literal type="number">0</literal></expr>:</case>      <comment type="block">/* Data character */</comment>
        <goto>goto <name>LITERAL</name>;</goto>

        <default>default:</default>
        <goto>goto <name>BADESCAPE</name>;</goto>
        </block_content>}</block></switch>
      </block_content>}</block></if>

    <comment type="block">/* Handle a literal code unit */</comment>

    <else>else
      <block>{<block_content>
      <label><name>LOADLITERAL</name>:</label>
      <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* Get character value, increment pointer */</comment>

      <label><name>LITERAL</name>:</label>
      <if_stmt><if>if <condition>(<expr><name>forcecase</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>||</operator> <name>ucp</name></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>uint32_t</name></type> <name>type</name> <init>= <expr><call><name>UCD_CHARTYPE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name>type</name></expr>]</index> <operator>==</operator> <name>ucp_L</name> <operator>&amp;&amp;</operator>
              <name>type</name> <operator>!=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>forcecase</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name>ucp_Lu</name></expr> </then><else>: <expr><name>ucp_Ll</name></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>ch</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></if>
        <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>code</name><operator>-&gt;</operator><name>tables</name></name> <operator>+</operator> <name>cbits_offset</name> <operator>+</operator>
              <operator>(</operator><ternary><condition><expr><operator>(</operator><name>forcecase</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name>cbit_upper</name></expr></then><else>:<expr><name>cbit_lower</name></expr></else></ternary><operator>)</operator>
              <operator>)</operator><index>[<expr><name>ch</name><operator>/</operator><literal type="number">8</literal></expr>]</index> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>ch</name><operator>%</operator><literal type="number">8</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>(</operator><name><name>code</name><operator>-&gt;</operator><name>tables</name></name> <operator>+</operator> <name>fcc_offset</name><operator>)</operator><index>[<expr><name>ch</name></expr>]</index></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>forcecase</name> <operator>=</operator> <name>forcecasereset</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>chlen</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>ord2utf</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{<block_content>
        <expr_stmt><expr><name><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>chlen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>CHECKMEMCPY</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>chlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt> <comment type="block">/* End handling a literal code unit */</comment>
    </block_content>}</block></for></block_content></block></else></if_stmt>   <comment type="block">/* End of loop for scanning the replacement. */</comment>

  <comment type="block">/* The replacement has been copied to the output, or its size has been
  remembered. Do the callout if there is one and we have done an actual
  replacement. */</comment>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>overflowed</name> <operator>&amp;&amp;</operator> <name>mcontext</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>mcontext</name><operator>-&gt;</operator><name>substitute_callout</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name><name>scb</name><operator>.</operator><name>subscount</name></name> <operator>=</operator> <name>subs</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scb</name><operator>.</operator><name>output_offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>buff_offset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>mcontext</name><operator>-&gt;</operator><name>substitute_callout</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>scb</name></expr></argument>, <argument><expr><name><name>mcontext</name><operator>-&gt;</operator><name>substitute_callout_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* A non-zero return means cancel this substitution. Instead, copy the
    matched string fragment. */</comment>

    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>newlength</name> <init>= <expr><name><name>scb</name><operator>.</operator><name>output_offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>scb</name><operator>.</operator><name>output_offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>oldlength</name> <init>= <expr><name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>buff_offset</name> <operator>-=</operator> <name>newlength</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>lengthleft</name> <operator>+=</operator> <name>newlength</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>replacement_only</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>CHECKMEMCPY</name><argument_list>(<argument><expr><name>subject</name> <operator>+</operator> <name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>oldlength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <comment type="block">/* A negative return means do not do any more. */</comment>

      <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>suboptions</name> <operator>&amp;=</operator> <operator>(</operator><operator>~</operator><name>PCRE2_SUBSTITUTE_GLOBAL</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Save the details of this match. See above for how this data is used. If we
  matched an empty string, do the magic for global matches. Update the start
  offset to point to the rest of the subject string. If we re-used an existing
  match for the first match, switch to the internal match data block. */</comment>

  <expr_stmt><expr><name><name>ovecsave</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ovecsave</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ovecsave</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>start_offset</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>goptions</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <name>start_offset</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
    <expr><name>PCRE2_ANCHORED</name><operator>|</operator><name>PCRE2_NOTEMPTY_ATSTART</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><name>start_offset</name> <operator>=</operator> <name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block> while <condition>(<expr><operator>(</operator><name>suboptions</name> <operator>&amp;</operator> <name>PCRE2_SUBSTITUTE_GLOBAL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>  <comment type="block">/* Repeat "do" loop */</comment>

<comment type="block">/* Copy the rest of the subject unless not required, and terminate the output
with a binary zero. */</comment>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>replacement_only</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>fraglength</name> <operator>=</operator> <name>length</name> <operator>-</operator> <name>start_offset</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>CHECKMEMCPY</name><argument_list>(<argument><expr><name>subject</name> <operator>+</operator> <name>start_offset</name></expr></argument>, <argument><expr><name>fraglength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>temp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECKMEMCPY</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* If overflowed is set it means the PCRE2_SUBSTITUTE_OVERFLOW_LENGTH is set,
and matching has carried on after a full buffer, in order to compute the length
needed. Otherwise, an overflow generates an immediate error return. */</comment>

<if_stmt><if>if <condition>(<expr><name>overflowed</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PCRE2_ERROR_NOMEMORY</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>blength</name> <operator>=</operator> <name>buff_length</name> <operator>+</operator> <name>extra_needed</name></expr>;</expr_stmt>
  </block_content>}</block></if>

<comment type="block">/* After a successful execution, return the number of substitutions and set the
length of buffer used, excluding the trailing zero. */</comment>

<else>else
  <block>{<block_content>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>subs</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>blength</name> <operator>=</operator> <name>buff_offset</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<label><name>EXIT</name>:</label>
<if_stmt><if>if <condition>(<expr><name>internal_match_data</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pcre2_match_data_free</name><argument_list>(<argument><expr><name>internal_match_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>match_data</name><operator>-&gt;</operator><name>rc</name></name> <operator>=</operator> <name>rc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><name>rc</name></expr>;</return>

<label><name>NOROOM</name>:</label>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PCRE2_ERROR_NOMEMORY</name></expr>;</expr_stmt>
<goto>goto <name>EXIT</name>;</goto>

<label><name>BAD</name>:</label>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PCRE2_ERROR_BADREPLACEMENT</name></expr>;</expr_stmt>
<goto>goto <name>PTREXIT</name>;</goto>

<label><name>BADESCAPE</name>:</label>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>PCRE2_ERROR_BADREPESCAPE</name></expr>;</expr_stmt>

<label><name>PTREXIT</name>:</label>
<expr_stmt><expr><operator>*</operator><name>blength</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <name>replacement</name><operator>)</operator></expr>;</expr_stmt>
<goto>goto <name>EXIT</name>;</goto>
</block_content>}</block></function>

<comment type="block">/* End of pcre2_substitute.c */</comment>
</unit>
