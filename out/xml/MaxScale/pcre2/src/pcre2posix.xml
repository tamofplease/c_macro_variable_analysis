<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/pcre2/src/pcre2posix.c"><comment type="block" format="doxygen">/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/</comment>

<comment type="block">/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
     Original API code Copyright (c) 1997-2012 University of Cambridge
          New API code Copyright (c) 2016-2019 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/</comment>


<comment type="block">/* This module is a wrapper that provides a POSIX API to the underlying PCRE2
functions. The operative functions are called pcre2_regcomp(), etc., with
wrappers that use the plain POSIX names. In addition, pcre2posix.h defines the
POSIX names as macros for the pcre2_xxx functions, so any program that includes
it and uses the POSIX names will call the base functions directly. This makes
it easier for an application to be sure it gets the PCRE2 versions in the
presence of other POSIX regex libraries. */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Ensure that the PCRE2POSIX_EXP_xxx macros are set appropriately for
compiling these functions. This must come before including pcre2posix.h, where
they are set for an application (using these functions) if they have not
previously been set. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PCRE2_STATIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2POSIX_EXP_DECL</name></cpp:macro> <cpp:value>extern __declspec(dllexport)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2POSIX_EXP_DEFN</name></cpp:macro> <cpp:value>__declspec(dllexport)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Older versions of MSVC lack snprintf(). This define allows for
warning/error-free compilation and testing with MSVC compilers back to at least
MSVC 10/2010. Except for VC6 (which is missing some fundamentals and fails). */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>_MSC_VER</name> <operator>&lt;</operator> <literal type="number">1900</literal><operator>)</operator></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>snprintf</name></cpp:macro> <cpp:value>_snprintf</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Compile-time error numbers start at this value. It should probably never be
changed. This #define is a copy of the one in pcre2_internal.h. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPILE_ERROR_BASE</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>


<comment type="block">/* Standard C headers */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<comment type="block">/* PCRE2 headers */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2posix.h"</cpp:file></cpp:include>

<comment type="block">/* When compiling with the MSVC compiler, it is sometimes necessary to include
a "calling convention" before exported function names. (This is secondhand
information; I know nothing about MSVC myself). For example, something like

  void __cdecl function(....)

might be needed. In order to make this easy, all the exported functions have
PCRE2_CALL_CONVENTION just before their names. It is rarely needed; if not
set, we ensure here that it has no effect. */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PCRE2_CALL_CONVENTION</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CALL_CONVENTION</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Table to translate PCRE2 compile time error codes into POSIX error codes.
Only a few PCRE2 errors with a value greater than 23 turn into special POSIX
codes: most go to REG_BADPAT. The second table lists, in pairs, those that
don't. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>eint1</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>,           <comment type="block">/* No error */</comment>
  <expr><name>REG_EESCAPE</name></expr>, <comment type="block">/* \ at end of pattern */</comment>
  <expr><name>REG_EESCAPE</name></expr>, <comment type="block">/* \c at end of pattern */</comment>
  <expr><name>REG_EESCAPE</name></expr>, <comment type="block">/* unrecognized character follows \ */</comment>
  <expr><name>REG_BADBR</name></expr>,   <comment type="block">/* numbers out of order in {} quantifier */</comment>
  <comment type="block">/* 5 */</comment>
  <expr><name>REG_BADBR</name></expr>,   <comment type="block">/* number too big in {} quantifier */</comment>
  <expr><name>REG_EBRACK</name></expr>,  <comment type="block">/* missing terminating ] for character class */</comment>
  <expr><name>REG_ECTYPE</name></expr>,  <comment type="block">/* invalid escape sequence in character class */</comment>
  <expr><name>REG_ERANGE</name></expr>,  <comment type="block">/* range out of order in character class */</comment>
  <expr><name>REG_BADRPT</name></expr>,  <comment type="block">/* nothing to repeat */</comment>
  <comment type="block">/* 10 */</comment>
  <expr><name>REG_ASSERT</name></expr>,  <comment type="block">/* internal error: unexpected repeat */</comment>
  <expr><name>REG_BADPAT</name></expr>,  <comment type="block">/* unrecognized character after (? or (?- */</comment>
  <expr><name>REG_BADPAT</name></expr>,  <comment type="block">/* POSIX named classes are supported only within a class */</comment>
  <expr><name>REG_BADPAT</name></expr>,  <comment type="block">/* POSIX collating elements are not supported */</comment>
  <expr><name>REG_EPAREN</name></expr>,  <comment type="block">/* missing ) */</comment>
  <comment type="block">/* 15 */</comment>
  <expr><name>REG_ESUBREG</name></expr>, <comment type="block">/* reference to non-existent subpattern */</comment>
  <expr><name>REG_INVARG</name></expr>,  <comment type="block">/* pattern passed as NULL */</comment>
  <expr><name>REG_INVARG</name></expr>,  <comment type="block">/* unknown compile-time option bit(s) */</comment>
  <expr><name>REG_EPAREN</name></expr>,  <comment type="block">/* missing ) after (?# comment */</comment>
  <expr><name>REG_ESIZE</name></expr>,   <comment type="block">/* parentheses nested too deeply */</comment>
  <comment type="block">/* 20 */</comment>
  <expr><name>REG_ESIZE</name></expr>,   <comment type="block">/* regular expression too large */</comment>
  <expr><name>REG_ESPACE</name></expr>,  <comment type="block">/* failed to get memory */</comment>
  <expr><name>REG_EPAREN</name></expr>,  <comment type="block">/* unmatched closing parenthesis */</comment>
  <expr><name>REG_ASSERT</name></expr>   <comment type="block">/* internal error: code overflow */</comment>
  }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>eint2</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="number">30</literal></expr>, <expr><name>REG_ECTYPE</name></expr>,  <comment type="block">/* unknown POSIX class name */</comment>
  <expr><literal type="number">32</literal></expr>, <expr><name>REG_INVARG</name></expr>,  <comment type="block">/* this version of PCRE2 does not have Unicode support */</comment>
  <expr><literal type="number">37</literal></expr>, <expr><name>REG_EESCAPE</name></expr>, <comment type="block">/* PCRE2 does not support \L, \l, \N{name}, \U, or \u */</comment>
  <expr><literal type="number">56</literal></expr>, <expr><name>REG_INVARG</name></expr>,  <comment type="block">/* internal error: unknown newline setting */</comment>
  <expr><literal type="number">92</literal></expr>, <expr><name>REG_INVARG</name></expr>,  <comment type="block">/* invalid option bits with PCRE2_LITERAL */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Table of texts corresponding to POSIX error codes */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>pstring</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="string">""</literal></expr>,                                <comment type="block">/* Dummy for value 0 */</comment>
  <expr><literal type="string">"internal error"</literal></expr>,                  <comment type="block">/* REG_ASSERT */</comment>
  <expr><literal type="string">"invalid repeat counts in {}"</literal></expr>,     <comment type="block">/* BADBR      */</comment>
  <expr><literal type="string">"pattern error"</literal></expr>,                   <comment type="block">/* BADPAT     */</comment>
  <expr><literal type="string">"? * + invalid"</literal></expr>,                   <comment type="block">/* BADRPT     */</comment>
  <expr><literal type="string">"unbalanced {}"</literal></expr>,                   <comment type="block">/* EBRACE     */</comment>
  <expr><literal type="string">"unbalanced []"</literal></expr>,                   <comment type="block">/* EBRACK     */</comment>
  <expr><literal type="string">"collation error - not relevant"</literal></expr>,  <comment type="block">/* ECOLLATE   */</comment>
  <expr><literal type="string">"bad class"</literal></expr>,                       <comment type="block">/* ECTYPE     */</comment>
  <expr><literal type="string">"bad escape sequence"</literal></expr>,             <comment type="block">/* EESCAPE    */</comment>
  <expr><literal type="string">"empty expression"</literal></expr>,                <comment type="block">/* EMPTY      */</comment>
  <expr><literal type="string">"unbalanced ()"</literal></expr>,                   <comment type="block">/* EPAREN     */</comment>
  <expr><literal type="string">"bad range inside []"</literal></expr>,             <comment type="block">/* ERANGE     */</comment>
  <expr><literal type="string">"expression too big"</literal></expr>,              <comment type="block">/* ESIZE      */</comment>
  <expr><literal type="string">"failed to get memory"</literal></expr>,            <comment type="block">/* ESPACE     */</comment>
  <expr><literal type="string">"bad back reference"</literal></expr>,              <comment type="block">/* ESUBREG    */</comment>
  <expr><literal type="string">"bad argument"</literal></expr>,                    <comment type="block">/* INVARG     */</comment>
  <expr><literal type="string">"match failed"</literal></expr>                     <comment type="block">/* NOMATCH    */</comment>
}</block></expr></init></decl>;</decl_stmt>



<comment type="block" format="doxygen">/*************************************************
*      Wrappers with traditional POSIX names     *
*************************************************/</comment>

<comment type="block">/* Keep defining them to preseve the ABI for applications linked to the pcre2
POSIX library before these names were changed into macros in pcre2posix.h.
This also ensures that the POSIX names are callable from languages that do not
include pcre2posix.h. It is vital to #undef the macro definitions from
pcre2posix.h! */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>regerror</name></cpp:undef>
<function_decl><type><name>PCRE2POSIX_EXP_DECL</name> <name>size_t</name></type> <name>regerror</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>regex_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>PCRE2POSIX_EXP_DEFN</name> <name>size_t</name> <name>PCRE2_CALL_CONVENTION</name></type>
<name>regerror</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>regex_t</name> <modifier>*</modifier></type><name>preg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>errbuf_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>pcre2_regerror</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>, <argument><expr><name>preg</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errbuf_size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>regfree</name></cpp:undef>
<function_decl><type><name>PCRE2POSIX_EXP_DECL</name> <name>void</name></type> <name>regfree</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>PCRE2POSIX_EXP_DEFN</name> <name>void</name> <name>PCRE2_CALL_CONVENTION</name></type>
<name>regfree</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>preg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcre2_regfree</name><argument_list>(<argument><expr><name>preg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>regcomp</name></cpp:undef>
<function_decl><type><name>PCRE2POSIX_EXP_DECL</name> <name>int</name></type> <name>regcomp</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>PCRE2POSIX_EXP_DEFN</name> <name>int</name> <name>PCRE2_CALL_CONVENTION</name></type>
<name>regcomp</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>preg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>pcre2_regcomp</name><argument_list>(<argument><expr><name>preg</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>cflags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>regexec</name></cpp:undef>
<function_decl><type><name>PCRE2POSIX_EXP_DECL</name> <name>int</name></type> <name>regexec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>regex_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>,
  <parameter><decl><type><name>regmatch_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>PCRE2POSIX_EXP_DEFN</name> <name>int</name> <name>PCRE2_CALL_CONVENTION</name></type>
<name>regexec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>regex_t</name> <modifier>*</modifier></type><name>preg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nmatch</name></decl></parameter>,
  <parameter><decl><type><name>regmatch_t</name></type> <name><name>pmatch</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>pcre2_regexec</name><argument_list>(<argument><expr><name>preg</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>nmatch</name></expr></argument>, <argument><expr><name>pmatch</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*          Translate error code to string        *
*************************************************/</comment>

<function><type><name>PCRE2POSIX_EXP_DEFN</name> <name>size_t</name> <name>PCRE2_CALL_CONVENTION</name></type>
<name>pcre2_regerror</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>regex_t</name> <modifier>*</modifier></type><name>preg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>,
  <parameter><decl><type><name>size_t</name></type> <name>errbuf_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>used</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl>;</decl_stmt>

<expr_stmt><expr><name>message</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>errcode</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>errcode</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>pstring</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>)</operator></expr>?</condition><then>
  <expr><literal type="string">"unknown error code"</literal></expr> </then><else>: <expr><name><name>pstring</name><index>[<expr><name>errcode</name></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>preg</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>preg</name><operator>-&gt;</operator><name>re_erroffset</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>used</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errbuf_size</name></expr></argument>, <argument><expr><literal type="string">"%s at offset %-6d"</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>,
    <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>preg</name><operator>-&gt;</operator><name>re_erroffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><name>used</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errbuf_size</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<return>return <expr><name>used</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*           Free store held by a regex           *
*************************************************/</comment>

<function><type><name>PCRE2POSIX_EXP_DEFN</name> <name>void</name> <name>PCRE2_CALL_CONVENTION</name></type>
<name>pcre2_regfree</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>preg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>pcre2_match_data_free</name><argument_list>(<argument><expr><name><name>preg</name><operator>-&gt;</operator><name>re_match_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pcre2_code_free</name><argument_list>(<argument><expr><name><name>preg</name><operator>-&gt;</operator><name>re_pcre2_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*            Compile a regular expression        *
*************************************************/</comment>

<comment type="block">/*
Arguments:
  preg        points to a structure for recording the compiled expression
  pattern     the pattern to compile
  cflags      compilation flags

Returns:      0 on success
              various non-zero codes on failure
*/</comment>

<function><type><name>PCRE2POSIX_EXP_DEFN</name> <name>int</name> <name>PCRE2_CALL_CONVENTION</name></type>
<name>pcre2_regcomp</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>preg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>erroffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>patlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>errorcode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>options</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>re_nsub</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>patlen</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>cflags</name> <operator>&amp;</operator> <name>REG_PEND</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name><name>preg</name><operator>-&gt;</operator><name>re_endp</name></name> <operator>-</operator> <name>pattern</name><operator>)</operator></expr> </then><else>:
  <expr><name>PCRE2_ZERO_TERMINATED</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cflags</name> <operator>&amp;</operator> <name>REG_ICASE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>    <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_CASELESS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cflags</name> <operator>&amp;</operator> <name>REG_NEWLINE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_MULTILINE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cflags</name> <operator>&amp;</operator> <name>REG_DOTALL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>   <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_DOTALL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cflags</name> <operator>&amp;</operator> <name>REG_NOSPEC</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>   <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_LITERAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cflags</name> <operator>&amp;</operator> <name>REG_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>      <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_UTF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cflags</name> <operator>&amp;</operator> <name>REG_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>      <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_UCP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cflags</name> <operator>&amp;</operator> <name>REG_UNGREEDY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_UNGREEDY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>preg</name><operator>-&gt;</operator><name>re_cflags</name></name> <operator>=</operator> <name>cflags</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>preg</name><operator>-&gt;</operator><name>re_pcre2_code</name></name> <operator>=</operator> <call><name>pcre2_compile</name><argument_list>(<argument><expr><operator>(</operator><name>PCRE2_SPTR</name><operator>)</operator><name>pattern</name></expr></argument>, <argument><expr><name>patlen</name></expr></argument>, <argument><expr><name>options</name></expr></argument>,
  <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>erroffset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>preg</name><operator>-&gt;</operator><name>re_erroffset</name></name> <operator>=</operator> <name>erroffset</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>preg</name><operator>-&gt;</operator><name>re_pcre2_code</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* A negative value is a UTF error; otherwise all error codes are greater
  than COMPILE_ERROR_BASE, but check, just in case. */</comment>

  <if_stmt><if>if <condition>(<expr><name>errorcode</name> <operator>&lt;</operator> <name>COMPILE_ERROR_BASE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REG_BADPAT</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>errorcode</name> <operator>-=</operator> <name>COMPILE_ERROR_BASE</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>errorcode</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>eint1</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><specifier>const</specifier> <name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name><name>eint1</name><index>[<expr><name>errorcode</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>eint2</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><specifier>const</specifier> <name>int</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><name>errorcode</name> <operator>==</operator> <name><name>eint2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name><name>eint2</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
  <return>return <expr><name>REG_BADPAT</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcre2_pattern_info</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>pcre2_code</name> <operator>*</operator><operator>)</operator><name><name>preg</name><operator>-&gt;</operator><name>re_pcre2_code</name></name></expr></argument>,
  <argument><expr><name>PCRE2_INFO_CAPTURECOUNT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>re_nsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>preg</name><operator>-&gt;</operator><name>re_nsub</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>re_nsub</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>preg</name><operator>-&gt;</operator><name>re_match_data</name></name> <operator>=</operator> <call><name>pcre2_match_data_create</name><argument_list>(<argument><expr><name>re_nsub</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>preg</name><operator>-&gt;</operator><name>re_erroffset</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* No meaning after successful compile */</comment>

<if_stmt><if>if <condition>(<expr><name><name>preg</name><operator>-&gt;</operator><name>re_match_data</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>pcre2_code_free</name><argument_list>(<argument><expr><name><name>preg</name><operator>-&gt;</operator><name>re_pcre2_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>REG_ESPACE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*              Match a regular expression        *
*************************************************/</comment>

<comment type="block">/* A suitable match_data block, large enough to hold all possible captures, was
obtained when the pattern was compiled, to save having to allocate and free it
for each match. If REG_NOSUB was specified at compile time, the nmatch and
pmatch arguments are ignored, and the only result is yes/no/error. */</comment>

<function><type><name>PCRE2POSIX_EXP_DEFN</name> <name>int</name> <name>PCRE2_CALL_CONVENTION</name></type>
<name>pcre2_regexec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>regex_t</name> <modifier>*</modifier></type><name>preg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nmatch</name></decl></parameter>,
  <parameter><decl><type><name>regmatch_t</name></type> <name><name>pmatch</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>, <decl><type ref="prev"/><name>so</name></decl>, <decl><type ref="prev"/><name>eo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>options</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pcre2_match_data</name> <modifier>*</modifier></type><name>md</name> <init>= <expr><operator>(</operator><name>pcre2_match_data</name> <operator>*</operator><operator>)</operator><name><name>preg</name><operator>-&gt;</operator><name>re_match_data</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>REG_NOTBOL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_NOTBOL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>REG_NOTEOL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_NOTEOL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>REG_NOTEMPTY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_NOTEMPTY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* When REG_NOSUB was specified, or if no vector has been passed in which to
put captured strings, ensure that nmatch is zero. This will stop any attempt to
write to pmatch. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>preg</name><operator>-&gt;</operator><name>re_cflags</name></name> <operator>&amp;</operator> <name>REG_NOSUB</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>pmatch</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>nmatch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* REG_STARTEND is a BSD extension, to allow for non-NUL-terminated strings.
The man page from OS X says "REG_STARTEND affects only the location of the
string, not how it is matched". That is why the "so" value is used to bump the
start location rather than being passed as a PCRE2 "starting offset". */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>REG_STARTEND</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>pmatch</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>REG_INVARG</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>so</name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_so</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>eo</name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>rm_eo</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><name>so</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>eo</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pcre2_match</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>pcre2_code</name> <operator>*</operator><operator>)</operator><name><name>preg</name><operator>-&gt;</operator><name>re_pcre2_code</name></name></expr></argument>,
  <argument><expr><operator>(</operator><name>PCRE2_SPTR</name><operator>)</operator><name>string</name> <operator>+</operator> <name>so</name></expr></argument>, <argument><expr><operator>(</operator><name>eo</name> <operator>-</operator> <name>so</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>md</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Successful match */</comment>

<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>ovector</name> <init>= <expr><call><name>pcre2_get_ovector_pointer</name><argument_list>(<argument><expr><name>md</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><name>rc</name> <operator>&gt;</operator> <name>nmatch</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>nmatch</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>rc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
    <expr_stmt><expr><name><name>pmatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rm_so</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>ovector</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>PCRE2_UNSET</name><operator>)</operator></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>:
      <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>ovector</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name>so</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pmatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rm_eo</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>ovector</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>PCRE2_UNSET</name><operator>)</operator></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>:
      <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>ovector</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>so</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></for>
  <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nmatch</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pmatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rm_so</name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rm_eo</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Unsuccessful match */</comment>

<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;=</operator> <name>PCRE2_ERROR_UTF8_ERR1</name> <operator>&amp;&amp;</operator> <name>rc</name> <operator>&gt;=</operator> <name>PCRE2_ERROR_UTF8_ERR21</name></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><name>REG_INVARG</name></expr>;</return></block_content></block></if></if_stmt>

<switch>switch<condition>(<expr><name>rc</name></expr>)</condition>
  <block>{<block_content>
  <default>default:</default> <return>return <expr><name>REG_ASSERT</name></expr>;</return>
  <case>case <expr><name>PCRE2_ERROR_BADMODE</name></expr>:</case> <return>return <expr><name>REG_INVARG</name></expr>;</return>
  <case>case <expr><name>PCRE2_ERROR_BADMAGIC</name></expr>:</case> <return>return <expr><name>REG_INVARG</name></expr>;</return>
  <case>case <expr><name>PCRE2_ERROR_BADOPTION</name></expr>:</case> <return>return <expr><name>REG_INVARG</name></expr>;</return>
  <case>case <expr><name>PCRE2_ERROR_BADUTFOFFSET</name></expr>:</case> <return>return <expr><name>REG_INVARG</name></expr>;</return>
  <case>case <expr><name>PCRE2_ERROR_MATCHLIMIT</name></expr>:</case> <return>return <expr><name>REG_ESPACE</name></expr>;</return>
  <case>case <expr><name>PCRE2_ERROR_NOMATCH</name></expr>:</case> <return>return <expr><name>REG_NOMATCH</name></expr>;</return>
  <case>case <expr><name>PCRE2_ERROR_NOMEMORY</name></expr>:</case> <return>return <expr><name>REG_ESPACE</name></expr>;</return>
  <case>case <expr><name>PCRE2_ERROR_NULL</name></expr>:</case> <return>return <expr><name>REG_INVARG</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* End of pcre2posix.c */</comment>
</unit>
