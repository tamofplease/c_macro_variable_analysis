<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/pcre2/src/pcre2_printint.c"><comment type="block" format="doxygen">/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/</comment>

<comment type="block">/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
     Original API code Copyright (c) 1997-2012 University of Cambridge
          New API code Copyright (c) 2016-2019 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/</comment>


<comment type="block">/* This module contains a PCRE private debugging function for printing out the
internal form of a compiled regular expression, along with some supporting
local functions. This source file is #included in pcre2test.c at each supported
code unit width, with PCRE2_SUFFIX set appropriately, just like the functions
that comprise the library. It can also optionally be included in
pcre2_compile.c for detailed debugging in error situations. */</comment>


<comment type="block">/* Tables of operator names. The same 8-bit table is used for all code unit
widths, so it must be defined only once. The list itself is defined in
pcre2_internal.h, which is #included by pcre2test before this file. */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>OP_LISTS_DEFINED</name></cpp:ifndef>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>OP_names</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>OP_NAME_LIST</name></expr> }</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP_LISTS_DEFINED</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* The functions and tables herein must all have mode-dependent names. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OP_lengths</name></cpp:macro>            <cpp:value>PCRE2_SUFFIX(OP_lengths_)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>get_ucpname</name></cpp:macro>           <cpp:value>PCRE2_SUFFIX(get_ucpname_)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pcre2_printint</name></cpp:macro>        <cpp:value>PCRE2_SUFFIX(pcre2_printint_)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>print_char</name></cpp:macro>            <cpp:value>PCRE2_SUFFIX(print_char_)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>print_custring</name></cpp:macro>        <cpp:value>PCRE2_SUFFIX(print_custring_)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>print_custring_bylen</name></cpp:macro>  <cpp:value>PCRE2_SUFFIX(print_custring_bylen_)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>print_prop</name></cpp:macro>            <cpp:value>PCRE2_SUFFIX(print_prop_)</cpp:value></cpp:define>

<comment type="block">/* Table of sizes for the fixed-length opcodes. It's defined in a macro so that
the definition is next to the definition of the opcodes in pcre2_internal.h.
The contents of the table are, however, mode-dependent. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>OP_lengths</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>OP_LENGTHS</name></expr> }</block></expr></init></decl>;</decl_stmt>



<comment type="block" format="doxygen">/*************************************************
*       Print one character from a string        *
*************************************************/</comment>

<comment type="block">/* In UTF mode the character may occupy more than one code unit.

Arguments:
  f           file to write to
  ptr         pointer to first code unit of the character
  utf         TRUE if string is UTF (will be FALSE if UTF is not supported)

Returns:      number of additional code units used
*/</comment>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>print_char</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>utf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>one_code_unit</name> <init>= <expr><operator>!</operator><name>utf</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* If UTF is supported and requested, check for a valid single code unit. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
  <expr_stmt><expr><name>one_code_unit</name> <operator>=</operator> <name>c</name> <operator>&lt;</operator> <literal type="number">0x80</literal></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:elif>
  <expr_stmt><expr><name>one_code_unit</name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0xfc00</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0xd800</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>one_code_unit</name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0xfffff800u</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0xd800u</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* CODE_UNIT_WIDTH */</comment>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

<comment type="block">/* Handle a valid one-code-unit character at any width. */</comment>

<if_stmt><if>if <condition>(<expr><name>one_code_unit</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>PRINTABLE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>)</operator><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\\x%02x"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\\x{%02x}"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Code for invalid UTF code units and multi-unit UTF characters is different
for each width. If UTF is not supported, control should never get here, but we
need a return statement to keep the compiler happy. */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifndef>
<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<comment type="block">/* Malformed UTF-8 should occur only if the sanity check has been turned off.
Rather than swallow random bytes, just stop if we hit a bad one. Print it with
\X instead of \x as an indication. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0xc0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\\X{%x}"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>       <comment type="block">/* Invalid starting byte */</comment>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>a</name> <init>= <expr><call><name>PRIV</name><argument_list>(<argument><expr><name>utf8_table4</name></expr></argument>)</argument_list></call><index>[<expr><name>c</name> <operator>&amp;</operator> <literal type="number">0x3f</literal></expr>]</index></expr></init></decl>;</decl_stmt>  <comment type="block">/* Number of additional bytes */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>s</name> <init>= <expr><literal type="number">6</literal><operator>*</operator><name>a</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>utf8_table3</name></expr></argument>)</argument_list></call><index>[<expr><name>a</name></expr>]</index><operator>)</operator> <operator>&lt;&lt;</operator> <name>s</name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>a</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x80</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\\X{%x}"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Invalid secondary byte */</comment>
      <return>return <expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>s</name> <operator>-=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>c</name> <operator>|=</operator> <operator>(</operator><name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>s</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\\x{%x}"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 8 */</comment>

<comment type="block">/* UTF-16: rather than swallow a low surrogate, just stop if we hit a bad one.
Print it with \X instead of \x as an indication. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xfc00</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0xdc00</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\\X{%x}"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x3ff</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">10</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3ff</literal><operator>)</operator><operator>)</operator> <operator>+</operator> <literal type="number">0x10000</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\\x{%x}"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 16 */</comment>

<comment type="block">/* For UTF-32 we get here only for a malformed code unit, which should only
occur if the sanity check has been turned off. Print it with \X instead of \x
as an indication. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\\X{%x}"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 32 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*     Print string as a list of code units       *
*************************************************/</comment>

<comment type="block">/* These take no account of UTF as they always print each individual code unit.
The string is zero-terminated for print_custring(); the length is given for
print_custring_bylen().

Arguments:
  f          file to write to
  ptr        point to the string
  len        length for print_custring_bylen()

Returns:     nothing
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_custring</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>ptr</name><operator>++</operator></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>PRINTABLE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\\x{%x}"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_custring_bylen</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<for>for <control>(<init>;</init> <condition><expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>len</name><operator>--</operator></expr></incr>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>ptr</name><operator>++</operator></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>PRINTABLE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\\x{%x}"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*          Find Unicode property name            *
*************************************************/</comment>

<comment type="block">/* When there is no UTF/UCP support, the table of names does not exist. This
function should not be called in such configurations, because a pattern that
tries to use Unicode properties won't compile. Rather than put lots of #ifdefs
into the main code, however, we just put one into this function. */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_ucpname</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>ptype</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>pvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>utt_size</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>==</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>utt</name></expr></argument>)</argument_list></call><index>[<expr><name>i</name></expr>]</index><operator>.</operator><name>type</name> <operator>&amp;&amp;</operator> <name>pvalue</name> <operator>==</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>utt</name></expr></argument>)</argument_list></call><index>[<expr><name>i</name></expr>]</index><operator>.</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><call><name>PRIV</name><argument_list>(<argument><expr><name>utt_names</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>utt</name></expr></argument>)</argument_list></call><index>[<expr><name>i</name></expr>]</index><operator>.</operator><name>name_offset</name></expr> </then><else>: <expr><literal type="string">"??"</literal></expr></else></ternary></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>   <comment type="block">/* No UTF support */</comment>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>ptype</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pvalue</name></expr>;</expr_stmt>
<return>return <expr><literal type="string">"??"</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*       Print Unicode property value             *
*************************************************/</comment>

<comment type="block">/* "Normal" properties can be printed from tables. The PT_CLIST property is a
pseudo-property that contains a pointer to a list of case-equivalent
characters.

Arguments:
  f            file to write to
  code         pointer in the compiled code
  before       text to print before
  after        text to print after

Returns:       nothing
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_prop</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>before</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>after</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>PT_CLIST</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%s%s %s%s"</literal></expr></argument>, <argument><expr><name>before</name></expr></argument>, <argument><expr><name><name>OP_names</name><index>[<expr><operator>*</operator><name>code</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>get_ucpname</name><argument_list>(<argument><expr><name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
    <argument><expr><name><name>code</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>not</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_PROP</name><operator>)</operator></expr>?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"not "</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_caseless_sets</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>code</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%s%sclist"</literal></expr></argument>, <argument><expr><name>before</name></expr></argument>, <argument><expr><name>not</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>&lt;</operator> <name>NOTACHAR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" %04x"</literal></expr></argument>, <argument><expr><operator>*</operator><name>p</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*            Print compiled pattern              *
*************************************************/</comment>

<comment type="block">/* The print_lengths flag controls whether offsets and lengths of items are
printed. Lenths can be turned off from pcre2test so that automatic tests on
bytecode can be written that do not depend on the value of LINK_SIZE.

Arguments:
  re              a compiled pattern
  f               the file to write to
  print_lengths   show various lengths

Returns:          nothing
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pcre2_printint</name><parameter_list>(<parameter><decl><type><name>pcre2_code</name> <modifier>*</modifier></type><name>re</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>print_lengths</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>codestart</name></decl>, <decl><type ref="prev"/><name>nametable</name></decl>, <decl><type ref="prev"/><name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>nesize</name> <init>= <expr><name><name>re</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name> <init>= <expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>nametable</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SPTR</name><operator>)</operator><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>re</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pcre2_real_code</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>code</name> <operator>=</operator> <name>codestart</name> <operator>=</operator> <name>nametable</name> <operator>+</operator> <name><name>re</name><operator>-&gt;</operator><name>name_count</name></name> <operator>*</operator> <name><name>re</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>;</expr_stmt>

<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ccode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>flag</name> <init>= <expr><literal type="string">"  "</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>extra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>print_lengths</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%3d "</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>code</name> <operator>-</operator> <name>codestart</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <switch>switch<condition>(<expr><operator>*</operator><name>code</name></expr>)</condition>
    <block>{<block_content>
<comment type="block">/* ========================================================================== */</comment>
      <comment type="block">/* These cases are never obeyed. This is a fudge that causes a compile-
      time error if the vectors OP_names or OP_lengths, which are indexed
      by opcode, are not the correct length. It seems to be the only way to do
      such a check at compile time, as the sizeof() operator does not work in
      the C preprocessor. */</comment>

      <case>case <expr><name>OP_TABLE_LENGTH</name></expr>:</case>
      <case>case <expr><name>OP_TABLE_LENGTH</name> <operator>+</operator>
        <operator>(</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>OP_names</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>==</operator> <name>OP_TABLE_LENGTH</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <name>OP_TABLE_LENGTH</name><operator>)</operator><operator>)</operator></expr>:</case>
      <return>return;</return>
<comment type="block">/* ========================================================================== */</comment>

    <case>case <expr><name>OP_END</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"    %s\n"</literal></expr></argument>, <argument><expr><name><name>OP_names</name><index>[<expr><operator>*</operator><name>code</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"------------------------------------------------------------------\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>

    <case>case <expr><name>OP_CHAR</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <do>do
      <block>{<block_content>
      <expr_stmt><expr><name>code</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>code</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>print_char</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block>
    while <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_CHAR</name></expr>)</condition>;</do>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <continue>continue;</continue>

    <case>case <expr><name>OP_CHARI</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" /i "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <do>do
      <block>{<block_content>
      <expr_stmt><expr><name>code</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>code</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>print_char</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block>
    while <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_CHARI</name></expr>)</condition>;</do>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <continue>continue;</continue>

    <case>case <expr><name>OP_CBRA</name></expr>:</case>
    <case>case <expr><name>OP_CBRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SCBRA</name></expr>:</case>
    <case>case <expr><name>OP_SCBRAPOS</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>print_lengths</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%3d "</literal></expr></argument>, <argument><expr><call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%s %d"</literal></expr></argument>, <argument><expr><name><name>OP_names</name><index>[<expr><operator>*</operator><name>code</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_BRA</name></expr>:</case>
    <case>case <expr><name>OP_BRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_SBRA</name></expr>:</case>
    <case>case <expr><name>OP_SBRAPOS</name></expr>:</case>
    <case>case <expr><name>OP_KETRMAX</name></expr>:</case>
    <case>case <expr><name>OP_KETRMIN</name></expr>:</case>
    <case>case <expr><name>OP_KETRPOS</name></expr>:</case>
    <case>case <expr><name>OP_ALT</name></expr>:</case>
    <case>case <expr><name>OP_KET</name></expr>:</case>
    <case>case <expr><name>OP_ASSERT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERT_NOT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK_NOT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERT_NA</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK_NA</name></expr>:</case>
    <case>case <expr><name>OP_ONCE</name></expr>:</case>
    <case>case <expr><name>OP_SCRIPT_RUN</name></expr>:</case>
    <case>case <expr><name>OP_COND</name></expr>:</case>
    <case>case <expr><name>OP_SCOND</name></expr>:</case>
    <case>case <expr><name>OP_REVERSE</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>print_lengths</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%3d "</literal></expr></argument>, <argument><expr><call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>OP_names</name><index>[<expr><operator>*</operator><name>code</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CLOSE</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"    %s %d"</literal></expr></argument>, <argument><expr><name><name>OP_names</name><index>[<expr><operator>*</operator><name>code</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CREF</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%3d %s"</literal></expr></argument>, <argument><expr><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>OP_names</name><index>[<expr><operator>*</operator><name>code</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_DNCREF</name></expr>:</case>
      <block>{<block_content>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>entry</name> <init>= <expr><name>nametable</name> <operator>+</operator> <operator>(</operator><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>*</operator> <name>nesize</name><operator>)</operator> <operator>+</operator> <name>IMM2_SIZE</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" %s Cond ref &lt;"</literal></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>print_custring</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"&gt;%d"</literal></expr></argument>, <argument><expr><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block>
    <break>break;</break>

    <case>case <expr><name>OP_RREF</name></expr>:</case>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>RREF_ANY</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"    Cond recurse any"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"    Cond recurse %d"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_DNRREF</name></expr>:</case>
      <block>{<block_content>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>entry</name> <init>= <expr><name>nametable</name> <operator>+</operator> <operator>(</operator><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>*</operator> <name>nesize</name><operator>)</operator> <operator>+</operator> <name>IMM2_SIZE</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" %s Cond recurse &lt;"</literal></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>print_custring</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"&gt;%d"</literal></expr></argument>, <argument><expr><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block>
    <break>break;</break>

    <case>case <expr><name>OP_FALSE</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"    Cond false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_TRUE</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"    Cond true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_STARI</name></expr>:</case>
    <case>case <expr><name>OP_MINSTARI</name></expr>:</case>
    <case>case <expr><name>OP_POSSTARI</name></expr>:</case>
    <case>case <expr><name>OP_PLUSI</name></expr>:</case>
    <case>case <expr><name>OP_MINPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_POSPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_QUERYI</name></expr>:</case>
    <case>case <expr><name>OP_MINQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_POSQUERYI</name></expr>:</case>
    <expr_stmt><expr><name>flag</name> <operator>=</operator> <literal type="string">"/i"</literal></expr>;</expr_stmt>
    <comment type="block">/* Fall through */</comment>
    <case>case <expr><name>OP_STAR</name></expr>:</case>
    <case>case <expr><name>OP_MINSTAR</name></expr>:</case>
    <case>case <expr><name>OP_POSSTAR</name></expr>:</case>
    <case>case <expr><name>OP_PLUS</name></expr>:</case>
    <case>case <expr><name>OP_MINPLUS</name></expr>:</case>
    <case>case <expr><name>OP_POSPLUS</name></expr>:</case>
    <case>case <expr><name>OP_QUERY</name></expr>:</case>
    <case>case <expr><name>OP_MINQUERY</name></expr>:</case>
    <case>case <expr><name>OP_POSQUERY</name></expr>:</case>
    <case>case <expr><name>OP_TYPESTAR</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINSTAR</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSSTAR</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPLUS</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINPLUS</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSPLUS</name></expr>:</case>
    <case>case <expr><name>OP_TYPEQUERY</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINQUERY</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSQUERY</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" %s "</literal></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>code</name> <operator>&gt;=</operator> <name>OP_TYPESTAR</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>OP_PROP</name> <operator>||</operator> <name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>print_prop</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>code</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>extra</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>OP_names</name><index>[<expr><name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>extra</name> <operator>=</operator> <call><name>print_char</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>code</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>utf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>OP_names</name><index>[<expr><operator>*</operator><name>code</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_EXACTI</name></expr>:</case>
    <case>case <expr><name>OP_UPTOI</name></expr>:</case>
    <case>case <expr><name>OP_MINUPTOI</name></expr>:</case>
    <case>case <expr><name>OP_POSUPTOI</name></expr>:</case>
    <expr_stmt><expr><name>flag</name> <operator>=</operator> <literal type="string">"/i"</literal></expr>;</expr_stmt>
    <comment type="block">/* Fall through */</comment>
    <case>case <expr><name>OP_EXACT</name></expr>:</case>
    <case>case <expr><name>OP_UPTO</name></expr>:</case>
    <case>case <expr><name>OP_MINUPTO</name></expr>:</case>
    <case>case <expr><name>OP_POSUPTO</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" %s "</literal></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>extra</name> <operator>=</operator> <call><name>print_char</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>code</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>code</name> <operator>!=</operator> <name>OP_EXACT</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>code</name> <operator>!=</operator> <name>OP_EXACTI</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"0,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%d}"</literal></expr></argument>, <argument><expr><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_MINUPTO</name> <operator>||</operator> <operator>*</operator><name>code</name> <operator>==</operator> <name>OP_MINUPTOI</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_POSUPTO</name> <operator>||</operator> <operator>*</operator><name>code</name> <operator>==</operator> <name>OP_POSUPTOI</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_TYPEEXACT</name></expr>:</case>
    <case>case <expr><name>OP_TYPEUPTO</name></expr>:</case>
    <case>case <expr><name>OP_TYPEMINUPTO</name></expr>:</case>
    <case>case <expr><name>OP_TYPEPOSUPTO</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>code</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>]</index></name> <operator>==</operator> <name>OP_PROP</name> <operator>||</operator> <name><name>code</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>]</index></name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>print_prop</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>code</name> <operator>+</operator> <name>IMM2_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"    "</literal></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>extra</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"    %s"</literal></expr></argument>, <argument><expr><name><name>OP_names</name><index>[<expr><name><name>code</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>]</index></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>code</name> <operator>!=</operator> <name>OP_TYPEEXACT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"0,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%d}"</literal></expr></argument>, <argument><expr><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_TYPEMINUPTO</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_TYPEPOSUPTO</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_NOTI</name></expr>:</case>
    <expr_stmt><expr><name>flag</name> <operator>=</operator> <literal type="string">"/i"</literal></expr>;</expr_stmt>
    <comment type="block">/* Fall through */</comment>
    <case>case <expr><name>OP_NOT</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" %s [^"</literal></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>extra</name> <operator>=</operator> <call><name>print_char</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>code</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>utf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_NOTSTARI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINSTARI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSSTARI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSPLUSI</name></expr>:</case>
    <case>case <expr><name>OP_NOTQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINQUERYI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSQUERYI</name></expr>:</case>
    <expr_stmt><expr><name>flag</name> <operator>=</operator> <literal type="string">"/i"</literal></expr>;</expr_stmt>
    <comment type="block">/* Fall through */</comment>

    <case>case <expr><name>OP_NOTSTAR</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINSTAR</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSSTAR</name></expr>:</case>
    <case>case <expr><name>OP_NOTPLUS</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINPLUS</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSPLUS</name></expr>:</case>
    <case>case <expr><name>OP_NOTQUERY</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINQUERY</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSQUERY</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" %s [^"</literal></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>extra</name> <operator>=</operator> <call><name>print_char</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>code</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>utf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"]%s"</literal></expr></argument>, <argument><expr><name><name>OP_names</name><index>[<expr><operator>*</operator><name>code</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_NOTEXACTI</name></expr>:</case>
    <case>case <expr><name>OP_NOTUPTOI</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINUPTOI</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSUPTOI</name></expr>:</case>
    <expr_stmt><expr><name>flag</name> <operator>=</operator> <literal type="string">"/i"</literal></expr>;</expr_stmt>
    <comment type="block">/* Fall through */</comment>

    <case>case <expr><name>OP_NOTEXACT</name></expr>:</case>
    <case>case <expr><name>OP_NOTUPTO</name></expr>:</case>
    <case>case <expr><name>OP_NOTMINUPTO</name></expr>:</case>
    <case>case <expr><name>OP_NOTPOSUPTO</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" %s [^"</literal></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>extra</name> <operator>=</operator> <call><name>print_char</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>code</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"]{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>code</name> <operator>!=</operator> <name>OP_NOTEXACT</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>code</name> <operator>!=</operator> <name>OP_NOTEXACTI</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"0,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%d}"</literal></expr></argument>, <argument><expr><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_NOTMINUPTO</name> <operator>||</operator> <operator>*</operator><name>code</name> <operator>==</operator> <name>OP_NOTMINUPTOI</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else
    if <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_NOTPOSUPTO</name> <operator>||</operator> <operator>*</operator><name>code</name> <operator>==</operator> <name>OP_NOTPOSUPTOI</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_RECURSE</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>print_lengths</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%3d "</literal></expr></argument>, <argument><expr><call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"    "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>OP_names</name><index>[<expr><operator>*</operator><name>code</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_REFI</name></expr>:</case>
    <expr_stmt><expr><name>flag</name> <operator>=</operator> <literal type="string">"/i"</literal></expr>;</expr_stmt>
    <comment type="block">/* Fall through */</comment>
    <case>case <expr><name>OP_REF</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" %s \\%d"</literal></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ccode</name> <operator>=</operator> <name>code</name> <operator>+</operator> <name><name>OP_lengths</name><index>[<expr><operator>*</operator><name>code</name></expr>]</index></name></expr>;</expr_stmt>
    <goto>goto <name>CLASS_REF_REPEAT</name>;</goto>

    <case>case <expr><name>OP_DNREFI</name></expr>:</case>
    <expr_stmt><expr><name>flag</name> <operator>=</operator> <literal type="string">"/i"</literal></expr>;</expr_stmt>
    <comment type="block">/* Fall through */</comment>
    <case>case <expr><name>OP_DNREF</name></expr>:</case>
      <block>{<block_content>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>entry</name> <init>= <expr><name>nametable</name> <operator>+</operator> <operator>(</operator><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>*</operator> <name>nesize</name><operator>)</operator> <operator>+</operator> <name>IMM2_SIZE</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" %s \\k&lt;"</literal></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>print_custring</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"&gt;%d"</literal></expr></argument>, <argument><expr><call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block>
    <expr_stmt><expr><name>ccode</name> <operator>=</operator> <name>code</name> <operator>+</operator> <name><name>OP_lengths</name><index>[<expr><operator>*</operator><name>code</name></expr>]</index></name></expr>;</expr_stmt>
    <goto>goto <name>CLASS_REF_REPEAT</name>;</goto>

    <case>case <expr><name>OP_CALLOUT</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"    %s %d %d %d"</literal></expr></argument>, <argument><expr><name><name>OP_names</name><index>[<expr><operator>*</operator><name>code</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr>]</index></name></expr></argument>,
      <argument><expr><call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CALLOUT_STR</name></expr>:</case>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>code</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>LINK_SIZE</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"    %s %c"</literal></expr></argument>, <argument><expr><name><name>OP_names</name><index>[<expr><operator>*</operator><name>code</name></expr>]</index></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>extra</name> <operator>=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>print_custring_bylen</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>code</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>, <argument><expr><name>extra</name> <operator>-</operator> <literal type="number">3</literal> <operator>-</operator> <literal type="number">4</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><call><name>PRIV</name><argument_list>(<argument><expr><name>callout_start_delims</name></expr></argument>)</argument_list></call><index>[<expr><name>i</name></expr>]</index> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>callout_start_delims</name></expr></argument>)</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>callout_end_delims</name></expr></argument>)</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>
        <break>break;</break>
        </block_content>}</block></if></if_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%c %d %d %d"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">3</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
      <argument><expr><call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_PROP</name></expr>:</case>
    <case>case <expr><name>OP_NOTPROP</name></expr>:</case>
    <expr_stmt><expr><call><name>print_prop</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="string">"    "</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* OP_XCLASS cannot occur in 8-bit, non-UTF mode. However, there's no harm
    in having this code always here, and it makes it less messy without all
    those #ifdefs. */</comment>

    <case>case <expr><name>OP_CLASS</name></expr>:</case>
    <case>case <expr><name>OP_NCLASS</name></expr>:</case>
    <case>case <expr><name>OP_XCLASS</name></expr>:</case>
      <block>{<block_content>
      <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>min</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BOOL</name></type> <name>printmap</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BOOL</name></type> <name>invertmap</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>inverted_map</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"    ["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_XCLASS</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>extra</name> <operator>=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ccode</name> <operator>=</operator> <name>code</name> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>printmap</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>ccode</name> <operator>&amp;</operator> <name>XCL_MAP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>ccode</name> <operator>&amp;</operator> <name>XCL_NOT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>invertmap</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>ccode</name> <operator>&amp;</operator> <name>XCL_HASPROP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"^"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>ccode</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><name>printmap</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ccode</name> <operator>=</operator> <name>code</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

      <comment type="block">/* Print a bit map */</comment>

      <if_stmt><if>if <condition>(<expr><name>printmap</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>map</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>ccode</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>invertmap</name></expr>)</condition>
          <block>{<block_content>
          <comment type="block">/* Using 255 ^ instead of ~ avoids clang sanitize warning. */</comment>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>inverted_map</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">255</literal> <operator>^</operator> <name><name>map</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
          <expr_stmt><expr><name>map</name> <operator>=</operator> <name>inverted_map</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>map</name><index>[<expr><name>i</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>i</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
              <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>map</name><index>[<expr><name>j</name><operator>/</operator><literal type="number">8</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>j</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name>i</name> <operator>==</operator> <literal type="char">']'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\\"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>PRINTABLE</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
              <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\\x%02x"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>--</operator><name>j</name> <operator>&gt;</operator> <name>i</name></expr>)</condition>
              <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><name>j</name> <operator>!=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
              <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name>j</name> <operator>==</operator> <literal type="char">']'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\\"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
              <if_stmt><if>if <condition>(<expr><call><name>PRINTABLE</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\\x%02x"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        <expr_stmt><expr><name>ccode</name> <operator>+=</operator> <literal type="number">32</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* For an XCLASS there is always some additional data */</comment>

      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_XCLASS</name></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>ch</name></decl>;</decl_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>ch</name> <operator>=</operator> <operator>*</operator><name>ccode</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <name>XCL_END</name></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>BOOL</name></type> <name>not</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>notch</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

          <switch>switch<condition>(<expr><name>ch</name></expr>)</condition>
            <block>{<block_content>
            <case>case <expr><name>XCL_NOTPROP</name></expr>:</case>
            <expr_stmt><expr><name>not</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>notch</name> <operator>=</operator> <literal type="string">"^"</literal></expr>;</expr_stmt>
            <comment type="block">/* Fall through */</comment>

            <case>case <expr><name>XCL_PROP</name></expr>:</case>
              <block>{<block_content>
              <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ptype</name> <init>= <expr><operator>*</operator><name>ccode</name><operator>++</operator></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pvalue</name> <init>= <expr><operator>*</operator><name>ccode</name><operator>++</operator></expr></init></decl>;</decl_stmt>

              <switch>switch<condition>(<expr><name>ptype</name></expr>)</condition>
                <block>{<block_content>
                <case>case <expr><name>PT_PXGRAPH</name></expr>:</case>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"[:%sgraph:]"</literal></expr></argument>, <argument><expr><name>notch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

                <case>case <expr><name>PT_PXPRINT</name></expr>:</case>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"[:%sprint:]"</literal></expr></argument>, <argument><expr><name>notch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

                <case>case <expr><name>PT_PXPUNCT</name></expr>:</case>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"[:%spunct:]"</literal></expr></argument>, <argument><expr><name>notch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

                <default>default:</default>
                <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\\%c{%s}"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>not</name></expr>?</condition><then> <expr><literal type="char">'P'</literal></expr></then><else>:<expr><literal type="char">'p'</literal></expr></else></ternary><operator>)</operator></expr></argument>,
                  <argument><expr><call><name>get_ucpname</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
                </block_content>}</block></switch>
              </block_content>}</block>
            <break>break;</break>

            <default>default:</default>
            <expr_stmt><expr><name>ccode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>print_char</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>ccode</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>XCL_RANGE</name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>ccode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>print_char</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>ccode</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <break>break;</break>
            </block_content>}</block></switch>
          </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Indicate a non-UTF class which was created by negation */</comment>

      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"]%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_NCLASS</name><operator>)</operator></expr>?</condition><then> <expr><literal type="string">" (neg)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Handle repeats after a class or a back reference */</comment>

      <label><name>CLASS_REF_REPEAT</name>:</label>
      <switch>switch<condition>(<expr><operator>*</operator><name>ccode</name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>OP_CRSTAR</name></expr>:</case>
        <case>case <expr><name>OP_CRMINSTAR</name></expr>:</case>
        <case>case <expr><name>OP_CRPLUS</name></expr>:</case>
        <case>case <expr><name>OP_CRMINPLUS</name></expr>:</case>
        <case>case <expr><name>OP_CRQUERY</name></expr>:</case>
        <case>case <expr><name>OP_CRMINQUERY</name></expr>:</case>
        <case>case <expr><name>OP_CRPOSSTAR</name></expr>:</case>
        <case>case <expr><name>OP_CRPOSPLUS</name></expr>:</case>
        <case>case <expr><name>OP_CRPOSQUERY</name></expr>:</case>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>OP_names</name><index>[<expr><operator>*</operator><name>ccode</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>extra</name> <operator>+=</operator> <name><name>OP_lengths</name><index>[<expr><operator>*</operator><name>ccode</name></expr>]</index></name></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>OP_CRRANGE</name></expr>:</case>
        <case>case <expr><name>OP_CRMINRANGE</name></expr>:</case>
        <case>case <expr><name>OP_CRPOSRANGE</name></expr>:</case>
        <expr_stmt><expr><name>min</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>ccode</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>ccode</name></expr></argument>,<argument><expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>max</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"{%u,}"</literal></expr></argument>, <argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"{%u,%u}"</literal></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ccode</name> <operator>==</operator> <name>OP_CRMINRANGE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>*</operator><name>ccode</name> <operator>==</operator> <name>OP_CRPOSRANGE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>extra</name> <operator>+=</operator> <name><name>OP_lengths</name><index>[<expr><operator>*</operator><name>ccode</name></expr>]</index></name></expr>;</expr_stmt>
        <break>break;</break>

        <comment type="block">/* Do nothing if it's not a repeat; this code stops picky compilers
        warning about the lack of a default code path. */</comment>

        <default>default:</default>
        <break>break;</break>
        </block_content>}</block></switch>
      </block_content>}</block>
    <break>break;</break>

    <case>case <expr><name>OP_MARK</name></expr>:</case>
    <case>case <expr><name>OP_COMMIT_ARG</name></expr>:</case>
    <case>case <expr><name>OP_PRUNE_ARG</name></expr>:</case>
    <case>case <expr><name>OP_SKIP_ARG</name></expr>:</case>
    <case>case <expr><name>OP_THEN_ARG</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"    %s "</literal></expr></argument>, <argument><expr><name><name>OP_names</name><index>[<expr><operator>*</operator><name>code</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>print_custring_bylen</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>code</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>extra</name> <operator>+=</operator> <name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_THEN</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"    %s"</literal></expr></argument>, <argument><expr><name><name>OP_names</name><index>[<expr><operator>*</operator><name>code</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CIRCM</name></expr>:</case>
    <case>case <expr><name>OP_DOLLM</name></expr>:</case>
    <expr_stmt><expr><name>flag</name> <operator>=</operator> <literal type="string">"/m"</literal></expr>;</expr_stmt>
    <comment type="block">/* Fall through */</comment>

    <comment type="block">/* Anything else is just an item with no data, but possibly a flag. */</comment>

    <default>default:</default>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">" %s %s"</literal></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name><name>OP_names</name><index>[<expr><operator>*</operator><name>code</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></switch>

  <expr_stmt><expr><name>code</name> <operator>+=</operator> <name><name>OP_lengths</name><index>[<expr><operator>*</operator><name>code</name></expr>]</index></name> <operator>+</operator> <name>extra</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* End of pcre2_printint.c */</comment>
</unit>
