<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/pcre2/src/pcre2_compile.c"><comment type="block" format="doxygen">/*************************************************
*      Perl-Compatible Regular Expressions       *
*************************************************/</comment>

<comment type="block">/* PCRE is a library of functions to support regular expressions whose syntax
and semantics are as close as possible to those of the Perl 5 language.

                       Written by Philip Hazel
     Original API code Copyright (c) 1997-2012 University of Cambridge
          New API code Copyright (c) 2016-2020 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NLBLOCK</name></cpp:macro> <cpp:value>cb</cpp:value></cpp:define>             <comment type="block">/* Block containing newline information */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSSTART</name></cpp:macro> <cpp:value>start_pattern</cpp:value></cpp:define>  <comment type="block">/* Field containing processed string start */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSEND</name></cpp:macro>   <cpp:value>end_pattern</cpp:value></cpp:define>    <comment type="block">/* Field containing processed string end */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_internal.h"</cpp:file></cpp:include>

<comment type="block">/* In rare error cases debugging might require calling pcre2_printint(). */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EBCDIC</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINTABLE</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((c) &gt;= 64 &amp;&amp; (c) &lt; 255)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINTABLE</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((c) &gt;= 32 &amp;&amp; (c) &lt; 127)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2_printint.c"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_CALL_PRINTINT</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Other debugging code can be enabled by these defines. */</comment>

<comment type="block">/* #define DEBUG_SHOW_CAPTURES */</comment>
<comment type="block">/* #define DEBUG_SHOW_PARSED */</comment>

<comment type="block">/* There are a few things that vary with different code unit sizes. Handle them
by defining macros in order to minimize #if usage. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRING_UTFn_RIGHTPAR</name></cpp:macro>     <cpp:value>STRING_UTF8_RIGHTPAR, 5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XDIGIT</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>                <cpp:value>xdigitab[c]</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* Either 16-bit or 32-bit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XDIGIT</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>                <cpp:value>(MAX_255(c)? xdigitab[c] : 0xff)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRING_UTFn_RIGHTPAR</name></cpp:macro>     <cpp:value>STRING_UTF16_RIGHTPAR, 6</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* 32-bit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRING_UTFn_RIGHTPAR</name></cpp:macro>     <cpp:value>STRING_UTF32_RIGHTPAR, 6</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Macros to store and retrieve a PCRE2_SIZE value in the parsed pattern, which
consists of uint32_t elements. Assume that if uint32_t can't hold it, two of
them will be able to (i.e. assume a 64-bit world). */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_SIZE_MAX</name> <operator>&lt;=</operator> <name>UINT32_MAX</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUTOFFSET</name><parameter_list>(<parameter><type><name>s</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>*p++ = s</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETOFFSET</name><parameter_list>(<parameter><type><name>s</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>s = *p++</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETPLUSOFFSET</name><parameter_list>(<parameter><type><name>s</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>s = *(++p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READPLUSOFFSET</name><parameter_list>(<parameter><type><name>s</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>s = p[1]</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SKIPOFFSET</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>p++</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZEOFFSET</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUTOFFSET</name><parameter_list>(<parameter><type><name>s</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>{ *p++ = (uint32_t)(s &gt;&gt; 32); *p++ = (uint32_t)(s &amp; 0xffffffff); }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETOFFSET</name><parameter_list>(<parameter><type><name>s</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>{ s = ((PCRE2_SIZE)p[0] &lt;&lt; 32) | (PCRE2_SIZE)p[1]; p += 2; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETPLUSOFFSET</name><parameter_list>(<parameter><type><name>s</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>{ s = ((PCRE2_SIZE)p[1] &lt;&lt; 32) | (PCRE2_SIZE)p[2]; p += 2; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READPLUSOFFSET</name><parameter_list>(<parameter><type><name>s</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>{ s = ((PCRE2_SIZE)p[1] &lt;&lt; 32) | (PCRE2_SIZE)p[2]; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SKIPOFFSET</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>p += 2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZEOFFSET</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Macros for manipulating elements of the parsed pattern vector. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_CODE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>(x &amp; 0xffff0000u)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_DATA</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>(x &amp; 0x0000ffffu)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_DIFF</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x-y)&gt;&gt;16)</cpp:value></cpp:define>

<comment type="block">/* Function definitions to allow mutual recursion */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
  <name>add_list_to_class_internal</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type></decl></parameter>,
    <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>int</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>int</name></type>
  <name>compile_regex</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type></decl></parameter>,
    <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>branch_chain</name> <modifier>*</modifier></type></decl></parameter>,
    <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>
  <name>get_branchlength</name><parameter_list>(<parameter><decl><type><name>uint32_t</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>parsed_recurse_check</name> <modifier>*</modifier></type></decl></parameter>,
    <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>BOOL</name></type>
  <name>set_lookbehind_lengths</name><parameter_list>(<parameter><decl><type><name>uint32_t</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>parsed_recurse_check</name> <modifier>*</modifier></type></decl></parameter>,
    <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>
  <name>check_lookbehinds</name><parameter_list>(<parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>parsed_recurse_check</name> <modifier>*</modifier></type></decl></parameter>,
    <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block" format="doxygen">/*************************************************
*      Code parameters and static tables         *
*************************************************/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_GROUP_NUMBER</name></cpp:macro>   <cpp:value>65535u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_REPEAT_COUNT</name></cpp:macro>   <cpp:value>65535u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPEAT_UNLIMITED</name></cpp:macro>   <cpp:value>(MAX_REPEAT_COUNT+1)</cpp:value></cpp:define>

<comment type="block">/* COMPILE_WORK_SIZE specifies the size of stack workspace, which is used in
different ways in the different pattern scans. The parsing and group-
identifying pre-scan uses it to handle nesting, and needs it to be 16-bit
aligned for this. Having defined the size in code units, we set up
C16_WORK_SIZE as the number of elements in the 16-bit vector.

During the first compiling phase, when determining how much memory is required,
the regex is partly compiled into this space, but the compiled parts are
discarded as soon as they can be, so that hopefully there will never be an
overrun. The code does, however, check for an overrun, which can occur for
pathological patterns. The size of the workspace depends on LINK_SIZE because
the length of compiled items varies with this.

In the real compile phase, this workspace is not currently used. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPILE_WORK_SIZE</name></cpp:macro> <cpp:value>(3000*LINK_SIZE)</cpp:value></cpp:define>   <comment type="block">/* Size in code units */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>C16_WORK_SIZE</name></cpp:macro> \
  <cpp:value>((COMPILE_WORK_SIZE * sizeof(PCRE2_UCHAR))/sizeof(uint16_t))</cpp:value></cpp:define>

<comment type="block">/* A uint32_t vector is used for caching information about the size of
capturing groups, to improve performance. A default is created on the stack of
this size. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GROUPINFO_DEFAULT_SIZE</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>

<comment type="block">/* The overrun tests check for a slightly smaller size so that they detect the
overrun before it actually does run off the end of the data block. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WORK_SIZE_SAFETY_MARGIN</name></cpp:macro> <cpp:value>(100)</cpp:value></cpp:define>

<comment type="block">/* This value determines the size of the initial vector that is used for
remembering named groups during the pre-compile. It is allocated on the stack,
but if it is too small, it is expanded, in a similar way to the workspace. The
value is the number of slots in the list. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAMED_GROUP_LIST_SIZE</name></cpp:macro>  <cpp:value>20</cpp:value></cpp:define>

<comment type="block">/* The pre-compiling pass over the pattern creates a parsed pattern in a vector
of uint32_t. For short patterns this lives on the stack, with this size. Heap
memory is used for longer patterns. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSED_PATTERN_DEFAULT_SIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>

<comment type="block">/* Maximum length value to check against when making sure that the variable
that holds the compiled pattern length does not overflow. We make it a bit less
than INT_MAX to allow for adding in group terminating code units, so that we
don't have to check them every time. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFLOW_MAX</name></cpp:macro> <cpp:value>(INT_MAX - 20)</cpp:value></cpp:define>

<comment type="block">/* Code values for parsed patterns, which are stored in a vector of 32-bit
unsigned ints. Values less than META_END are literal data values. The coding
for identifying the item is in the top 16-bits, leaving 16 bits for the
additional data that some of them need. The META_CODE, META_DATA, and META_DIFF
macros are used to manipulate parsed pattern elements.

NOTE: When these definitions are changed, the table of extra lengths for each
code (meta_extra_lengths, just below) must be updated to remain in step. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_END</name></cpp:macro>              <cpp:value>0x80000000u</cpp:value></cpp:define>  <comment type="block">/* End of pattern */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_ALT</name></cpp:macro>              <cpp:value>0x80010000u</cpp:value></cpp:define>  <comment type="block">/* alternation */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_ATOMIC</name></cpp:macro>           <cpp:value>0x80020000u</cpp:value></cpp:define>  <comment type="block">/* atomic group */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_BACKREF</name></cpp:macro>          <cpp:value>0x80030000u</cpp:value></cpp:define>  <comment type="block">/* Back ref */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_BACKREF_BYNAME</name></cpp:macro>   <cpp:value>0x80040000u</cpp:value></cpp:define>  <comment type="block">/* \k'name' */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_BIGVALUE</name></cpp:macro>         <cpp:value>0x80050000u</cpp:value></cpp:define>  <comment type="block">/* Next is a literal &gt; META_END */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_CALLOUT_NUMBER</name></cpp:macro>   <cpp:value>0x80060000u</cpp:value></cpp:define>  <comment type="block">/* (?C with numerical argument */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_CALLOUT_STRING</name></cpp:macro>   <cpp:value>0x80070000u</cpp:value></cpp:define>  <comment type="block">/* (?C with string argument */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_CAPTURE</name></cpp:macro>          <cpp:value>0x80080000u</cpp:value></cpp:define>  <comment type="block">/* Capturing parenthesis */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_CIRCUMFLEX</name></cpp:macro>       <cpp:value>0x80090000u</cpp:value></cpp:define>  <comment type="block">/* ^ metacharacter */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_CLASS</name></cpp:macro>            <cpp:value>0x800a0000u</cpp:value></cpp:define>  <comment type="block">/* start non-empty class */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_CLASS_EMPTY</name></cpp:macro>      <cpp:value>0x800b0000u</cpp:value></cpp:define>  <comment type="block">/* empty class */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_CLASS_EMPTY_NOT</name></cpp:macro>  <cpp:value>0x800c0000u</cpp:value></cpp:define>  <comment type="block">/* negative empty class */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_CLASS_END</name></cpp:macro>        <cpp:value>0x800d0000u</cpp:value></cpp:define>  <comment type="block">/* end of non-empty class */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_CLASS_NOT</name></cpp:macro>        <cpp:value>0x800e0000u</cpp:value></cpp:define>  <comment type="block">/* start non-empty negative class */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_COND_ASSERT</name></cpp:macro>      <cpp:value>0x800f0000u</cpp:value></cpp:define>  <comment type="block">/* (?(?assertion)... */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_COND_DEFINE</name></cpp:macro>      <cpp:value>0x80100000u</cpp:value></cpp:define>  <comment type="block">/* (?(DEFINE)... */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_COND_NAME</name></cpp:macro>        <cpp:value>0x80110000u</cpp:value></cpp:define>  <comment type="block">/* (?(&lt;name&gt;)... */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_COND_NUMBER</name></cpp:macro>      <cpp:value>0x80120000u</cpp:value></cpp:define>  <comment type="block">/* (?(digits)... */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_COND_RNAME</name></cpp:macro>       <cpp:value>0x80130000u</cpp:value></cpp:define>  <comment type="block">/* (?(R&amp;name)... */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_COND_RNUMBER</name></cpp:macro>     <cpp:value>0x80140000u</cpp:value></cpp:define>  <comment type="block">/* (?(Rdigits)... */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_COND_VERSION</name></cpp:macro>     <cpp:value>0x80150000u</cpp:value></cpp:define>  <comment type="block">/* (?(VERSION&lt;op&gt;x.y)... */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_DOLLAR</name></cpp:macro>           <cpp:value>0x80160000u</cpp:value></cpp:define>  <comment type="block">/* $ metacharacter */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_DOT</name></cpp:macro>              <cpp:value>0x80170000u</cpp:value></cpp:define>  <comment type="block">/* . metacharacter */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_ESCAPE</name></cpp:macro>           <cpp:value>0x80180000u</cpp:value></cpp:define>  <comment type="block">/* \d and friends */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_KET</name></cpp:macro>              <cpp:value>0x80190000u</cpp:value></cpp:define>  <comment type="block">/* closing parenthesis */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_NOCAPTURE</name></cpp:macro>        <cpp:value>0x801a0000u</cpp:value></cpp:define>  <comment type="block">/* no capture parens */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_OPTIONS</name></cpp:macro>          <cpp:value>0x801b0000u</cpp:value></cpp:define>  <comment type="block">/* (?i) and friends */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_POSIX</name></cpp:macro>            <cpp:value>0x801c0000u</cpp:value></cpp:define>  <comment type="block">/* POSIX class item */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_POSIX_NEG</name></cpp:macro>        <cpp:value>0x801d0000u</cpp:value></cpp:define>  <comment type="block">/* negative POSIX class item */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_RANGE_ESCAPED</name></cpp:macro>    <cpp:value>0x801e0000u</cpp:value></cpp:define>  <comment type="block">/* range with at least one escape */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_RANGE_LITERAL</name></cpp:macro>    <cpp:value>0x801f0000u</cpp:value></cpp:define>  <comment type="block">/* range defined literally */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_RECURSE</name></cpp:macro>          <cpp:value>0x80200000u</cpp:value></cpp:define>  <comment type="block">/* Recursion */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_RECURSE_BYNAME</name></cpp:macro>   <cpp:value>0x80210000u</cpp:value></cpp:define>  <comment type="block">/* (?&amp;name) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_SCRIPT_RUN</name></cpp:macro>       <cpp:value>0x80220000u</cpp:value></cpp:define>  <comment type="block">/* (*script_run:...) */</comment>

<comment type="block">/* These must be kept together to make it easy to check that an assertion
is present where expected in a conditional group. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_LOOKAHEAD</name></cpp:macro>        <cpp:value>0x80230000u</cpp:value></cpp:define>  <comment type="block">/* (?= */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_LOOKAHEADNOT</name></cpp:macro>     <cpp:value>0x80240000u</cpp:value></cpp:define>  <comment type="block">/* (?! */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_LOOKBEHIND</name></cpp:macro>       <cpp:value>0x80250000u</cpp:value></cpp:define>  <comment type="block">/* (?&lt;= */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_LOOKBEHINDNOT</name></cpp:macro>    <cpp:value>0x80260000u</cpp:value></cpp:define>  <comment type="block">/* (?&lt;! */</comment>

<comment type="block">/* These cannot be conditions */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_LOOKAHEAD_NA</name></cpp:macro>     <cpp:value>0x80270000u</cpp:value></cpp:define>  <comment type="block">/* (*napla: */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_LOOKBEHIND_NA</name></cpp:macro>    <cpp:value>0x80280000u</cpp:value></cpp:define>  <comment type="block">/* (*naplb: */</comment>

<comment type="block">/* These must be kept in this order, with consecutive values, and the _ARG
versions of COMMIT, PRUNE, SKIP, and THEN immediately after their non-argument
versions. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_MARK</name></cpp:macro>             <cpp:value>0x80290000u</cpp:value></cpp:define>  <comment type="block">/* (*MARK) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_ACCEPT</name></cpp:macro>           <cpp:value>0x802a0000u</cpp:value></cpp:define>  <comment type="block">/* (*ACCEPT) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_FAIL</name></cpp:macro>             <cpp:value>0x802b0000u</cpp:value></cpp:define>  <comment type="block">/* (*FAIL) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_COMMIT</name></cpp:macro>           <cpp:value>0x802c0000u</cpp:value></cpp:define>  <comment type="block">/* These               */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_COMMIT_ARG</name></cpp:macro>       <cpp:value>0x802d0000u</cpp:value></cpp:define>  <comment type="block">/*   pairs             */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_PRUNE</name></cpp:macro>            <cpp:value>0x802e0000u</cpp:value></cpp:define>  <comment type="block">/*     must            */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_PRUNE_ARG</name></cpp:macro>        <cpp:value>0x802f0000u</cpp:value></cpp:define>  <comment type="block">/*       be            */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_SKIP</name></cpp:macro>             <cpp:value>0x80300000u</cpp:value></cpp:define>  <comment type="block">/*         kept        */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_SKIP_ARG</name></cpp:macro>         <cpp:value>0x80310000u</cpp:value></cpp:define>  <comment type="block">/*           in        */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_THEN</name></cpp:macro>             <cpp:value>0x80320000u</cpp:value></cpp:define>  <comment type="block">/*             this    */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_THEN_ARG</name></cpp:macro>         <cpp:value>0x80330000u</cpp:value></cpp:define>  <comment type="block">/*               order */</comment>

<comment type="block">/* These must be kept in groups of adjacent 3 values, and all together. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_ASTERISK</name></cpp:macro>         <cpp:value>0x80340000u</cpp:value></cpp:define>  <comment type="block">/* *  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_ASTERISK_PLUS</name></cpp:macro>    <cpp:value>0x80350000u</cpp:value></cpp:define>  <comment type="block">/* *+ */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_ASTERISK_QUERY</name></cpp:macro>   <cpp:value>0x80360000u</cpp:value></cpp:define>  <comment type="block">/* *? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_PLUS</name></cpp:macro>             <cpp:value>0x80370000u</cpp:value></cpp:define>  <comment type="block">/* +  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_PLUS_PLUS</name></cpp:macro>        <cpp:value>0x80380000u</cpp:value></cpp:define>  <comment type="block">/* ++ */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_PLUS_QUERY</name></cpp:macro>       <cpp:value>0x80390000u</cpp:value></cpp:define>  <comment type="block">/* +? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_QUERY</name></cpp:macro>            <cpp:value>0x803a0000u</cpp:value></cpp:define>  <comment type="block">/* ?  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_QUERY_PLUS</name></cpp:macro>       <cpp:value>0x803b0000u</cpp:value></cpp:define>  <comment type="block">/* ?+ */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_QUERY_QUERY</name></cpp:macro>      <cpp:value>0x803c0000u</cpp:value></cpp:define>  <comment type="block">/* ?? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_MINMAX</name></cpp:macro>           <cpp:value>0x803d0000u</cpp:value></cpp:define>  <comment type="block">/* {n,m}  repeat */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_MINMAX_PLUS</name></cpp:macro>      <cpp:value>0x803e0000u</cpp:value></cpp:define>  <comment type="block">/* {n,m}+ repeat */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_MINMAX_QUERY</name></cpp:macro>     <cpp:value>0x803f0000u</cpp:value></cpp:define>  <comment type="block">/* {n,m}? repeat */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_FIRST_QUANTIFIER</name></cpp:macro> <cpp:value>META_ASTERISK</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_LAST_QUANTIFIER</name></cpp:macro>  <cpp:value>META_MINMAX_QUERY</cpp:value></cpp:define>

<comment type="block">/* This is a special "meta code" that is used only to distinguish (*asr: from
(*sr: in the table of aphabetic assertions. It is never stored in the parsed
pattern because (*asr: is turned into (*sr:(*atomic: at that stage. There is
therefore no need for it to have a length entry, so use a high value. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>META_ATOMIC_SCRIPT_RUN</name></cpp:macro> <cpp:value>0x8fff0000u</cpp:value></cpp:define>

<comment type="block">/* Table of extra lengths for each of the meta codes. Must be kept in step with
the definitions above. For some items these values are a basic length to which
a variable amount has to be added. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name><name>meta_extra_lengths</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_END */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_ALT */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_ATOMIC */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_BACKREF - more if group is &gt;= 10 */</comment>
  <expr><literal type="number">1</literal><operator>+</operator><name>SIZEOFFSET</name></expr>,  <comment type="block">/* META_BACKREF_BYNAME */</comment>
  <expr><literal type="number">1</literal></expr>,             <comment type="block">/* META_BIGVALUE */</comment>
  <expr><literal type="number">3</literal></expr>,             <comment type="block">/* META_CALLOUT_NUMBER */</comment>
  <expr><literal type="number">3</literal><operator>+</operator><name>SIZEOFFSET</name></expr>,  <comment type="block">/* META_CALLOUT_STRING */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_CAPTURE */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_CIRCUMFLEX */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_CLASS */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_CLASS_EMPTY */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_CLASS_EMPTY_NOT */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_CLASS_END */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_CLASS_NOT */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_COND_ASSERT */</comment>
  <expr><name>SIZEOFFSET</name></expr>,    <comment type="block">/* META_COND_DEFINE */</comment>
  <expr><literal type="number">1</literal><operator>+</operator><name>SIZEOFFSET</name></expr>,  <comment type="block">/* META_COND_NAME */</comment>
  <expr><literal type="number">1</literal><operator>+</operator><name>SIZEOFFSET</name></expr>,  <comment type="block">/* META_COND_NUMBER */</comment>
  <expr><literal type="number">1</literal><operator>+</operator><name>SIZEOFFSET</name></expr>,  <comment type="block">/* META_COND_RNAME */</comment>
  <expr><literal type="number">1</literal><operator>+</operator><name>SIZEOFFSET</name></expr>,  <comment type="block">/* META_COND_RNUMBER */</comment>
  <expr><literal type="number">3</literal></expr>,             <comment type="block">/* META_COND_VERSION */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_DOLLAR */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_DOT */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_ESCAPE - more for ESC_P, ESC_p, ESC_g, ESC_k */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_KET */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_NOCAPTURE */</comment>
  <expr><literal type="number">1</literal></expr>,             <comment type="block">/* META_OPTIONS */</comment>
  <expr><literal type="number">1</literal></expr>,             <comment type="block">/* META_POSIX */</comment>
  <expr><literal type="number">1</literal></expr>,             <comment type="block">/* META_POSIX_NEG */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_RANGE_ESCAPED */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_RANGE_LITERAL */</comment>
  <expr><name>SIZEOFFSET</name></expr>,    <comment type="block">/* META_RECURSE */</comment>
  <expr><literal type="number">1</literal><operator>+</operator><name>SIZEOFFSET</name></expr>,  <comment type="block">/* META_RECURSE_BYNAME */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_SCRIPT_RUN */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_LOOKAHEAD */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_LOOKAHEADNOT */</comment>
  <expr><name>SIZEOFFSET</name></expr>,    <comment type="block">/* META_LOOKBEHIND */</comment>
  <expr><name>SIZEOFFSET</name></expr>,    <comment type="block">/* META_LOOKBEHINDNOT */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_LOOKAHEAD_NA */</comment>
  <expr><name>SIZEOFFSET</name></expr>,    <comment type="block">/* META_LOOKBEHIND_NA */</comment>
  <expr><literal type="number">1</literal></expr>,             <comment type="block">/* META_MARK - plus the string length */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_ACCEPT */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_FAIL */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_COMMIT */</comment>
  <expr><literal type="number">1</literal></expr>,             <comment type="block">/* META_COMMIT_ARG - plus the string length */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_PRUNE */</comment>
  <expr><literal type="number">1</literal></expr>,             <comment type="block">/* META_PRUNE_ARG - plus the string length */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_SKIP */</comment>
  <expr><literal type="number">1</literal></expr>,             <comment type="block">/* META_SKIP_ARG - plus the string length */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_THEN */</comment>
  <expr><literal type="number">1</literal></expr>,             <comment type="block">/* META_THEN_ARG - plus the string length */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_ASTERISK */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_ASTERISK_PLUS */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_ASTERISK_QUERY */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_PLUS */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_PLUS_PLUS */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_PLUS_QUERY */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_QUERY */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_QUERY_PLUS */</comment>
  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* META_QUERY_QUERY */</comment>
  <expr><literal type="number">2</literal></expr>,             <comment type="block">/* META_MINMAX */</comment>
  <expr><literal type="number">2</literal></expr>,             <comment type="block">/* META_MINMAX_PLUS */</comment>
  <expr><literal type="number">2</literal></expr>              <comment type="block">/* META_MINMAX_QUERY */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Types for skipping parts of a parsed pattern. */</comment>

<enum>enum <block>{ <decl><name>PSKIP_ALT</name></decl>, <decl><name>PSKIP_CLASS</name></decl>, <decl><name>PSKIP_KET</name></decl> }</block>;</enum>

<comment type="block">/* Macro for setting individual bits in class bitmaps. It took some
experimenting to figure out how to stop gcc 5.3.0 from warning with
-Wconversion. This version gets a warning:

  #define SETBIT(a,b) a[(b)/8] |= (uint8_t)(1u &lt;&lt; ((b)&amp;7))

Let's hope the apparently less efficient version isn't actually so bad if the
compiler is clever with identical subexpressions. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETBIT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a[(b)/8] = (uint8_t)(a[(b)/8] | (1u &lt;&lt; ((b)&amp;7)))</cpp:value></cpp:define>

<comment type="block">/* Private flags added to firstcu and reqcu. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REQ_CASELESS</name></cpp:macro>    <cpp:value>(1u &lt;&lt; 0)</cpp:value></cpp:define>       <comment type="block">/* Indicates caselessness */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REQ_VARY</name></cpp:macro>        <cpp:value>(1u &lt;&lt; 1)</cpp:value></cpp:define>       <comment type="block">/* reqcu followed non-literal item */</comment>
<comment type="block">/* Negative values for the firstcu and reqcu flags */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REQ_UNSET</name></cpp:macro>       <cpp:value>(-2)</cpp:value></cpp:define>            <comment type="block">/* Not yet found anything */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REQ_NONE</name></cpp:macro>        <cpp:value>(-1)</cpp:value></cpp:define>            <comment type="block">/* Found not fixed char */</comment>

<comment type="block">/* These flags are used in the groupinfo vector. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GI_SET_FIXED_LENGTH</name></cpp:macro>    <cpp:value>0x80000000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GI_NOT_FIXED_LENGTH</name></cpp:macro>    <cpp:value>0x40000000u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GI_FIXED_LENGTH_MASK</name></cpp:macro>   <cpp:value>0x0000ffffu</cpp:value></cpp:define>

<comment type="block">/* This simple test for a decimal digit works for both ASCII/Unicode and EBCDIC
and is fast (a good compiler can turn it into a subtraction and unsigned
comparison). */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_DIGIT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) &gt;= CHAR_0 &amp;&amp; (x) &lt;= CHAR_9)</cpp:value></cpp:define>

<comment type="block">/* Table to identify hex digits. The tables in chartables are dependent on the
locale, and may mark arbitrary characters as digits. We want to recognize only
0-9, a-z, and A-Z as hex digits, which is why we have a private table here. It
costs 256 bytes, but it is a lot faster than doing character value tests (at
least in some simple cases I timed), and in some applications one wants PCRE2
to compile efficiently as well as match efficiently. The value in the table is
the binary hex digit value, or 0xff for non-hex digits. */</comment>

<comment type="block">/* This is the "normal" case, for ASCII systems, and EBCDIC systems running in
UTF-8 mode. */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EBCDIC</name></cpp:ifndef>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>xdigitab</name><index>[]</index></name> <init>=
  <expr><block>{
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*   0-  7 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*   8- 15 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  16- 23 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  24- 31 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*    - '  */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  ( - /  */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x05</literal></expr>,<expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x07</literal></expr>, <comment type="block">/*  0 - 7  */</comment>
  <expr><literal type="number">0x08</literal></expr>,<expr><literal type="number">0x09</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  8 - ?  */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0x0a</literal></expr>,<expr><literal type="number">0x0b</literal></expr>,<expr><literal type="number">0x0c</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x0f</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  @ - G  */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  H - O  */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  P - W  */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  X - _  */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0x0a</literal></expr>,<expr><literal type="number">0x0b</literal></expr>,<expr><literal type="number">0x0c</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x0f</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  ` - g  */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  h - o  */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  p - w  */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  x -127 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 128-135 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 136-143 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 144-151 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 152-159 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 160-167 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 168-175 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 176-183 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 184-191 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 192-199 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 2ff-207 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 208-215 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 216-223 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 224-231 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 232-239 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 240-247 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>}</block></expr></init></decl>;</decl_stmt><comment type="block">/* 248-255 */</comment>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<comment type="block">/* This is the "abnormal" case, for EBCDIC systems not running in UTF-8 mode. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>xdigitab</name><index>[]</index></name> <init>=
  <expr><block>{
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*   0-  7  0 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*   8- 15    */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  16- 23 10 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  24- 31    */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  32- 39 20 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  40- 47    */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  48- 55 30 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  56- 63    */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*    - 71 40 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  72- |     */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  &amp; - 87 50 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  88- 95    */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  - -103 60 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 104- ?     */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 112-119 70 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 120- "     */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0x0a</literal></expr>,<expr><literal type="number">0x0b</literal></expr>,<expr><literal type="number">0x0c</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x0f</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 128- g  80 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  h -143    */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 144- p  90 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  q -159    */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 160- x  A0 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  y -175    */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  ^ -183 B0 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/* 184-191    */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0x0a</literal></expr>,<expr><literal type="number">0x0b</literal></expr>,<expr><literal type="number">0x0c</literal></expr>,<expr><literal type="number">0x0d</literal></expr>,<expr><literal type="number">0x0e</literal></expr>,<expr><literal type="number">0x0f</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  { - G  C0 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  H -207    */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  } - P  D0 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  Q -223    */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  \ - X  E0 */</comment>
  <expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>, <comment type="block">/*  Y -239    */</comment>
  <expr><literal type="number">0x00</literal></expr>,<expr><literal type="number">0x01</literal></expr>,<expr><literal type="number">0x02</literal></expr>,<expr><literal type="number">0x03</literal></expr>,<expr><literal type="number">0x04</literal></expr>,<expr><literal type="number">0x05</literal></expr>,<expr><literal type="number">0x06</literal></expr>,<expr><literal type="number">0x07</literal></expr>, <comment type="block">/*  0 - 7  F0 */</comment>
  <expr><literal type="number">0x08</literal></expr>,<expr><literal type="number">0x09</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>,<expr><literal type="number">0xff</literal></expr>}</block></expr></init></decl>;</decl_stmt><comment type="block">/*  8 -255    */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* EBCDIC */</comment>


<comment type="block">/* Table for handling alphanumeric escaped characters. Positive returns are
simple data values; negative values are for special things like \d and so on.
Zero means further processing is needed (for things like \x), or the escape is
invalid. */</comment>

<comment type="block">/* This is the "normal" table for ASCII systems or for EBCDIC systems running
in UTF-8 mode. It runs from '0' to 'z'. */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EBCDIC</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ESCAPES_FIRST</name></cpp:macro>       <cpp:value>CHAR_0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ESCAPES_LAST</name></cpp:macro>        <cpp:value>CHAR_z</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UPPER_CASE</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>(c-32)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>short</name> <name>int</name></type> <name><name>escapes</name><index>[]</index></name> <init>= <expr><block>{
     <expr><literal type="number">0</literal></expr>,                       <expr><literal type="number">0</literal></expr>,
     <expr><literal type="number">0</literal></expr>,                       <expr><literal type="number">0</literal></expr>,
     <expr><literal type="number">0</literal></expr>,                       <expr><literal type="number">0</literal></expr>,
     <expr><literal type="number">0</literal></expr>,                       <expr><literal type="number">0</literal></expr>,
     <expr><literal type="number">0</literal></expr>,                       <expr><literal type="number">0</literal></expr>,
     <expr><name>CHAR_COLON</name></expr>,              <expr><name>CHAR_SEMICOLON</name></expr>,
     <expr><name>CHAR_LESS_THAN_SIGN</name></expr>,     <expr><name>CHAR_EQUALS_SIGN</name></expr>,
     <expr><name>CHAR_GREATER_THAN_SIGN</name></expr>,  <expr><name>CHAR_QUESTION_MARK</name></expr>,
     <expr><name>CHAR_COMMERCIAL_AT</name></expr>,      <expr><operator>-</operator><name>ESC_A</name></expr>,
     <expr><operator>-</operator><name>ESC_B</name></expr>,                  <expr><operator>-</operator><name>ESC_C</name></expr>,
     <expr><operator>-</operator><name>ESC_D</name></expr>,                  <expr><operator>-</operator><name>ESC_E</name></expr>,
     <expr><literal type="number">0</literal></expr>,                       <expr><operator>-</operator><name>ESC_G</name></expr>,
     <expr><operator>-</operator><name>ESC_H</name></expr>,                  <expr><literal type="number">0</literal></expr>,
     <expr><literal type="number">0</literal></expr>,                       <expr><operator>-</operator><name>ESC_K</name></expr>,
     <expr><literal type="number">0</literal></expr>,                       <expr><literal type="number">0</literal></expr>,
     <expr><operator>-</operator><name>ESC_N</name></expr>,                  <expr><literal type="number">0</literal></expr>,
     <expr><operator>-</operator><name>ESC_P</name></expr>,                  <expr><operator>-</operator><name>ESC_Q</name></expr>,
     <expr><operator>-</operator><name>ESC_R</name></expr>,                  <expr><operator>-</operator><name>ESC_S</name></expr>,
     <expr><literal type="number">0</literal></expr>,                       <expr><literal type="number">0</literal></expr>,
     <expr><operator>-</operator><name>ESC_V</name></expr>,                  <expr><operator>-</operator><name>ESC_W</name></expr>,
     <expr><operator>-</operator><name>ESC_X</name></expr>,                  <expr><literal type="number">0</literal></expr>,
     <expr><operator>-</operator><name>ESC_Z</name></expr>,                  <expr><name>CHAR_LEFT_SQUARE_BRACKET</name></expr>,
     <expr><name>CHAR_BACKSLASH</name></expr>,          <expr><name>CHAR_RIGHT_SQUARE_BRACKET</name></expr>,
     <expr><name>CHAR_CIRCUMFLEX_ACCENT</name></expr>,  <expr><name>CHAR_UNDERSCORE</name></expr>,
     <expr><name>CHAR_GRAVE_ACCENT</name></expr>,       <expr><name>CHAR_BEL</name></expr>,
     <expr><operator>-</operator><name>ESC_b</name></expr>,                  <expr><literal type="number">0</literal></expr>,
     <expr><operator>-</operator><name>ESC_d</name></expr>,                  <expr><name>CHAR_ESC</name></expr>,
     <expr><name>CHAR_FF</name></expr>,                 <expr><literal type="number">0</literal></expr>,
     <expr><operator>-</operator><name>ESC_h</name></expr>,                  <expr><literal type="number">0</literal></expr>,
     <expr><literal type="number">0</literal></expr>,                       <expr><operator>-</operator><name>ESC_k</name></expr>,
     <expr><literal type="number">0</literal></expr>,                       <expr><literal type="number">0</literal></expr>,
     <expr><name>CHAR_LF</name></expr>,                 <expr><literal type="number">0</literal></expr>,
     <expr><operator>-</operator><name>ESC_p</name></expr>,                  <expr><literal type="number">0</literal></expr>,
     <expr><name>CHAR_CR</name></expr>,                 <expr><operator>-</operator><name>ESC_s</name></expr>,
     <expr><name>CHAR_HT</name></expr>,                 <expr><literal type="number">0</literal></expr>,
     <expr><operator>-</operator><name>ESC_v</name></expr>,                  <expr><operator>-</operator><name>ESC_w</name></expr>,
     <expr><literal type="number">0</literal></expr>,                       <expr><literal type="number">0</literal></expr>,
     <expr><operator>-</operator><name>ESC_z</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<comment type="block">/* This is the "abnormal" table for EBCDIC systems without UTF-8 support.
It runs from 'a' to '9'. For some minimal testing of EBCDIC features, the code
is sometimes compiled on an ASCII system. In this case, we must not use CHAR_a
because it is defined as 'a', which of course picks up the ASCII value. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="char">'a'</literal> <operator>==</operator> <literal type="number">0x81</literal></expr></cpp:if>                    <comment type="block">/* Check for a real EBCDIC environment */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ESCAPES_FIRST</name></cpp:macro>       <cpp:value>CHAR_a</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ESCAPES_LAST</name></cpp:macro>        <cpp:value>CHAR_9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UPPER_CASE</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>       <cpp:value>(c+64)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>                              <comment type="block">/* Testing in an ASCII environment */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ESCAPES_FIRST</name></cpp:macro>  <cpp:value>((unsigned char)'\x81')</cpp:value></cpp:define>   <comment type="block">/* EBCDIC 'a' */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ESCAPES_LAST</name></cpp:macro>   <cpp:value>((unsigned char)'\xf9')</cpp:value></cpp:define>   <comment type="block">/* EBCDIC '9' */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UPPER_CASE</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(c-32)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>short</name> <name>int</name></type> <name><name>escapes</name><index>[]</index></name> <init>= <expr><block>{
<comment type="block">/*  80 */</comment>         <expr><name>CHAR_BEL</name></expr>, <expr><operator>-</operator><name>ESC_b</name></expr>,       <expr><literal type="number">0</literal></expr>, <expr><operator>-</operator><name>ESC_d</name></expr>, <expr><name>CHAR_ESC</name></expr>, <expr><name>CHAR_FF</name></expr>,      <expr><literal type="number">0</literal></expr>,
<comment type="block">/*  88 */</comment> <expr><operator>-</operator><name>ESC_h</name></expr>,        <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,     <expr><literal type="char">'{'</literal></expr>,      <expr><literal type="number">0</literal></expr>,        <expr><literal type="number">0</literal></expr>,       <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,
<comment type="block">/*  90 */</comment>      <expr><literal type="number">0</literal></expr>,        <expr><literal type="number">0</literal></expr>, <expr><operator>-</operator><name>ESC_k</name></expr>,       <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,  <expr><name>CHAR_LF</name></expr>,       <expr><literal type="number">0</literal></expr>, <expr><operator>-</operator><name>ESC_p</name></expr>,
<comment type="block">/*  98 */</comment>      <expr><literal type="number">0</literal></expr>,  <expr><name>CHAR_CR</name></expr>,      <expr><literal type="number">0</literal></expr>,     <expr><literal type="char">'}'</literal></expr>,      <expr><literal type="number">0</literal></expr>,        <expr><literal type="number">0</literal></expr>,       <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,
<comment type="block">/*  A0 */</comment>      <expr><literal type="number">0</literal></expr>,      <expr><literal type="char">'~'</literal></expr>, <expr><operator>-</operator><name>ESC_s</name></expr>, <expr><name>CHAR_HT</name></expr>,      <expr><literal type="number">0</literal></expr>,   <expr><operator>-</operator><name>ESC_v</name></expr>,  <expr><operator>-</operator><name>ESC_w</name></expr>,      <expr><literal type="number">0</literal></expr>,
<comment type="block">/*  A8 */</comment>      <expr><literal type="number">0</literal></expr>,   <expr><operator>-</operator><name>ESC_z</name></expr>,      <expr><literal type="number">0</literal></expr>,       <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,      <expr><literal type="char">'['</literal></expr>,       <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,
<comment type="block">/*  B0 */</comment>      <expr><literal type="number">0</literal></expr>,        <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,       <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,        <expr><literal type="number">0</literal></expr>,       <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,
<comment type="block">/*  B8 */</comment>      <expr><literal type="number">0</literal></expr>,        <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,       <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,      <expr><literal type="char">']'</literal></expr>,     <expr><literal type="char">'='</literal></expr>,    <expr><literal type="char">'-'</literal></expr>,
<comment type="block">/*  C0 */</comment>    <expr><literal type="char">'{'</literal></expr>,   <expr><operator>-</operator><name>ESC_A</name></expr>, <expr><operator>-</operator><name>ESC_B</name></expr>,  <expr><operator>-</operator><name>ESC_C</name></expr>, <expr><operator>-</operator><name>ESC_D</name></expr>,   <expr><operator>-</operator><name>ESC_E</name></expr>,       <expr><literal type="number">0</literal></expr>, <expr><operator>-</operator><name>ESC_G</name></expr>,
<comment type="block">/*  C8 */</comment> <expr><operator>-</operator><name>ESC_H</name></expr>,        <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,       <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,        <expr><literal type="number">0</literal></expr>,       <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,
<comment type="block">/*  D0 */</comment>    <expr><literal type="char">'}'</literal></expr>,        <expr><literal type="number">0</literal></expr>, <expr><operator>-</operator><name>ESC_K</name></expr>,       <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,   <expr><operator>-</operator><name>ESC_N</name></expr>,       <expr><literal type="number">0</literal></expr>, <expr><operator>-</operator><name>ESC_P</name></expr>,
<comment type="block">/*  D8 */</comment> <expr><operator>-</operator><name>ESC_Q</name></expr>,   <expr><operator>-</operator><name>ESC_R</name></expr>,      <expr><literal type="number">0</literal></expr>,       <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,        <expr><literal type="number">0</literal></expr>,       <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,
<comment type="block">/*  E0 */</comment>   <expr><literal type="char">'\\'</literal></expr>,        <expr><literal type="number">0</literal></expr>, <expr><operator>-</operator><name>ESC_S</name></expr>,       <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,   <expr><operator>-</operator><name>ESC_V</name></expr>,  <expr><operator>-</operator><name>ESC_W</name></expr>, <expr><operator>-</operator><name>ESC_X</name></expr>,
<comment type="block">/*  E8 */</comment>      <expr><literal type="number">0</literal></expr>,   <expr><operator>-</operator><name>ESC_Z</name></expr>,      <expr><literal type="number">0</literal></expr>,       <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,        <expr><literal type="number">0</literal></expr>,       <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,
<comment type="block">/*  F0 */</comment>      <expr><literal type="number">0</literal></expr>,        <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,       <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,        <expr><literal type="number">0</literal></expr>,       <expr><literal type="number">0</literal></expr>,      <expr><literal type="number">0</literal></expr>,
<comment type="block">/*  F8 */</comment>      <expr><literal type="number">0</literal></expr>,        <expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* We also need a table of characters that may follow \c in an EBCDIC
environment for characters 0-31. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name><name>ebcdic_escape_c</name><index>[]</index></name> <init>= <expr><literal type="string">"@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"</literal></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* EBCDIC */</comment>


<comment type="block">/* Table of special "verbs" like (*PRUNE). This is a short table, so it is
searched linearly. Put all the names into a single string, in order to reduce
the number of relocations when a shared library is dynamically linked. The
string is built from string macros so that it works in UTF-8 mode on EBCDIC
platforms. */</comment>

<typedef>typedef <type><struct>struct <name>verbitem</name> <block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl>;</decl_stmt>          <comment type="block">/* Length of verb name */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>meta</name></decl>;</decl_stmt>             <comment type="block">/* Base META_ code */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>has_arg</name></decl>;</decl_stmt>               <comment type="block">/* Argument requirement */</comment>
}</block></struct></type> <name>verbitem</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>verbnames</name><index>[]</index></name> <init>=
  <expr><literal type="string">"\0"</literal>                       <comment type="block">/* Empty name is a shorthand for MARK */</comment>
  <name>STRING_MARK0</name>
  <name>STRING_ACCEPT0</name>
  <name>STRING_F0</name>
  <name>STRING_FAIL0</name>
  <name>STRING_COMMIT0</name>
  <name>STRING_PRUNE0</name>
  <name>STRING_SKIP0</name>
  <name>STRING_THEN</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>verbitem</name></type> <name><name>verbs</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><name>META_MARK</name></expr>,   <expr><operator>+</operator><literal type="number">1</literal></expr> }</block></expr>,  <comment type="block">/* &gt; 0 =&gt; must have an argument */</comment>
  <expr><block>{ <expr><literal type="number">4</literal></expr>, <expr><name>META_MARK</name></expr>,   <expr><operator>+</operator><literal type="number">1</literal></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="number">6</literal></expr>, <expr><name>META_ACCEPT</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>,  <comment type="block">/* &lt; 0 =&gt; Optional argument, convert to pre-MARK */</comment>
  <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><name>META_FAIL</name></expr>,   <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="number">4</literal></expr>, <expr><name>META_FAIL</name></expr>,   <expr><operator>-</operator><literal type="number">1</literal></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="number">6</literal></expr>, <expr><name>META_COMMIT</name></expr>,  <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="number">5</literal></expr>, <expr><name>META_PRUNE</name></expr>,   <expr><literal type="number">0</literal></expr> }</block></expr>,  <comment type="block">/* Optional argument; bump META code if found */</comment>
  <expr><block>{ <expr><literal type="number">4</literal></expr>, <expr><name>META_SKIP</name></expr>,    <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="number">4</literal></expr>, <expr><name>META_THEN</name></expr>,    <expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>verbcount</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>verbs</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>verbitem</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<comment type="block">/* Verb opcodes, indexed by their META code offset from META_MARK. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint32_t</name></type> <name><name>verbops</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>OP_MARK</name></expr>, <expr><name>OP_ACCEPT</name></expr>, <expr><name>OP_FAIL</name></expr>, <expr><name>OP_COMMIT</name></expr>, <expr><name>OP_COMMIT_ARG</name></expr>, <expr><name>OP_PRUNE</name></expr>,
  <expr><name>OP_PRUNE_ARG</name></expr>, <expr><name>OP_SKIP</name></expr>, <expr><name>OP_SKIP_ARG</name></expr>, <expr><name>OP_THEN</name></expr>, <expr><name>OP_THEN_ARG</name></expr> }</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Table of "alpha assertions" like (*pla:...), similar to the (*VERB) table. */</comment>

<typedef>typedef <type><struct>struct <name>alasitem</name> <block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl>;</decl_stmt>          <comment type="block">/* Length of name */</comment>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>meta</name></decl>;</decl_stmt>             <comment type="block">/* Base META_ code */</comment>
}</block></struct></type> <name>alasitem</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>alasnames</name><index>[]</index></name> <init>=
  <expr><name>STRING_pla0</name>
  <name>STRING_plb0</name>
  <name>STRING_napla0</name>
  <name>STRING_naplb0</name>
  <name>STRING_nla0</name>
  <name>STRING_nlb0</name>
  <name>STRING_positive_lookahead0</name>
  <name>STRING_positive_lookbehind0</name>
  <name>STRING_non_atomic_positive_lookahead0</name>
  <name>STRING_non_atomic_positive_lookbehind0</name>
  <name>STRING_negative_lookahead0</name>
  <name>STRING_negative_lookbehind0</name>
  <name>STRING_atomic0</name>
  <name>STRING_sr0</name>
  <name>STRING_asr0</name>
  <name>STRING_script_run0</name>
  <name>STRING_atomic_script_run</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>alasitem</name></type> <name><name>alasmeta</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{  <expr><literal type="number">3</literal></expr>, <expr><name>META_LOOKAHEAD</name></expr>         }</block></expr>,
  <expr><block>{  <expr><literal type="number">3</literal></expr>, <expr><name>META_LOOKBEHIND</name></expr>        }</block></expr>,
  <expr><block>{  <expr><literal type="number">5</literal></expr>, <expr><name>META_LOOKAHEAD_NA</name></expr>      }</block></expr>,
  <expr><block>{  <expr><literal type="number">5</literal></expr>, <expr><name>META_LOOKBEHIND_NA</name></expr>     }</block></expr>,
  <expr><block>{  <expr><literal type="number">3</literal></expr>, <expr><name>META_LOOKAHEADNOT</name></expr>      }</block></expr>,
  <expr><block>{  <expr><literal type="number">3</literal></expr>, <expr><name>META_LOOKBEHINDNOT</name></expr>     }</block></expr>,
  <expr><block>{ <expr><literal type="number">18</literal></expr>, <expr><name>META_LOOKAHEAD</name></expr>         }</block></expr>,
  <expr><block>{ <expr><literal type="number">19</literal></expr>, <expr><name>META_LOOKBEHIND</name></expr>        }</block></expr>,
  <expr><block>{ <expr><literal type="number">29</literal></expr>, <expr><name>META_LOOKAHEAD_NA</name></expr>      }</block></expr>,
  <expr><block>{ <expr><literal type="number">30</literal></expr>, <expr><name>META_LOOKBEHIND_NA</name></expr>     }</block></expr>,
  <expr><block>{ <expr><literal type="number">18</literal></expr>, <expr><name>META_LOOKAHEADNOT</name></expr>      }</block></expr>,
  <expr><block>{ <expr><literal type="number">19</literal></expr>, <expr><name>META_LOOKBEHINDNOT</name></expr>     }</block></expr>,
  <expr><block>{  <expr><literal type="number">6</literal></expr>, <expr><name>META_ATOMIC</name></expr>            }</block></expr>,
  <expr><block>{  <expr><literal type="number">2</literal></expr>, <expr><name>META_SCRIPT_RUN</name></expr>        }</block></expr>, <comment type="block">/* sr = script run */</comment>
  <expr><block>{  <expr><literal type="number">3</literal></expr>, <expr><name>META_ATOMIC_SCRIPT_RUN</name></expr> }</block></expr>, <comment type="block">/* asr = atomic script run */</comment>
  <expr><block>{ <expr><literal type="number">10</literal></expr>, <expr><name>META_SCRIPT_RUN</name></expr>        }</block></expr>, <comment type="block">/* script run */</comment>
  <expr><block>{ <expr><literal type="number">17</literal></expr>, <expr><name>META_ATOMIC_SCRIPT_RUN</name></expr> }</block></expr>  <comment type="block">/* atomic script run */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>alascount</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>alasmeta</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>alasitem</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<comment type="block">/* Offsets from OP_STAR for case-independent and negative repeat opcodes. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name><name>chartypeoffset</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>OP_STAR</name> <operator>-</operator> <name>OP_STAR</name></expr>,    <expr><name>OP_STARI</name> <operator>-</operator> <name>OP_STAR</name></expr>,
  <expr><name>OP_NOTSTAR</name> <operator>-</operator> <name>OP_STAR</name></expr>, <expr><name>OP_NOTSTARI</name> <operator>-</operator> <name>OP_STAR</name></expr> }</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Tables of names of POSIX character classes and their lengths. The names are
now all in a single string, to reduce the number of relocations when a shared
library is dynamically loaded. The list of lengths is terminated by a zero
length entry. The first three must be alpha, lower, upper, as this is assumed
for handling case independence. The indices for graph, print, and punct are
needed, so identify them. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>posix_names</name><index>[]</index></name> <init>=
  <expr><name>STRING_alpha0</name> <name>STRING_lower0</name> <name>STRING_upper0</name> <name>STRING_alnum0</name>
  <name>STRING_ascii0</name> <name>STRING_blank0</name> <name>STRING_cntrl0</name> <name>STRING_digit0</name>
  <name>STRING_graph0</name> <name>STRING_print0</name> <name>STRING_punct0</name> <name>STRING_space0</name>
  <name>STRING_word0</name>  <name>STRING_xdigit</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>posix_name_lengths</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PC_GRAPH</name></cpp:macro>  <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PC_PRINT</name></cpp:macro>  <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PC_PUNCT</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<comment type="block">/* Table of class bit maps for each POSIX class. Each class is formed from a
base map, with an optional addition or removal of another map. Then, for some
classes, there is some additional tweaking: for [:blank:] the vertical space
characters are removed, and for [:alpha:] and [:alnum:] the underscore
character is removed. The triples in the table consist of the base map offset,
second map offset or -1 if no second map, and a non-negative value for map
addition or a negative value for map subtraction (if there are two maps). The
absolute value of the third field has these meanings: 0 =&gt; no tweaking, 1 =&gt;
remove vertical space characters, 2 =&gt; remove underscore. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>posix_class_maps</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>cbit_word</name></expr>,  <expr><name>cbit_digit</name></expr>, <expr><operator>-</operator><literal type="number">2</literal></expr>,             <comment type="block">/* alpha */</comment>
  <expr><name>cbit_lower</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,          <expr><literal type="number">0</literal></expr>,             <comment type="block">/* lower */</comment>
  <expr><name>cbit_upper</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,          <expr><literal type="number">0</literal></expr>,             <comment type="block">/* upper */</comment>
  <expr><name>cbit_word</name></expr>,  <expr><operator>-</operator><literal type="number">1</literal></expr>,          <expr><literal type="number">2</literal></expr>,             <comment type="block">/* alnum - word without underscore */</comment>
  <expr><name>cbit_print</name></expr>, <expr><name>cbit_cntrl</name></expr>,  <expr><literal type="number">0</literal></expr>,             <comment type="block">/* ascii */</comment>
  <expr><name>cbit_space</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,          <expr><literal type="number">1</literal></expr>,             <comment type="block">/* blank - a GNU extension */</comment>
  <expr><name>cbit_cntrl</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,          <expr><literal type="number">0</literal></expr>,             <comment type="block">/* cntrl */</comment>
  <expr><name>cbit_digit</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,          <expr><literal type="number">0</literal></expr>,             <comment type="block">/* digit */</comment>
  <expr><name>cbit_graph</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,          <expr><literal type="number">0</literal></expr>,             <comment type="block">/* graph */</comment>
  <expr><name>cbit_print</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,          <expr><literal type="number">0</literal></expr>,             <comment type="block">/* print */</comment>
  <expr><name>cbit_punct</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,          <expr><literal type="number">0</literal></expr>,             <comment type="block">/* punct */</comment>
  <expr><name>cbit_space</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,          <expr><literal type="number">0</literal></expr>,             <comment type="block">/* space */</comment>
  <expr><name>cbit_word</name></expr>,  <expr><operator>-</operator><literal type="number">1</literal></expr>,          <expr><literal type="number">0</literal></expr>,             <comment type="block">/* word - a Perl extension */</comment>
  <expr><name>cbit_xdigit</name></expr>,<expr><operator>-</operator><literal type="number">1</literal></expr>,          <expr><literal type="number">0</literal></expr>              <comment type="block">/* xdigit */</comment>
}</block></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>

<comment type="block">/* The POSIX class Unicode property substitutes that are used in UCP mode must
be in the order of the POSIX class names, defined above. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>posix_substitutes</name><index>[]</index></name> <init>= <expr><block>{
  <expr><name>PT_GC</name></expr>, <expr><name>ucp_L</name></expr>,     <comment type="block">/* alpha */</comment>
  <expr><name>PT_PC</name></expr>, <expr><name>ucp_Ll</name></expr>,    <comment type="block">/* lower */</comment>
  <expr><name>PT_PC</name></expr>, <expr><name>ucp_Lu</name></expr>,    <comment type="block">/* upper */</comment>
  <expr><name>PT_ALNUM</name></expr>, <expr><literal type="number">0</literal></expr>,      <comment type="block">/* alnum */</comment>
  <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,            <comment type="block">/* ascii, treat as non-UCP */</comment>
  <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>,            <comment type="block">/* blank, treat as \h */</comment>
  <expr><name>PT_PC</name></expr>, <expr><name>ucp_Cc</name></expr>,    <comment type="block">/* cntrl */</comment>
  <expr><name>PT_PC</name></expr>, <expr><name>ucp_Nd</name></expr>,    <comment type="block">/* digit */</comment>
  <expr><name>PT_PXGRAPH</name></expr>, <expr><literal type="number">0</literal></expr>,    <comment type="block">/* graph */</comment>
  <expr><name>PT_PXPRINT</name></expr>, <expr><literal type="number">0</literal></expr>,    <comment type="block">/* print */</comment>
  <expr><name>PT_PXPUNCT</name></expr>, <expr><literal type="number">0</literal></expr>,    <comment type="block">/* punct */</comment>
  <expr><name>PT_PXSPACE</name></expr>, <expr><literal type="number">0</literal></expr>,    <comment type="block">/* space */</comment>   <comment type="block">/* Xps is POSIX space, but from 8.34 */</comment>
  <expr><name>PT_WORD</name></expr>, <expr><literal type="number">0</literal></expr>,       <comment type="block">/* word  */</comment>   <comment type="block">/* Perl and POSIX space are the same */</comment>
  <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>             <comment type="block">/* xdigit, treat as non-UCP */</comment>
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POSIX_SUBSIZE</name></cpp:macro> <cpp:value>(sizeof(posix_substitutes) / (2*sizeof(uint32_t)))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

<comment type="block">/* Masks for checking option settings. When PCRE2_LITERAL is set, only a subset
are allowed. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUBLIC_LITERAL_COMPILE_OPTIONS</name></cpp:macro> \
  <cpp:value>(PCRE2_ANCHORED|PCRE2_AUTO_CALLOUT|PCRE2_CASELESS|PCRE2_ENDANCHORED| \
   PCRE2_FIRSTLINE|PCRE2_LITERAL|PCRE2_MATCH_INVALID_UTF| \
   PCRE2_NO_START_OPTIMIZE|PCRE2_NO_UTF_CHECK|PCRE2_USE_OFFSET_LIMIT|PCRE2_UTF)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUBLIC_COMPILE_OPTIONS</name></cpp:macro> \
  <cpp:value>(PUBLIC_LITERAL_COMPILE_OPTIONS| \
   PCRE2_ALLOW_EMPTY_CLASS|PCRE2_ALT_BSUX|PCRE2_ALT_CIRCUMFLEX| \
   PCRE2_ALT_VERBNAMES|PCRE2_DOLLAR_ENDONLY|PCRE2_DOTALL|PCRE2_DUPNAMES| \
   PCRE2_EXTENDED|PCRE2_EXTENDED_MORE|PCRE2_MATCH_UNSET_BACKREF| \
   PCRE2_MULTILINE|PCRE2_NEVER_BACKSLASH_C|PCRE2_NEVER_UCP| \
   PCRE2_NEVER_UTF|PCRE2_NO_AUTO_CAPTURE|PCRE2_NO_AUTO_POSSESS| \
   PCRE2_NO_DOTSTAR_ANCHOR|PCRE2_UCP|PCRE2_UNGREEDY)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUBLIC_LITERAL_COMPILE_EXTRA_OPTIONS</name></cpp:macro> \
   <cpp:value>(PCRE2_EXTRA_MATCH_LINE|PCRE2_EXTRA_MATCH_WORD)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUBLIC_COMPILE_EXTRA_OPTIONS</name></cpp:macro> \
   <cpp:value>(PUBLIC_LITERAL_COMPILE_EXTRA_OPTIONS| \
    PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES|PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL| \
    PCRE2_EXTRA_ESCAPED_CR_IS_LF|PCRE2_EXTRA_ALT_BSUX)</cpp:value></cpp:define>

<comment type="block">/* Compile time error code numbers. They are given names so that they can more
easily be tracked. When a new number is added, the tables called eint1 and
eint2 in pcre2posix.c may need to be updated, and a new error text must be
added to compile_error_texts in pcre2_error.c. */</comment>

<enum>enum <block>{ <decl><name>ERR0</name> <init>= <expr><name>COMPILE_ERROR_BASE</name></expr></init></decl>,
       <decl><name>ERR1</name></decl>,  <decl><name>ERR2</name></decl>,  <decl><name>ERR3</name></decl>,  <decl><name>ERR4</name></decl>,  <decl><name>ERR5</name></decl>,  <decl><name>ERR6</name></decl>,  <decl><name>ERR7</name></decl>,  <decl><name>ERR8</name></decl>,  <decl><name>ERR9</name></decl>,  <decl><name>ERR10</name></decl>,
       <decl><name>ERR11</name></decl>, <decl><name>ERR12</name></decl>, <decl><name>ERR13</name></decl>, <decl><name>ERR14</name></decl>, <decl><name>ERR15</name></decl>, <decl><name>ERR16</name></decl>, <decl><name>ERR17</name></decl>, <decl><name>ERR18</name></decl>, <decl><name>ERR19</name></decl>, <decl><name>ERR20</name></decl>,
       <decl><name>ERR21</name></decl>, <decl><name>ERR22</name></decl>, <decl><name>ERR23</name></decl>, <decl><name>ERR24</name></decl>, <decl><name>ERR25</name></decl>, <decl><name>ERR26</name></decl>, <decl><name>ERR27</name></decl>, <decl><name>ERR28</name></decl>, <decl><name>ERR29</name></decl>, <decl><name>ERR30</name></decl>,
       <decl><name>ERR31</name></decl>, <decl><name>ERR32</name></decl>, <decl><name>ERR33</name></decl>, <decl><name>ERR34</name></decl>, <decl><name>ERR35</name></decl>, <decl><name>ERR36</name></decl>, <decl><name>ERR37</name></decl>, <decl><name>ERR38</name></decl>, <decl><name>ERR39</name></decl>, <decl><name>ERR40</name></decl>,
       <decl><name>ERR41</name></decl>, <decl><name>ERR42</name></decl>, <decl><name>ERR43</name></decl>, <decl><name>ERR44</name></decl>, <decl><name>ERR45</name></decl>, <decl><name>ERR46</name></decl>, <decl><name>ERR47</name></decl>, <decl><name>ERR48</name></decl>, <decl><name>ERR49</name></decl>, <decl><name>ERR50</name></decl>,
       <decl><name>ERR51</name></decl>, <decl><name>ERR52</name></decl>, <decl><name>ERR53</name></decl>, <decl><name>ERR54</name></decl>, <decl><name>ERR55</name></decl>, <decl><name>ERR56</name></decl>, <decl><name>ERR57</name></decl>, <decl><name>ERR58</name></decl>, <decl><name>ERR59</name></decl>, <decl><name>ERR60</name></decl>,
       <decl><name>ERR61</name></decl>, <decl><name>ERR62</name></decl>, <decl><name>ERR63</name></decl>, <decl><name>ERR64</name></decl>, <decl><name>ERR65</name></decl>, <decl><name>ERR66</name></decl>, <decl><name>ERR67</name></decl>, <decl><name>ERR68</name></decl>, <decl><name>ERR69</name></decl>, <decl><name>ERR70</name></decl>,
       <decl><name>ERR71</name></decl>, <decl><name>ERR72</name></decl>, <decl><name>ERR73</name></decl>, <decl><name>ERR74</name></decl>, <decl><name>ERR75</name></decl>, <decl><name>ERR76</name></decl>, <decl><name>ERR77</name></decl>, <decl><name>ERR78</name></decl>, <decl><name>ERR79</name></decl>, <decl><name>ERR80</name></decl>,
       <decl><name>ERR81</name></decl>, <decl><name>ERR82</name></decl>, <decl><name>ERR83</name></decl>, <decl><name>ERR84</name></decl>, <decl><name>ERR85</name></decl>, <decl><name>ERR86</name></decl>, <decl><name>ERR87</name></decl>, <decl><name>ERR88</name></decl>, <decl><name>ERR89</name></decl>, <decl><name>ERR90</name></decl>,
       <decl><name>ERR91</name></decl>, <decl><name>ERR92</name></decl>, <decl><name>ERR93</name></decl>, <decl><name>ERR94</name></decl>, <decl><name>ERR95</name></decl>, <decl><name>ERR96</name></decl>, <decl><name>ERR97</name></decl>, <decl><name>ERR98</name></decl> }</block>;</enum>

<comment type="block">/* This is a table of start-of-pattern options such as (*UTF) and settings such
as (*LIMIT_MATCH=nnnn) and (*CRLF). For completeness and backward
compatibility, (*UTFn) is supported in the relevant libraries, but (*UTF) is
generic and always supported. */</comment>

<enum>enum <block>{ <decl><name>PSO_OPT</name></decl>,     <comment type="block">/* Value is an option bit */</comment>
       <decl><name>PSO_FLG</name></decl>,     <comment type="block">/* Value is a flag bit */</comment>
       <decl><name>PSO_NL</name></decl>,      <comment type="block">/* Value is a newline type */</comment>
       <decl><name>PSO_BSR</name></decl>,     <comment type="block">/* Value is a \R type */</comment>
       <decl><name>PSO_LIMH</name></decl>,    <comment type="block">/* Read integer value for heap limit */</comment>
       <decl><name>PSO_LIMM</name></decl>,    <comment type="block">/* Read integer value for match limit */</comment>
       <decl><name>PSO_LIMD</name></decl> }</block>;</enum>  <comment type="block">/* Read integer value for depth limit */</comment>

<typedef>typedef <type><struct>struct <name>pso</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>length</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>value</name></decl>;</decl_stmt>
}</block></struct></type> <name>pso</name>;</typedef>

<comment type="block">/* NB: STRING_UTFn_RIGHTPAR contains the length as well */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>pso</name></type> <name><name>pso_list</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{ <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>STRING_UTFn_RIGHTPAR</name></expr>,                  <expr><name>PSO_OPT</name></expr>, <expr><name>PCRE2_UTF</name></expr> }</block></expr>,
  <expr><block>{ <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>STRING_UTF_RIGHTPAR</name></expr>,                <expr><literal type="number">4</literal></expr>, <expr><name>PSO_OPT</name></expr>, <expr><name>PCRE2_UTF</name></expr> }</block></expr>,
  <expr><block>{ <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>STRING_UCP_RIGHTPAR</name></expr>,                <expr><literal type="number">4</literal></expr>, <expr><name>PSO_OPT</name></expr>, <expr><name>PCRE2_UCP</name></expr> }</block></expr>,
  <expr><block>{ <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>STRING_NOTEMPTY_RIGHTPAR</name></expr>,           <expr><literal type="number">9</literal></expr>, <expr><name>PSO_FLG</name></expr>, <expr><name>PCRE2_NOTEMPTY_SET</name></expr> }</block></expr>,
  <expr><block>{ <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>STRING_NOTEMPTY_ATSTART_RIGHTPAR</name></expr>,  <expr><literal type="number">17</literal></expr>, <expr><name>PSO_FLG</name></expr>, <expr><name>PCRE2_NE_ATST_SET</name></expr> }</block></expr>,
  <expr><block>{ <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>STRING_NO_AUTO_POSSESS_RIGHTPAR</name></expr>,   <expr><literal type="number">16</literal></expr>, <expr><name>PSO_OPT</name></expr>, <expr><name>PCRE2_NO_AUTO_POSSESS</name></expr> }</block></expr>,
  <expr><block>{ <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>STRING_NO_DOTSTAR_ANCHOR_RIGHTPAR</name></expr>, <expr><literal type="number">18</literal></expr>, <expr><name>PSO_OPT</name></expr>, <expr><name>PCRE2_NO_DOTSTAR_ANCHOR</name></expr> }</block></expr>,
  <expr><block>{ <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>STRING_NO_JIT_RIGHTPAR</name></expr>,             <expr><literal type="number">7</literal></expr>, <expr><name>PSO_FLG</name></expr>, <expr><name>PCRE2_NOJIT</name></expr> }</block></expr>,
  <expr><block>{ <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>STRING_NO_START_OPT_RIGHTPAR</name></expr>,      <expr><literal type="number">13</literal></expr>, <expr><name>PSO_OPT</name></expr>, <expr><name>PCRE2_NO_START_OPTIMIZE</name></expr> }</block></expr>,
  <expr><block>{ <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>STRING_LIMIT_HEAP_EQ</name></expr>,              <expr><literal type="number">11</literal></expr>, <expr><name>PSO_LIMH</name></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{ <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>STRING_LIMIT_MATCH_EQ</name></expr>,             <expr><literal type="number">12</literal></expr>, <expr><name>PSO_LIMM</name></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{ <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>STRING_LIMIT_DEPTH_EQ</name></expr>,             <expr><literal type="number">12</literal></expr>, <expr><name>PSO_LIMD</name></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{ <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>STRING_LIMIT_RECURSION_EQ</name></expr>,         <expr><literal type="number">16</literal></expr>, <expr><name>PSO_LIMD</name></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
  <expr><block>{ <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>STRING_CR_RIGHTPAR</name></expr>,                 <expr><literal type="number">3</literal></expr>, <expr><name>PSO_NL</name></expr>,  <expr><name>PCRE2_NEWLINE_CR</name></expr> }</block></expr>,
  <expr><block>{ <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>STRING_LF_RIGHTPAR</name></expr>,                 <expr><literal type="number">3</literal></expr>, <expr><name>PSO_NL</name></expr>,  <expr><name>PCRE2_NEWLINE_LF</name></expr> }</block></expr>,
  <expr><block>{ <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>STRING_CRLF_RIGHTPAR</name></expr>,               <expr><literal type="number">5</literal></expr>, <expr><name>PSO_NL</name></expr>,  <expr><name>PCRE2_NEWLINE_CRLF</name></expr> }</block></expr>,
  <expr><block>{ <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>STRING_ANY_RIGHTPAR</name></expr>,                <expr><literal type="number">4</literal></expr>, <expr><name>PSO_NL</name></expr>,  <expr><name>PCRE2_NEWLINE_ANY</name></expr> }</block></expr>,
  <expr><block>{ <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>STRING_NUL_RIGHTPAR</name></expr>,                <expr><literal type="number">4</literal></expr>, <expr><name>PSO_NL</name></expr>,  <expr><name>PCRE2_NEWLINE_NUL</name></expr> }</block></expr>,
  <expr><block>{ <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>STRING_ANYCRLF_RIGHTPAR</name></expr>,            <expr><literal type="number">8</literal></expr>, <expr><name>PSO_NL</name></expr>,  <expr><name>PCRE2_NEWLINE_ANYCRLF</name></expr> }</block></expr>,
  <expr><block>{ <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>STRING_BSR_ANYCRLF_RIGHTPAR</name></expr>,       <expr><literal type="number">12</literal></expr>, <expr><name>PSO_BSR</name></expr>, <expr><name>PCRE2_BSR_ANYCRLF</name></expr> }</block></expr>,
  <expr><block>{ <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>STRING_BSR_UNICODE_RIGHTPAR</name></expr>,       <expr><literal type="number">12</literal></expr>, <expr><name>PSO_BSR</name></expr>, <expr><name>PCRE2_BSR_UNICODE</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* This table is used when converting repeating opcodes into possessified
versions as a result of an explicit possessive quantifier such as ++. A zero
value means there is no possessified version - in those cases the item in
question must be wrapped in ONCE brackets. The table is truncated at OP_CALLOUT
because all relevant opcodes are less than that. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name></type> <name><name>opcode_possessify</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,   <comment type="block">/* 0 - 15  */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,   <comment type="block">/* 16 - 31 */</comment>

  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* NOTI */</comment>
  <expr><name>OP_POSSTAR</name></expr>, <expr><literal type="number">0</literal></expr>,           <comment type="block">/* STAR, MINSTAR */</comment>
  <expr><name>OP_POSPLUS</name></expr>, <expr><literal type="number">0</literal></expr>,           <comment type="block">/* PLUS, MINPLUS */</comment>
  <expr><name>OP_POSQUERY</name></expr>, <expr><literal type="number">0</literal></expr>,          <comment type="block">/* QUERY, MINQUERY */</comment>
  <expr><name>OP_POSUPTO</name></expr>, <expr><literal type="number">0</literal></expr>,           <comment type="block">/* UPTO, MINUPTO */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* EXACT */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,              <comment type="block">/* POS{STAR,PLUS,QUERY,UPTO} */</comment>

  <expr><name>OP_POSSTARI</name></expr>, <expr><literal type="number">0</literal></expr>,          <comment type="block">/* STARI, MINSTARI */</comment>
  <expr><name>OP_POSPLUSI</name></expr>, <expr><literal type="number">0</literal></expr>,          <comment type="block">/* PLUSI, MINPLUSI */</comment>
  <expr><name>OP_POSQUERYI</name></expr>, <expr><literal type="number">0</literal></expr>,         <comment type="block">/* QUERYI, MINQUERYI */</comment>
  <expr><name>OP_POSUPTOI</name></expr>, <expr><literal type="number">0</literal></expr>,          <comment type="block">/* UPTOI, MINUPTOI */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* EXACTI */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,              <comment type="block">/* POS{STARI,PLUSI,QUERYI,UPTOI} */</comment>

  <expr><name>OP_NOTPOSSTAR</name></expr>, <expr><literal type="number">0</literal></expr>,        <comment type="block">/* NOTSTAR, NOTMINSTAR */</comment>
  <expr><name>OP_NOTPOSPLUS</name></expr>, <expr><literal type="number">0</literal></expr>,        <comment type="block">/* NOTPLUS, NOTMINPLUS */</comment>
  <expr><name>OP_NOTPOSQUERY</name></expr>, <expr><literal type="number">0</literal></expr>,       <comment type="block">/* NOTQUERY, NOTMINQUERY */</comment>
  <expr><name>OP_NOTPOSUPTO</name></expr>, <expr><literal type="number">0</literal></expr>,        <comment type="block">/* NOTUPTO, NOTMINUPTO */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* NOTEXACT */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,              <comment type="block">/* NOTPOS{STAR,PLUS,QUERY,UPTO} */</comment>

  <expr><name>OP_NOTPOSSTARI</name></expr>, <expr><literal type="number">0</literal></expr>,       <comment type="block">/* NOTSTARI, NOTMINSTARI */</comment>
  <expr><name>OP_NOTPOSPLUSI</name></expr>, <expr><literal type="number">0</literal></expr>,       <comment type="block">/* NOTPLUSI, NOTMINPLUSI */</comment>
  <expr><name>OP_NOTPOSQUERYI</name></expr>, <expr><literal type="number">0</literal></expr>,      <comment type="block">/* NOTQUERYI, NOTMINQUERYI */</comment>
  <expr><name>OP_NOTPOSUPTOI</name></expr>, <expr><literal type="number">0</literal></expr>,       <comment type="block">/* NOTUPTOI, NOTMINUPTOI */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* NOTEXACTI */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,              <comment type="block">/* NOTPOS{STARI,PLUSI,QUERYI,UPTOI} */</comment>

  <expr><name>OP_TYPEPOSSTAR</name></expr>, <expr><literal type="number">0</literal></expr>,       <comment type="block">/* TYPESTAR, TYPEMINSTAR */</comment>
  <expr><name>OP_TYPEPOSPLUS</name></expr>, <expr><literal type="number">0</literal></expr>,       <comment type="block">/* TYPEPLUS, TYPEMINPLUS */</comment>
  <expr><name>OP_TYPEPOSQUERY</name></expr>, <expr><literal type="number">0</literal></expr>,      <comment type="block">/* TYPEQUERY, TYPEMINQUERY */</comment>
  <expr><name>OP_TYPEPOSUPTO</name></expr>, <expr><literal type="number">0</literal></expr>,       <comment type="block">/* TYPEUPTO, TYPEMINUPTO */</comment>
  <expr><literal type="number">0</literal></expr>,                       <comment type="block">/* TYPEEXACT */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,              <comment type="block">/* TYPEPOS{STAR,PLUS,QUERY,UPTO} */</comment>

  <expr><name>OP_CRPOSSTAR</name></expr>, <expr><literal type="number">0</literal></expr>,         <comment type="block">/* CRSTAR, CRMINSTAR */</comment>
  <expr><name>OP_CRPOSPLUS</name></expr>, <expr><literal type="number">0</literal></expr>,         <comment type="block">/* CRPLUS, CRMINPLUS */</comment>
  <expr><name>OP_CRPOSQUERY</name></expr>, <expr><literal type="number">0</literal></expr>,        <comment type="block">/* CRQUERY, CRMINQUERY */</comment>
  <expr><name>OP_CRPOSRANGE</name></expr>, <expr><literal type="number">0</literal></expr>,        <comment type="block">/* CRRANGE, CRMINRANGE */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,              <comment type="block">/* CRPOS{STAR,PLUS,QUERY,RANGE} */</comment>

  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                 <comment type="block">/* CLASS, NCLASS, XCLASS */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                    <comment type="block">/* REF, REFI */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,                    <comment type="block">/* DNREF, DNREFI */</comment>
  <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>                     <comment type="block">/* RECURSE, CALLOUT */</comment>
}</block></expr></init></decl>;</decl_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_SHOW_PARSED</name></cpp:ifdef>
<comment type="block" format="doxygen">/*************************************************
*     Show the parsed pattern for debugging      *
*************************************************/</comment>

<comment type="block">/* For debugging the pre-scan, this code, which outputs the parsed data vector,
can be enabled. */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>show_parsed</name><parameter_list>(<parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pptr</name> <init>= <expr><name><name>cb</name><operator>-&gt;</operator><name>parsed_pattern</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>max</name></decl>, <decl><type ref="prev"/><name>min</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>offset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>length</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>meta_arg</name> <init>= <expr><call><name>META_DATA</name><argument_list>(<argument><expr><operator>*</operator><name>pptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"+++ %02d %.8x "</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pptr</name> <operator>-</operator> <name><name>cb</name><operator>-&gt;</operator><name>parsed_pattern</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>*</operator><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pptr</name> <operator>&lt;</operator> <name>META_END</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pptr</name> <operator>&gt;</operator> <literal type="number">32</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>pptr</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><operator>*</operator><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>pptr</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if>

  <else>else<block type="pseudo"><block_content> <switch>switch <condition>(<expr><call><name>META_CODE</name><argument_list>(<argument><expr><operator>*</operator><name>pptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    <default>default:</default>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"**** OOPS - unknown META value - giving up ****\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>

    <case>case <expr><name>META_END</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META_END\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>

    <case>case <expr><name>META_CAPTURE</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META_CAPTURE %d"</literal></expr></argument>, <argument><expr><name>meta_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_RECURSE</name></expr>:</case>
    <expr_stmt><expr><call><name>GETOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META_RECURSE %d %zd"</literal></expr></argument>, <argument><expr><name>meta_arg</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_BACKREF</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>meta_arg</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>cb</name><operator>-&gt;</operator><name>small_ref_offset</name><index>[<expr><name>meta_arg</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>GETOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META_BACKREF %d %zd"</literal></expr></argument>, <argument><expr><name>meta_arg</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_ESCAPE</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>meta_arg</name> <operator>==</operator> <name>ESC_P</name> <operator>||</operator> <name>meta_arg</name> <operator>==</operator> <name>ESC_p</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>ptype</name> <init>= <expr><operator>*</operator><name>pptr</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>pvalue</name> <init>= <expr><operator>*</operator><name>pptr</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META \\%c %d %d"</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>meta_arg</name> <operator>==</operator> <name>ESC_P</name><operator>)</operator></expr>?</condition><then> <expr><literal type="char">'P'</literal></expr></then><else>:<expr><literal type="char">'p'</literal></expr></else></ternary></expr></argument>,
        <argument><expr><name>ptype</name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>cc</name></decl>;</decl_stmt>
      <comment type="block">/* There's just one escape we might have here that isn't negated in the
      escapes table. */</comment>
      <if_stmt><if>if <condition>(<expr><name>meta_arg</name> <operator>==</operator> <name>ESC_g</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>=</operator> <name>CHAR_g</name></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content> <for>for <control>(<init><expr><name>cc</name> <operator>=</operator> <name>ESCAPES_FIRST</name></expr>;</init> <condition><expr><name>cc</name> <operator>&lt;=</operator> <name>ESCAPES_LAST</name></expr>;</condition> <incr><expr><name>cc</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>meta_arg</name> <operator>==</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><operator>-</operator><name><name>escapes</name><index>[<expr><name>cc</name> <operator>-</operator> <name>ESCAPES_FIRST</name></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for></block_content></block></else></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&gt;</operator> <name>ESCAPES_LAST</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cc</name> <operator>=</operator> <name>CHAR_QUESTION_MARK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META \\%c"</literal></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <break>break;</break>

    <case>case <expr><name>META_MINMAX</name></expr>:</case>
    <expr_stmt><expr><name>min</name> <operator>=</operator> <operator>*</operator><name>pptr</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>max</name> <operator>=</operator> <operator>*</operator><name>pptr</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>max</name> <operator>!=</operator> <name>REPEAT_UNLIMITED</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META {%d,%d}"</literal></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META {%d,}"</literal></expr></argument>, <argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <break>break;</break>

    <case>case <expr><name>META_MINMAX_QUERY</name></expr>:</case>
    <expr_stmt><expr><name>min</name> <operator>=</operator> <operator>*</operator><name>pptr</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>max</name> <operator>=</operator> <operator>*</operator><name>pptr</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>max</name> <operator>!=</operator> <name>REPEAT_UNLIMITED</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META {%d,%d}?"</literal></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META {%d,}?"</literal></expr></argument>, <argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <break>break;</break>

    <case>case <expr><name>META_MINMAX_PLUS</name></expr>:</case>
    <expr_stmt><expr><name>min</name> <operator>=</operator> <operator>*</operator><name>pptr</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>max</name> <operator>=</operator> <operator>*</operator><name>pptr</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>max</name> <operator>!=</operator> <name>REPEAT_UNLIMITED</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META {%d,%d}+"</literal></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META {%d,}+"</literal></expr></argument>, <argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <break>break;</break>

    <case>case <expr><name>META_BIGVALUE</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META_BIGVALUE %.8x"</literal></expr></argument>, <argument><expr><operator>*</operator><name>pptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_CIRCUMFLEX</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META_CIRCUMFLEX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_COND_ASSERT</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META_COND_ASSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_DOLLAR</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META_DOLLAR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_DOT</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META_DOT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_ASTERISK</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META *"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_ASTERISK_QUERY</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META *?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_ASTERISK_PLUS</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META *+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_PLUS</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META +"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_PLUS_QUERY</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META +?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_PLUS_PLUS</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META ++"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_QUERY</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META ?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_QUERY_QUERY</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META ??"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_QUERY_PLUS</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META ?+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

    <case>case <expr><name>META_ATOMIC</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (?&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_NOCAPTURE</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (?:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_LOOKAHEAD</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (?="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_LOOKAHEADNOT</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (?!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_LOOKAHEAD_NA</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (*napla:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_SCRIPT_RUN</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (*sr:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_KET</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META )"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_ALT</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META | %d"</literal></expr></argument>, <argument><expr><name>meta_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

    <case>case <expr><name>META_CLASS</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META ["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_CLASS_NOT</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META [^"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_CLASS_END</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META ]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_CLASS_EMPTY</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META []"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_CLASS_EMPTY_NOT</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META [^]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

    <case>case <expr><name>META_RANGE_LITERAL</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META - (literal)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_RANGE_ESCAPED</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META - (escaped)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

    <case>case <expr><name>META_POSIX</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META_POSIX %d"</literal></expr></argument>, <argument><expr><operator>*</operator><name>pptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_POSIX_NEG</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META_POSIX_NEG %d"</literal></expr></argument>, <argument><expr><operator>*</operator><name>pptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

    <case>case <expr><name>META_ACCEPT</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (*ACCEPT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_FAIL</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (*FAIL)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_COMMIT</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (*COMMIT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_PRUNE</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (*PRUNE)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_SKIP</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (*SKIP)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><name>META_THEN</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (*THEN)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

    <case>case <expr><name>META_OPTIONS</name></expr>:</case> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META_OPTIONS 0x%02x"</literal></expr></argument>, <argument><expr><operator>*</operator><name>pptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

    <case>case <expr><name>META_LOOKBEHIND</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (?&lt;= %d offset="</literal></expr></argument>, <argument><expr><name>meta_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GETOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%zd"</literal></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_LOOKBEHIND_NA</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (*naplb: %d offset="</literal></expr></argument>, <argument><expr><name>meta_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GETOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%zd"</literal></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_LOOKBEHINDNOT</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (?&lt;! %d offset="</literal></expr></argument>, <argument><expr><name>meta_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GETOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%zd"</literal></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_CALLOUT_NUMBER</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (?C%d) next=%d/%d"</literal></expr></argument>, <argument><expr><name><name>pptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>pptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
       <argument><expr><name><name>pptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_CALLOUT_STRING</name></expr>:</case>
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>patoffset</name> <init>= <expr><operator>*</operator><name>pptr</name><operator>++</operator></expr></init></decl>;</decl_stmt>    <comment type="block">/* Offset of next pattern item */</comment>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>patlength</name> <init>= <expr><operator>*</operator><name>pptr</name><operator>++</operator></expr></init></decl>;</decl_stmt>    <comment type="block">/* Length of next pattern item */</comment>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (?Cstring) length=%d offset="</literal></expr></argument>, <argument><expr><operator>*</operator><name>pptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%zd next=%d/%d"</literal></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>patoffset</name></expr></argument>, <argument><expr><name>patlength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block>
    <break>break;</break>

    <case>case <expr><name>META_RECURSE_BYNAME</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (?(&amp;name) length=%d offset="</literal></expr></argument>, <argument><expr><operator>*</operator><name>pptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GETOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%zd"</literal></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_BACKREF_BYNAME</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META_BACKREF_BYNAME length=%d offset="</literal></expr></argument>, <argument><expr><operator>*</operator><name>pptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GETOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%zd"</literal></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_COND_NUMBER</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META_COND_NUMBER %d offset="</literal></expr></argument>, <argument><expr><name><name>pptr</name><index>[<expr><name>SIZEOFFSET</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GETOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%zd"</literal></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pptr</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_COND_DEFINE</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (?(DEFINE) offset="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GETOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%zd"</literal></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_COND_VERSION</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (?(VERSION%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>pptr</name><operator>++</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">"="</literal></expr> </then><else>: <expr><literal type="string">"&gt;="</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%d."</literal></expr></argument>, <argument><expr><operator>*</operator><name>pptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%d)"</literal></expr></argument>, <argument><expr><operator>*</operator><name>pptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_COND_NAME</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (?(&lt;name&gt;) length=%d offset="</literal></expr></argument>, <argument><expr><operator>*</operator><name>pptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GETOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%zd"</literal></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_COND_RNAME</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (?(R&amp;name) length=%d offset="</literal></expr></argument>, <argument><expr><operator>*</operator><name>pptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GETOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%zd"</literal></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* This is kept as a name, because it might be. */</comment>

    <case>case <expr><name>META_COND_RNUMBER</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (?(Rnumber) length=%d offset="</literal></expr></argument>, <argument><expr><operator>*</operator><name>pptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GETOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%zd"</literal></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_MARK</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (*MARK:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>SHOWARG</name>;</goto>

    <case>case <expr><name>META_COMMIT_ARG</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (*COMMIT:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>SHOWARG</name>;</goto>

    <case>case <expr><name>META_PRUNE_ARG</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (*PRUNE:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>SHOWARG</name>;</goto>

    <case>case <expr><name>META_SKIP_ARG</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (*SKIP:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>SHOWARG</name>;</goto>

    <case>case <expr><name>META_THEN_ARG</name></expr>:</case>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"META (*THEN:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <label><name>SHOWARG</name>:</label>
    <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>*</operator><name>pptr</name><operator>++</operator></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>cc</name> <init>= <expr><operator>*</operator><name>pptr</name><operator>++</operator></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>cc</name> <operator>&gt;</operator> <literal type="number">32</literal> <operator>&amp;&amp;</operator> <name>cc</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\\x{%x}"</literal></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></for>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">") length=%u"</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></switch></block_content></block></else></if_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
<return>return;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* DEBUG_SHOW_PARSED */</comment>



<comment type="block" format="doxygen">/*************************************************
*               Copy compiled code               *
*************************************************/</comment>

<comment type="block">/* Compiled JIT code cannot be copied, so the new compiled block has no
associated JIT data. */</comment>

<function><type><name>PCRE2_EXP_DEFN</name> <name>pcre2_code</name> <modifier>*</modifier> <name>PCRE2_CALL_CONVENTION</name></type>
<name>pcre2_code_copy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pcre2_code</name> <modifier>*</modifier></type><name>code</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_SIZE</name><modifier>*</modifier></type> <name>ref_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pcre2_code</name> <modifier>*</modifier></type><name>newcode</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>code</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>newcode</name> <operator>=</operator> <call><name><name>code</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>malloc</name></name><argument_list>(<argument><expr><name><name>code</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>, <argument><expr><name><name>code</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>newcode</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newcode</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name><name>code</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newcode</name><operator>-&gt;</operator><name>executable_jit</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<comment type="block">/* If the code is one that has been deserialized, increment the reference count
in the decoded tables. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>code</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_DEREF_TABLES</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>ref_count</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>code</name><operator>-&gt;</operator><name>tables</name></name> <operator>+</operator> <name>TABLES_LENGTH</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><operator>*</operator><name>ref_count</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<return>return <expr><name>newcode</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*     Copy compiled code and character tables    *
*************************************************/</comment>

<comment type="block">/* Compiled JIT code cannot be copied, so the new compiled block has no
associated JIT data. This version of code_copy also makes a separate copy of
the character tables. */</comment>

<function><type><name>PCRE2_EXP_DEFN</name> <name>pcre2_code</name> <modifier>*</modifier> <name>PCRE2_CALL_CONVENTION</name></type>
<name>pcre2_code_copy_with_tables</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pcre2_code</name> <modifier>*</modifier></type><name>code</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_SIZE</name><modifier>*</modifier></type> <name>ref_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pcre2_code</name> <modifier>*</modifier></type><name>newcode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>newtables</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>code</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>newcode</name> <operator>=</operator> <call><name><name>code</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>malloc</name></name><argument_list>(<argument><expr><name><name>code</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>, <argument><expr><name><name>code</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>newcode</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newcode</name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><name><name>code</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newcode</name><operator>-&gt;</operator><name>executable_jit</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>newtables</name> <operator>=</operator> <call><name><name>code</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>malloc</name></name><argument_list>(<argument><expr><name>TABLES_LENGTH</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_SIZE</name></expr></argument>)</argument_list></sizeof></expr></argument>,
  <argument><expr><name><name>code</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>newtables</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name><name>code</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>free</name></name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>newcode</name></expr></argument>, <argument><expr><name><name>code</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newtables</name></expr></argument>, <argument><expr><name><name>code</name><operator>-&gt;</operator><name>tables</name></name></expr></argument>, <argument><expr><name>TABLES_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ref_count</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>newtables</name> <operator>+</operator> <name>TABLES_LENGTH</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ref_count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>newcode</name><operator>-&gt;</operator><name>tables</name></name> <operator>=</operator> <name>newtables</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newcode</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PCRE2_DEREF_TABLES</name></expr>;</expr_stmt>
<return>return <expr><name>newcode</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*               Free compiled code               *
*************************************************/</comment>

<function><type><name>PCRE2_EXP_DEFN</name> <name>void</name> <name>PCRE2_CALL_CONVENTION</name></type>
<name>pcre2_code_free</name><parameter_list>(<parameter><decl><type><name>pcre2_code</name> <modifier>*</modifier></type><name>code</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_SIZE</name><modifier>*</modifier></type> <name>ref_count</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>code</name><operator>-&gt;</operator><name>executable_jit</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><call><name>PRIV</name><argument_list>(<argument><expr><name>jit_free</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name><name>code</name><operator>-&gt;</operator><name>executable_jit</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>code</name><operator>-&gt;</operator><name>memctl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>code</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_DEREF_TABLES</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* Decoded tables belong to the codes after deserialization, and they must
    be freed when there are no more references to them. The *ref_count should
    always be &gt; 0. */</comment>

    <expr_stmt><expr><name>ref_count</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>code</name><operator>-&gt;</operator><name>tables</name></name> <operator>+</operator> <name>TABLES_LENGTH</name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ref_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>(</operator><operator>*</operator><name>ref_count</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ref_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>code</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>free</name></name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>code</name><operator>-&gt;</operator><name>tables</name></name></expr></argument>, <argument><expr><name><name>code</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name><name>code</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>free</name></name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name><name>code</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*         Read a number, possibly signed         *
*************************************************/</comment>

<comment type="block">/* This function is used to read numbers in the pattern. The initial pointer
must be the sign or first digit of the number. When relative values (introduced
by + or -) are allowed, they are relative group numbers, and the result must be
greater than zero.

Arguments:
  ptrptr      points to the character pointer variable
  ptrend      points to the end of the input string
  allow_sign  if &lt; 0, sign not allowed; if &gt;= 0, sign is relative to this
  max_value   the largest number allowed
  max_error   the error to give for an over-large number
  intptr      where to put the result
  errcodeptr  where to put an error code

Returns:      TRUE  - a number was read
              FALSE - errorcode == 0 =&gt; no number was found
                      errorcode != 0 =&gt; an error occurred
*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>read_number</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name> <modifier>*</modifier></type><name>ptrptr</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ptrend</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>allow_sign</name></decl></parameter>,
  <parameter><decl><type><name>uint32_t</name></type> <name>max_value</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>max_error</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>intptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>errorcodeptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sign</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ptr</name> <init>= <expr><operator>*</operator><name>ptrptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>yield</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>allow_sign</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>&lt;</operator> <name>ptrend</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_PLUS</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>max_value</name> <operator>-=</operator> <name>allow_sign</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_MINUS</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>sign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name> <operator>||</operator> <operator>!</operator><call><name>IS_DIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator> <call><name>IS_DIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name>n</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>*</operator><name>ptr</name><operator>++</operator> <operator>-</operator> <name>CHAR_0</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name>max_value</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>max_error</name></expr>;</expr_stmt>
    <goto>goto <name>EXIT</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>allow_sign</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>sign</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR26</name></expr>;</expr_stmt>  <comment type="block">/* +0 and -0 are not allowed */</comment>
    <goto>goto <name>EXIT</name>;</goto>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>sign</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>+=</operator> <name>allow_sign</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name>n</name> <operator>&gt;</operator> <name>allow_sign</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR15</name></expr>;</expr_stmt>  <comment type="block">/* Non-existent subpattern */</comment>
    <goto>goto <name>EXIT</name>;</goto>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <name>allow_sign</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>n</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>yield</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<label><name>EXIT</name>:</label>
<expr_stmt><expr><operator>*</operator><name>intptr</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ptrptr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>yield</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*         Read repeat counts                     *
*************************************************/</comment>

<comment type="block">/* Read an item of the form {n,m} and return the values if non-NULL pointers
are supplied. Repeat counts must be less than 65536 (MAX_REPEAT_COUNT); a
larger value is used for "unlimited". We have to use signed arguments for
read_number() because it is capable of returning a signed value.

Arguments:
  ptrptr         points to pointer to character after'{'
  ptrend         pointer to end of input
  minp           if not NULL, pointer to int for min
  maxp           if not NULL, pointer to int for max (-1 if no max)
                 returned as -1 if no max
  errorcodeptr   points to error code variable

Returns:         FALSE if not a repeat quantifier, errorcode set zero
                 FALSE on error, with errorcode set non-zero
                 TRUE on success, with pointer updated to point after '}'
*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>read_repeat_counts</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name> <modifier>*</modifier></type><name>ptrptr</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ptrend</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>minp</name></decl></parameter>,
  <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>maxp</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>errorcodeptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>p</name> <init>= <expr><operator>*</operator><name>ptrptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>yield</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>min</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>max</name> <init>= <expr><name>REPEAT_UNLIMITED</name></expr></init></decl>;</decl_stmt> <comment type="block">/* This value is larger than MAX_REPEAT_COUNT */</comment>

<comment type="block">/* NB read_number() initializes the error code to zero. The only error is for a
number that is too big. */</comment>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>MAX_REPEAT_COUNT</name></expr></argument>, <argument><expr><name>ERR5</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>min</name></expr></argument>, <argument><expr><name>errorcodeptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
  <goto>goto <name>EXIT</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>EXIT</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>CHAR_RIGHT_CURLY_BRACKET</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>max</name> <operator>=</operator> <name>min</name></expr>;</expr_stmt>
  </block_content>}</block></if>

<else>else
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator> <operator>!=</operator> <name>CHAR_COMMA</name> <operator>||</operator> <name>p</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>EXIT</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>CHAR_RIGHT_CURLY_BRACKET</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>MAX_REPEAT_COUNT</name></expr></argument>, <argument><expr><name>ERR5</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max</name></expr></argument>,
        <argument><expr><name>errorcodeptr</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>p</name> <operator>&gt;=</operator> <name>ptrend</name> <operator>||</operator>  <operator>*</operator><name>p</name> <operator>!=</operator> <name>CHAR_RIGHT_CURLY_BRACKET</name></expr>)</condition><block type="pseudo"><block_content>
      <goto>goto <name>EXIT</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>max</name> <operator>&lt;</operator> <name>min</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR4</name></expr>;</expr_stmt>
      <goto>goto <name>EXIT</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>yield</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>minp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>minp</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>min</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>maxp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>maxp</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>max</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* Update the pattern pointer on success, or after an error, but not when
the result is "not a repeat quantifier". */</comment>

<label><name>EXIT</name>:</label>
<if_stmt><if>if <condition>(<expr><name>yield</name> <operator>||</operator> <operator>*</operator><name>errorcodeptr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>ptrptr</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>yield</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*            Handle escapes                      *
*************************************************/</comment>

<comment type="block">/* This function is called when a \ has been encountered. It either returns a
positive value for a simple escape such as \d, or 0 for a data character, which
is placed in chptr. A backreference to group n is returned as negative n. On
entry, ptr is pointing at the character after \. On exit, it points after the
final code unit of the escape sequence.

This function is also called from pcre2_substitute() to handle escape sequences
in replacement strings. In this case, the cb argument is NULL, and in the case
of escapes that have further processing, only sequences that define a data
character are recognised. The isclass argument is not relevant; the options
argument is the final value of the compiled pattern's options.

Arguments:
  ptrptr         points to the input position pointer
  ptrend         points to the end of the input
  chptr          points to a returned data character
  errorcodeptr   points to the errorcode variable (containing zero)
  options        the current options bits
  isclass        TRUE if inside a character class
  cb             compile data block or NULL when called from pcre2_substitute()

Returns:         zero =&gt; a data character
                 positive =&gt; a special escape sequence
                 negative =&gt; a numerical back reference
                 on error, errorcodeptr is set non-zero
*/</comment>

<function><type><name>int</name>
<name>PRIV</name></type>(<name>check_escape</name>)<parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name> <modifier>*</modifier></type><name>ptrptr</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ptrend</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>chptr</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>errorcodeptr</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>extra_options</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>isclass</name></decl></parameter>,
  <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name> <init>= <expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ptr</name> <init>= <expr><operator>*</operator><name>ptrptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>cc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>escape</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<comment type="block">/* If backslash is at the end of the string, it's an error. */</comment>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR1</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>         <comment type="block">/* Get character value, increment pointer */</comment>
<expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>              <comment type="block">/* Be optimistic */</comment>

<comment type="block">/* Non-alphanumerics are literals, so we just leave the value in c. An initial
value test saves a memory lookup for code points outside the alphanumeric
range. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>c</name> <argument_list type="generic">&lt; <argument><expr><name>ESCAPES_FIRST</name> <operator>||</operator> <name>c</name></expr></argument> &gt;</argument_list></name> <name>ESCAPES_LAST</name></expr>)</condition> <block>{<block_content/>}</block></if>  <comment type="block">/* Definitely literal */</comment>

<comment type="block">/* Otherwise, do a table lookup. Non-zero values need little processing here. A
positive value is a literal value for something like \n. A negative value is
the negation of one of the ESC_ macros that is passed back for handling by the
calling function. Some extra checking is needed for \N because only \N{U+dddd}
is supported. If the value is zero, further processing is handled below. */</comment>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <name><name>escapes</name><index>[<expr><name>c</name> <operator>-</operator> <name>ESCAPES_FIRST</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>i</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_CR</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>extra_options</name> <operator>&amp;</operator> <name>PCRE2_EXTRA_ESCAPED_CR_IS_LF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <name>CHAR_LF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else  <comment type="block">/* Negative table entry */</comment>
    <block>{<block_content>
    <expr_stmt><expr><name>escape</name> <operator>=</operator> <operator>-</operator><name>i</name></expr>;</expr_stmt>                    <comment type="block">/* Else return a special escape */</comment>
    <if_stmt><if>if <condition>(<expr><name>cb</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>escape</name> <operator>==</operator> <name>ESC_P</name> <operator>||</operator> <name>escape</name> <operator>==</operator> <name>ESC_p</name> <operator>||</operator> <name>escape</name> <operator>==</operator> <name>ESC_X</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>external_flags</name></name> <operator>|=</operator> <name>PCRE2_HASBKPORX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>   <comment type="block">/* Note \P, \p, or \X */</comment>

    <comment type="block">/* Perl supports \N{name} for character names and \N{U+dddd} for numerical
    Unicode code points, as well as plain \N for "not newline". PCRE does not
    support \N{name}. However, it does support quantification such as \N{2,3},
    so if \N{ is not followed by U+dddd we check for a quantifier. */</comment>

    <if_stmt><if>if <condition>(<expr><name>escape</name> <operator>==</operator> <name>ESC_N</name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_LEFT_CURLY_BRACKET</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>p</name> <init>= <expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

      <comment type="block">/* \N{U+ can be handled by the \x{ code. However, this construction is
      not valid in EBCDIC environments because it specifies a Unicode
      character, not a codepoint in the local code. For example \N{U+0041}
      must be "A" in all environments. Also, in Perl, \N{U+ forces Unicode
      casing semantics for the entire pattern, so allow it only in UTF (i.e.
      Unicode) mode. */</comment>

      <if_stmt><if>if <condition>(<expr><name>ptrend</name> <operator>-</operator> <name>p</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <name>CHAR_U</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_PLUS</name></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EBCDIC</name></cpp:ifdef>
        <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR93</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>escape</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>   <comment type="block">/* Not a fancy escape after all */</comment>
          <goto>goto <name>COME_FROM_NU</name>;</goto>
          </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR93</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>

      <comment type="block">/* Give an error if what follows is not a quantifier, but don't override
      an error set by the quantifier reader (e.g. number overflow). */</comment>

      <else>else
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_repeat_counts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>errorcodeptr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
             <operator>*</operator><name>errorcodeptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR37</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>

<comment type="block">/* Escapes that need further processing, including those that are unknown, have
a zero entry in the lookup table. When called from pcre2_substitute(), only \c,
\o, and \x are recognized (\u and \U can never appear as they are used for case
forcing). */</comment>

<else>else
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>oldptr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>overflow</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>alt_bsux</name> <init>=
    <expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_ALT_BSUX</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name>extra_options</name> <operator>&amp;</operator> <name>PCRE2_EXTRA_ALT_BSUX</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Filter calls from pcre2_substitute(). */</comment>

  <if_stmt><if>if <condition>(<expr><name>cb</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>CHAR_c</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>CHAR_o</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>CHAR_x</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR3</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>alt_bsux</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>   <comment type="block">/* Do not modify \x handling */</comment>
    </block_content>}</block></if></if_stmt>

  <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* A number of Perl escapes are not handled by PCRE. We give an explicit
    error. */</comment>

    <case>case <expr><name>CHAR_F</name></expr>:</case>
    <case>case <expr><name>CHAR_l</name></expr>:</case>
    <case>case <expr><name>CHAR_L</name></expr>:</case>
    <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR37</name></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* \u is unrecognized when neither PCRE2_ALT_BSUX nor PCRE2_EXTRA_ALT_BSUX
    is set. Otherwise, \u must be followed by exactly four hex digits or, if
    PCRE2_EXTRA_ALT_BSUX is set, by any number of hex digits in braces.
    Otherwise it is a lowercase u letter. This gives some compatibility with
    ECMAScript (aka JavaScript). */</comment>

    <case>case <expr><name>CHAR_u</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>alt_bsux</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR37</name></expr>;</expr_stmt></block_content></block></if> <else>else
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>xc</name></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_LEFT_CURLY_BRACKET</name> <operator>&amp;&amp;</operator>
          <operator>(</operator><name>extra_options</name> <operator>&amp;</operator> <name>PCRE2_EXTRA_ALT_BSUX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>hptr</name> <init>= <expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>cc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <while>while <condition>(<expr><name>hptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>xc</name> <operator>=</operator> <call><name>XDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>hptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0xff</literal></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name>cc</name> <operator>&amp;</operator> <literal type="number">0xf0000000</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>  <comment type="block">/* Test for 32-bit overflow */</comment>
            <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR77</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>hptr</name></expr>;</expr_stmt>   <comment type="block">/* Show where */</comment>
            <break>break;</break>        <comment type="block">/* *hptr != } will cause another break below */</comment>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>(</operator><name>cc</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator> <name>xc</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>hptr</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></while>

        <if_stmt><if>if <condition>(<expr><name>hptr</name> <operator>==</operator> <name>ptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>||</operator>   <comment type="block">/* No hex digits */</comment>
            <name>hptr</name> <operator>&gt;=</operator> <name>ptrend</name> <operator>||</operator>    <comment type="block">/* Hit end of input */</comment>
            <operator>*</operator><name>hptr</name> <operator>!=</operator> <name>CHAR_RIGHT_CURLY_BRACKET</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* No } terminator */</comment>
          <break>break;</break></block_content></block></if></if_stmt>         <comment type="block">/* Hex escape not recognized */</comment>

        <expr_stmt><expr><name>c</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>          <comment type="block">/* Accept the code point */</comment>
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>hptr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if>

      <else>else  <comment type="block">/* Must be exactly 4 hex digits */</comment>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>ptrend</name> <operator>-</operator> <name>ptr</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>               <comment type="block">/* Less than 4 chars */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>cc</name> <operator>=</operator> <call><name>XDIGIT</name><argument_list>(<argument><expr><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0xff</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* Not a hex digit */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>xc</name> <operator>=</operator> <call><name>XDIGIT</name><argument_list>(<argument><expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0xff</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* Not a hex digit */</comment>
        <expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>(</operator><name>cc</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator> <name>xc</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>xc</name> <operator>=</operator> <call><name>XDIGIT</name><argument_list>(<argument><expr><name><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0xff</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* Not a hex digit */</comment>
        <expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>(</operator><name>cc</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator> <name>xc</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>xc</name> <operator>=</operator> <call><name>XDIGIT</name><argument_list>(<argument><expr><name><name>ptr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0xff</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* Not a hex digit */</comment>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>cc</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator> <name>xc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">0x10ffffU</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR77</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else
          if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">0xd800</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="number">0xdfff</literal> <operator>&amp;&amp;</operator>
              <operator>(</operator><name>extra_options</name> <operator>&amp;</operator> <name>PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR73</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>c</name> <operator>&gt;</operator> <name>MAX_NON_UTF_CHAR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR77</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    <break>break;</break>

    <comment type="block">/* \U is unrecognized unless PCRE2_ALT_BSUX or PCRE2_EXTRA_ALT_BSUX is set,
    in which case it is an upper case letter. */</comment>

    <case>case <expr><name>CHAR_U</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>alt_bsux</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR37</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <break>break;</break>

    <comment type="block">/* In a character class, \g is just a literal "g". Outside a character
    class, \g must be followed by one of a number of specific things:

    (1) A number, either plain or braced. If positive, it is an absolute
    backreference. If negative, it is a relative backreference. This is a Perl
    5.10 feature.

    (2) Perl 5.10 also supports \g{name} as a reference to a named group. This
    is part of Perl's movement towards a unified syntax for back references. As
    this is synonymous with \k{name}, we fudge it up by pretending it really
    was \k{name}.

    (3) For Oniguruma compatibility we also support \g followed by a name or a
    number either in angle brackets or in single quotes. However, these are
    (possibly recursive) subroutine calls, _not_ backreferences. We return
    the ESC_g code.

    Summary: Return a negative number for a numerical back reference, ESC_k for
    a named back reference, and ESC_g for a named or numbered subroutine call.
    */</comment>

    <case>case <expr><name>CHAR_g</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>isclass</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR57</name></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_LESS_THAN_SIGN</name> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_APOSTROPHE</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>escape</name> <operator>=</operator> <name>ESC_g</name></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* If there is a brace delimiter, try to read a numerical reference. If
    there isn't one, assume we have a name and treat it as \k. */</comment>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_LEFT_CURLY_BRACKET</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>p</name> <init>= <expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name></expr></argument>, <argument><expr><name>MAX_GROUP_NUMBER</name></expr></argument>, <argument><expr><name>ERR61</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>,
          <argument><expr><name>errorcodeptr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>errorcodeptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>escape</name> <operator>=</operator> <name>ESC_k</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* No number found */</comment>
        <break>break;</break>
        </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name>ptrend</name> <operator>||</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <name>CHAR_RIGHT_CURLY_BRACKET</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR57</name></expr>;</expr_stmt>
        <break>break;</break>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      </block_content>}</block></if>

    <comment type="block">/* Read an undelimited number */</comment>

    <else>else
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name></expr></argument>, <argument><expr><name>MAX_GROUP_NUMBER</name></expr></argument>, <argument><expr><name>ERR61</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>,
          <argument><expr><name>errorcodeptr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>errorcodeptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR57</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* No number found */</comment>
        <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>s</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR15</name></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>escape</name> <operator>=</operator> <operator>-</operator><name>s</name></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* The handling of escape sequences consisting of a string of digits
    starting with one that is not zero is not straightforward. Perl has changed
    over the years. Nowadays \g{} for backreferences and \o{} for octal are
    recommended to avoid the ambiguities in the old syntax.

    Outside a character class, the digits are read as a decimal number. If the
    number is less than 10, or if there are that many previous extracting left
    brackets, it is a back reference. Otherwise, up to three octal digits are
    read to form an escaped character code. Thus \123 is likely to be octal 123
    (cf \0123, which is octal 012 followed by the literal 3).

    Inside a character class, \ followed by a digit is always either a literal
    8 or 9 or an octal number. */</comment>

    <case>case <expr><name>CHAR_1</name></expr>:</case> <case>case <expr><name>CHAR_2</name></expr>:</case> <case>case <expr><name>CHAR_3</name></expr>:</case> <case>case <expr><name>CHAR_4</name></expr>:</case> <case>case <expr><name>CHAR_5</name></expr>:</case>
    <case>case <expr><name>CHAR_6</name></expr>:</case> <case>case <expr><name>CHAR_7</name></expr>:</case> <case>case <expr><name>CHAR_8</name></expr>:</case> <case>case <expr><name>CHAR_9</name></expr>:</case>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isclass</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>oldptr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>   <comment type="block">/* Back to the digit */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>INT_MAX</name><operator>/</operator><literal type="number">10</literal> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ERR61</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>,
          <argument><expr><name>errorcodeptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>

      <comment type="block">/* \1 to \9 are always back references. \8x and \9x are too; \1x to \7x
      are octal escapes if there are not that many previous captures. */</comment>

      <if_stmt><if>if <condition>(<expr><name>s</name> <operator>&lt;</operator> <literal type="number">10</literal> <operator>||</operator> <name><name>oldptr</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&gt;=</operator> <name>CHAR_8</name> <operator>||</operator> <name>s</name> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>MAX_GROUP_NUMBER</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR61</name></expr>;</expr_stmt></block_content></block></if>
          <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>escape</name> <operator>=</operator> <operator>-</operator><name>s</name></expr>;</expr_stmt></block_content></block></else></if_stmt>     <comment type="block">/* Indicates a back reference */</comment>
        <break>break;</break>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>oldptr</name></expr>;</expr_stmt>      <comment type="block">/* Put the pointer back and fall through */</comment>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Handle a digit following \ when the number is not a back reference, or
    we are within a character class. If the first digit is 8 or 9, Perl used to
    generate a binary zero and then treat the digit as a following literal. At
    least by Perl 5.18 this changed so as not to insert the binary zero. */</comment>

    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <name>CHAR_8</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

    <comment type="block">/* Fall through */</comment>

    <comment type="block">/* \0 always starts an octal number, but we may drop through to here with a
    larger first octal digit. The original code used just to take the least
    significant 8 bits of octal numbers (I think this is what early Perls used
    to do). Nowadays we allow for larger numbers in UTF-8 mode and 16-bit mode,
    but no more than 3 octal digits. */</comment>

    <case>case <expr><name>CHAR_0</name></expr>:</case>
    <expr_stmt><expr><name>c</name> <operator>-=</operator> <name>CHAR_0</name></expr>;</expr_stmt>
    <while>while<condition>(<expr><name>i</name><operator>++</operator> <operator>&lt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>&gt;=</operator> <name>CHAR_0</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>&lt;=</operator> <name>CHAR_7</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <name>c</name> <operator>*</operator> <literal type="number">8</literal> <operator>+</operator> <operator>*</operator><name>ptr</name><operator>++</operator> <operator>-</operator> <name>CHAR_0</name></expr>;</expr_stmt></block_content></block></while>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>utf</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&gt;</operator> <literal type="number">0xff</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR51</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>

    <comment type="block">/* \o is a relatively new Perl feature, supporting a more general way of
    specifying character codes in octal. The only supported form is \o{ddd}. */</comment>

    <case>case <expr><name>CHAR_o</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name> <operator>||</operator> <operator>*</operator><name>ptr</name><operator>++</operator> <operator>!=</operator> <name>CHAR_LEFT_CURLY_BRACKET</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR55</name></expr>;</expr_stmt>
      </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_RIGHT_CURLY_BRACKET</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR78</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>overflow</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>&gt;=</operator> <name>CHAR_0</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>&lt;=</operator> <name>CHAR_7</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>*</operator><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cc</name> <operator>==</operator> <name>CHAR_0</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>     <comment type="block">/* Leading zeroes */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">0x20000000l</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>overflow</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>cc</name> <operator>-</operator> <name>CHAR_0</name><operator>)</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <operator>(</operator><ternary><condition><expr><name>utf</name></expr> ?</condition><then> <expr><literal type="number">0x10ffffU</literal></expr> </then><else>: <expr><literal type="number">0xffU</literal></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>overflow</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:elif>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <operator>(</operator><ternary><condition><expr><name>utf</name></expr> ?</condition><then> <expr><literal type="number">0x10ffffU</literal></expr> </then><else>: <expr><literal type="number">0xffffU</literal></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>overflow</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:elif>
        <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&gt;</operator> <literal type="number">0x10ffffU</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>overflow</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></while>
      <if_stmt><if>if <condition>(<expr><name>overflow</name></expr>)</condition>
        <block>{<block_content>
        <while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>&gt;=</operator> <name>CHAR_0</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>&lt;=</operator> <name>CHAR_7</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR34</name></expr>;</expr_stmt>
        </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name><operator>++</operator> <operator>==</operator> <name>CHAR_RIGHT_CURLY_BRACKET</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&gt;=</operator> <literal type="number">0xd800</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="number">0xdfff</literal> <operator>&amp;&amp;</operator>
            <operator>(</operator><name>extra_options</name> <operator>&amp;</operator> <name>PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR73</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR64</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    <break>break;</break>

    <comment type="block">/* When PCRE2_ALT_BSUX or PCRE2_EXTRA_ALT_BSUX is set, \x must be followed
    by two hexadecimal digits. Otherwise it is a lowercase x letter. */</comment>

    <case>case <expr><name>CHAR_x</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>alt_bsux</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>xc</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>ptrend</name> <operator>-</operator> <name>ptr</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>               <comment type="block">/* Less than 2 characters */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>cc</name> <operator>=</operator> <call><name>XDIGIT</name><argument_list>(<argument><expr><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0xff</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* Not a hex digit */</comment>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>xc</name> <operator>=</operator> <call><name>XDIGIT</name><argument_list>(<argument><expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0xff</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* Not a hex digit */</comment>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>cc</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator> <name>xc</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      </block_content>}</block></if>

    <comment type="block">/* Handle \x in Perl's style. \x{ddd} is a character code which can be
    greater than 0xff in UTF-8 or non-8bit mode, but only if the ddd are hex
    digits. If not, { used to be treated as a data character. However, Perl
    seems to read hex digits up to the first non-such, and ignore the rest, so
    that, for example \x{zz} matches a binary zero. This seems crazy, so PCRE
    now gives an error. */</comment>

    <else>else
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_LEFT_CURLY_BRACKET</name></expr>)</condition>
        <block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EBCDIC</name></cpp:ifndef>
        <label><name>COME_FROM_NU</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if <condition>(<expr><operator>++</operator><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_RIGHT_CURLY_BRACKET</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR78</name></expr>;</expr_stmt>
          <break>break;</break>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>overflow</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

        <while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>cc</name> <operator>=</operator> <call><name>XDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0xff</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>   <comment type="block">/* Leading zeroes */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
          <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">0x10000000l</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>overflow</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break> </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator> <name>cc</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name>utf</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&gt;</operator> <literal type="number">0x10ffffU</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><name>utf</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&gt;</operator> <name>MAX_NON_UTF_CHAR</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>overflow</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
            <break>break;</break>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></while>

        <if_stmt><if>if <condition>(<expr><name>overflow</name></expr>)</condition>
          <block>{<block_content>
          <while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator> <call><name>XDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0xff</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
          <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR34</name></expr>;</expr_stmt>
          </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name><operator>++</operator> <operator>==</operator> <name>CHAR_RIGHT_CURLY_BRACKET</name></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&gt;=</operator> <literal type="number">0xd800</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="number">0xdfff</literal> <operator>&amp;&amp;</operator>
              <operator>(</operator><name>extra_options</name> <operator>&amp;</operator> <name>PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR73</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if>

        <comment type="block">/* If the sequence of hex digits does not end with '}', give an error.
        We used just to recognize this construct and fall through to the normal
        \x handling, but nowadays Perl gives an error, which seems much more
        sensible, so we do too. */</comment>

        <else>else
          <block>{<block_content>
          <expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR67</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>   <comment type="block">/* End of \x{} processing */</comment>

      <comment type="block">/* Read a up to two hex digits after \x */</comment>

      <else>else
        <block>{<block_content>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name> <operator>||</operator> <operator>(</operator><name>cc</name> <operator>=</operator> <call><name>XDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0xff</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* Not a hex digit */</comment>
        <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name> <operator>||</operator> <operator>(</operator><name>cc</name> <operator>=</operator> <call><name>XDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0xff</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* Not a hex digit */</comment>
        <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator> <name>cc</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>     <comment type="block">/* End of \xdd handling */</comment>
      </block_content>}</block></else></if_stmt>       <comment type="block">/* End of Perl-style \x handling */</comment>
    <break>break;</break>

    <comment type="block">/* The handling of \c is different in ASCII and EBCDIC environments. In an
    ASCII (or Unicode) environment, an error is given if the character
    following \c is not a printable ASCII character. Otherwise, the following
    character is upper-cased if it is a letter, and after that the 0x40 bit is
    flipped. The result is the value of the escape.

    In an EBCDIC environment the handling of \c is compatible with the
    specification in the perlebcdic document. The following character must be
    a letter or one of small number of special characters. These provide a
    means of defining the character values 0-31.

    For testing the EBCDIC handling of \c in an ASCII environment, recognize
    the EBCDIC value of 'c' explicitly. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>EBCDIC</name> <operator>&amp;&amp;</operator> <literal type="char">'a'</literal> <operator>!=</operator> <literal type="number">0x81</literal></expr></cpp:if>
    <case>case <expr><literal type="number">0x83</literal></expr>:</case>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <case>case <expr><name>CHAR_c</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR2</name></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>ptr</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <name>CHAR_a</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <name>CHAR_z</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>UPPER_CASE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Handle \c in an ASCII/Unicode environment. */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EBCDIC</name></cpp:ifndef>    <comment type="block">/* ASCII/UTF-8 coding */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>c</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">32</literal> <operator>||</operator> <name>c</name></expr></argument> &gt;</argument_list></name> <literal type="number">126</literal></expr>)</condition>  <comment type="block">/* Excludes all non-printable ASCII */</comment>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR68</name></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>c</name> <operator>^=</operator> <literal type="number">0x40</literal></expr>;</expr_stmt>

    <comment type="block">/* Handle \c in an EBCDIC environment. The special case \c? is converted to
    255 (0xff) or 95 (0x5f) if other characters suggest we are using the
    POSIX-BC encoding. (This is the way Perl indicates that it handles \c?.)
    The other valid sequences correspond to a list of specific characters. */</comment>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_QUESTION_MARK</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><literal type="char">'\\'</literal> <operator>==</operator> <literal type="number">188</literal> <operator>&amp;&amp;</operator> <literal type="char">'`'</literal> <operator>==</operator> <literal type="number">74</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0x5f</literal></expr> </then><else>: <expr><literal type="number">0xff</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
    <else>else
      <block>{<block_content>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name><name>ebcdic_escape_c</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR68</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* EBCDIC */</comment>

    <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* Any other alphanumeric following \ is an error. Perl gives an error only
    if in warning mode, but PCRE doesn't have a warning mode. */</comment>

    <default>default:</default>
    <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR3</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>ptrptr</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>     <comment type="block">/* Point to the character at fault */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></switch>
  </block_content>}</block></else></if_stmt>

<comment type="block">/* Set the pointer to the next character before returning. */</comment>

<expr_stmt><expr><operator>*</operator><name>ptrptr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>chptr</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<return>return <expr><name>escape</name></expr>;</return>
</block_content>}</block></function>



<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<comment type="block" format="doxygen">/*************************************************
*               Handle \P and \p                 *
*************************************************/</comment>

<comment type="block">/* This function is called after \P or \p has been encountered, provided that
PCRE2 is compiled with support for UTF and Unicode properties. On entry, the
contents of ptrptr are pointing after the P or p. On exit, it is left pointing
after the final code unit of the escape sequence.

Arguments:
  ptrptr         the pattern position pointer
  negptr         a boolean that is set TRUE for negation else FALSE
  ptypeptr       an unsigned int that is set to the type value
  pdataptr       an unsigned int that is set to the detailed property value
  errorcodeptr   the error code variable
  cb             the compile data

Returns:         TRUE if the type value was found, or FALSE for an invalid type
*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>get_ucp</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name> <modifier>*</modifier></type><name>ptrptr</name></decl></parameter>, <parameter><decl><type><name>BOOL</name> <modifier>*</modifier></type><name>negptr</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>ptypeptr</name></decl></parameter>,
  <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>pdataptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>errorcodeptr</name></decl></parameter>, <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>bot</name></decl>, <decl><type ref="prev"/><name>top</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ptr</name> <init>= <expr><operator>*</operator><name>ptrptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name><name>name</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name><name>cb</name><operator>-&gt;</operator><name>end_pattern</name></name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>ERROR_RETURN</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>negptr</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<comment type="block">/* \P or \p can be followed by a name in {}, optionally preceded by ^ for
negation. */</comment>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_LEFT_CURLY_BRACKET</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name><name>cb</name><operator>-&gt;</operator><name>end_pattern</name></name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>ERROR_RETURN</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_CIRCUMFLEX_ACCENT</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>negptr</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name><name>cb</name><operator>-&gt;</operator><name>end_pattern</name></name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>ERROR_RETURN</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_NUL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>ERROR_RETURN</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_RIGHT_CURLY_BRACKET</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>CHAR_RIGHT_CURLY_BRACKET</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>ERROR_RETURN</name>;</goto></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if>

<comment type="block">/* Otherwise there is just one following character, which must be an ASCII
letter. */</comment>

<if type="elseif">else if <condition>(<expr><call><name>MAX_255</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_letter</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <goto>goto <name>ERROR_RETURN</name>;</goto></block_content></block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>ptrptr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

<comment type="block">/* Search for a recognized property name using binary chop. */</comment>

<expr_stmt><expr><name>bot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>top</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>utt_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>bot</name> <operator>&lt;</operator> <name>top</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>bot</name> <operator>+</operator> <name>top</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>r</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>strcmp_c8</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>PRIV</name><argument_list>(<argument><expr><name>utt_names</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>utt</name></expr></argument>)</argument_list></call><index>[<expr><name>i</name></expr>]</index><operator>.</operator><name>name_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ptypeptr</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>utt</name></expr></argument>)</argument_list></call><index>[<expr><name>i</name></expr>]</index><operator>.</operator><name>type</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pdataptr</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>utt</name></expr></argument>)</argument_list></call><index>[<expr><name>i</name></expr>]</index><operator>.</operator><name>value</name></expr>;</expr_stmt>
    <return>return <expr><name>TRUE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>r</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bot</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>top</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR47</name></expr>;</expr_stmt>   <comment type="block">/* Unrecognized name */</comment>
<return>return <expr><name>FALSE</name></expr>;</return>

<label><name>ERROR_RETURN</name>:</label>            <comment type="block">/* Malformed \P or \p */</comment>
<expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR46</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ptrptr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<comment type="block" format="doxygen">/*************************************************
*           Check for POSIX class syntax         *
*************************************************/</comment>

<comment type="block">/* This function is called when the sequence "[:" or "[." or "[=" is
encountered in a character class. It checks whether this is followed by a
sequence of characters terminated by a matching ":]" or ".]" or "=]". If we
reach an unescaped ']' without the special preceding character, return FALSE.

Originally, this function only recognized a sequence of letters between the
terminators, but it seems that Perl recognizes any sequence of characters,
though of course unknown POSIX names are subsequently rejected. Perl gives an
"Unknown POSIX class" error for [:f\oo:] for example, where previously PCRE
didn't consider this to be a POSIX class. Likewise for [:1234:].

The problem in trying to be exactly like Perl is in the handling of escapes. We
have to be sure that [abc[:x\]pqr] is *not* treated as containing a POSIX
class, but [abc[:x\]pqr:]] is (so that an error can be generated). The code
below handles the special cases \\ and \], but does not try to do any other
escape processing. This makes it different from Perl for cases such as
[:l\ower:] where Perl recognizes it as the POSIX class "lower" but PCRE does
not recognize "l\ower". This is a lesser evil than not diagnosing bad classes
when Perl does, I think.

A user pointed out that PCRE was rejecting [:a[:digit:]] whereas Perl was not.
It seems that the appearance of a nested POSIX class supersedes an apparent
external class. For example, [:a[:digit:]b:] matches "a", "b", ":", or
a digit. This is handled by returning FALSE if the start of a new group with
the same terminator is encountered, since the next closing sequence must close
the nested group, not the outer one.

In Perl, unescaped square brackets may also appear as part of class names. For
example, [:a[:abc]b:] gives unknown POSIX class "[:abc]b:]". However, for
[:a[:abc]b][b:] it gives unknown POSIX class "[:abc]b][b:]", which does not
seem right at all. PCRE does not allow closing square brackets in POSIX class
names.

Arguments:
  ptr      pointer to the character after the initial [ (colon, dot, equals)
  ptrend   pointer to the end of the pattern
  endptr   where to return a pointer to the terminating ':', '.', or '='

Returns:   TRUE or FALSE
*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>check_posix_syntax</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ptrend</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name> <modifier>*</modifier></type><name>endptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>terminator</name></decl>;</decl_stmt>  <comment type="block">/* Don't combine these lines; the Solaris cc */</comment>
<expr_stmt><expr><name>terminator</name> <operator>=</operator> <operator>*</operator><name>ptr</name><operator>++</operator></expr>;</expr_stmt>     <comment type="block">/* compiler warns about "non-constant" initializer. */</comment>

<for>for <control>(<init>;</init> <condition><expr><name>ptrend</name> <operator>-</operator> <name>ptr</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_BACKSLASH</name> <operator>&amp;&amp;</operator>
      <operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_RIGHT_SQUARE_BRACKET</name> <operator>||</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_BACKSLASH</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>

  <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_LEFT_SQUARE_BRACKET</name> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>terminator</name><operator>)</operator> <operator>||</operator>
            <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_RIGHT_SQUARE_BRACKET</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if>

  <if type="elseif">else if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>terminator</name> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_RIGHT_SQUARE_BRACKET</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>endptr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
    <return>return <expr><name>TRUE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*          Check POSIX class name                *
*************************************************/</comment>

<comment type="block">/* This function is called to check the name given in a POSIX-style class entry
such as [:alnum:].

Arguments:
  ptr        points to the first letter
  len        the length of the name

Returns:     a value representing the name, or -1 if unknown
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_posix_name</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pn</name> <init>= <expr><name>posix_names</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yield</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name><name>posix_name_lengths</name><index>[<expr><name>yield</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name><name>posix_name_lengths</name><index>[<expr><name>yield</name></expr>]</index></name> <operator>&amp;&amp;</operator>
    <call><call><name>PRIV</name><argument_list>(<argument><expr><name>strncmp_c8</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>pn</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>yield</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pn</name> <operator>+=</operator> <name><name>posix_name_lengths</name><index>[<expr><name>yield</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>yield</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*       Read a subpattern or VERB name           *
*************************************************/</comment>

<comment type="block">/* This function is called from parse_regex() below whenever it needs to read
the name of a subpattern or a (*VERB) or an (*alpha_assertion). The initial
pointer must be to the character before the name. If that character is '*' we
are reading a verb or alpha assertion name. The pointer is updated to point
after the name, for a VERB or alpha assertion name, or after tha name's
terminator for a subpattern name. Returning both the offset and the name
pointer is redundant information, but some callers use one and some the other,
so it is simplest just to return both.

Arguments:
  ptrptr      points to the character pointer variable
  ptrend      points to the end of the input string
  utf         true if the input is UTF-encoded
  terminator  the terminator of a subpattern name must be this
  offsetptr   where to put the offset from the start of the pattern
  nameptr     where to put a pointer to the name in the input
  namelenptr  where to put the length of the name
  errcodeptr  where to put an error code
  cb          pointer to the compile data block

Returns:    TRUE if a name was read
            FALSE otherwise, with error code set
*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>read_name</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name> <modifier>*</modifier></type><name>ptrptr</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ptrend</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>utf</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>terminator</name></decl></parameter>,
  <parameter><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>offsetptr</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name> <modifier>*</modifier></type><name>nameptr</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>namelenptr</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>errorcodeptr</name></decl></parameter>, <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ptr</name> <init>= <expr><operator>*</operator><name>ptrptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>is_group</name> <init>= <expr><operator>(</operator><operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_ASTERISK</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>++</operator><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition>               <comment type="block">/* No characters in name */</comment>
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <ternary><condition><expr><name>is_group</name></expr>?</condition><then> <expr><name>ERR62</name></expr></then><else>: <comment type="block">/* Subpattern name expected */</comment>
                            <expr><name>ERR60</name></expr></else></ternary></expr>;</expr_stmt> <comment type="block">/* Verb not recognized or malformed */</comment>
  <goto>goto <name>FAILED</name>;</goto>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>nameptr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>offsetptr</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <name><name>cb</name><operator>-&gt;</operator><name>start_pattern</name></name><operator>)</operator></expr>;</expr_stmt>

<comment type="block">/* In UTF mode, a group name may contain letters and decimal digits as defined
by Unicode properties, and underscores, but must not start with a digit. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <name>is_group</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>type</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>GETCHAR</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>UCD_CHARTYPE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>ucp_Nd</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR44</name></expr>;</expr_stmt>
    <goto>goto <name>FAILED</name>;</goto>
    </block_content>}</block></if></if_stmt>

  <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>ucp_Nd</name> <operator>&amp;&amp;</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>ucp_gentype</name></expr></argument>)</argument_list></call><index>[<expr><name>type</name></expr>]</index> <operator>!=</operator> <name>ucp_L</name> <operator>&amp;&amp;</operator>
        <name>c</name> <operator>!=</operator> <name>CHAR_UNDERSCORE</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FORWARDCHARTEST</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>GETCHAR</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>UCD_CHARTYPE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>utf</name></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* Avoid compiler warning */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>      <comment type="block">/* SUPPORT_UNICODE */</comment>

<comment type="block">/* Handle non-group names and group names in non-UTF modes. A group name must
not start with a digit. If either of the others start with a digit it just
won't be recognized. */</comment>

  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>is_group</name> <operator>&amp;&amp;</operator> <call><name>IS_DIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR44</name></expr>;</expr_stmt>
    <goto>goto <name>FAILED</name>;</goto>
    </block_content>}</block></if></if_stmt>

  <while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator> <call><name>MAX_255</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><operator>*</operator><name>ptr</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_word</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block>

<comment type="block">/* Check name length */</comment>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;</operator> <operator>*</operator><name>nameptr</name> <operator>+</operator> <name>MAX_NAME_SIZE</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR48</name></expr>;</expr_stmt>
  <goto>goto <name>FAILED</name>;</goto>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>namelenptr</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <operator>*</operator><name>nameptr</name><operator>)</operator></expr>;</expr_stmt>

<comment type="block">/* Subpattern names must not be empty, and their terminator is checked here.
(What follows a verb or alpha assertion name is checked separately.) */</comment>

<if_stmt><if>if <condition>(<expr><name>is_group</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <operator>*</operator><name>nameptr</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR62</name></expr>;</expr_stmt>   <comment type="block">/* Subpattern name expected */</comment>
    <goto>goto <name>FAILED</name>;</goto>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <operator>(</operator><name>PCRE2_UCHAR</name><operator>)</operator><name>terminator</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR42</name></expr>;</expr_stmt>
    <goto>goto <name>FAILED</name>;</goto>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>ptrptr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>TRUE</name></expr>;</return>

<label><name>FAILED</name>:</label>
<expr_stmt><expr><operator>*</operator><name>ptrptr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*          Manage callouts at start of cycle     *
*************************************************/</comment>

<comment type="block">/* At the start of a new item in parse_regex() we are able to record the
details of the previous item in a prior callout, and also to set up an
automatic callout if enabled. Avoid having two adjacent automatic callouts,
which would otherwise happen for items such as \Q that contribute nothing to
the parsed pattern.

Arguments:
  ptr              current pattern pointer
  pcalloutptr      points to a pointer to previous callout, or NULL
  auto_callout     TRUE if auto_callouts are enabled
  parsed_pattern   the parsed pattern pointer
  cb               compile block

Returns: possibly updated parsed_pattern pointer.
*/</comment>

<function><type><specifier>static</specifier> <name>uint32_t</name> <modifier>*</modifier></type>
<name>manage_callouts</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>pcalloutptr</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>auto_callout</name></decl></parameter>,
  <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>parsed_pattern</name></decl></parameter>, <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>previous_callout</name> <init>= <expr><operator>*</operator><name>pcalloutptr</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>previous_callout</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>previous_callout</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator>
  <name><name>cb</name><operator>-&gt;</operator><name>start_pattern</name></name> <operator>-</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><name><name>previous_callout</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>auto_callout</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>previous_callout</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if> <else>else
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>previous_callout</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
      <name>previous_callout</name> <operator>!=</operator> <name>parsed_pattern</name> <operator>-</operator> <literal type="number">4</literal> <operator>||</operator>
      <name><name>previous_callout</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">255</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>previous_callout</name> <operator>=</operator> <name>parsed_pattern</name></expr>;</expr_stmt>  <comment type="block">/* Set up new automatic callout */</comment>
    <expr_stmt><expr><name>parsed_pattern</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>previous_callout</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>META_CALLOUT_NUMBER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>previous_callout</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>previous_callout</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>previous_callout</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <name><name>cb</name><operator>-&gt;</operator><name>start_pattern</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pcalloutptr</name> <operator>=</operator> <name>previous_callout</name></expr>;</expr_stmt>
<return>return <expr><name>parsed_pattern</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*      Parse regex and identify named groups     *
*************************************************/</comment>

<comment type="block">/* This function is called first of all. It scans the pattern and does two
things: (1) It identifies capturing groups and makes a table of named capturing
groups so that information about them is fully available to both the compiling
scans. (2) It writes a parsed version of the pattern with comments omitted and
escapes processed into the parsed_pattern vector.

Arguments:
  ptr             points to the start of the pattern
  options         compiling dynamic options (may change during the scan)
  has_lookbehind  points to a boolean, set TRUE if a lookbehind is found
  cb              pointer to the compile data block

Returns:   zero on success or a non-zero error code, with the
             error offset placed in the cb field
*/</comment>

<comment type="block">/* A structure and some flags for dealing with nested groups. */</comment>

<typedef>typedef <type><struct>struct <name>nest_save</name> <block>{
  <decl_stmt><decl><type><name>uint16_t</name></type>  <name>nest_depth</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type>  <name>reset_group</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type>  <name>max_group</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type>  <name>flags</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type>  <name>options</name></decl>;</decl_stmt>
}</block></struct></type> <name>nest_save</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSF_RESET</name></cpp:macro>          <cpp:value>0x0001u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSF_CONDASSERT</name></cpp:macro>     <cpp:value>0x0002u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSF_ATOMICSR</name></cpp:macro>       <cpp:value>0x0004u</cpp:value></cpp:define>

<comment type="block">/* Options that are changeable within the pattern must be tracked during
parsing. Some (e.g. PCRE2_EXTENDED) are implemented entirely during parsing,
but all must be tracked so that META_OPTIONS items set the correct values for
the main compiling phase. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSE_TRACKED_OPTIONS</name></cpp:macro> <cpp:value>(PCRE2_CASELESS|PCRE2_DOTALL|PCRE2_DUPNAMES| \
  PCRE2_EXTENDED|PCRE2_EXTENDED_MORE|PCRE2_MULTILINE|PCRE2_NO_AUTO_CAPTURE| \
  PCRE2_UNGREEDY)</cpp:value></cpp:define>

<comment type="block">/* States used for analyzing ranges in character classes. The two OK values
must be last. */</comment>

<enum>enum <block>{ <decl><name>RANGE_NO</name></decl>, <decl><name>RANGE_STARTED</name></decl>, <decl><name>RANGE_OK_ESCAPED</name></decl>, <decl><name>RANGE_OK_LITERAL</name></decl> }</block>;</enum>

<comment type="block">/* Only in 32-bit mode can there be literals &gt; META_END. A macro encapsulates
the storing of literal values in the main parsed pattern, where they can always
be quantified. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSED_LITERAL</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>{ \
  if (c &gt;= META_END) *p++ = META_BIGVALUE; \
  *p++ = c; \
  okquantifier = TRUE; \
  }</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSED_LITERAL</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>*p++ = c; okquantifier = TRUE;</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Here's the actual function. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>parse_regex</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>BOOL</name> <modifier>*</modifier></type><name>has_lookbehind</name></decl></parameter>,
  <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>delimiter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>namelen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>class_range_state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>verblengthptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Value avoids compiler warning */</comment>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>verbstartptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>previous_callout</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>parsed_pattern</name> <init>= <expr><name><name>cb</name><operator>-&gt;</operator><name>parsed_pattern</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>parsed_pattern_end</name> <init>= <expr><name><name>cb</name><operator>-&gt;</operator><name>parsed_pattern_end</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>meta_quantifier</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>add_after_mark</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>extra_options</name> <init>= <expr><name><name>cb</name><operator>-&gt;</operator><name>cx</name><operator>-&gt;</operator><name>extra_options</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>nest_depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>after_manual_callout</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>expect_cond_assert</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>errorcode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>escape</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>inescq</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>inverbname</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name> <init>= <expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>auto_callout</name> <init>= <expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_AUTO_CALLOUT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>isdupname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>negate_class</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>okquantifier</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>thisptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ptrend</name> <init>= <expr><name><name>cb</name><operator>-&gt;</operator><name>end_pattern</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>verbnamestart</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* Value avoids compiler warning */</comment>
<decl_stmt><decl><type><name>named_group</name> <modifier>*</modifier></type><name>ng</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>nest_save</name> <modifier>*</modifier></type><name>top_nest</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end_nests</name></decl>;</decl_stmt>

<comment type="block">/* Insert leading items for word and line matching (features provided for the
benefit of pcre2grep). */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>extra_options</name> <operator>&amp;</operator> <name>PCRE2_EXTRA_MATCH_LINE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_CIRCUMFLEX</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_NOCAPTURE</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name>extra_options</name> <operator>&amp;</operator> <name>PCRE2_EXTRA_MATCH_WORD</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_ESCAPE</name> <operator>+</operator> <name>ESC_b</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_NOCAPTURE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* If the pattern is actually a literal string, process it separately to avoid
cluttering up the main loop. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_LITERAL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>parsed_pattern</name> <operator>&gt;=</operator> <name>parsed_pattern_end</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR63</name></expr>;</expr_stmt>  <comment type="block">/* Internal error (parsed pattern overflow) */</comment>
      <goto>goto <name>FAILED</name>;</goto>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>thisptr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>auto_callout</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>parsed_pattern</name> <operator>=</operator> <call><name>manage_callouts</name><argument_list>(<argument><expr><name>thisptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>previous_callout</name></expr></argument>,
        <argument><expr><name>auto_callout</name></expr></argument>, <argument><expr><name>parsed_pattern</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>PARSED_LITERAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>parsed_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
  <goto>goto <name>PARSED_END</name>;</goto>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Process a real regex which may contain meta-characters. */</comment>

<expr_stmt><expr><name>top_nest</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>end_nests</name> <operator>=</operator> <operator>(</operator><name>nest_save</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>start_workspace</name></name> <operator>+</operator> <name><name>cb</name><operator>-&gt;</operator><name>workspace_size</name></name><operator>)</operator></expr>;</expr_stmt>

<comment type="block">/* The size of the nest_save structure might not be a factor of the size of the
workspace. Therefore we must round down end_nests so as to correctly avoid
creating a nest_save that spans the end of the workspace. */</comment>

<expr_stmt><expr><name>end_nests</name> <operator>=</operator> <operator>(</operator><name>nest_save</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>end_nests</name> <operator>-</operator>
  <operator>(</operator><operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>workspace_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>%</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>nest_save</name></expr></argument>)</argument_list></sizeof><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

<comment type="block">/* PCRE2_EXTENDED_MORE implies PCRE2_EXTENDED */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_EXTENDED_MORE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_EXTENDED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* Now scan the pattern */</comment>

<while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>prev_expect_cond_assert</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>min_repeat</name></decl>, <decl><type ref="prev"/><name>max_repeat</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>set</name></decl>, <decl><type ref="prev"/><name>unset</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>optset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>terminator</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>prev_meta_quantifier</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>prev_okquantifier</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>tempptr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>offset</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>parsed_pattern</name> <operator>&gt;=</operator> <name>parsed_pattern_end</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR63</name></expr>;</expr_stmt>  <comment type="block">/* Internal error (parsed pattern overflow) */</comment>
    <goto>goto <name>FAILED</name>;</goto>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>nest_depth</name> <operator>&gt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>cx</name><operator>-&gt;</operator><name>parens_nest_limit</name></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR19</name></expr>;</expr_stmt>
    <goto>goto <name>FAILED</name>;</goto>        <comment type="block">/* Parentheses too deeply nested */</comment>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Get next input character, save its position for callout handling. */</comment>

  <expr_stmt><expr><name>thisptr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Copy quoted literals until \E, allowing for the possibility of automatic
  callouts, except when processing a (*VERB) "name".  */</comment>

  <if_stmt><if>if <condition>(<expr><name>inescq</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_BACKSLASH</name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_E</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>inescq</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>   <comment type="block">/* Skip E */</comment>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>expect_cond_assert</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>   <comment type="block">/* A literal is not allowed if we are */</comment>
        <block>{<block_content>                           <comment type="block">/* expecting a conditional assertion, */</comment>
        <expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>                      <comment type="block">/* but an empty \Q\E sequence is OK.  */</comment>
        <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR28</name></expr>;</expr_stmt>
        <goto>goto <name>FAILED</name>;</goto>
        </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>inverbname</name></expr>)</condition>
        <block>{<block_content>                          <comment type="block">/* Don't use PARSED_LITERAL() because it */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>    <comment type="block">/* sets okquantifier. */</comment>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <name>META_END</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_BIGVALUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>after_manual_callout</name><operator>--</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>parsed_pattern</name> <operator>=</operator> <call><name>manage_callouts</name><argument_list>(<argument><expr><name>thisptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>previous_callout</name></expr></argument>,
            <argument><expr><name>auto_callout</name></expr></argument>, <argument><expr><name>parsed_pattern</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>PARSED_LITERAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>parsed_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>meta_quantifier</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <continue>continue;</continue>  <comment type="block">/* Next character */</comment>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* If we are processing the "name" part of a (*VERB:NAME) item, all
  characters up to the closing parenthesis are literals except when
  PCRE2_ALT_VERBNAMES is set. That causes backslash interpretation, but only \Q
  and \E and escaped characters are allowed (no character types such as \d). If
  PCRE2_EXTENDED is also set, we must ignore white space and # comments. Do
  this by not entering the special (*VERB:NAME) processing - they are then
  picked up below. Note that c is a character, not a code unit, so we must not
  use MAX_255 to test its size because MAX_255 tests code units and is assumed
  TRUE in 8-bit mode. */</comment>

  <if_stmt><if>if <condition>(<expr><name>inverbname</name> <operator>&amp;&amp;</operator>
       <operator>(</operator>
        <comment type="block">/* EITHER: not both options set */</comment>
        <operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_EXTENDED</name> <operator>|</operator> <name>PCRE2_ALT_VERBNAMES</name><operator>)</operator><operator>)</operator> <operator>!=</operator>
                    <operator>(</operator><name>PCRE2_EXTENDED</name> <operator>|</operator> <name>PCRE2_ALT_VERBNAMES</name><operator>)</operator><operator>)</operator> <operator>||</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
        <comment type="block">/* OR: character &gt; 255 AND not Unicode Pattern White Space */</comment>
        <operator>(</operator><name>c</name> <operator>&gt;</operator> <literal type="number">255</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name><operator>|</operator><literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x200f</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name><operator>|</operator><literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x2029</literal><operator>)</operator> <operator>||</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* OR: not a # comment or isspace() white space */</comment>
        <operator>(</operator><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>CHAR_NUMBER_SIGN</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_space</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
        <comment type="block">/* and not CHAR_NEL when Unicode is supported */</comment>
          <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>CHAR_NEL</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
       <operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>verbnamelength</name></decl>;</decl_stmt>

    <switch>switch<condition>(<expr><name>c</name></expr>)</condition>
      <block>{<block_content>
      <default>default:</default>                     <comment type="block">/* Don't use PARSED_LITERAL() because it */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>    <comment type="block">/* sets okquantifier. */</comment>
      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <name>META_END</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_BIGVALUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>CHAR_RIGHT_PARENTHESIS</name></expr>:</case>
      <expr_stmt><expr><name>inverbname</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <comment type="block">/* This is the length in characters */</comment>
      <expr_stmt><expr><name>verbnamelength</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>parsed_pattern</name> <operator>-</operator> <name>verblengthptr</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      <comment type="block">/* But the limit on the length is in code units */</comment>
      <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>-</operator> <name>verbnamestart</name> <operator>-</operator> <literal type="number">1</literal> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>MAX_MARK</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR76</name></expr>;</expr_stmt>
        <goto>goto <name>FAILED</name>;</goto>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>verblengthptr</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>verbnamelength</name></expr>;</expr_stmt>

      <comment type="block">/* If this name was on a verb such as (*ACCEPT) which does not continue,
      a (*MARK) was generated for the name. We now add the original verb as the
      next item. */</comment>

      <if_stmt><if>if <condition>(<expr><name>add_after_mark</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>add_after_mark</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>add_after_mark</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <case>case <expr><name>CHAR_BACKSLASH</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_ALT_VERBNAMES</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>escape</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>check_escape</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>, <argument><expr><name>options</name></expr></argument>,
          <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>cx</name><operator>-&gt;</operator><name>extra_options</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>errorcode</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>FAILED</name>;</goto></block_content></block></if></if_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>escape</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>   <comment type="block">/* Treat all as literal */</comment>

      <switch>switch<condition>(<expr><name>escape</name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><literal type="number">0</literal></expr>:</case>                    <comment type="block">/* Don't use PARSED_LITERAL() because it */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>    <comment type="block">/* sets okquantifier. */</comment>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <name>META_END</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_BIGVALUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>ESC_Q</name></expr>:</case>
        <expr_stmt><expr><name>inescq</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>ESC_E</name></expr>:</case>           <comment type="block">/* Ignore */</comment>
        <break>break;</break>

        <default>default:</default>
        <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR40</name></expr>;</expr_stmt>    <comment type="block">/* Invalid in verb name */</comment>
        <goto>goto <name>FAILED</name>;</goto>
        </block_content>}</block></switch>
      </block_content>}</block></switch>
    <continue>continue;</continue>   <comment type="block">/* Next character in pattern */</comment>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Not a verb name character. At this point we must process everything that
  must not change the quantification state. This is mainly comments, but we
  handle \Q and \E here as well, so that an item such as A\Q\E+ is treated as
  A+, as in Perl. An isolated \E is ignored. */</comment>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_BACKSLASH</name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>&lt;</operator> <name>ptrend</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_Q</name> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_E</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>inescq</name> <operator>=</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_Q</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
      <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Skip over whitespace and # comments in extended mode. Note that c is a
  character, not a code unit, so we must not use MAX_255 to test its size
  because MAX_255 tests code units and is assumed TRUE in 8-bit mode. The
  whitespace characters are those designated as "Pattern White Space" by
  Unicode, which are the isspace() characters plus CHAR_NEL (newline), which is
  U+0085 in Unicode, plus U+200E, U+200F, U+2028, and U+2029. These are a
  subset of space characters that match \h and \v. */</comment>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_EXTENDED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_space</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_NEL</name> <operator>||</operator> <operator>(</operator><name>c</name><operator>|</operator><literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x200f</literal> <operator>||</operator> <operator>(</operator><name>c</name><operator>|</operator><literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x2029</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_NUMBER_SIGN</name></expr>)</condition>
      <block>{<block_content>
      <while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IS_NEWLINE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>      <comment type="block">/* For non-fixed-length newline cases, */</comment>
          <block>{<block_content>                       <comment type="block">/* IS_NEWLINE sets cb-&gt;nllen. */</comment>
          <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>cb</name><operator>-&gt;</operator><name>nllen</name></name></expr>;</expr_stmt>
          <break>break;</break>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>FORWARDCHARTEST</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></while>
      <continue>continue;</continue>  <comment type="block">/* Next character in pattern */</comment>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Skip over bracketed comments */</comment>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_LEFT_PARENTHESIS</name> <operator>&amp;&amp;</operator> <name>ptrend</name> <operator>-</operator> <name>ptr</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
      <name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_QUESTION_MARK</name> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_NUMBER_SIGN</name></expr>)</condition>
    <block>{<block_content>
    <while>while <condition>(<expr><operator>++</operator><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_RIGHT_PARENTHESIS</name></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>
    <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR18</name></expr>;</expr_stmt>  <comment type="block">/* A special error for missing ) in a comment */</comment>
      <goto>goto <name>FAILED</name>;</goto>        <comment type="block">/* to make it easier to debug. */</comment>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
    <continue>continue;</continue>  <comment type="block">/* Next character in pattern */</comment>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the next item is not a quantifier, fill in length of any previous
  callout and create an auto callout if required. */</comment>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>CHAR_ASTERISK</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>CHAR_PLUS</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>CHAR_QUESTION_MARK</name> <operator>&amp;&amp;</operator>
       <operator>(</operator><name>c</name> <operator>!=</operator> <name>CHAR_LEFT_CURLY_BRACKET</name> <operator>||</operator>
         <operator>(</operator><name>tempptr</name> <operator>=</operator> <name>ptr</name><operator>,</operator>
         <operator>!</operator><call><name>read_repeat_counts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tempptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>after_manual_callout</name><operator>--</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>parsed_pattern</name> <operator>=</operator> <call><name>manage_callouts</name><argument_list>(<argument><expr><name>thisptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>previous_callout</name></expr></argument>, <argument><expr><name>auto_callout</name></expr></argument>,
        <argument><expr><name>parsed_pattern</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* If expect_cond_assert is 2, we have just passed (?( and are expecting an
  assertion, possibly preceded by a callout. If the value is 1, we have just
  had the callout and expect an assertion. There must be at least 3 more
  characters in all cases. When expect_cond_assert is 2, we know that the
  current character is an opening parenthesis, as otherwise we wouldn't be
  here. However, when it is 1, we need to check, and it's easiest just to check
  always. Note that expect_cond_assert may be negative, since all callouts just
  decrement it. */</comment>

  <if_stmt><if>if <condition>(<expr><name>expect_cond_assert</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>BOOL</name></type> <name>ok</name> <init>= <expr><name>c</name> <operator>==</operator> <name>CHAR_LEFT_PARENTHESIS</name> <operator>&amp;&amp;</operator> <name>ptrend</name> <operator>-</operator> <name>ptr</name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator>
              <operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_QUESTION_MARK</name> <operator>||</operator> <name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_ASTERISK</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ok</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_ASTERISK</name></expr>)</condition>  <comment type="block">/* New alpha assertion format, possibly */</comment>
        <block>{<block_content>
        <expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>MAX_255</name><argument_list>(<argument><expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_lcletter</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content> <switch>switch<condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>  <comment type="block">/* Traditional symbolic format */</comment>
        <block>{<block_content>
        <case>case <expr><name>CHAR_C</name></expr>:</case>
        <expr_stmt><expr><name>ok</name> <operator>=</operator> <name>expect_cond_assert</name> <operator>==</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><name>CHAR_EQUALS_SIGN</name></expr>:</case>
        <case>case <expr><name>CHAR_EXCLAMATION_MARK</name></expr>:</case>
        <break>break;</break>

        <case>case <expr><name>CHAR_LESS_THAN_SIGN</name></expr>:</case>
        <expr_stmt><expr><name>ok</name> <operator>=</operator> <name><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_EQUALS_SIGN</name> <operator>||</operator> <name><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_EXCLAMATION_MARK</name></expr>;</expr_stmt>
        <break>break;</break>

        <default>default:</default>
        <expr_stmt><expr><name>ok</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
        </block_content>}</block></switch></block_content></block></else></if_stmt>
      </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>   <comment type="block">/* Adjust error offset */</comment>
      <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR28</name></expr>;</expr_stmt>
      <goto>goto <name>FAILED</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Remember whether we are expecting a conditional assertion, and set the
  default for this item. */</comment>

  <expr_stmt><expr><name>prev_expect_cond_assert</name> <operator>=</operator> <name>expect_cond_assert</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>expect_cond_assert</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* Remember quantification status for the previous significant item, then set
  default for this item. */</comment>

  <expr_stmt><expr><name>prev_okquantifier</name> <operator>=</operator> <name>okquantifier</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>prev_meta_quantifier</name> <operator>=</operator> <name>meta_quantifier</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>okquantifier</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>meta_quantifier</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <comment type="block">/* If the previous significant item was a quantifier, adjust the parsed code
  if there is a following modifier. The base meta value is always followed by
  the PLUS and QUERY values, in that order. We do this here rather than after
  reading a quantifier so that intervening comments and /x whitespace can be
  ignored without having to replicate code. */</comment>

  <if_stmt><if>if <condition>(<expr><name>prev_meta_quantifier</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>==</operator> <name>CHAR_QUESTION_MARK</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>CHAR_PLUS</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name><name>parsed_pattern</name><index>[<expr><ternary><condition><expr><operator>(</operator><name>prev_meta_quantifier</name> <operator>==</operator> <name>META_MINMAX</name><operator>)</operator></expr>?</condition><then> <expr><operator>-</operator><literal type="number">3</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>]</index></name> <operator>=</operator>
      <name>prev_meta_quantifier</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>c</name> <operator>==</operator> <name>CHAR_QUESTION_MARK</name><operator>)</operator></expr>?</condition><then>
        <expr><literal type="number">0x00020000u</literal></expr> </then><else>: <expr><literal type="number">0x00010000u</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <continue>continue;</continue>  <comment type="block">/* Next character in pattern */</comment>
    </block_content>}</block></if></if_stmt>


  <comment type="block">/* Process the next item in the main part of a pattern. */</comment>

  <switch>switch<condition>(<expr><name>c</name></expr>)</condition>
    <block>{<block_content>
    <default>default:</default>              <comment type="block">/* Non-special character */</comment>
    <expr_stmt><expr><call><name>PARSED_LITERAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>parsed_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>


    <comment type="block">/* ---- Escape sequence ---- */</comment>

    <case>case <expr><name>CHAR_BACKSLASH</name></expr>:</case>
    <expr_stmt><expr><name>tempptr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>escape</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>check_escape</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>, <argument><expr><name>options</name></expr></argument>,
      <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>cx</name><operator>-&gt;</operator><name>extra_options</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>errorcode</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <label><name>ESCAPE_FAILED</name>:</label>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>extra_options</name> <operator>&amp;</operator> <name>PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>FAILED</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>tempptr</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <name>CHAR_BACKSLASH</name></expr>;</expr_stmt></block_content></block></if> <else>else
        <block>{<block_content>
        <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Get character value, increment pointer */</comment>
        </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>escape</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                 <comment type="block">/* Treat as literal character */</comment>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* The escape was a data escape or literal character. */</comment>

    <if_stmt><if>if <condition>(<expr><name>escape</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>PARSED_LITERAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>parsed_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>

    <comment type="block">/* The escape was a back (or forward) reference. We keep the offset in
    order to give a more useful diagnostic for a bad forward reference. For
    references to groups numbered less than 10 we can't use more than two items
    in parsed_pattern because they may be just two characters in the input (and
    in a 64-bit world an offset may need two elements). So for them, the offset
    of the first occurrent is held in a special vector. */</comment>

    <if type="elseif">else if <condition>(<expr><name>escape</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <name><name>cb</name><operator>-&gt;</operator><name>start_pattern</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>escape</name> <operator>=</operator> <operator>-</operator><name>escape</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_BACKREF</name> <operator>|</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>escape</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>escape</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>small_ref_offset</name><index>[<expr><name>escape</name></expr>]</index></name> <operator>==</operator> <name>PCRE2_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>small_ref_offset</name><index>[<expr><name>escape</name></expr>]</index></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><call><name>PUTOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>parsed_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>okquantifier</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></if>

    <comment type="block">/* The escape was a character class such as \d etc. or other special
    escape indicator such as \A or \X. Most of them generate just a single
    parsed item, but \P and \p are followed by a 16-bit type and a 16-bit
    value. They are supported only when Unicode is available. The type and
    value are packed into a single 32-bit value so that the whole sequences
    uses only two elements in the parsed_vector. This is because the same
    coding is used if \d (for example) is turned into \p{Nd} when PCRE2_UCP is
    set.

    There are also some cases where the escape sequence is followed by a name:
    \k{name}, \k&lt;name&gt;, and \k'name' are backreferences by name, and \g&lt;name&gt;
    and \g'name' are subroutine calls by name; \g{name} is a synonym for
    \k{name}. Note that \g&lt;number&gt; and \g'number' are handled by check_escape()
    and returned as a negative value (handled above). A name is coded as an
    offset into the pattern and a length. */</comment>

    <else>else<block type="pseudo"><block_content> <switch>switch <condition>(<expr><name>escape</name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>ESC_C</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NEVER_BACKSLASH_C</name></cpp:ifdef>
      <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR85</name></expr>;</expr_stmt>
      <goto>goto <name>ESCAPE_FAILED</name>;</goto>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NEVER_BACKSLASH_C</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR83</name></expr>;</expr_stmt>
        <goto>goto <name>ESCAPE_FAILED</name>;</goto>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>okquantifier</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_ESCAPE</name> <operator>+</operator> <name>escape</name></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>ESC_X</name></expr>:</case>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifndef>
      <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR45</name></expr>;</expr_stmt>   <comment type="block">/* Supported only with Unicode support */</comment>
      <goto>goto <name>ESCAPE_FAILED</name>;</goto>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <case>case <expr><name>ESC_H</name></expr>:</case>
      <case>case <expr><name>ESC_h</name></expr>:</case>
      <case>case <expr><name>ESC_N</name></expr>:</case>
      <case>case <expr><name>ESC_R</name></expr>:</case>
      <case>case <expr><name>ESC_V</name></expr>:</case>
      <case>case <expr><name>ESC_v</name></expr>:</case>
      <expr_stmt><expr><name>okquantifier</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_ESCAPE</name> <operator>+</operator> <name>escape</name></expr>;</expr_stmt>
      <break>break;</break>

      <default>default:</default>  <comment type="block">/* \A, \B, \b, \G, \K, \Z, \z cannot be quantified. */</comment>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_ESCAPE</name> <operator>+</operator> <name>escape</name></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/* Escapes that change in UCP mode. Note that PCRE2_UCP will never be set
      without Unicode support because it is checked when pcre2_compile() is
      called. */</comment>

      <case>case <expr><name>ESC_d</name></expr>:</case>
      <case>case <expr><name>ESC_D</name></expr>:</case>
      <case>case <expr><name>ESC_s</name></expr>:</case>
      <case>case <expr><name>ESC_S</name></expr>:</case>
      <case>case <expr><name>ESC_w</name></expr>:</case>
      <case>case <expr><name>ESC_W</name></expr>:</case>
      <expr_stmt><expr><name>okquantifier</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_ESCAPE</name> <operator>+</operator> <name>escape</name></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_ESCAPE</name> <operator>+</operator>
          <operator>(</operator><ternary><condition><expr><operator>(</operator><name>escape</name> <operator>==</operator> <name>ESC_d</name> <operator>||</operator> <name>escape</name> <operator>==</operator> <name>ESC_s</name> <operator>||</operator> <name>escape</name> <operator>==</operator> <name>ESC_w</name><operator>)</operator></expr>?</condition><then>
            <expr><name>ESC_p</name></expr> </then><else>: <expr><name>ESC_P</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <switch>switch<condition>(<expr><name>escape</name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>ESC_d</name></expr>:</case>
          <case>case <expr><name>ESC_D</name></expr>:</case>
          <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>PT_PC</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <name>ucp_Nd</name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>ESC_s</name></expr>:</case>
          <case>case <expr><name>ESC_S</name></expr>:</case>
          <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>PT_SPACE</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>ESC_w</name></expr>:</case>
          <case>case <expr><name>ESC_W</name></expr>:</case>
          <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>PT_WORD</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
          <break>break;</break>
          </block_content>}</block></switch>
        </block_content>}</block></else></if_stmt>
      <break>break;</break>

      <comment type="block">/* Unicode property matching */</comment>

      <case>case <expr><name>ESC_P</name></expr>:</case>
      <case>case <expr><name>ESC_p</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
        <block>{<block_content>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>negated</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint16_t</name></type> <name>ptype</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>pdata</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ucp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>negated</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pdata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
          <goto>goto <name>ESCAPE_FAILED</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>negated</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>escape</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>escape</name> <operator>==</operator> <name>ESC_P</name><operator>)</operator></expr>?</condition><then> <expr><name>ESC_p</name></expr> </then><else>: <expr><name>ESC_P</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_ESCAPE</name> <operator>+</operator> <name>escape</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>ptype</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <name>pdata</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>okquantifier</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
        </block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR45</name></expr>;</expr_stmt>
      <goto>goto <name>ESCAPE_FAILED</name>;</goto>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>  <comment type="block">/* End \P and \p */</comment>

      <comment type="block">/* When \g is used with quotes or angle brackets as delimiters, it is a
      numerical or named subroutine call, and control comes here. When used
      with brace delimiters it is a numberical back reference and does not come
      here because check_escape() returns it directly as a reference. \k is
      always a named back reference. */</comment>

      <case>case <expr><name>ESC_g</name></expr>:</case>
      <case>case <expr><name>ESC_k</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name> <operator>||</operator> <operator>(</operator><operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_LEFT_CURLY_BRACKET</name> <operator>&amp;&amp;</operator>
          <operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_LESS_THAN_SIGN</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_APOSTROPHE</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>escape</name> <operator>==</operator> <name>ESC_g</name><operator>)</operator></expr>?</condition><then> <expr><name>ERR57</name></expr> </then><else>: <expr><name>ERR69</name></expr></else></ternary></expr>;</expr_stmt>
        <goto>goto <name>ESCAPE_FAILED</name>;</goto>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>terminator</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_LESS_THAN_SIGN</name><operator>)</operator></expr>?</condition><then>
        <expr><name>CHAR_GREATER_THAN_SIGN</name></expr> </then><else>: <expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_APOSTROPHE</name><operator>)</operator></expr>?</condition><then>
        <expr><name>CHAR_APOSTROPHE</name></expr> </then><else>: <expr><name>CHAR_RIGHT_CURLY_BRACKET</name></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>

      <comment type="block">/* For a non-braced \g, check for a numerical recursion. */</comment>

      <if_stmt><if>if <condition>(<expr><name>escape</name> <operator>==</operator> <name>ESC_g</name> <operator>&amp;&amp;</operator> <name>terminator</name> <operator>!=</operator> <name>CHAR_RIGHT_CURLY_BRACKET</name></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>p</name> <init>= <expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>read_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name></expr></argument>, <argument><expr><name>MAX_GROUP_NUMBER</name></expr></argument>, <argument><expr><name>ERR61</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>)</argument_list></call></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name>ptrend</name> <operator>||</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <name>terminator</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR57</name></expr>;</expr_stmt>
            <goto>goto <name>ESCAPE_FAILED</name>;</goto>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
          <goto>goto <name>SET_RECURSION</name>;</goto>
          </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>errorcode</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>ESCAPE_FAILED</name>;</goto></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Not a numerical recursion */</comment>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>terminator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>namelen</name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>ESCAPE_FAILED</name>;</goto></block_content></block></if></if_stmt>

      <comment type="block">/* \k and \g when used with braces are back references, whereas \g used
      with quotes or angle brackets is a recursion */</comment>

      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator>
        <ternary><condition><expr><operator>(</operator><name>escape</name> <operator>==</operator> <name>ESC_k</name> <operator>||</operator> <name>terminator</name> <operator>==</operator> <name>CHAR_RIGHT_CURLY_BRACKET</name><operator>)</operator></expr>?</condition><then>
          <expr><name>META_BACKREF_BYNAME</name></expr> </then><else>: <expr><name>META_RECURSE_BYNAME</name></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>namelen</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>PUTOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>parsed_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>okquantifier</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <break>break;</break>  <comment type="block">/* End special escape processing */</comment>
      </block_content>}</block></switch></block_content></block></else></if_stmt>
    <break>break;</break>    <comment type="block">/* End escape sequence processing */</comment>


    <comment type="block">/* ---- Single-character special items ---- */</comment>

    <case>case <expr><name>CHAR_CIRCUMFLEX_ACCENT</name></expr>:</case>
    <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_CIRCUMFLEX</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>CHAR_DOLLAR_SIGN</name></expr>:</case>
    <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_DOLLAR</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>CHAR_DOT</name></expr>:</case>
    <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_DOT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>okquantifier</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <break>break;</break>


    <comment type="block">/* ---- Single-character quantifiers ---- */</comment>

    <case>case <expr><name>CHAR_ASTERISK</name></expr>:</case>
    <expr_stmt><expr><name>meta_quantifier</name> <operator>=</operator> <name>META_ASTERISK</name></expr>;</expr_stmt>
    <goto>goto <name>CHECK_QUANTIFIER</name>;</goto>

    <case>case <expr><name>CHAR_PLUS</name></expr>:</case>
    <expr_stmt><expr><name>meta_quantifier</name> <operator>=</operator> <name>META_PLUS</name></expr>;</expr_stmt>
    <goto>goto <name>CHECK_QUANTIFIER</name>;</goto>

    <case>case <expr><name>CHAR_QUESTION_MARK</name></expr>:</case>
    <expr_stmt><expr><name>meta_quantifier</name> <operator>=</operator> <name>META_QUERY</name></expr>;</expr_stmt>
    <goto>goto <name>CHECK_QUANTIFIER</name>;</goto>


    <comment type="block">/* ---- Potential {n,m} quantifier ---- */</comment>

    <case>case <expr><name>CHAR_LEFT_CURLY_BRACKET</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_repeat_counts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>min_repeat</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max_repeat</name></expr></argument>,
        <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>errorcode</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>FAILED</name>;</goto></block_content></block></if></if_stmt>     <comment type="block">/* Error in quantifier. */</comment>
      <expr_stmt><expr><call><name>PARSED_LITERAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>parsed_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Not a quantifier */</comment>
      <break>break;</break>                               <comment type="block">/* No more quantifier processing */</comment>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>meta_quantifier</name> <operator>=</operator> <name>META_MINMAX</name></expr>;</expr_stmt>
    <comment type="block">/* Fall through */</comment>


    <comment type="block">/* ---- Quantifier post-processing ---- */</comment>

    <comment type="block">/* Check that a quantifier is allowed after the previous item. */</comment>

    <label><name>CHECK_QUANTIFIER</name>:</label>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>prev_okquantifier</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR9</name></expr>;</expr_stmt>
      <goto>goto <name>FAILED_BACK</name>;</goto>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Most (*VERB)s are not allowed to be quantified, but an ungreedy
    quantifier can be useful for (*ACCEPT) - meaning "succeed on backtrack", a
    sort of negated (*COMMIT). We therefore allow (*ACCEPT) to be quantified by
    wrapping it in non-capturing brackets, but we have to allow for a preceding
    (*MARK) for when (*ACCEPT) has an argument. */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>parsed_pattern</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>META_ACCEPT</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
      <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>parsed_pattern</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>p</name> <operator>&gt;=</operator> <name>verbstartptr</name></expr>;</condition> <incr><expr><name>p</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
      <expr_stmt><expr><operator>*</operator><name>verbstartptr</name> <operator>=</operator> <name>META_NOCAPTURE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>parsed_pattern</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>META_KET</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>parsed_pattern</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Now we can put the quantifier into the parsed pattern vector. At this
    stage, we have only the basic quantifier. The check for a following + or ?
    modifier happens at the top of the loop, after any intervening comments
    have been removed. */</comment>

    <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>meta_quantifier</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_LEFT_CURLY_BRACKET</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>min_repeat</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>max_repeat</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <break>break;</break>


    <comment type="block">/* ---- Character class ---- */</comment>

    <case>case <expr><name>CHAR_LEFT_SQUARE_BRACKET</name></expr>:</case>
    <expr_stmt><expr><name>okquantifier</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

    <comment type="block">/* In another (POSIX) regex library, the ugly syntax [[:&lt;:]] and [[:&gt;:]] is
    used for "start of word" and "end of word". As these are otherwise illegal
    sequences, we don't break anything by recognizing them. They are replaced
    by \b(?=\w) and \b(?&lt;=\w) respectively. Sequences like [a[:&lt;:]] are
    erroneous and are handled by the normal code below. */</comment>

    <if_stmt><if>if <condition>(<expr><name>ptrend</name> <operator>-</operator> <name>ptr</name> <operator>&gt;=</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator>
         <operator>(</operator><call><call><name>PRIV</name><argument_list>(<argument><expr><name>strncmp_c8</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>STRING_WEIRD_STARTWORD</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
          <call><call><name>PRIV</name><argument_list>(<argument><expr><name>strncmp_c8</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>STRING_WEIRD_ENDWORD</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_ESCAPE</name> <operator>+</operator> <name>ESC_b</name></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_LESS_THAN_SIGN</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_LOOKAHEAD</name></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_LOOKBEHIND</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>has_lookbehind</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

        <comment type="block">/* The offset is used only for the "non-fixed length" error; this won't
        occur here, so just store zero. */</comment>

        <expr_stmt><expr><call><name>PUTOFFSET</name><argument_list>(<argument><expr><operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>parsed_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_ESCAPE</name> <operator>+</operator> <name>ESC_w</name></expr>;</expr_stmt></block_content></block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_ESCAPE</name> <operator>+</operator> <name>ESC_p</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>PT_WORD</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_KET</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* PCRE supports POSIX class stuff inside a class. Perl gives an error if
    they are encountered at the top level, so we'll do that too. */</comment>

    <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_COLON</name> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_DOT</name> <operator>||</operator>
         <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_EQUALS_SIGN</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <call><name>check_posix_syntax</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tempptr</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name>ptr</name><operator>--</operator> <operator>==</operator> <name>CHAR_COLON</name><operator>)</operator></expr>?</condition><then> <expr><name>ERR12</name></expr> </then><else>: <expr><name>ERR13</name></expr></else></ternary></expr>;</expr_stmt>
      <goto>goto <name>FAILED</name>;</goto>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process a regular character class. If the first character is '^', set
    the negation flag. If the first few characters (either before or after ^)
    are \Q\E or \E or space or tab in extended-more mode, we skip them too.
    This makes for compatibility with Perl. */</comment>

    <expr_stmt><expr><name>negate_class</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_BACKSLASH</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_E</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>ptrend</name> <operator>-</operator> <name>ptr</name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator>
             <macro><name>PRIV</name><argument_list>(<argument>strncmp_c8</argument>)</argument_list></macro><operator>(</operator><name>ptr</name><operator>,</operator> <name>STR_Q</name> <name>STR_BACKSLASH</name> <name>STR_E</name><operator>,</operator> <literal type="number">3</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
          <break>break;</break></block_content></block></else></if_stmt>
        </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_EXTENDED_MORE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
               <operator>(</operator><name>c</name> <operator>==</operator> <name>CHAR_SPACE</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>CHAR_HT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* Note: just these two */</comment>
        <continue>continue;</continue></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><operator>!</operator><name>negate_class</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <name>CHAR_CIRCUMFLEX_ACCENT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>negate_class</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content> <break>break;</break></block_content></block></else></if_stmt>
      </block_content>}</block></while>

    <comment type="block">/* Now the real contents of the class; c has the first "real" character.
    Empty classes are permitted only if the option is set. */</comment>

    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_RIGHT_SQUARE_BRACKET</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>external_options</name></name> <operator>&amp;</operator> <name>PCRE2_ALLOW_EMPTY_CLASS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><name>negate_class</name></expr>?</condition><then> <expr><name>META_CLASS_EMPTY_NOT</name></expr> </then><else>: <expr><name>META_CLASS_EMPTY</name></expr></else></ternary></expr>;</expr_stmt>
      <break>break;</break>  <comment type="block">/* End of class processing */</comment>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Process a non-empty class. */</comment>

    <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><name>negate_class</name></expr>?</condition><then> <expr><name>META_CLASS_NOT</name></expr> </then><else>: <expr><name>META_CLASS</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>class_range_state</name> <operator>=</operator> <name>RANGE_NO</name></expr>;</expr_stmt>

    <comment type="block">/* In an EBCDIC environment, Perl treats alphabetic ranges specially
    because there are holes in the encoding, and simply using the range A-Z
    (for example) would include the characters in the holes. This applies only
    to ranges where both values are literal; [\xC1-\xE9] is different to [A-Z]
    in this respect. In order to accommodate this, we keep track of whether
    character values are literal or not, and a state variable for handling
    ranges. */</comment>

    <comment type="block">/* Loop for the contents of the class */</comment>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
      <block>{<block_content>
      <decl_stmt><decl><type><name>BOOL</name></type> <name>char_is_literal</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Inside \Q...\E everything is literal except \E */</comment>

      <if_stmt><if>if <condition>(<expr><name>inescq</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_BACKSLASH</name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_E</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>inescq</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>                   <comment type="block">/* Reset literal state */</comment>
          <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>                            <comment type="block">/* Skip the 'E' */</comment>
          <goto>goto <name>CLASS_CONTINUE</name>;</goto>
          </block_content>}</block></if></if_stmt>
        <goto>goto <name>CLASS_LITERAL</name>;</goto>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Skip over space and tab (only) in extended-more mode. */</comment>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_EXTENDED_MORE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
          <operator>(</operator><name>c</name> <operator>==</operator> <name>CHAR_SPACE</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>CHAR_HT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>CLASS_CONTINUE</name>;</goto></block_content></block></if></if_stmt>

      <comment type="block">/* Handle POSIX class names. Perl allows a negation extension of the
      form [:^name:]. A square bracket that doesn't match the syntax is
      treated as a literal. We also recognize the POSIX constructions
      [.ch.] and [=ch=] ("collating elements") and fault them, as Perl
      5.6 and 5.8 do. */</comment>

      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_LEFT_SQUARE_BRACKET</name> <operator>&amp;&amp;</operator>
          <name>ptrend</name> <operator>-</operator> <name>ptr</name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator>
          <operator>(</operator><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_COLON</name> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_DOT</name> <operator>||</operator>
           <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_EQUALS_SIGN</name><operator>)</operator> <operator>&amp;&amp;</operator>
          <call><name>check_posix_syntax</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tempptr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>posix_negate</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>posix_class</name></decl>;</decl_stmt>

        <comment type="block">/* Perl treats a hyphen before a POSIX class as a literal, not the
        start of a range. However, it gives a warning in its warning mode. PCRE
        does not have a warning mode, so we give an error, because this is
        likely an error on the user's part. */</comment>

        <if_stmt><if>if <condition>(<expr><name>class_range_state</name> <operator>==</operator> <name>RANGE_STARTED</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR50</name></expr>;</expr_stmt>
          <goto>goto <name>FAILED</name>;</goto>
          </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_COLON</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR13</name></expr>;</expr_stmt>
          <goto>goto <name>FAILED_BACK</name>;</goto>
          </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><operator>++</operator><name>ptr</name><operator>)</operator> <operator>==</operator> <name>CHAR_CIRCUMFLEX_ACCENT</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>posix_negate</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>posix_class</name> <operator>=</operator> <call><name>check_posix_name</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>tempptr</name> <operator>-</operator> <name>ptr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>posix_class</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR30</name></expr>;</expr_stmt>
          <goto>goto <name>FAILED</name>;</goto>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>tempptr</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>

        <comment type="block">/* Perl treats a hyphen after a POSIX class as a literal, not the
        start of a range. However, it gives a warning in its warning mode
        unless the hyphen is the last character in the class. PCRE does not
        have a warning mode, so we give an error, because this is likely an
        error on the user's part. */</comment>

        <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_MINUS</name> <operator>&amp;&amp;</operator>
            <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>CHAR_RIGHT_SQUARE_BRACKET</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR50</name></expr>;</expr_stmt>
          <goto>goto <name>FAILED</name>;</goto>
          </block_content>}</block></if></if_stmt>

        <comment type="block">/* Set "a hyphen is not the start of a range" for the -] case, and also
        in case the POSIX class is followed by \E or \Q\E (possibly repeated -
        fuzzers do that kind of thing) and *then* a hyphen. This causes that
        hyphen to be treated as a literal. I don't think it's worth setting up
        special apparatus to do otherwise. */</comment>

        <expr_stmt><expr><name>class_range_state</name> <operator>=</operator> <name>RANGE_NO</name></expr>;</expr_stmt>

        <comment type="block">/* When PCRE2_UCP is set, some of the POSIX classes are converted to
        use Unicode properties \p or \P or, in one case, \h or \H. The
        substitutes table has two values per class, containing the type and
        value of a \p or \P item. The special cases are specified with a
        negative type: a non-zero value causes \h or \H to be used, and a zero
        value falls through to behave like a non-UCP POSIX class. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>ptype</name> <init>= <expr><name><name>posix_substitutes</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>posix_class</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>pvalue</name> <init>= <expr><name><name>posix_substitutes</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>posix_class</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_ESCAPE</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>posix_negate</name></expr>?</condition><then> <expr><name>ESC_P</name></expr> </then><else>: <expr><name>ESC_p</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>ptype</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <name>pvalue</name></expr>;</expr_stmt>
            <goto>goto <name>CLASS_CONTINUE</name>;</goto>
            </block_content>}</block></if></if_stmt>

          <if_stmt><if>if <condition>(<expr><name>pvalue</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_ESCAPE</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>posix_negate</name></expr>?</condition><then> <expr><name>ESC_H</name></expr> </then><else>: <expr><name>ESC_h</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
            <goto>goto <name>CLASS_CONTINUE</name>;</goto>
            </block_content>}</block></if></if_stmt>

          <comment type="block">/* Fall through */</comment>
          </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

        <comment type="block">/* Non-UCP POSIX class */</comment>

        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><name>posix_negate</name></expr>?</condition><then> <expr><name>META_POSIX_NEG</name></expr> </then><else>: <expr><name>META_POSIX</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>posix_class</name></expr>;</expr_stmt>
        </block_content>}</block></if>

      <comment type="block">/* Handle potential start of range */</comment>

      <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_MINUS</name> <operator>&amp;&amp;</operator> <name>class_range_state</name> <operator>&gt;=</operator> <name>RANGE_OK_ESCAPED</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>class_range_state</name> <operator>==</operator> <name>RANGE_OK_LITERAL</name><operator>)</operator></expr>?</condition><then>
          <expr><name>META_RANGE_LITERAL</name></expr> </then><else>: <expr><name>META_RANGE_ESCAPED</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name>class_range_state</name> <operator>=</operator> <name>RANGE_STARTED</name></expr>;</expr_stmt>
        </block_content>}</block></if>

      <comment type="block">/* Handle a literal character */</comment>

      <if type="elseif">else if <condition>(<expr><name>c</name> <operator>!=</operator> <name>CHAR_BACKSLASH</name></expr>)</condition>
        <block>{<block_content>
        <label><name>CLASS_LITERAL</name>:</label>
        <if_stmt><if>if <condition>(<expr><name>class_range_state</name> <operator>==</operator> <name>RANGE_STARTED</name></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name><name>parsed_pattern</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>       <comment type="block">/* Optimize one-char range */</comment>
            <expr_stmt><expr><name>parsed_pattern</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if>
          <if type="elseif">else if <condition>(<expr><name><name>parsed_pattern</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>&gt;</operator> <name>c</name></expr>)</condition>   <comment type="block">/* Check range is in order */</comment>
            <block>{<block_content>
            <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR8</name></expr>;</expr_stmt>
            <goto>goto <name>FAILED_BACK</name>;</goto>
            </block_content>}</block></if>
          <else>else
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>char_is_literal</name> <operator>&amp;&amp;</operator> <name><name>parsed_pattern</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>META_RANGE_LITERAL</name></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><name><name>parsed_pattern</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>META_RANGE_ESCAPED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>PARSED_LITERAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>parsed_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><name>class_range_state</name> <operator>=</operator> <name>RANGE_NO</name></expr>;</expr_stmt>
          </block_content>}</block></if>
        <else>else  <comment type="block">/* Potential start of range */</comment>
          <block>{<block_content>
          <expr_stmt><expr><name>class_range_state</name> <operator>=</operator> <ternary><condition><expr><name>char_is_literal</name></expr>?</condition><then>
            <expr><name>RANGE_OK_LITERAL</name></expr> </then><else>: <expr><name>RANGE_OK_ESCAPED</name></expr></else></ternary></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>PARSED_LITERAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>parsed_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>

      <comment type="block">/* Handle escapes in a class */</comment>

      <else>else
        <block>{<block_content>
        <expr_stmt><expr><name>tempptr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>escape</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>check_escape</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>, <argument><expr><name>options</name></expr></argument>,
          <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>cx</name><operator>-&gt;</operator><name>extra_options</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>errorcode</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name>extra_options</name> <operator>&amp;</operator> <name>PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>FAILED</name>;</goto></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>tempptr</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <name>CHAR_BACKSLASH</name></expr>;</expr_stmt></block_content></block></if> <else>else
            <block>{<block_content>
            <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Get character value, increment pointer */</comment>
            </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><name>escape</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                 <comment type="block">/* Treat as literal character */</comment>
          </block_content>}</block></if></if_stmt>

        <switch>switch<condition>(<expr><name>escape</name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><literal type="number">0</literal></expr>:</case>  <comment type="block">/* Escaped character code point is in c */</comment>
          <expr_stmt><expr><name>char_is_literal</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
          <goto>goto <name>CLASS_LITERAL</name>;</goto>

          <case>case <expr><name>ESC_b</name></expr>:</case>
          <expr_stmt><expr><name>c</name> <operator>=</operator> <name>CHAR_BS</name></expr>;</expr_stmt>    <comment type="block">/* \b is backspace in a class */</comment>
          <expr_stmt><expr><name>char_is_literal</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
          <goto>goto <name>CLASS_LITERAL</name>;</goto>

          <case>case <expr><name>ESC_Q</name></expr>:</case>
          <expr_stmt><expr><name>inescq</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>  <comment type="block">/* Enter literal mode */</comment>
          <goto>goto <name>CLASS_CONTINUE</name>;</goto>

          <case>case <expr><name>ESC_E</name></expr>:</case>     <comment type="block">/* Ignore orphan \E */</comment>
          <goto>goto <name>CLASS_CONTINUE</name>;</goto>

          <case>case <expr><name>ESC_B</name></expr>:</case>     <comment type="block">/* Always an error in a class */</comment>
          <case>case <expr><name>ESC_R</name></expr>:</case>
          <case>case <expr><name>ESC_X</name></expr>:</case>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR7</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>
          <goto>goto <name>FAILED</name>;</goto>
          </block_content>}</block></switch>

        <comment type="block">/* The second part of a range can be a single-character escape
        sequence (detected above), but not any of the other escapes. Perl
        treats a hyphen as a literal in such circumstances. However, in Perl's
        warning mode, a warning is given, so PCRE now faults it, as it is
        almost certainly a mistake on the user's part. */</comment>

        <if_stmt><if>if <condition>(<expr><name>class_range_state</name> <operator>==</operator> <name>RANGE_STARTED</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR50</name></expr>;</expr_stmt>
          <goto>goto <name>FAILED</name>;</goto>  <comment type="block">/* Not CLASS_ESCAPE_FAILED; always an error */</comment>
          </block_content>}</block></if></if_stmt>

        <comment type="block">/* Of the remaining escapes, only those that define characters are
        allowed in a class. None may start a range. */</comment>

        <expr_stmt><expr><name>class_range_state</name> <operator>=</operator> <name>RANGE_NO</name></expr>;</expr_stmt>
        <switch>switch<condition>(<expr><name>escape</name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>ESC_N</name></expr>:</case>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR71</name></expr>;</expr_stmt>
          <goto>goto <name>FAILED</name>;</goto>

          <case>case <expr><name>ESC_H</name></expr>:</case>
          <case>case <expr><name>ESC_h</name></expr>:</case>
          <case>case <expr><name>ESC_V</name></expr>:</case>
          <case>case <expr><name>ESC_v</name></expr>:</case>
          <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_ESCAPE</name> <operator>+</operator> <name>escape</name></expr>;</expr_stmt>
          <break>break;</break>

          <comment type="block">/* These escapes are converted to Unicode property tests when
          PCRE2_UCP is set. */</comment>

          <case>case <expr><name>ESC_d</name></expr>:</case>
          <case>case <expr><name>ESC_D</name></expr>:</case>
          <case>case <expr><name>ESC_s</name></expr>:</case>
          <case>case <expr><name>ESC_S</name></expr>:</case>
          <case>case <expr><name>ESC_w</name></expr>:</case>
          <case>case <expr><name>ESC_W</name></expr>:</case>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_ESCAPE</name> <operator>+</operator> <name>escape</name></expr>;</expr_stmt>
            </block_content>}</block></if>
          <else>else
            <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_ESCAPE</name> <operator>+</operator>
              <operator>(</operator><ternary><condition><expr><operator>(</operator><name>escape</name> <operator>==</operator> <name>ESC_d</name> <operator>||</operator> <name>escape</name> <operator>==</operator> <name>ESC_s</name> <operator>||</operator> <name>escape</name> <operator>==</operator> <name>ESC_w</name><operator>)</operator></expr>?</condition><then>
                <expr><name>ESC_p</name></expr> </then><else>: <expr><name>ESC_P</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
            <switch>switch<condition>(<expr><name>escape</name></expr>)</condition>
              <block>{<block_content>
              <case>case <expr><name>ESC_d</name></expr>:</case>
              <case>case <expr><name>ESC_D</name></expr>:</case>
              <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>PT_PC</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <name>ucp_Nd</name></expr>;</expr_stmt>
              <break>break;</break>

              <case>case <expr><name>ESC_s</name></expr>:</case>
              <case>case <expr><name>ESC_S</name></expr>:</case>
              <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>PT_SPACE</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
              <break>break;</break>

              <case>case <expr><name>ESC_w</name></expr>:</case>
              <case>case <expr><name>ESC_W</name></expr>:</case>
              <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>PT_WORD</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
              <break>break;</break>
              </block_content>}</block></switch>
            </block_content>}</block></else></if_stmt>
          <break>break;</break>

          <comment type="block">/* Explicit Unicode property matching */</comment>

          <case>case <expr><name>ESC_P</name></expr>:</case>
          <case>case <expr><name>ESC_p</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
            <block>{<block_content>
            <decl_stmt><decl><type><name>BOOL</name></type> <name>negated</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint16_t</name></type> <name>ptype</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>pdata</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_ucp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>negated</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pdata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
              <goto>goto <name>FAILED</name>;</goto></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>negated</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>escape</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>escape</name> <operator>==</operator> <name>ESC_P</name><operator>)</operator></expr>?</condition><then> <expr><name>ESC_p</name></expr> </then><else>: <expr><name>ESC_P</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_ESCAPE</name> <operator>+</operator> <name>escape</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>ptype</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <name>pdata</name></expr>;</expr_stmt>
            </block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR45</name></expr>;</expr_stmt>
          <goto>goto <name>FAILED</name>;</goto>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <break>break;</break>  <comment type="block">/* End \P and \p */</comment>

          <default>default:</default>    <comment type="block">/* All others are not allowed in a class */</comment>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR7</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>
          <goto>goto <name>FAILED</name>;</goto>
          </block_content>}</block></switch>

        <comment type="block">/* Perl gives a warning unless a following hyphen is the last character
        in the class. PCRE throws an error. */</comment>

        <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_MINUS</name> <operator>&amp;&amp;</operator>
            <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>CHAR_RIGHT_SQUARE_BRACKET</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR50</name></expr>;</expr_stmt>
          <goto>goto <name>FAILED</name>;</goto>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

      <comment type="block">/* Proceed to next thing in the class. */</comment>

      <label><name>CLASS_CONTINUE</name>:</label>
      <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR6</name></expr>;</expr_stmt>  <comment type="block">/* Missing terminating ']' */</comment>
        <goto>goto <name>FAILED</name>;</goto>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>GETCHARINCTEST</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_RIGHT_SQUARE_BRACKET</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>inescq</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>     <comment type="block">/* End of class-processing loop */</comment>

    <comment type="block">/* -] at the end of a class is a literal '-' */</comment>

    <if_stmt><if>if <condition>(<expr><name>class_range_state</name> <operator>==</operator> <name>RANGE_STARTED</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>parsed_pattern</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_MINUS</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>class_range_state</name> <operator>=</operator> <name>RANGE_NO</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_CLASS_END</name></expr>;</expr_stmt>
    <break>break;</break>  <comment type="block">/* End of character class */</comment>


    <comment type="block">/* ---- Opening parenthesis ---- */</comment>

    <case>case <expr><name>CHAR_LEFT_PARENTHESIS</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>UNCLOSED_PARENTHESIS</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* If ( is not followed by ? it is either a capture or a special verb or an
    alpha assertion or a positive non-atomic lookahead. */</comment>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_QUESTION_MARK</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vn</name></decl>;</decl_stmt>

      <comment type="block">/* Handle capturing brackets (or non-capturing if auto-capture is turned
      off). */</comment>

      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_ASTERISK</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>nest_depth</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NO_AUTO_CAPTURE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name> <operator>&gt;=</operator> <name>MAX_GROUP_NUMBER</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR97</name></expr>;</expr_stmt>
            <goto>goto <name>FAILED</name>;</goto>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_CAPTURE</name> <operator>|</operator> <name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name></expr>;</expr_stmt>
          </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_NOCAPTURE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>

      <comment type="block">/* Do nothing for (* followed by end of pattern or ) so it gives a "bad
      quantifier" error rather than "(*MARK) must have an argument". */</comment>

      <if type="elseif">else if <condition>(<expr><name>ptrend</name> <operator>-</operator> <name>ptr</name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>c</name> <operator>=</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>==</operator> <name>CHAR_RIGHT_PARENTHESIS</name></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if>

      <comment type="block">/* Handle "alpha assertions" such as (*pla:...). Most of these are
      synonyms for the historical symbolic assertions, but the script run and
      non-atomic lookaround ones are new. They are distinguished by starting
      with a lower case letter. Checking both ends of the alphabet makes this
      work in all character codes. */</comment>

      <if type="elseif">else if <condition>(<expr><call><name>CHMAX_255</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_lcletter</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>meta</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>vn</name> <operator>=</operator> <name>alasnames</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>namelen</name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>FAILED</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_COLON</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR95</name></expr>;</expr_stmt>  <comment type="block">/* Malformed */</comment>
          <goto>goto <name>FAILED</name>;</goto>
          </block_content>}</block></if></if_stmt>

        <comment type="block">/* Scan the table of alpha assertion names */</comment>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>alascount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>namelen</name> <operator>==</operator> <name><name>alasmeta</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>&amp;&amp;</operator>
              <call><call><name>PRIV</name><argument_list>(<argument><expr><name>strncmp_c8</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>vn</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>vn</name> <operator>+=</operator> <name><name>alasmeta</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>alascount</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR95</name></expr>;</expr_stmt>  <comment type="block">/* Alpha assertion not recognized */</comment>
          <goto>goto <name>FAILED</name>;</goto>
          </block_content>}</block></if></if_stmt>

        <comment type="block">/* Check for expecting an assertion condition. If so, only atomic
        lookaround assertions are valid. */</comment>

        <expr_stmt><expr><name>meta</name> <operator>=</operator> <name><name>alasmeta</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>meta</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>prev_expect_cond_assert</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>meta</name> <argument_list type="generic">&lt; <argument><expr><name>META_LOOKAHEAD</name> <operator>||</operator> <name>meta</name></expr></argument> &gt;</argument_list></name> <name>META_LOOKBEHINDNOT</name><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>meta</name> <operator>==</operator> <name>META_LOOKAHEAD_NA</name> <operator>||</operator> <name>meta</name> <operator>==</operator> <name>META_LOOKBEHIND_NA</name><operator>)</operator></expr>?</condition><then>
            <expr><name>ERR98</name></expr> </then><else>: <expr><name>ERR28</name></expr></else></ternary></expr>;</expr_stmt>  <comment type="block">/* (Atomic) assertion expected */</comment>
          <goto>goto <name>FAILED</name>;</goto>
          </block_content>}</block></if></if_stmt>

        <comment type="block">/* The lookaround alphabetic synonyms can mostly be handled by jumping
        to the code that handles the traditional symbolic forms. */</comment>

        <switch>switch<condition>(<expr><name>meta</name></expr>)</condition>
          <block>{<block_content>
          <default>default:</default>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR89</name></expr>;</expr_stmt>  <comment type="block">/* Unknown code; should never occur because */</comment>
          <goto>goto <name>FAILED</name>;</goto>        <comment type="block">/* the meta values come from a table above. */</comment>

          <case>case <expr><name>META_ATOMIC</name></expr>:</case>
          <goto>goto <name>ATOMIC_GROUP</name>;</goto>

          <case>case <expr><name>META_LOOKAHEAD</name></expr>:</case>
          <goto>goto <name>POSITIVE_LOOK_AHEAD</name>;</goto>

          <case>case <expr><name>META_LOOKAHEAD_NA</name></expr>:</case>
          <goto>goto <name>POSITIVE_NONATOMIC_LOOK_AHEAD</name>;</goto>

          <case>case <expr><name>META_LOOKAHEADNOT</name></expr>:</case>
          <goto>goto <name>NEGATIVE_LOOK_AHEAD</name>;</goto>

          <case>case <expr><name>META_LOOKBEHIND</name></expr>:</case>
          <case>case <expr><name>META_LOOKBEHINDNOT</name></expr>:</case>
          <case>case <expr><name>META_LOOKBEHIND_NA</name></expr>:</case>
          <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>meta</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>
          <goto>goto <name>POST_LOOKBEHIND</name>;</goto>

          <comment type="block">/* The script run facilities are handled here. Unicode support is
          required (give an error if not, as this is a security issue). Always
          record a META_SCRIPT_RUN item. Then, for the atomic version, insert
          META_ATOMIC and remember that we need two META_KETs at the end. */</comment>

          <case>case <expr><name>META_SCRIPT_RUN</name></expr>:</case>
          <case>case <expr><name>META_ATOMIC_SCRIPT_RUN</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
          <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_SCRIPT_RUN</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>nest_depth</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>meta</name> <operator>==</operator> <name>META_ATOMIC_SCRIPT_RUN</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_ATOMIC</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>top_nest</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>top_nest</name> <operator>=</operator> <operator>(</operator><name>nest_save</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>start_workspace</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><operator>++</operator><name>top_nest</name> <operator>&gt;=</operator> <name>end_nests</name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR84</name></expr>;</expr_stmt>
              <goto>goto <name>FAILED</name>;</goto>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>top_nest</name><operator>-&gt;</operator><name>nest_depth</name></name> <operator>=</operator> <name>nest_depth</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>top_nest</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>NSF_ATOMICSR</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>top_nest</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>options</name> <operator>&amp;</operator> <name>PARSE_TRACKED_OPTIONS</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <break>break;</break>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* SUPPORT_UNICODE */</comment>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR96</name></expr>;</expr_stmt>
          <goto>goto <name>FAILED</name>;</goto>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          </block_content>}</block></switch>
        </block_content>}</block></if>


      <comment type="block">/* ---- Handle (*VERB) and (*VERB:NAME) ---- */</comment>

      <else>else
        <block>{<block_content>
        <expr_stmt><expr><name>vn</name> <operator>=</operator> <name>verbnames</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>namelen</name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>FAILED</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name> <operator>||</operator> <operator>(</operator><operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_COLON</name> <operator>&amp;&amp;</operator>
                              <operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_RIGHT_PARENTHESIS</name><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR60</name></expr>;</expr_stmt>  <comment type="block">/* Malformed */</comment>
          <goto>goto <name>FAILED</name>;</goto>
          </block_content>}</block></if></if_stmt>

        <comment type="block">/* Scan the table of verb names */</comment>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>verbcount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>namelen</name> <operator>==</operator> <name><name>verbs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>&amp;&amp;</operator>
              <call><call><name>PRIV</name><argument_list>(<argument><expr><name>strncmp_c8</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>vn</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>vn</name> <operator>+=</operator> <name><name>verbs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>verbcount</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR60</name></expr>;</expr_stmt>  <comment type="block">/* Verb not recognized */</comment>
          <goto>goto <name>FAILED</name>;</goto>
          </block_content>}</block></if></if_stmt>

        <comment type="block">/* An empty argument is treated as no argument. */</comment>

        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_COLON</name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator>
             <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_RIGHT_PARENTHESIS</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* Advance to the closing parens */</comment>

        <comment type="block">/* Check for mandatory non-empty argument; this is (*MARK) */</comment>

        <if_stmt><if>if <condition>(<expr><name><name>verbs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>has_arg</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_COLON</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR66</name></expr>;</expr_stmt>
          <goto>goto <name>FAILED</name>;</goto>
          </block_content>}</block></if></if_stmt>

        <comment type="block">/* Remember where this verb, possibly with a preceding (*MARK), starts,
        for handling quantified (*ACCEPT). */</comment>

        <expr_stmt><expr><name>verbstartptr</name> <operator>=</operator> <name>parsed_pattern</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>okquantifier</name> <operator>=</operator> <operator>(</operator><name><name>verbs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>meta</name> <operator>==</operator> <name>META_ACCEPT</name><operator>)</operator></expr>;</expr_stmt>

        <comment type="block">/* It appears that Perl allows any characters whatsoever, other than a
        closing parenthesis, to appear in arguments ("names"), so we no longer
        insist on letters, digits, and underscores. Perl does not, however, do
        any interpretation within arguments, and has no means of including a
        closing parenthesis. PCRE supports escape processing but only when it
        is requested by an option. We set inverbname TRUE here, and let the
        main loop take care of this so that escape and \x processing is done by
        the main code above. */</comment>

        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>==</operator> <name>CHAR_COLON</name></expr>)</condition>   <comment type="block">/* Skip past : or ) */</comment>
          <block>{<block_content>
          <comment type="block">/* Some optional arguments can be treated as a preceding (*MARK) */</comment>

          <if_stmt><if>if <condition>(<expr><name><name>verbs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>has_arg</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>add_after_mark</name> <operator>=</operator> <name><name>verbs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>meta</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_MARK</name></expr>;</expr_stmt>
            </block_content>}</block></if>

          <comment type="block">/* The remaining verbs with arguments (except *MARK) need a different
          opcode. */</comment>

          <else>else
            <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name><name>verbs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>meta</name> <operator>+</operator>
              <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>verbs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>meta</name> <operator>!=</operator> <name>META_MARK</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0x00010000u</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

          <comment type="block">/* Set up for reading the name in the main loop. */</comment>

          <expr_stmt><expr><name>verblengthptr</name> <operator>=</operator> <name>parsed_pattern</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>verbnamestart</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>inverbname</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          </block_content>}</block></if>
        <else>else  <comment type="block">/* No verb "name" argument */</comment>
          <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name><name>verbs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>meta</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>     <comment type="block">/* End of (*VERB) handling */</comment>
      <break>break;</break>  <comment type="block">/* Done with this parenthesis */</comment>
      </block_content>}</block></if></if_stmt>       <comment type="block">/* End of groups that don't start with (? */</comment>


    <comment type="block">/* ---- Items starting (? ---- */</comment>

    <comment type="block">/* The type of item is determined by what follows (?. Handle (?| and option
    changes under "default" because both need a new block on the nest stack.
    Comments starting with (?# are handled above. Note that there is some
    ambiguity about the sequence (?- because if a digit follows it's a relative
    recursion or subroutine call whereas otherwise it's an option unsetting. */</comment>

    <if_stmt><if>if <condition>(<expr><operator>++</operator><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>UNCLOSED_PARENTHESIS</name>;</goto></block_content></block></if></if_stmt>

    <switch>switch<condition>(<expr><operator>*</operator><name>ptr</name></expr>)</condition>
      <block>{<block_content>
      <default>default:</default>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_MINUS</name> <operator>&amp;&amp;</operator> <name>ptrend</name> <operator>-</operator> <name>ptr</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>IS_DIGIT</name><argument_list>(<argument><expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>RECURSION_BYNUMBER</name>;</goto></block_content></block></if></if_stmt>  <comment type="block">/* The + case is handled by CHAR_PLUS */</comment>

      <comment type="block">/* We now have either (?| or a (possibly empty) option setting,
      optionally followed by a non-capturing group. */</comment>

      <expr_stmt><expr><name>nest_depth</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>top_nest</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>top_nest</name> <operator>=</operator> <operator>(</operator><name>nest_save</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>start_workspace</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><operator>++</operator><name>top_nest</name> <operator>&gt;=</operator> <name>end_nests</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR84</name></expr>;</expr_stmt>
        <goto>goto <name>FAILED</name>;</goto>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>top_nest</name><operator>-&gt;</operator><name>nest_depth</name></name> <operator>=</operator> <name>nest_depth</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>top_nest</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>top_nest</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>options</name> <operator>&amp;</operator> <name>PARSE_TRACKED_OPTIONS</name></expr>;</expr_stmt>

      <comment type="block">/* Start of non-capturing group that resets the capture count for each
      branch. */</comment>

      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_VERTICAL_LINE</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name><name>top_nest</name><operator>-&gt;</operator><name>reset_group</name></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>top_nest</name><operator>-&gt;</operator><name>max_group</name></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>top_nest</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>NSF_RESET</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>external_flags</name></name> <operator>|=</operator> <name>PCRE2_DUPCAPUSED</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_NOCAPTURE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>

      <comment type="block">/* Scan for options imnsxJU to be set or unset. */</comment>

      <else>else
        <block>{<block_content>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>hyphenok</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>oldoptions</name> <init>= <expr><name>options</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>top_nest</name><operator>-&gt;</operator><name>reset_group</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>top_nest</name><operator>-&gt;</operator><name>max_group</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>set</name> <operator>=</operator> <name>unset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>optset</name> <operator>=</operator> <operator>&amp;</operator><name>set</name></expr>;</expr_stmt>

        <comment type="block">/* ^ at the start unsets imnsx and disables the subsequent use of - */</comment>

        <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_CIRCUMFLEX_ACCENT</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>options</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>PCRE2_CASELESS</name><operator>|</operator><name>PCRE2_MULTILINE</name><operator>|</operator><name>PCRE2_NO_AUTO_CAPTURE</name><operator>|</operator>
                       <name>PCRE2_DOTALL</name><operator>|</operator><name>PCRE2_EXTENDED</name><operator>|</operator><name>PCRE2_EXTENDED_MORE</name><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>hyphenok</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

        <while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_RIGHT_PARENTHESIS</name> <operator>&amp;&amp;</operator>
                               <operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_COLON</name></expr>)</condition>
          <block>{<block_content>
          <switch>switch <condition>(<expr><operator>*</operator><name>ptr</name><operator>++</operator></expr>)</condition>
            <block>{<block_content>
            <case>case <expr><name>CHAR_MINUS</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>hyphenok</name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR94</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* Correct the offset */</comment>
              <goto>goto <name>FAILED</name>;</goto>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>optset</name> <operator>=</operator> <operator>&amp;</operator><name>unset</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>hyphenok</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
            <break>break;</break>

            <case>case <expr><name>CHAR_J</name></expr>:</case>  <comment type="block">/* Record that it changed in the external options */</comment>
            <expr_stmt><expr><operator>*</operator><name>optset</name> <operator>|=</operator> <name>PCRE2_DUPNAMES</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>external_flags</name></name> <operator>|=</operator> <name>PCRE2_JCHANGED</name></expr>;</expr_stmt>
            <break>break;</break>

            <case>case <expr><name>CHAR_i</name></expr>:</case> <expr_stmt><expr><operator>*</operator><name>optset</name> <operator>|=</operator> <name>PCRE2_CASELESS</name></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><name>CHAR_m</name></expr>:</case> <expr_stmt><expr><operator>*</operator><name>optset</name> <operator>|=</operator> <name>PCRE2_MULTILINE</name></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><name>CHAR_n</name></expr>:</case> <expr_stmt><expr><operator>*</operator><name>optset</name> <operator>|=</operator> <name>PCRE2_NO_AUTO_CAPTURE</name></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><name>CHAR_s</name></expr>:</case> <expr_stmt><expr><operator>*</operator><name>optset</name> <operator>|=</operator> <name>PCRE2_DOTALL</name></expr>;</expr_stmt> <break>break;</break>
            <case>case <expr><name>CHAR_U</name></expr>:</case> <expr_stmt><expr><operator>*</operator><name>optset</name> <operator>|=</operator> <name>PCRE2_UNGREEDY</name></expr>;</expr_stmt> <break>break;</break>

            <comment type="block">/* If x appears twice it sets the extended extended option. */</comment>

            <case>case <expr><name>CHAR_x</name></expr>:</case>
            <expr_stmt><expr><operator>*</operator><name>optset</name> <operator>|=</operator> <name>PCRE2_EXTENDED</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_x</name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><operator>*</operator><name>optset</name> <operator>|=</operator> <name>PCRE2_EXTENDED_MORE</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <break>break;</break>

            <default>default:</default>
            <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR11</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>    <comment type="block">/* Correct the offset */</comment>
            <goto>goto <name>FAILED</name>;</goto>
            </block_content>}</block></switch>
          </block_content>}</block></while>

        <comment type="block">/* If we are setting extended without extended-more, ensure that any
        existing extended-more gets unset. Also, unsetting extended must also
        unset extended-more. */</comment>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>set</name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_EXTENDED</name><operator>|</operator><name>PCRE2_EXTENDED_MORE</name><operator>)</operator><operator>)</operator> <operator>==</operator> <name>PCRE2_EXTENDED</name> <operator>||</operator>
            <operator>(</operator><name>unset</name> <operator>&amp;</operator> <name>PCRE2_EXTENDED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>unset</name> <operator>|=</operator> <name>PCRE2_EXTENDED_MORE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>options</name> <operator>=</operator> <operator>(</operator><name>options</name> <operator>|</operator> <name>set</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><operator>~</operator><name>unset</name><operator>)</operator></expr>;</expr_stmt>

        <comment type="block">/* If the options ended with ')' this is not the start of a nested
        group with option changes, so the options change at this level.
        In this case, if the previous level set up a nest block, discard the
        one we have just created. Otherwise adjust it for the previous level.
        If the options ended with ':' we are starting a non-capturing group,
        possibly with an options setting. */</comment>

        <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>UNCLOSED_PARENTHESIS</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>==</operator> <name>CHAR_RIGHT_PARENTHESIS</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>nest_depth</name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* This is not a nested group after all. */</comment>
          <if_stmt><if>if <condition>(<expr><name>top_nest</name> <operator>&gt;</operator> <operator>(</operator><name>nest_save</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>start_workspace</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
              <operator>(</operator><name>top_nest</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>nest_depth</name> <operator>==</operator> <name>nest_depth</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>top_nest</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if>
          <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name><name>top_nest</name><operator>-&gt;</operator><name>nest_depth</name></name> <operator>=</operator> <name>nest_depth</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
          </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_NOCAPTURE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* If nothing changed, no need to record. */</comment>

        <if_stmt><if>if <condition>(<expr><name>options</name> <operator>!=</operator> <name>oldoptions</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_OPTIONS</name></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>options</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>     <comment type="block">/* End options processing */</comment>
      <break>break;</break>  <comment type="block">/* End default case after (? */</comment>


      <comment type="block">/* ---- Python syntax support ---- */</comment>

      <case>case <expr><name>CHAR_P</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>++</operator><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>UNCLOSED_PARENTHESIS</name>;</goto></block_content></block></if></if_stmt>

      <comment type="block">/* (?P&lt;name&gt; is the same as (?&lt;name&gt;, which defines a named group. */</comment>

      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_LESS_THAN_SIGN</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>terminator</name> <operator>=</operator> <name>CHAR_GREATER_THAN_SIGN</name></expr>;</expr_stmt>
        <goto>goto <name>DEFINE_NAME</name>;</goto>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* (?P&gt;name) is the same as (?&amp;name), which is a recursion or subroutine
      call. */</comment>

      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_GREATER_THAN_SIGN</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>RECURSE_BY_NAME</name>;</goto></block_content></block></if></if_stmt>

      <comment type="block">/* (?P=name) is the same as \k&lt;name&gt;, a back reference by name. Anything
      else after (?P is an error. */</comment>

      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_EQUALS_SIGN</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR41</name></expr>;</expr_stmt>
        <goto>goto <name>FAILED</name>;</goto>
        </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>CHAR_RIGHT_PARENTHESIS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name>namelen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>FAILED</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_BACKREF_BYNAME</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>namelen</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PUTOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>parsed_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>okquantifier</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <break>break;</break>   <comment type="block">/* End of (?P processing */</comment>


      <comment type="block">/* ---- Recursion/subroutine calls by number ---- */</comment>

      <case>case <expr><name>CHAR_R</name></expr>:</case>
      <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>         <comment type="block">/* (?R) == (?R0) */</comment>
      <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_RIGHT_PARENTHESIS</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR58</name></expr>;</expr_stmt>
        <goto>goto <name>FAILED</name>;</goto>
        </block_content>}</block></if></if_stmt>
      <goto>goto <name>SET_RECURSION</name>;</goto>

      <comment type="block">/* An item starting (?- followed by a digit comes here via the "default"
      case because (?- followed by a non-digit is an options setting. */</comment>

      <case>case <expr><name>CHAR_PLUS</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>ptrend</name> <operator>-</operator> <name>ptr</name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>||</operator> <operator>!</operator><call><name>IS_DIGIT</name><argument_list>(<argument><expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR29</name></expr>;</expr_stmt>   <comment type="block">/* Missing number */</comment>
        <goto>goto <name>FAILED</name>;</goto>
        </block_content>}</block></if></if_stmt>
      <comment type="block">/* Fall through */</comment>

      <case>case <expr><name>CHAR_0</name></expr>:</case> <case>case <expr><name>CHAR_1</name></expr>:</case> <case>case <expr><name>CHAR_2</name></expr>:</case> <case>case <expr><name>CHAR_3</name></expr>:</case> <case>case <expr><name>CHAR_4</name></expr>:</case>
      <case>case <expr><name>CHAR_5</name></expr>:</case> <case>case <expr><name>CHAR_6</name></expr>:</case> <case>case <expr><name>CHAR_7</name></expr>:</case> <case>case <expr><name>CHAR_8</name></expr>:</case> <case>case <expr><name>CHAR_9</name></expr>:</case>
      <label><name>RECURSION_BYNUMBER</name>:</label>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>,
          <argument><expr><ternary><condition><expr><operator>(</operator><call><name>IS_DIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call><operator>)</operator></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>:<expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name><operator>)</operator></expr></else></ternary></expr></argument>, <comment type="block">/* + and - are relative */</comment>
          <argument><expr><name>MAX_GROUP_NUMBER</name></expr></argument>, <argument><expr><name>ERR61</name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>FAILED</name>;</goto></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>  <comment type="block">/* NB (?0) is permitted */</comment>
        <block>{<block_content>
        <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR15</name></expr>;</expr_stmt>   <comment type="block">/* Unknown group */</comment>
        <goto>goto <name>FAILED_BACK</name>;</goto>
        </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_RIGHT_PARENTHESIS</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>UNCLOSED_PARENTHESIS</name>;</goto></block_content></block></if></if_stmt>

      <label><name>SET_RECURSION</name>:</label>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_RECURSE</name> <operator>|</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>i</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <name><name>cb</name><operator>-&gt;</operator><name>start_pattern</name></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PUTOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>parsed_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>okquantifier</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <break>break;</break>  <comment type="block">/* End of recursive call by number handling */</comment>


      <comment type="block">/* ---- Recursion/subroutine calls by name ---- */</comment>

      <case>case <expr><name>CHAR_AMPERSAND</name></expr>:</case>
      <label><name>RECURSE_BY_NAME</name>:</label>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>CHAR_RIGHT_PARENTHESIS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name>namelen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>FAILED</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_RECURSE_BYNAME</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>namelen</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PUTOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>parsed_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>okquantifier</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/* ---- Callout with numerical or string argument ---- */</comment>

      <case>case <expr><name>CHAR_C</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>++</operator><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>UNCLOSED_PARENTHESIS</name>;</goto></block_content></block></if></if_stmt>

      <comment type="block">/* If the previous item was a condition starting (?(? an assertion,
      optionally preceded by a callout, is expected. This is checked later on,
      during actual compilation. However we need to identify this kind of
      assertion in this pass because it must not be qualified. The value of
      expect_cond_assert is set to 2 after (?(? is processed. We decrement it
      for a callout - still leaving a positive value that identifies the
      assertion. Multiple callouts or any other items will make it zero or
      less, which doesn't matter because they will cause an error later. */</comment>

      <expr_stmt><expr><name>expect_cond_assert</name> <operator>=</operator> <name>prev_expect_cond_assert</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

      <comment type="block">/* If previous_callout is not NULL, it means this follows a previous
      callout. If it was a manual callout, do nothing; this means its "length
      of next pattern item" field will remain zero. If it was an automatic
      callout, abolish it. */</comment>

      <if_stmt><if>if <condition>(<expr><name>previous_callout</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_AUTO_CALLOUT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
          <name>previous_callout</name> <operator>==</operator> <name>parsed_pattern</name> <operator>-</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator>
          <name><name>parsed_pattern</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">255</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>parsed_pattern</name> <operator>=</operator> <name>previous_callout</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <comment type="block">/* Save for updating next pattern item length, and skip one item before
      completing. */</comment>

      <expr_stmt><expr><name>previous_callout</name> <operator>=</operator> <name>parsed_pattern</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>after_manual_callout</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

      <comment type="block">/* Handle a string argument; specific delimiter is required. */</comment>

      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_RIGHT_PARENTHESIS</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_DIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>calloutlength</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>startptr</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>delimiter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><call><name>PRIV</name><argument_list>(<argument><expr><name>callout_start_delims</name></expr></argument>)</argument_list></call><index>[<expr><name>i</name></expr>]</index> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>callout_start_delims</name></expr></argument>)</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>delimiter</name> <operator>=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>callout_end_delims</name></expr></argument>)</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>
            <break>break;</break>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>delimiter</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR82</name></expr>;</expr_stmt>
          <goto>goto <name>FAILED</name>;</goto>
          </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name> <operator>=</operator> <name>META_CALLOUT_STRING</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>parsed_pattern</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>   <comment type="block">/* Skip pattern info */</comment>

        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>++</operator><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR81</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>startptr</name></expr>;</expr_stmt>   <comment type="block">/* To give a more useful message */</comment>
            <goto>goto <name>FAILED</name>;</goto>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>delimiter</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>++</operator><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <name>delimiter</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
          </block_content>}</block></for>

        <expr_stmt><expr><name>calloutlength</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <name>startptr</name><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>calloutlength</name> <operator>&gt;</operator> <name>UINT32_MAX</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR72</name></expr>;</expr_stmt>
          <goto>goto <name>FAILED</name>;</goto>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>calloutlength</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>startptr</name> <operator>-</operator> <name><name>cb</name><operator>-&gt;</operator><name>start_pattern</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PUTOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>parsed_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>

      <comment type="block">/* Handle a callout with an optional numerical argument, which must be
      less than or equal to 255. A missing argument gives 0. */</comment>

      <else>else
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name> <operator>=</operator> <name>META_CALLOUT_NUMBER</name></expr>;</expr_stmt>     <comment type="block">/* Numerical callout */</comment>
        <expr_stmt><expr><name>parsed_pattern</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>                       <comment type="block">/* Skip pattern info */</comment>
        <while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>ptrend</name> <operator>&amp;&amp;</operator> <call><name>IS_DIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>n</name> <operator>=</operator> <name>n</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>*</operator><name>ptr</name><operator>++</operator> <operator>-</operator> <name>CHAR_0</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR38</name></expr>;</expr_stmt>
            <goto>goto <name>FAILED</name>;</goto>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></while>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

      <comment type="block">/* Both formats must have a closing parenthesis */</comment>

      <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_RIGHT_PARENTHESIS</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR39</name></expr>;</expr_stmt>
        <goto>goto <name>FAILED</name>;</goto>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>

      <comment type="block">/* Remember the offset to the next item in the pattern, and set a default
      length. This should get updated after the next item is read. */</comment>

      <expr_stmt><expr><name><name>previous_callout</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <name><name>cb</name><operator>-&gt;</operator><name>start_pattern</name></name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>previous_callout</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <break>break;</break>                  <comment type="block">/* End callout */</comment>


      <comment type="block">/* ---- Conditional group ---- */</comment>

      <comment type="block">/* A condition can be an assertion, a number (referring to a numbered
      group's having been set), a name (referring to a named group), or 'R',
      referring to overall recursion. R&lt;digits&gt; and R&amp;name are also permitted
      for recursion state tests. Numbers may be preceded by + or - to specify a
      relative group number.

      There are several syntaxes for testing a named group: (?(name)) is used
      by Python; Perl 5.10 onwards uses (?(&lt;name&gt;) or (?('name')).

      There are two unfortunate ambiguities. 'R' can be the recursive thing or
      the name 'R' (and similarly for 'R' followed by digits). 'DEFINE' can be
      the Perl DEFINE feature or the Python named test. We look for a name
      first; if not found, we try the other case.

      For compatibility with auto-callouts, we allow a callout to be specified
      before a condition that is an assertion. */</comment>

      <case>case <expr><name>CHAR_LEFT_PARENTHESIS</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>++</operator><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>UNCLOSED_PARENTHESIS</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>nest_depth</name><operator>++</operator></expr>;</expr_stmt>

      <comment type="block">/* If the next character is ? or * there must be an assertion next
      (optionally preceded by a callout). We do not check this here, but
      instead we set expect_cond_assert to 2. If this is still greater than
      zero (callouts decrement it) when the next assertion is read, it will be
      marked as a condition that must not be repeated. A value greater than
      zero also causes checking that an assertion (possibly with callout)
      follows. */</comment>

      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_QUESTION_MARK</name> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_ASTERISK</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_COND_ASSERT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>   <comment type="block">/* Pull pointer back to the opening parenthesis. */</comment>
        <expr_stmt><expr><name>expect_cond_assert</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <break>break;</break>  <comment type="block">/* End of conditional */</comment>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Handle (?([+-]number)... */</comment>

      <if_stmt><if>if <condition>(<expr><call><name>read_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name></expr></argument>, <argument><expr><name>MAX_GROUP_NUMBER</name></expr></argument>, <argument><expr><name>ERR61</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR15</name></expr>;</expr_stmt>
          <goto>goto <name>FAILED</name>;</goto>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_COND_NUMBER</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <name><name>cb</name><operator>-&gt;</operator><name>start_pattern</name></name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PUTOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>parsed_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>errorcode</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>FAILED</name>;</goto></block_content></block></if>   <comment type="block">/* Number too big */</comment>

      <comment type="block">/* No number found. Handle the special case (?(VERSION[&gt;]=n.m)... */</comment>

      <if type="elseif">else if <condition>(<expr><name>ptrend</name> <operator>-</operator> <name>ptr</name> <operator>&gt;=</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator>
               <call><call><name>PRIV</name><argument_list>(<argument><expr><name>strncmp_c8</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>STRING_VERSION</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
               <name><name>ptr</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>!=</operator> <name>CHAR_RIGHT_PARENTHESIS</name></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>ge</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>major</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>minor</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_GREATER_THAN_SIGN</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>ge</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

        <comment type="block">/* NOTE: cannot write IS_DIGIT(*(++ptr)) here because IS_DIGIT
        references its argument twice. */</comment>

        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_EQUALS_SIGN</name> <operator>||</operator> <operator>(</operator><name>ptr</name><operator>++</operator><operator>,</operator> <operator>!</operator><call><name>IS_DIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
          <goto>goto <name>BAD_VERSION_CONDITION</name>;</goto></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>, <argument><expr><name>ERR79</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>major</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
          <goto>goto <name>FAILED</name>;</goto></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>BAD_VERSION_CONDITION</name>;</goto></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_DOT</name></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>++</operator><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name> <operator>||</operator> <operator>!</operator><call><name>IS_DIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>BAD_VERSION_CONDITION</name>;</goto></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>minor</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>ptr</name><operator>++</operator> <operator>-</operator> <name>CHAR_0</name><operator>)</operator> <operator>*</operator> <literal type="number">10</literal></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>BAD_VERSION_CONDITION</name>;</goto></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><call><name>IS_DIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>minor</name> <operator>+=</operator> <operator>*</operator><name>ptr</name><operator>++</operator> <operator>-</operator> <name>CHAR_0</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_RIGHT_PARENTHESIS</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>BAD_VERSION_CONDITION</name>;</goto></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_COND_VERSION</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>ge</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>major</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>minor</name></expr>;</expr_stmt>
        </block_content>}</block></if>

      <comment type="block">/* All the remaining cases now require us to read a name. We cannot at
      this stage distinguish ambiguous cases such as (?(R12) which might be a
      recursion test by number or a name, because the named groups have not yet
      all been identified. Those cases are treated as names, but given a
      different META code. */</comment>

      <else>else
        <block>{<block_content>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>was_r_ampersand</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_R</name> <operator>&amp;&amp;</operator> <name>ptrend</name> <operator>-</operator> <name>ptr</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_AMPERSAND</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>terminator</name> <operator>=</operator> <name>CHAR_RIGHT_PARENTHESIS</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>was_r_ampersand</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_LESS_THAN_SIGN</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>terminator</name> <operator>=</operator> <name>CHAR_GREATER_THAN_SIGN</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>CHAR_APOSTROPHE</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>terminator</name> <operator>=</operator> <name>CHAR_APOSTROPHE</name></expr>;</expr_stmt></block_content></block></if>
        <else>else
          <block>{<block_content>
          <expr_stmt><expr><name>terminator</name> <operator>=</operator> <name>CHAR_RIGHT_PARENTHESIS</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>   <comment type="block">/* Point to char before name */</comment>
          </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>terminator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>namelen</name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>FAILED</name>;</goto></block_content></block></if></if_stmt>

        <comment type="block">/* Handle (?(R&amp;name) */</comment>

        <if_stmt><if>if <condition>(<expr><name>was_r_ampersand</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name> <operator>=</operator> <name>META_COND_RNAME</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>   <comment type="block">/* Back to closing parens */</comment>
          </block_content>}</block></if>

        <comment type="block">/* Handle (?(name). If the name is "DEFINE" we identify it with a
        special code. Likewise if the name consists of R followed only by
        digits. Otherwise, handle it like a quoted name. */</comment>

        <if type="elseif">else if <condition>(<expr><name>terminator</name> <operator>==</operator> <name>CHAR_RIGHT_PARENTHESIS</name></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>namelen</name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>strncmp_c8</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>STRING_DEFINE</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name> <operator>=</operator> <name>META_COND_DEFINE</name></expr>;</expr_stmt></block_content></block></if>
          <else>else
            <block>{<block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>namelen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
              <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_DIGIT</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
            <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name>name</name> <operator>==</operator> <name>CHAR_R</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>namelen</name><operator>)</operator></expr>?</condition><then>
              <expr><name>META_COND_RNUMBER</name></expr> </then><else>: <expr><name>META_COND_NAME</name></expr></else></ternary></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          <expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>   <comment type="block">/* Back to closing parens */</comment>
          </block_content>}</block></if>

        <comment type="block">/* Handle (?('name') or (?(&lt;name&gt;) */</comment>

        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name> <operator>=</operator> <name>META_COND_NAME</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* All these cases except DEFINE end with the name length and offset;
        DEFINE just has an offset (for the "too many branches" error). */</comment>

        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>!=</operator> <name>META_COND_DEFINE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>namelen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>PUTOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>parsed_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>  <comment type="block">/* End cases that read a name */</comment>

      <comment type="block">/* Check the closing parenthesis of the condition */</comment>

      <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name> <operator>||</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <name>CHAR_RIGHT_PARENTHESIS</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR24</name></expr>;</expr_stmt>
        <goto>goto <name>FAILED</name>;</goto>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
      <break>break;</break>  <comment type="block">/* End of condition processing */</comment>


      <comment type="block">/* ---- Atomic group ---- */</comment>

      <case>case <expr><name>CHAR_GREATER_THAN_SIGN</name></expr>:</case>
      <label><name>ATOMIC_GROUP</name>:</label>                          <comment type="block">/* Come from (*atomic: */</comment>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_ATOMIC</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nest_depth</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
      <break>break;</break>


      <comment type="block">/* ---- Lookahead assertions ---- */</comment>

      <case>case <expr><name>CHAR_EQUALS_SIGN</name></expr>:</case>
      <label><name>POSITIVE_LOOK_AHEAD</name>:</label>                   <comment type="block">/* Come from (*pla: */</comment>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_LOOKAHEAD</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
      <goto>goto <name>POST_ASSERTION</name>;</goto>

      <case>case <expr><name>CHAR_ASTERISK</name></expr>:</case>
      <label><name>POSITIVE_NONATOMIC_LOOK_AHEAD</name>:</label>         <comment type="block">/* Come from (?* */</comment>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_LOOKAHEAD_NA</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
      <goto>goto <name>POST_ASSERTION</name>;</goto>

      <case>case <expr><name>CHAR_EXCLAMATION_MARK</name></expr>:</case>
      <label><name>NEGATIVE_LOOK_AHEAD</name>:</label>                   <comment type="block">/* Come from (*nla: */</comment>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_LOOKAHEADNOT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
      <goto>goto <name>POST_ASSERTION</name>;</goto>


      <comment type="block">/* ---- Lookbehind assertions ---- */</comment>

      <comment type="block">/* (?&lt; followed by = or ! or * is a lookbehind assertion. Otherwise (?&lt;
      is the start of the name of a capturing group. */</comment>

      <case>case <expr><name>CHAR_LESS_THAN_SIGN</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>ptrend</name> <operator>-</operator> <name>ptr</name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>||</operator>
         <operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>CHAR_EQUALS_SIGN</name> <operator>&amp;&amp;</operator>
          <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>CHAR_EXCLAMATION_MARK</name> <operator>&amp;&amp;</operator>
          <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>CHAR_ASTERISK</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>terminator</name> <operator>=</operator> <name>CHAR_GREATER_THAN_SIGN</name></expr>;</expr_stmt>
        <goto>goto <name>DEFINE_NAME</name>;</goto>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_EQUALS_SIGN</name><operator>)</operator></expr>?</condition><then>
        <expr><name>META_LOOKBEHIND</name></expr> </then><else>: <expr><ternary><condition><expr><operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_EXCLAMATION_MARK</name><operator>)</operator></expr>?</condition><then>
        <expr><name>META_LOOKBEHINDNOT</name></expr> </then><else>: <expr><name>META_LOOKBEHIND_NA</name></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>

      <label><name>POST_LOOKBEHIND</name>:</label>           <comment type="block">/* Come from (*plb: (*naplb: and (*nlb: */</comment>
      <expr_stmt><expr><operator>*</operator><name>has_lookbehind</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <name><name>cb</name><operator>-&gt;</operator><name>start_pattern</name></name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PUTOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>parsed_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <comment type="block">/* Fall through */</comment>

      <comment type="block">/* If the previous item was a condition starting (?(? an assertion,
      optionally preceded by a callout, is expected. This is checked later on,
      during actual compilation. However we need to identify this kind of
      assertion in this pass because it must not be qualified. The value of
      expect_cond_assert is set to 2 after (?(? is processed. We decrement it
      for a callout - still leaving a positive value that identifies the
      assertion. Multiple callouts or any other items will make it zero or
      less, which doesn't matter because they will cause an error later. */</comment>

      <label><name>POST_ASSERTION</name>:</label>
      <expr_stmt><expr><name>nest_depth</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>prev_expect_cond_assert</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>top_nest</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>top_nest</name> <operator>=</operator> <operator>(</operator><name>nest_save</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>start_workspace</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>++</operator><name>top_nest</name> <operator>&gt;=</operator> <name>end_nests</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR84</name></expr>;</expr_stmt>
          <goto>goto <name>FAILED</name>;</goto>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>top_nest</name><operator>-&gt;</operator><name>nest_depth</name></name> <operator>=</operator> <name>nest_depth</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>top_nest</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>NSF_CONDASSERT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>top_nest</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>options</name> <operator>&amp;</operator> <name>PARSE_TRACKED_OPTIONS</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>


      <comment type="block">/* ---- Define a named group ---- */</comment>

      <comment type="block">/* A named group may be defined as (?'name') or (?&lt;name&gt;). In the latter
      case we jump to DEFINE_NAME from the disambiguation of (?&lt; above with the
      terminator set to '&gt;'. */</comment>

      <case>case <expr><name>CHAR_APOSTROPHE</name></expr>:</case>
      <expr_stmt><expr><name>terminator</name> <operator>=</operator> <name>CHAR_APOSTROPHE</name></expr>;</expr_stmt>    <comment type="block">/* Terminator */</comment>

      <label><name>DEFINE_NAME</name>:</label>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>ptrend</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>terminator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>namelen</name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>FAILED</name>;</goto></block_content></block></if></if_stmt>

      <comment type="block">/* We have a name for this capturing group. It is also assigned a number,
      which is its primary means of identification. */</comment>

      <if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name> <operator>&gt;=</operator> <name>MAX_GROUP_NUMBER</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR97</name></expr>;</expr_stmt>
        <goto>goto <name>FAILED</name>;</goto>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_CAPTURE</name> <operator>|</operator> <name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>nest_depth</name><operator>++</operator></expr>;</expr_stmt>

      <comment type="block">/* Check not too many names */</comment>

      <if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>names_found</name></name> <operator>&gt;=</operator> <name>MAX_NAME_COUNT</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR49</name></expr>;</expr_stmt>
        <goto>goto <name>FAILED</name>;</goto>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Adjust the entry size to accommodate the longest name found. */</comment>

      <if_stmt><if>if <condition>(<expr><name>namelen</name> <operator>+</operator> <name>IMM2_SIZE</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>name_entry_size</name></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><operator>(</operator><name>namelen</name> <operator>+</operator> <name>IMM2_SIZE</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <comment type="block">/* Scan the list to check for duplicates. For duplicate names, if the
      number is the same, break the loop, which causes the name to be
      discarded; otherwise, if DUPNAMES is not set, give an error.
      If it is set, allow the name with a different number, but continue
      scanning in case this is a duplicate with the same number. For
      non-duplicate names, give an error if the number is duplicated. */</comment>

      <expr_stmt><expr><name>isdupname</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ng</name> <operator>=</operator> <name><name>cb</name><operator>-&gt;</operator><name>named_groups</name></name></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>names_found</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ng</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>namelen</name> <operator>==</operator> <name><name>ng</name><operator>-&gt;</operator><name>length</name></name> <operator>&amp;&amp;</operator>
            <call><call><name>PRIV</name><argument_list>(<argument><expr><name>strncmp</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>ng</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><name>namelen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name><name>ng</name><operator>-&gt;</operator><name>number</name></name> <operator>==</operator> <name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_DUPNAMES</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR43</name></expr>;</expr_stmt>
            <goto>goto <name>FAILED</name>;</goto>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>isdupname</name> <operator>=</operator> <name><name>ng</name><operator>-&gt;</operator><name>isdup</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>     <comment type="block">/* Mark as a duplicate */</comment>
          <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>dupnames</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>              <comment type="block">/* Duplicate names exist */</comment>
          </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>ng</name><operator>-&gt;</operator><name>number</name></name> <operator>==</operator> <name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR65</name></expr>;</expr_stmt>
          <goto>goto <name>FAILED</name>;</goto>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>names_found</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>   <comment type="block">/* Ignore duplicate with same number */</comment>

      <comment type="block">/* Increase the list size if necessary */</comment>

      <if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>names_found</name></name> <operator>&gt;=</operator> <name><name>cb</name><operator>-&gt;</operator><name>named_group_list_size</name></name></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>newsize</name> <init>= <expr><name><name>cb</name><operator>-&gt;</operator><name>named_group_list_size</name></name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>named_group</name> <modifier>*</modifier></type><name>newspace</name> <init>=
          <expr><call><name><name>cb</name><operator>-&gt;</operator><name>cx</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>malloc</name></name><argument_list>(<argument><expr><name>newsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>named_group</name></expr></argument>)</argument_list></sizeof></expr></argument>,
          <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>cx</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>newspace</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR21</name></expr>;</expr_stmt>
          <goto>goto <name>FAILED</name>;</goto>
          </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newspace</name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>named_groups</name></name></expr></argument>,
          <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>named_group_list_size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>named_group</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>named_group_list_size</name></name> <operator>&gt;</operator> <name>NAMED_GROUP_LIST_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name><name>cb</name><operator>-&gt;</operator><name>cx</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>free</name></name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>cb</name><operator>-&gt;</operator><name>named_groups</name></name></expr></argument>,
          <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>cx</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>named_groups</name></name> <operator>=</operator> <name>newspace</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>named_group_list_size</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Add this name to the list */</comment>

      <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>named_groups</name><index>[<expr><name><name>cb</name><operator>-&gt;</operator><name>names_found</name></name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>named_groups</name><index>[<expr><name><name>cb</name><operator>-&gt;</operator><name>names_found</name></name></expr>]</index></name><operator>.</operator><name>length</name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>namelen</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>named_groups</name><index>[<expr><name><name>cb</name><operator>-&gt;</operator><name>names_found</name></name></expr>]</index></name><operator>.</operator><name>number</name> <operator>=</operator> <name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>named_groups</name><index>[<expr><name><name>cb</name><operator>-&gt;</operator><name>names_found</name></name></expr>]</index></name><operator>.</operator><name>isdup</name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>isdupname</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>names_found</name></name><operator>++</operator></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></switch>        <comment type="block">/* End of (? switch */</comment>
    <break>break;</break>     <comment type="block">/* End of ( handling */</comment>


    <comment type="block">/* ---- Branch terminators ---- */</comment>

    <comment type="block">/* Alternation: reset the capture count if we are in a (?| group. */</comment>

    <case>case <expr><name>CHAR_VERTICAL_LINE</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>top_nest</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>top_nest</name><operator>-&gt;</operator><name>nest_depth</name></name> <operator>==</operator> <name>nest_depth</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name><name>top_nest</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>NSF_RESET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name> <operator>&gt;</operator> <name><name>top_nest</name><operator>-&gt;</operator><name>max_group</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>top_nest</name><operator>-&gt;</operator><name>max_group</name></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name> <operator>=</operator> <name><name>top_nest</name><operator>-&gt;</operator><name>reset_group</name></name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_ALT</name></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* End of group; reset the capture count to the maximum if we are in a (?|
    group and/or reset the options that are tracked during parsing. Disallow
    quantifier for a condition that is an assertion. */</comment>

    <case>case <expr><name>CHAR_RIGHT_PARENTHESIS</name></expr>:</case>
    <expr_stmt><expr><name>okquantifier</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>top_nest</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>top_nest</name><operator>-&gt;</operator><name>nest_depth</name></name> <operator>==</operator> <name>nest_depth</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>options</name> <operator>=</operator> <operator>(</operator><name>options</name> <operator>&amp;</operator> <operator>~</operator><name>PARSE_TRACKED_OPTIONS</name><operator>)</operator> <operator>|</operator> <name><name>top_nest</name><operator>-&gt;</operator><name>options</name></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>top_nest</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>NSF_RESET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
          <name><name>top_nest</name><operator>-&gt;</operator><name>max_group</name></name> <operator>&gt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name> <operator>=</operator> <name><name>top_nest</name><operator>-&gt;</operator><name>max_group</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>top_nest</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>NSF_CONDASSERT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>okquantifier</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>top_nest</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>NSF_ATOMICSR</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_KET</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>top_nest</name> <operator>==</operator> <operator>(</operator><name>nest_save</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>start_workspace</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>top_nest</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>top_nest</name><operator>--</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>nest_depth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>    <comment type="block">/* Unmatched closing parenthesis */</comment>
      <block>{<block_content>
      <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR22</name></expr>;</expr_stmt>
      <goto>goto <name>FAILED_BACK</name>;</goto>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nest_depth</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_KET</name></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></switch>  <comment type="block">/* End of switch on pattern character */</comment>
  </block_content>}</block></while>    <comment type="block">/* End of main character scan loop */</comment>

<comment type="block">/* End of pattern reached. Check for missing ) at the end of a verb name. */</comment>

<if_stmt><if>if <condition>(<expr><name>inverbname</name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>&gt;=</operator> <name>ptrend</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR60</name></expr>;</expr_stmt>
  <goto>goto <name>FAILED</name>;</goto>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Manage callout for the final item */</comment>

<label><name>PARSED_END</name>:</label>
<expr_stmt><expr><name>parsed_pattern</name> <operator>=</operator> <call><name>manage_callouts</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>previous_callout</name></expr></argument>, <argument><expr><name>auto_callout</name></expr></argument>,
  <argument><expr><name>parsed_pattern</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Insert trailing items for word and line matching (features provided for the
benefit of pcre2grep). */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>extra_options</name> <operator>&amp;</operator> <name>PCRE2_EXTRA_MATCH_LINE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_KET</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_DOLLAR</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name>extra_options</name> <operator>&amp;</operator> <name>PCRE2_EXTRA_MATCH_WORD</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_KET</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>parsed_pattern</name><operator>++</operator> <operator>=</operator> <name>META_ESCAPE</name> <operator>+</operator> <name>ESC_b</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Terminate the parsed pattern, then return success if all groups are closed.
Otherwise we have unclosed parentheses. */</comment>

<if_stmt><if>if <condition>(<expr><name>parsed_pattern</name> <operator>&gt;=</operator> <name>parsed_pattern_end</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR63</name></expr>;</expr_stmt>  <comment type="block">/* Internal error (parsed pattern overflow) */</comment>
  <goto>goto <name>FAILED</name>;</goto>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>parsed_pattern</name> <operator>=</operator> <name>META_END</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nest_depth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<label><name>UNCLOSED_PARENTHESIS</name>:</label>
<expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR14</name></expr>;</expr_stmt>

<comment type="block">/* Come here for all failures. */</comment>

<label><name>FAILED</name>:</label>
<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>erroroffset</name></name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <name><name>cb</name><operator>-&gt;</operator><name>start_pattern</name></name><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><name>errorcode</name></expr>;</return>

<comment type="block">/* Some errors need to indicate the previous character. */</comment>

<label><name>FAILED_BACK</name>:</label>
<expr_stmt><expr><name>ptr</name><operator>--</operator></expr>;</expr_stmt>
<goto>goto <name>FAILED</name>;</goto>

<comment type="block">/* This failure happens several times. */</comment>

<label><name>BAD_VERSION_CONDITION</name>:</label>
<expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR79</name></expr>;</expr_stmt>
<goto>goto <name>FAILED</name>;</goto>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*       Find first significant opcode            *
*************************************************/</comment>

<comment type="block">/* This is called by several functions that scan a compiled expression looking
for a fixed first character, or an anchoring opcode etc. It skips over things
that do not influence this. For some calls, it makes sense to skip negative
forward and all backward assertions, and also the \b assertion; for others it
does not.

Arguments:
  code         pointer to the start of the group
  skipassert   TRUE if certain assertions are to be skipped

Returns:       pointer to the first significant opcode
*/</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>PCRE2_UCHAR</name><modifier>*</modifier></type>
<name>first_significant_code</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>skipassert</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <switch>switch <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><operator>*</operator><name>code</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>OP_ASSERT_NOT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK_NOT</name></expr>:</case>
    <case>case <expr><name>OP_ASSERTBACK_NA</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>skipassert</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>
    <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
    <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>code</name></expr>]</index></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_WORD_BOUNDARY</name></expr>:</case>
    <case>case <expr><name>OP_NOT_WORD_BOUNDARY</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>skipassert</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Fall through */</comment>

    <case>case <expr><name>OP_CALLOUT</name></expr>:</case>
    <case>case <expr><name>OP_CREF</name></expr>:</case>
    <case>case <expr><name>OP_DNCREF</name></expr>:</case>
    <case>case <expr><name>OP_RREF</name></expr>:</case>
    <case>case <expr><name>OP_DNRREF</name></expr>:</case>
    <case>case <expr><name>OP_FALSE</name></expr>:</case>
    <case>case <expr><name>OP_TRUE</name></expr>:</case>
    <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>code</name></expr>]</index></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_CALLOUT_STR</name></expr>:</case>
    <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_SKIPZERO</name></expr>:</case>
    <expr_stmt><expr><name>code</name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_COND</name></expr>:</case>
    <case>case <expr><name>OP_SCOND</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>code</name><index>[<expr><literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name></expr>]</index></name> <operator>!=</operator> <name>OP_FALSE</name> <operator>||</operator>   <comment type="block">/* Not DEFINE */</comment>
        <name><name>code</name><index>[<expr><call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>!=</operator> <name>OP_KET</name></expr>)</condition><block type="pseudo"><block_content>      <comment type="block">/* More than one branch */</comment>
      <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>OP_MARK</name></expr>:</case>
    <case>case <expr><name>OP_COMMIT_ARG</name></expr>:</case>
    <case>case <expr><name>OP_PRUNE_ARG</name></expr>:</case>
    <case>case <expr><name>OP_SKIP_ARG</name></expr>:</case>
    <case>case <expr><name>OP_THEN_ARG</name></expr>:</case>
    <expr_stmt><expr><name>code</name> <operator>+=</operator> <name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>code</name></expr>]</index></expr>;</expr_stmt>
    <break>break;</break>

    <default>default:</default>
    <return>return <expr><name>code</name></expr>;</return>
    </block_content>}</block></switch>
  </block_content>}</block></for>
<comment type="block">/* Control never reaches here */</comment>
</block_content>}</block></function>



<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<comment type="block" format="doxygen">/*************************************************
*           Get othercase range                  *
*************************************************/</comment>

<comment type="block">/* This function is passed the start and end of a class range in UCP mode. It
searches up the characters, looking for ranges of characters in the "other"
case. Each call returns the next one, updating the start address. A character
with multiple other cases is returned on its own with a special return value.

Arguments:
  cptr        points to starting character value; updated
  d           end value
  ocptr       where to put start of othercase range
  odptr       where to put end of othercase range

Yield:        -1 when no more
               0 when a range is returned
              &gt;0 the CASESET offset for char with multiple other cases
                in this case, ocptr contains the original
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_othercase_range</name><parameter_list>(<parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>cptr</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>d</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>ocptr</name></decl></parameter>,
  <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>odptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>othercase</name></decl>, <decl><type ref="prev"/><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>co</name></decl>;</decl_stmt>

<comment type="block">/* Find the first character that has an other case. If it has multiple other
cases, return its case offset value. */</comment>

<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cptr</name></expr>;</init> <condition><expr><name>c</name> <operator>&lt;=</operator> <name>d</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>co</name> <operator>=</operator> <call><name>UCD_CASESET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ocptr</name> <operator>=</operator> <name>c</name><operator>++</operator></expr>;</expr_stmt>   <comment type="block">/* Character that has the set */</comment>
    <expr_stmt><expr><operator>*</operator><name>cptr</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>      <comment type="block">/* Rest of input range */</comment>
    <return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>co</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>othercase</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <name>d</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Reached end of range */</comment>

<comment type="block">/* Found a character that has a single other case. Search for the end of the
range, which is either the end of the input range, or a character that has zero
or more than one other cases. */</comment>

<expr_stmt><expr><operator>*</operator><name>ocptr</name> <operator>=</operator> <name>othercase</name></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name>othercase</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><operator>++</operator><name>c</name></expr>;</init> <condition><expr><name>c</name> <operator>&lt;=</operator> <name>d</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>co</name> <operator>=</operator> <call><name>UCD_CASESET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>next</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>next</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><name>odptr</name> <operator>=</operator> <name>next</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>     <comment type="block">/* End of othercase range */</comment>
<expr_stmt><expr><operator>*</operator><name>cptr</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>             <comment type="block">/* Rest of input range */</comment>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>



<comment type="block" format="doxygen">/*************************************************
* Add a character or range to a class (internal) *
*************************************************/</comment>

<comment type="block">/* This function packages up the logic of adding a character or range of
characters to a class. The character values in the arguments will be within the
valid values for the current mode (8-bit, 16-bit, UTF, etc). This function is
called only from within the "add to class" group of functions, some of which
are recursive and mutually recursive. The external entry point is
add_to_class().

Arguments:
  classbits     the bit map for characters &lt; 256
  uchardptr     points to the pointer for extra data
  options       the options word
  cb            compile data
  start         start of range character
  end           end of range character

Returns:        the number of &lt; 256 characters added
                the pointer to extra data is updated
*/</comment>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>add_to_class_internal</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>classbits</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier><modifier>*</modifier></type><name>uchardptr</name></decl></parameter>,
  <parameter><decl><type><name>uint32_t</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>classbits_end</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>end</name> <operator>&lt;=</operator> <literal type="number">0xff</literal></expr> ?</condition><then> <expr><name>end</name></expr> </then><else>: <expr><literal type="number">0xff</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>n8</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* If caseless matching is required, scan the range and process alternate
cases. In Unicode, there are 8-bit characters that have alternate cases that
are greater than 255 and vice-versa. Sometimes we can just extend the original
range. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_CASELESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_UTF</name><operator>|</operator><name>PCRE2_UCP</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>oc</name></decl>, <decl><type ref="prev"/><name>od</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>options</name> <operator>&amp;=</operator> <operator>~</operator><name>PCRE2_CASELESS</name></expr>;</expr_stmt>   <comment type="block">/* Remove for recursive calls */</comment>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>get_othercase_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>od</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <comment type="block">/* Handle a single character that has more than one other case. */</comment>

      <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n8</name> <operator>+=</operator> <call><name>add_list_to_class_internal</name><argument_list>(<argument><expr><name>classbits</name></expr></argument>, <argument><expr><name>uchardptr</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>,
        <argument><expr><call><name>PRIV</name><argument_list>(<argument><expr><name>ucd_caseless_sets</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>rc</name></expr></argument>, <argument><expr><name>oc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

      <comment type="block">/* Do nothing if the other case range is within the original range. */</comment>

      <if type="elseif">else if <condition>(<expr><name>oc</name> <operator>&gt;=</operator> <name><name>cb</name><operator>-&gt;</operator><name>class_range_start</name></name> <operator>&amp;&amp;</operator> <name>od</name> <operator>&lt;=</operator> <name><name>cb</name><operator>-&gt;</operator><name>class_range_end</name></name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if>

      <comment type="block">/* Extend the original range if there is overlap, noting that if oc &lt; c, we
      can't have od &gt; end because a subrange is always shorter than the basic
      range. Otherwise, use a recursive call to add the additional range. */</comment>

      <if type="elseif">else if <condition>(<expr><name>oc</name> <operator>&lt;</operator> <name>start</name> <operator>&amp;&amp;</operator> <name>od</name> <operator>&gt;=</operator> <name>start</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>start</name> <operator>=</operator> <name>oc</name></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* Extend downwards */</comment>
      <if type="elseif">else if <condition>(<expr><name>od</name> <operator>&gt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <name>oc</name> <operator>&lt;=</operator> <name>end</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>end</name> <operator>=</operator> <name>od</name></expr>;</expr_stmt>       <comment type="block">/* Extend upwards */</comment>
        <if_stmt><if>if <condition>(<expr><name>end</name> <operator>&gt;</operator> <name>classbits_end</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>classbits_end</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>end</name> <operator>&lt;=</operator> <literal type="number">0xff</literal></expr> ?</condition><then> <expr><name>end</name></expr> </then><else>: <expr><literal type="number">0xff</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>n8</name> <operator>+=</operator> <call><name>add_to_class_internal</name><argument_list>(<argument><expr><name>classbits</name></expr></argument>, <argument><expr><name>uchardptr</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>oc</name></expr></argument>, <argument><expr><name>od</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></while>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

  <comment type="block">/* Not UTF mode */</comment>

  <for>for <control>(<init><expr><name>c</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>c</name> <operator>&lt;=</operator> <name>classbits_end</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
    <expr_stmt><expr><call><name>SETBIT</name><argument_list>(<argument><expr><name>classbits</name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>fcc</name><index>[<expr><name>c</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n8</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Now handle the originally supplied range. Adjust the final value according
to the bit length - this means that the same lists of (e.g.) horizontal spaces
can be used in all cases. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>end</name> <operator>&gt;</operator> <name>MAX_NON_UTF_CHAR</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>end</name> <operator>=</operator> <name>MAX_NON_UTF_CHAR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>class_range_start</name></name> <operator>&amp;&amp;</operator> <name>end</name> <operator>&lt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>class_range_end</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>n8</name></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* Use the bitmap for characters &lt; 256. Otherwise use extra data.*/</comment>

<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>c</name> <operator>&lt;=</operator> <name>classbits_end</name></expr>;</condition> <incr><expr><name>c</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <comment type="block">/* Regardless of start, c will always be &lt;= 255. */</comment>
  <expr_stmt><expr><call><name>SETBIT</name><argument_list>(<argument><expr><name>classbits</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n8</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_WIDE_CHARS</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;=</operator> <literal type="number">0xff</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">0xff</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name> <operator>&gt;=</operator> <name>start</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>uchardata</name> <init>= <expr><operator>*</operator><name>uchardptr</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <name>end</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>uchardata</name><operator>++</operator> <operator>=</operator> <name>XCL_RANGE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>uchardata</name> <operator>+=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>ord2utf</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>uchardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>uchardata</name> <operator>+=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>ord2utf</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>end</name></expr></argument>, <argument><expr><name>uchardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>start</name> <operator>==</operator> <name>end</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>uchardata</name><operator>++</operator> <operator>=</operator> <name>XCL_SINGLE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>uchardata</name> <operator>+=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>ord2utf</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>uchardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

  <comment type="block">/* Without UTF support, character values are constrained by the bit length,
  and can only be &gt; 256 for 16-bit and 32-bit libraries. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
    <block>{<block_content/>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <name>end</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>uchardata</name><operator>++</operator> <operator>=</operator> <name>XCL_RANGE</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>uchardata</name><operator>++</operator> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>uchardata</name><operator>++</operator> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name>start</name> <operator>==</operator> <name>end</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>uchardata</name><operator>++</operator> <operator>=</operator> <name>XCL_SINGLE</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>uchardata</name><operator>++</operator> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* PCRE2_CODE_UNIT_WIDTH == 8 */</comment>
  <expr_stmt><expr><operator>*</operator><name>uchardptr</name> <operator>=</operator> <name>uchardata</name></expr>;</expr_stmt>   <comment type="block">/* Updata extra data pointer */</comment>
  </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* SUPPORT_WIDE_CHARS */</comment>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>uchardptr</name></expr>;</expr_stmt>          <comment type="block">/* Avoid compiler warning */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SUPPORT_WIDE_CHARS */</comment>

<return>return <expr><name>n8</name></expr>;</return>    <comment type="block">/* Number of 8-bit characters */</comment>
</block_content>}</block></function>



<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<comment type="block" format="doxygen">/*************************************************
* Add a list of characters to a class (internal) *
*************************************************/</comment>

<comment type="block">/* This function is used for adding a list of case-equivalent characters to a
class when in UTF mode. This function is called only from within
add_to_class_internal(), with which it is mutually recursive.

Arguments:
  classbits     the bit map for characters &lt; 256
  uchardptr     points to the pointer for extra data
  options       the options word
  cb            contains pointers to tables etc.
  p             points to row of 32-bit values, terminated by NOTACHAR
  except        character to omit; this is used when adding lists of
                  case-equivalent characters to avoid including the one we
                  already know about

Returns:        the number of &lt; 256 characters added
                the pointer to extra data is updated
*/</comment>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>add_list_to_class_internal</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>classbits</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier><modifier>*</modifier></type><name>uchardptr</name></decl></parameter>,
  <parameter><decl><type><name>uint32_t</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>except</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>n8</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <name>NOTACHAR</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>except</name></expr>)</condition>
    <block>{<block_content>
    <while>while<condition>(<expr><name><name>p</name><index>[<expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><name>n8</name> <operator>+=</operator> <call><name>add_to_class_internal</name><argument_list>(<argument><expr><name>classbits</name></expr></argument>, <argument><expr><name>uchardptr</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
<return>return <expr><name>n8</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<comment type="block" format="doxygen">/*************************************************
*   External entry point for add range to class  *
*************************************************/</comment>

<comment type="block">/* This function sets the overall range so that the internal functions can try
to avoid duplication when handling case-independence.

Arguments:
  classbits     the bit map for characters &lt; 256
  uchardptr     points to the pointer for extra data
  options       the options word
  cb            compile data
  start         start of range character
  end           end of range character

Returns:        the number of &lt; 256 characters added
                the pointer to extra data is updated
*/</comment>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>add_to_class</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>classbits</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier><modifier>*</modifier></type><name>uchardptr</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>options</name></decl></parameter>,
  <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>class_range_start</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>class_range_end</name></name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
<return>return <expr><call><name>add_to_class_internal</name><argument_list>(<argument><expr><name>classbits</name></expr></argument>, <argument><expr><name>uchardptr</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*   External entry point for add list to class   *
*************************************************/</comment>

<comment type="block">/* This function is used for adding a list of horizontal or vertical whitespace
characters to a class. The list must be in order so that ranges of characters
can be detected and handled appropriately. This function sets the overall range
so that the internal functions can try to avoid duplication when handling
case-independence.

Arguments:
  classbits     the bit map for characters &lt; 256
  uchardptr     points to the pointer for extra data
  options       the options word
  cb            contains pointers to tables etc.
  p             points to row of 32-bit values, terminated by NOTACHAR
  except        character to omit; this is used when adding lists of
                  case-equivalent characters to avoid including the one we
                  already know about

Returns:        the number of &lt; 256 characters added
                the pointer to extra data is updated
*/</comment>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>add_list_to_class</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>classbits</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier><modifier>*</modifier></type><name>uchardptr</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>options</name></decl></parameter>,
  <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>except</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>n8</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <name>NOTACHAR</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>except</name></expr>)</condition>
    <block>{<block_content>
    <while>while<condition>(<expr><name><name>p</name><index>[<expr><name>n</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>class_range_start</name></name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>class_range_end</name></name> <operator>=</operator> <name><name>p</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>n8</name> <operator>+=</operator> <call><name>add_to_class_internal</name><argument_list>(<argument><expr><name>classbits</name></expr></argument>, <argument><expr><name>uchardptr</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></while>
<return>return <expr><name>n8</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*    Add characters not in a list to a class     *
*************************************************/</comment>

<comment type="block">/* This function is used for adding the complement of a list of horizontal or
vertical whitespace to a class. The list must be in order.

Arguments:
  classbits     the bit map for characters &lt; 256
  uchardptr     points to the pointer for extra data
  options       the options word
  cb            contains pointers to tables etc.
  p             points to row of 32-bit values, terminated by NOTACHAR

Returns:        the number of &lt; 256 characters added
                the pointer to extra data is updated
*/</comment>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>add_not_list_to_class</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>classbits</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier><modifier>*</modifier></type><name>uchardptr</name></decl></parameter>,
  <parameter><decl><type><name>uint32_t</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint32_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name> <init>= <expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>n8</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>n8</name> <operator>+=</operator> <call><name>add_to_class</name><argument_list>(<argument><expr><name>classbits</name></expr></argument>, <argument><expr><name>uchardptr</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <name>NOTACHAR</name></expr>)</condition>
  <block>{<block_content>
  <while>while <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><name>n8</name> <operator>+=</operator> <call><name>add_to_class</name><argument_list>(<argument><expr><name>classbits</name></expr></argument>, <argument><expr><name>uchardptr</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
    <argument><expr><ternary><condition><expr><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NOTACHAR</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><name>utf</name></expr> ?</condition><then> <expr><literal type="number">0x10ffffu</literal></expr> </then><else>: <expr><literal type="number">0xffffffffu</literal></expr></else></ternary><operator>)</operator></expr> </then><else>: <expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
<return>return <expr><name>n8</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*    Find details of duplicate group names       *
*************************************************/</comment>

<comment type="block">/* This is called from compile_branch() when it needs to know the index and
count of duplicates in the names table when processing named backreferences,
either directly, or as conditions.

Arguments:
  name          points to the name
  length        the length of the name
  indexptr      where to put the index
  countptr      where to put the count of duplicates
  errorcodeptr  where to put an error code
  cb            the compile block

Returns:        TRUE if OK, FALSE if not, error code set
*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>find_dupname_details</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>indexptr</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>countptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>errorcodeptr</name></decl></parameter>, <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>groupnumber</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>cb</name><operator>-&gt;</operator><name>name_table</name></name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Find the first entry in the table */</comment>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>names_found</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><call><name>PRIV</name><argument_list>(<argument><expr><name>strncmp</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>slot</name><operator>+</operator><name>IMM2_SIZE</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
      <name><name>slot</name><index>[<expr><name>IMM2_SIZE</name><operator>+</operator><name>length</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>slot</name> <operator>+=</operator> <name><name>cb</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>

<comment type="block">/* This should not occur, because this function is called only when we know we
have duplicate names. Give an internal error. */</comment>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>cb</name><operator>-&gt;</operator><name>names_found</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR53</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>erroroffset</name></name> <operator>=</operator> <name>name</name> <operator>-</operator> <name><name>cb</name><operator>-&gt;</operator><name>start_pattern</name></name></expr>;</expr_stmt>
  <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Record the index and then see how many duplicates there are, updating the
backref map and maximum back reference as we do. */</comment>

<expr_stmt><expr><operator>*</operator><name>indexptr</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>groupnumber</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>slot</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>backref_map</name></name> <operator>|=</operator> <ternary><condition><expr><operator>(</operator><name>groupnumber</name> <operator>&lt;</operator> <literal type="number">32</literal><operator>)</operator></expr>?</condition><then> <expr><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>groupnumber</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>groupnumber</name> <operator>&gt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>top_backref</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>top_backref</name></name> <operator>=</operator> <name>groupnumber</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>++</operator><name>i</name> <operator>&gt;=</operator> <name><name>cb</name><operator>-&gt;</operator><name>names_found</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>slot</name> <operator>+=</operator> <name><name>cb</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><call><name>PRIV</name><argument_list>(<argument><expr><name>strncmp</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>slot</name><operator>+</operator><name>IMM2_SIZE</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
    <operator>(</operator><name>slot</name><operator>+</operator><name>IMM2_SIZE</name><operator>)</operator><index>[<expr><name>length</name></expr>]</index> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><name>countptr</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*           Compile one branch                   *
*************************************************/</comment>

<comment type="block">/* Scan the parsed pattern, compiling it into the a vector of PCRE2_UCHAR. If
the options are changed during the branch, the pointer is used to change the
external options bits. This function is used during the pre-compile phase when
we are trying to find out the amount of memory needed, as well as during the
real compile phase. The value of lengthptr distinguishes the two phases.

Arguments:
  optionsptr        pointer to the option bits
  codeptr           points to the pointer to the current code point
  pptrptr           points to the current parsed pattern pointer
  errorcodeptr      points to error code variable
  firstcuptr        place to put the first required code unit
  firstcuflagsptr   place to put the first code unit flags, or a negative number
  reqcuptr          place to put the last required code unit
  reqcuflagsptr     place to put the last required code unit flags, or a negative number
  bcptr             points to current branch chain
  cb                contains pointers to tables etc.
  lengthptr         NULL during the real compile phase
                    points to length accumulator during pre-compile phase

Returns:            0 There's been an error, *errorcodeptr is non-zero
                   +1 Success, this branch must match at least one character
                   -1 Success, this branch may match an empty string
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_branch</name><parameter_list>(<parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>optionsptr</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier><modifier>*</modifier></type><name>codeptr</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>pptrptr</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>errorcodeptr</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>firstcuptr</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>firstcuflagsptr</name></decl></parameter>,
  <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>reqcuptr</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>reqcuflagsptr</name></decl></parameter>, <parameter><decl><type><name>branch_chain</name> <modifier>*</modifier></type><name>bcptr</name></decl></parameter>,
  <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>lengthptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>bravalue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>okreturn</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>group_return</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>repeat_min</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>repeat_max</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>      <comment type="block">/* To please picky compilers */</comment>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>greedy_default</name></decl>, <decl><type ref="prev"/><name>greedy_non_default</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>repeat_type</name></decl>, <decl><type ref="prev"/><name>op_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>options</name> <init>= <expr><operator>*</operator><name>optionsptr</name></expr></init></decl>;</decl_stmt>               <comment type="block">/* May change dynamically */</comment>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>firstcu</name></decl>, <decl><type ref="prev"/><name>reqcu</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>zeroreqcu</name></decl>, <decl><type ref="prev"/><name>zerofirstcu</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>escape</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pptr</name> <init>= <expr><operator>*</operator><name>pptrptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>meta</name></decl>, <decl><type ref="prev"/><name>meta_arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>firstcuflags</name></decl>, <decl><type ref="prev"/><name>reqcuflags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>zeroreqcuflags</name></decl>, <decl><type ref="prev"/><name>zerofirstcuflags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>req_caseopt</name></decl>, <decl><type ref="prev"/><name>reqvary</name></decl>, <decl><type ref="prev"/><name>tempreqvary</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>length_prevgroup</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>code</name> <init>= <expr><operator>*</operator><name>codeptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>last_code</name> <init>= <expr><name>code</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>orig_code</name> <init>= <expr><name>code</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>tempcode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>previous</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>op_previous</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>groupsetfirstcu</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>had_accept</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>matched_char</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>previous_matched_char</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>reset_caseful</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>cbits</name> <init>= <expr><name><name>cb</name><operator>-&gt;</operator><name>cbits</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>classbits</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/* We can fish out the UTF setting once and for all into a BOOL, but we must
not do this for other options (e.g. PCRE2_EXTENDED) because they may change
dynamically as we process the pattern. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name> <init>= <expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>ucp</name> <init>= <expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* No Unicode support */</comment>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Helper variables for OP_XCLASS opcode (for characters &gt; 255). We define
class_uchardata always so that it can be passed to add_to_class() always,
though it will not be used in non-UTF 8-bit cases. This avoids having to supply
alternative calls for the different cases. */</comment>

<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>class_uchardata</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_WIDE_CHARS</name></cpp:ifdef>
<decl_stmt><decl><type><name>BOOL</name></type> <name>xclass</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>class_uchardata_base</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Set up the default and non-default settings for greediness */</comment>

<expr_stmt><expr><name>greedy_default</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_UNGREEDY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>greedy_non_default</name> <operator>=</operator> <name>greedy_default</name> <operator>^</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<comment type="block">/* Initialize no first unit, no required unit. REQ_UNSET means "no char
matching encountered yet". It gets changed to REQ_NONE if we hit something that
matches a non-fixed first unit; reqcu just remains unset if we never find one.

When we hit a repeat whose minimum is zero, we may have to adjust these values
to take the zero repeat into account. This is implemented by setting them to
zerofirstcu and zeroreqcu when such a repeat is encountered. The individual
item types that can be repeated set these backoff variables appropriately. */</comment>

<expr_stmt><expr><name>firstcu</name> <operator>=</operator> <name>reqcu</name> <operator>=</operator> <name>zerofirstcu</name> <operator>=</operator> <name>zeroreqcu</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>firstcuflags</name> <operator>=</operator> <name>reqcuflags</name> <operator>=</operator> <name>zerofirstcuflags</name> <operator>=</operator> <name>zeroreqcuflags</name> <operator>=</operator> <name>REQ_UNSET</name></expr>;</expr_stmt>

<comment type="block">/* The variable req_caseopt contains either the REQ_CASELESS value or zero,
according to the current setting of the caseless flag. The REQ_CASELESS value
leaves the lower 28 bit empty. It is added into the firstcu or reqcu variables
to record the case status of the value. This is used only for ASCII characters.
*/</comment>

<expr_stmt><expr><name>req_caseopt</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_CASELESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name>REQ_CASELESS</name></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<comment type="block">/* Switch on next META item until the end of the branch */</comment>

<for>for <control>(<init>;</init><condition>;</condition> <incr><expr><name>pptr</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_WIDE_CHARS</name></cpp:ifdef>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>xclass_has_prop</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>negate_class</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>should_flip_negation</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>match_all_or_no_wide_chars</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>possessive_quantifier</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>note_group_empty</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>class_has_8bitchar</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>mclength</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>skipunits</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>subreqcu</name></decl>, <decl><type ref="prev"/><name>subfirstcu</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>groupnumber</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>verbarglen</name></decl>, <decl><type ref="prev"/><name>verbculen</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>subreqcuflags</name></decl>, <decl><type ref="prev"/><name>subfirstcuflags</name></decl>;</decl_stmt>  <comment type="block">/* Must be signed */</comment>
  <decl_stmt><decl><type><name>open_capitem</name> <modifier>*</modifier></type><name>oc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name><name>mcbuffer</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>

  <comment type="block">/* Get next META item in the pattern and its potential argument. */</comment>

  <expr_stmt><expr><name>meta</name> <operator>=</operator> <call><name>META_CODE</name><argument_list>(<argument><expr><operator>*</operator><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>meta_arg</name> <operator>=</operator> <call><name>META_DATA</name><argument_list>(<argument><expr><operator>*</operator><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we are in the pre-compile phase, accumulate the length used for the
  previous cycle of this loop, unless the next item is a quantifier. */</comment>

  <if_stmt><if>if <condition>(<expr><name>lengthptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>code</name> <operator>&gt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>start_workspace</name></name> <operator>+</operator> <name><name>cb</name><operator>-&gt;</operator><name>workspace_size</name></name> <operator>-</operator>
        <name>WORK_SIZE_SAFETY_MARGIN</name></expr>)</condition>                       <comment type="block">/* Check for overrun */</comment>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>code</name> <operator>&gt;=</operator> <name><name>cb</name><operator>-&gt;</operator><name>start_workspace</name></name> <operator>+</operator> <name><name>cb</name><operator>-&gt;</operator><name>workspace_size</name></name><operator>)</operator></expr>?</condition><then>
        <expr><name>ERR52</name></expr> </then><else>: <expr><name>ERR86</name></expr></else></ternary></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* There is at least one situation where code goes backwards: this is the
    case of a zero quantifier after a class (e.g. [ab]{0}). When the quantifier
    is processed, the whole class is eliminated. However, it is created first,
    so we have to allow memory for it. Therefore, don't ever reduce the length
    at this point. */</comment>

    <if_stmt><if>if <condition>(<expr><name>code</name> <operator>&lt;</operator> <name>last_code</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>code</name> <operator>=</operator> <name>last_code</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If the next thing is not a quantifier, we add the length of the previous
    item into the total, and reset the code pointer to the start of the
    workspace. Otherwise leave the previous item available to be quantified. */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>meta</name> <argument_list type="generic">&lt; <argument><expr><name>META_ASTERISK</name> <operator>||</operator> <name>meta</name></expr></argument> &gt;</argument_list></name> <name>META_MINMAX_QUERY</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>OFLOW_MAX</name> <operator>-</operator> <operator>*</operator><name>lengthptr</name> <operator>&lt;</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>code</name> <operator>-</operator> <name>orig_code</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR20</name></expr>;</expr_stmt>   <comment type="block">/* Integer overflow */</comment>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>lengthptr</name> <operator>+=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>code</name> <operator>-</operator> <name>orig_code</name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>lengthptr</name> <operator>&gt;</operator> <name>MAX_PATTERN_SIZE</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR20</name></expr>;</expr_stmt>   <comment type="block">/* Pattern is too large */</comment>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>orig_code</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Remember where this code item starts so we can catch the "backwards"
    case above next time round. */</comment>

    <expr_stmt><expr><name>last_code</name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Process the next parsed pattern item. If it is not a quantifier, remember
  where it starts so that it can be quantified when a quantifier follows.
  Checking for the legality of quantifiers happens in parse_regex(), except for
  a quantifier after an assertion that is a condition. */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>meta</name> <argument_list type="generic">&lt; <argument><expr><name>META_ASTERISK</name> <operator>||</operator> <name>meta</name></expr></argument> &gt;</argument_list></name> <name>META_MINMAX_QUERY</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>previous</name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>matched_char</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>had_accept</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>okreturn</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>previous_matched_char</name> <operator>=</operator> <name>matched_char</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>matched_char</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>note_group_empty</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>skipunits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>         <comment type="block">/* Default value for most subgroups */</comment>

  <switch>switch<condition>(<expr><name>meta</name></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* ===================================================================*/</comment>
    <comment type="block">/* The branch terminates at pattern end or | or ) */</comment>

    <case>case <expr><name>META_END</name></expr>:</case>
    <case>case <expr><name>META_ALT</name></expr>:</case>
    <case>case <expr><name>META_KET</name></expr>:</case>
    <expr_stmt><expr><operator>*</operator><name>firstcuptr</name> <operator>=</operator> <name>firstcu</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>firstcuflagsptr</name> <operator>=</operator> <name>firstcuflags</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>reqcuptr</name> <operator>=</operator> <name>reqcu</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>reqcuflagsptr</name> <operator>=</operator> <name>reqcuflags</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>codeptr</name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pptrptr</name> <operator>=</operator> <name>pptr</name></expr>;</expr_stmt>
    <return>return <expr><name>okreturn</name></expr>;</return>


    <comment type="block">/* ===================================================================*/</comment>
    <comment type="block">/* Handle single-character metacharacters. In multiline mode, ^ disables
    the setting of any following char as a first character. */</comment>

    <case>case <expr><name>META_CIRCUMFLEX</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_MULTILINE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>firstcuflags</name> <operator>==</operator> <name>REQ_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>zerofirstcuflags</name> <operator>=</operator> <name>firstcuflags</name> <operator>=</operator> <name>REQ_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_CIRCM</name></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_CIRC</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <break>break;</break>

    <case>case <expr><name>META_DOLLAR</name></expr>:</case>
    <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_MULTILINE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name>OP_DOLLM</name></expr> </then><else>: <expr><name>OP_DOLL</name></expr></else></ternary></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* There can never be a first char if '.' is first, whatever happens about
    repeats. The value of reqcu doesn't change either. */</comment>

    <case>case <expr><name>META_DOT</name></expr>:</case>
    <expr_stmt><expr><name>matched_char</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>firstcuflags</name> <operator>==</operator> <name>REQ_UNSET</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>firstcuflags</name> <operator>=</operator> <name>REQ_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zerofirstcu</name> <operator>=</operator> <name>firstcu</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zerofirstcuflags</name> <operator>=</operator> <name>firstcuflags</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zeroreqcu</name> <operator>=</operator> <name>reqcu</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zeroreqcuflags</name> <operator>=</operator> <name>reqcuflags</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_DOTALL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name>OP_ALLANY</name></expr></then><else>: <expr><name>OP_ANY</name></expr></else></ternary></expr>;</expr_stmt>
    <break>break;</break>


    <comment type="block">/* ===================================================================*/</comment>
    <comment type="block">/* Empty character classes are allowed if PCRE2_ALLOW_EMPTY_CLASS is set.
    Otherwise, an initial ']' is taken as a data character. When empty classes
    are allowed, [] must always fail, so generate OP_FAIL, whereas [^] must
    match any character, so generate OP_ALLANY. */</comment>

    <case>case <expr><name>META_CLASS_EMPTY</name></expr>:</case>
    <case>case <expr><name>META_CLASS_EMPTY_NOT</name></expr>:</case>
    <expr_stmt><expr><name>matched_char</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>meta</name> <operator>==</operator> <name>META_CLASS_EMPTY_NOT</name><operator>)</operator></expr>?</condition><then> <expr><name>OP_ALLANY</name></expr> </then><else>: <expr><name>OP_FAIL</name></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>firstcuflags</name> <operator>==</operator> <name>REQ_UNSET</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>firstcuflags</name> <operator>=</operator> <name>REQ_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zerofirstcu</name> <operator>=</operator> <name>firstcu</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zerofirstcuflags</name> <operator>=</operator> <name>firstcuflags</name></expr>;</expr_stmt>
    <break>break;</break>


    <comment type="block">/* ===================================================================*/</comment>
    <comment type="block">/* Non-empty character class. If the included characters are all &lt; 256, we
    build a 32-byte bitmap of the permitted characters, except in the special
    case where there is only one such character. For negated classes, we build
    the map as usual, then invert it at the end. However, we use a different
    opcode so that data characters &gt; 255 can be handled correctly.

    If the class contains characters outside the 0-255 range, a different
    opcode is compiled. It may optionally have a bit map for characters &lt; 256,
    but those above are are explicitly listed afterwards. A flag code unit
    tells whether the bitmap is present, and whether this is a negated class or
    not. */</comment>

    <case>case <expr><name>META_CLASS_NOT</name></expr>:</case>
    <case>case <expr><name>META_CLASS</name></expr>:</case>
    <expr_stmt><expr><name>matched_char</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>negate_class</name> <operator>=</operator> <name>meta</name> <operator>==</operator> <name>META_CLASS_NOT</name></expr>;</expr_stmt>

    <comment type="block">/* We can optimize the case of a single character in a class by generating
    OP_CHAR or OP_CHARI if it's positive, or OP_NOT or OP_NOTI if it's
    negative. In the negative case there can be no first char if this item is
    first, whatever repeat count may follow. In the case of reqcu, save the
    previous value for reinstating. */</comment>

    <comment type="block">/* NOTE: at present this optimization is not effective if the only
    character in a class in 32-bit, non-UCP mode has its top bit set. */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>pptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name>META_END</name> <operator>&amp;&amp;</operator> <name><name>pptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>META_CLASS_END</name></expr>)</condition>
      <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>d</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name> <init>= <expr><name><name>pptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>                 <comment type="block">/* Move on to class end */</comment>
      <if_stmt><if>if <condition>(<expr><name>meta</name> <operator>==</operator> <name>META_CLASS</name></expr>)</condition>    <comment type="block">/* A positive one-char class can be */</comment>
        <block>{<block_content>                        <comment type="block">/* handled as a normal literal character. */</comment>
        <expr_stmt><expr><name>meta</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>                <comment type="block">/* Set up the character */</comment>
        <goto>goto <name>NORMAL_CHAR_SET</name>;</goto>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Handle a negative one-character class */</comment>

      <expr_stmt><expr><name>zeroreqcu</name> <operator>=</operator> <name>reqcu</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zeroreqcuflags</name> <operator>=</operator> <name>reqcuflags</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>firstcuflags</name> <operator>==</operator> <name>REQ_UNSET</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>firstcuflags</name> <operator>=</operator> <name>REQ_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>zerofirstcu</name> <operator>=</operator> <name>firstcu</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zerofirstcuflags</name> <operator>=</operator> <name>firstcuflags</name></expr>;</expr_stmt>

      <comment type="block">/* For caseless UTF or UCP mode, check whether this character has more
      than one other case. If so, generate a special OP_NOTPROP item instead of
      OP_NOTI. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>utf</name><operator>||</operator><name>ucp</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_CASELESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
          <operator>(</operator><name>d</name> <operator>=</operator> <call><name>UCD_CASESET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_NOTPROP</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>PT_CLIST</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
        <break>break;</break>   <comment type="block">/* We are finished with this class */</comment>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <comment type="block">/* Char has only one other case, or UCP not available */</comment>

      <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_CASELESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name>OP_NOTI</name></expr></then><else>: <expr><name>OP_NOT</name></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>PUTCHAR</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>   <comment type="block">/* We are finished with this class */</comment>
      </block_content>}</block></if></if_stmt>        <comment type="block">/* End of 1-char optimization */</comment>

    <comment type="block">/* Handle character classes that contain more than just one literal
    character. If there are exactly two characters in a positive class, see if
    they are case partners. This can be optimized to generate a caseless single
    character match (which also sets first/required code units if relevant). */</comment>

    <if_stmt><if>if <condition>(<expr><name>meta</name> <operator>==</operator> <name>META_CLASS</name> <operator>&amp;&amp;</operator> <name><name>pptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name>META_END</name> <operator>&amp;&amp;</operator> <name><name>pptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;</operator> <name>META_END</name> <operator>&amp;&amp;</operator>
        <name><name>pptr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <name>META_CLASS_END</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name> <init>= <expr><name><name>pptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><call><name>UCD_CASESET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>d</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>utf</name> <operator>||</operator> <name>ucp</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>c</name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">8</literal></expr></cpp:if>
          <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>d</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>TABLE_GET</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>fcc</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
          </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>d</name> <operator>&amp;&amp;</operator> <name><name>pptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>d</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>                 <comment type="block">/* Move on to class end */</comment>
          <expr_stmt><expr><name>meta</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_CASELESS</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>reset_caseful</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_CASELESS</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>req_caseopt</name> <operator>=</operator> <name>REQ_CASELESS</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          <goto>goto <name>CLASS_CASELESS_CHAR</name>;</goto>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* If a non-extended class contains a negative special such as \S, we need
    to flip the negation flag at the end, so that support for characters &gt; 255
    works correctly (they are all included in the class). An extended class may
    need to insert specific matching or non-matching code for wide characters.
    */</comment>

    <expr_stmt><expr><name>should_flip_negation</name> <operator>=</operator> <name>match_all_or_no_wide_chars</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

    <comment type="block">/* Extended class (xclass) will be used when characters &gt; 255
    might match. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_WIDE_CHARS</name></cpp:ifdef>
    <expr_stmt><expr><name>xclass</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>class_uchardata</name> <operator>=</operator> <name>code</name> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>   <comment type="block">/* For XCLASS items */</comment>
    <expr_stmt><expr><name>class_uchardata_base</name> <operator>=</operator> <name>class_uchardata</name></expr>;</expr_stmt>   <comment type="block">/* Save the start */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* For optimization purposes, we track some properties of the class:
    class_has_8bitchar will be non-zero if the class contains at least one
    character with a code point less than 256; xclass_has_prop will be TRUE if
    Unicode property checks are present in the class. */</comment>

    <expr_stmt><expr><name>class_has_8bitchar</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_WIDE_CHARS</name></cpp:ifdef>
    <expr_stmt><expr><name>xclass_has_prop</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Initialize the 256-bit (32-byte) bit map to all zeros. We build the map
    in a temporary bit of memory, in case the class contains fewer than two
    8-bit characters because in that case the compiled code doesn't use the bit
    map. */</comment>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>classbits</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">32</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Process items until META_CLASS_END is reached. */</comment>

    <while>while <condition>(<expr><operator>(</operator><name>meta</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>++</operator><name>pptr</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <name>META_CLASS_END</name></expr>)</condition>
      <block>{<block_content>
      <comment type="block">/* Handle POSIX classes such as [:alpha:] etc. */</comment>

      <if_stmt><if>if <condition>(<expr><name>meta</name> <operator>==</operator> <name>META_POSIX</name> <operator>||</operator> <name>meta</name> <operator>==</operator> <name>META_POSIX_NEG</name></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>local_negate</name> <init>= <expr><operator>(</operator><name>meta</name> <operator>==</operator> <name>META_POSIX_NEG</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>posix_class</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>++</operator><name>pptr</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>taboffset</name></decl>, <decl><type ref="prev"/><name>tabopt</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint8_t</name></type> <name><name>pbits</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><name>should_flip_negation</name> <operator>=</operator> <name>local_negate</name></expr>;</expr_stmt>  <comment type="block">/* Note negative special */</comment>

        <comment type="block">/* If matching is caseless, upper and lower are converted to alpha.
        This relies on the fact that the class table starts with alpha,
        lower, upper as the first 3 entries. */</comment>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_CASELESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>posix_class</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>posix_class</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* When PCRE2_UCP is set, some of the POSIX classes are converted to
        different escape sequences that use Unicode properties \p or \P.
        Others that are not available via \p or \P have to generate
        XCL_PROP/XCL_NOTPROP directly, which is done here. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <switch>switch<condition>(<expr><name>posix_class</name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>PC_GRAPH</name></expr>:</case>
          <case>case <expr><name>PC_PRINT</name></expr>:</case>
          <case>case <expr><name>PC_PUNCT</name></expr>:</case>
          <expr_stmt><expr><operator>*</operator><name>class_uchardata</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><name>local_negate</name></expr>?</condition><then> <expr><name>XCL_NOTPROP</name></expr> </then><else>: <expr><name>XCL_PROP</name></expr></else></ternary></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>class_uchardata</name><operator>++</operator> <operator>=</operator> <operator>(</operator><name>PCRE2_UCHAR</name><operator>)</operator>
            <operator>(</operator><ternary><condition><expr><operator>(</operator><name>posix_class</name> <operator>==</operator> <name>PC_GRAPH</name><operator>)</operator></expr>?</condition><then> <expr><name>PT_PXGRAPH</name></expr> </then><else>:
             <expr><ternary><condition><expr><operator>(</operator><name>posix_class</name> <operator>==</operator> <name>PC_PRINT</name><operator>)</operator></expr>?</condition><then> <expr><name>PT_PXPRINT</name></expr> </then><else>: <expr><name>PT_PXPUNCT</name></expr></else></ternary></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>class_uchardata</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>xclass_has_prop</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          <goto>goto <name>CONTINUE_CLASS</name>;</goto>

          <comment type="block">/* For the other POSIX classes (ascii, xdigit) we are going to
          fall through to the non-UCP case and build a bit map for
          characters with code points less than 256. However, if we are in
          a negated POSIX class, characters with code points greater than
          255 must either all match or all not match, depending on whether
          the whole class is not or is negated. For example, for
          [[:^ascii:]... they must all match, whereas for [^[:^xdigit:]...
          they must not.

          In the special case where there are no xclass items, this is
          automatically handled by the use of OP_CLASS or OP_NCLASS, but an
          explicit range is needed for OP_XCLASS. Setting a flag here
          causes the range to be generated later when it is known that
          OP_XCLASS is required. In the 8-bit library this is relevant only in
          utf mode, since no wide characters can exist otherwise. */</comment>

          <default>default:</default>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
          <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <expr_stmt><expr><name>match_all_or_no_wide_chars</name> <operator>|=</operator> <name>local_negate</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <break>break;</break>
          </block_content>}</block></switch></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>

        <comment type="block">/* In the non-UCP case, or when UCP makes no difference, we build the
        bit map for the POSIX class in a chunk of local store because we may
        be adding and subtracting from it, and we don't want to subtract bits
        that may be in the main map already. At the end we or the result into
        the bit map that is being built. */</comment>

        <expr_stmt><expr><name>posix_class</name> <operator>*=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

        <comment type="block">/* Copy in the first table (always present) */</comment>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pbits</name></expr></argument>, <argument><expr><name>cbits</name> <operator>+</operator> <name><name>posix_class_maps</name><index>[<expr><name>posix_class</name></expr>]</index></name></expr></argument>,
          <argument><expr><literal type="number">32</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If there is a second table, add or remove it as required. */</comment>

        <expr_stmt><expr><name>taboffset</name> <operator>=</operator> <name><name>posix_class_maps</name><index>[<expr><name>posix_class</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tabopt</name> <operator>=</operator> <name><name>posix_class_maps</name><index>[<expr><name>posix_class</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>taboffset</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>tabopt</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pbits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|=</operator> <name><name>cbits</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator><name>i</name> <operator>+</operator> <name>taboffset</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for></block_content></block></if>
          <else>else<block type="pseudo"><block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pbits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name><name>cbits</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator><name>i</name> <operator>+</operator> <name>taboffset</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for></block_content></block></else></if_stmt>
          </block_content>}</block></if></if_stmt>

        <comment type="block">/* Now see if we need to remove any special characters. An option
        value of 1 removes vertical space and 2 removes underscore. */</comment>

        <if_stmt><if>if <condition>(<expr><name>tabopt</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>tabopt</name> <operator>=</operator> <operator>-</operator><name>tabopt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>tabopt</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pbits</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><literal type="number">0x3c</literal></expr>;</expr_stmt></block_content></block></if>
          <if type="elseif">else if <condition>(<expr><name>tabopt</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>pbits</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Add the POSIX table or its complement into the main table that is
        being built and we are done. */</comment>

        <if_stmt><if>if <condition>(<expr><name>local_negate</name></expr>)</condition><block type="pseudo"><block_content>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>classbits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|=</operator> <operator>~</operator><name><name>pbits</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>classbits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|=</operator> <name><name>pbits</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for></block_content></block></else></if_stmt>

        <comment type="block">/* Every class contains at least one &lt; 256 character. */</comment>

        <expr_stmt><expr><name>class_has_8bitchar</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <goto>goto <name>CONTINUE_CLASS</name>;</goto>    <comment type="block">/* End of POSIX handling */</comment>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Other than POSIX classes, the only items we should encounter are
      \d-type escapes and literal characters (possibly as ranges). */</comment>

      <if_stmt><if>if <condition>(<expr><name>meta</name> <operator>==</operator> <name>META_BIGVALUE</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>meta</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>++</operator><name>pptr</name><operator>)</operator></expr>;</expr_stmt>
        <goto>goto <name>CLASS_LITERAL</name>;</goto>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Any other non-literal must be an escape */</comment>

      <if_stmt><if>if <condition>(<expr><name>meta</name> <operator>&gt;=</operator> <name>META_END</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>META_CODE</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>META_ESCAPE</name></expr>)</condition>
          <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_SHOW_PARSED</name></cpp:ifdef>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"** Unrecognized parsed pattern item 0x%.8x "</literal>
                          <literal type="string">"in character class\n"</literal></expr></argument>, <argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR89</name></expr>;</expr_stmt>  <comment type="block">/* Internal error - unrecognized. */</comment>
          <return>return <expr><literal type="number">0</literal></expr>;</return>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>escape</name> <operator>=</operator> <call><name>META_DATA</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Every class contains at least one &lt; 256 character. */</comment>

        <expr_stmt><expr><name>class_has_8bitchar</name><operator>++</operator></expr>;</expr_stmt>

        <switch>switch<condition>(<expr><name>escape</name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>ESC_d</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>classbits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|=</operator> <name><name>cbits</name><index>[<expr><name>i</name><operator>+</operator><name>cbit_digit</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
          <break>break;</break>

          <case>case <expr><name>ESC_D</name></expr>:</case>
          <expr_stmt><expr><name>should_flip_negation</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>classbits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|=</operator> <operator>~</operator><name><name>cbits</name><index>[<expr><name>i</name><operator>+</operator><name>cbit_digit</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
          <break>break;</break>

          <case>case <expr><name>ESC_w</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>classbits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|=</operator> <name><name>cbits</name><index>[<expr><name>i</name><operator>+</operator><name>cbit_word</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
          <break>break;</break>

          <case>case <expr><name>ESC_W</name></expr>:</case>
          <expr_stmt><expr><name>should_flip_negation</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>classbits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|=</operator> <operator>~</operator><name><name>cbits</name><index>[<expr><name>i</name><operator>+</operator><name>cbit_word</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
          <break>break;</break>

          <comment type="block">/* Perl 5.004 onwards omitted VT from \s, but restored it at Perl
          5.18. Before PCRE 8.34, we had to preserve the VT bit if it was
          previously set by something earlier in the character class.
          Luckily, the value of CHAR_VT is 0x0b in both ASCII and EBCDIC, so
          we could just adjust the appropriate bit. From PCRE 8.34 we no
          longer treat \s and \S specially. */</comment>

          <case>case <expr><name>ESC_s</name></expr>:</case>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>classbits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|=</operator> <name><name>cbits</name><index>[<expr><name>i</name><operator>+</operator><name>cbit_space</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
          <break>break;</break>

          <case>case <expr><name>ESC_S</name></expr>:</case>
          <expr_stmt><expr><name>should_flip_negation</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>classbits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|=</operator> <operator>~</operator><name><name>cbits</name><index>[<expr><name>i</name><operator>+</operator><name>cbit_space</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
          <break>break;</break>

          <comment type="block">/* When adding the horizontal or vertical space lists to a class, or
          their complements, disable PCRE2_CASELESS, because it justs wastes
          time, and in the "not-x" UTF cases can create unwanted duplicates in
          the XCLASS list (provoked by characters that have more than one other
          case and by both cases being in the same "not-x" sublist). */</comment>

          <case>case <expr><name>ESC_h</name></expr>:</case>
          <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>add_list_to_class</name><argument_list>(<argument><expr><name>classbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>class_uchardata</name></expr></argument>,
            <argument><expr><name>options</name> <operator>&amp;</operator> <operator>~</operator><name>PCRE2_CASELESS</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><call><name>PRIV</name><argument_list>(<argument><expr><name>hspace_list</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NOTACHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>ESC_H</name></expr>:</case>
          <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>add_not_list_to_class</name><argument_list>(<argument><expr><name>classbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>class_uchardata</name></expr></argument>,
            <argument><expr><name>options</name> <operator>&amp;</operator> <operator>~</operator><name>PCRE2_CASELESS</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><call><name>PRIV</name><argument_list>(<argument><expr><name>hspace_list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>ESC_v</name></expr>:</case>
          <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>add_list_to_class</name><argument_list>(<argument><expr><name>classbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>class_uchardata</name></expr></argument>,
            <argument><expr><name>options</name> <operator>&amp;</operator> <operator>~</operator><name>PCRE2_CASELESS</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><call><name>PRIV</name><argument_list>(<argument><expr><name>vspace_list</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NOTACHAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>ESC_V</name></expr>:</case>
          <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>add_not_list_to_class</name><argument_list>(<argument><expr><name>classbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>class_uchardata</name></expr></argument>,
            <argument><expr><name>options</name> <operator>&amp;</operator> <operator>~</operator><name>PCRE2_CASELESS</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><call><name>PRIV</name><argument_list>(<argument><expr><name>vspace_list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>

          <comment type="block">/* If Unicode is not supported, \P and \p are not allowed and are
          faulted at parse time, so will never appear here. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
          <case>case <expr><name>ESC_p</name></expr>:</case>
          <case>case <expr><name>ESC_P</name></expr>:</case>
            <block>{<block_content>
            <decl_stmt><decl><type><name>uint32_t</name></type> <name>ptype</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>++</operator><name>pptr</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint32_t</name></type> <name>pdata</name> <init>= <expr><operator>*</operator><name>pptr</name> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><operator>*</operator><name>class_uchardata</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>escape</name> <operator>==</operator> <name>ESC_p</name><operator>)</operator></expr>?</condition><then> <expr><name>XCL_PROP</name></expr> </then><else>: <expr><name>XCL_NOTPROP</name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>class_uchardata</name><operator>++</operator> <operator>=</operator> <name>ptype</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>class_uchardata</name><operator>++</operator> <operator>=</operator> <name>pdata</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>xclass_has_prop</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>class_has_8bitchar</name><operator>--</operator></expr>;</expr_stmt>                <comment type="block">/* Undo! */</comment>
            </block_content>}</block>
          <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          </block_content>}</block></switch>

        <goto>goto <name>CONTINUE_CLASS</name>;</goto>
        </block_content>}</block></if>  <comment type="block">/* End handling \d-type escapes */</comment>

      <comment type="block">/* A literal character may be followed by a range meta. At parse time
      there are checks for out-of-order characters, for ranges where the two
      characters are equal, and for hyphens that cannot indicate a range. At
      this point, therefore, no checking is needed. */</comment>

      <else>else
        <block>{<block_content>
        <decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

        <label><name>CLASS_LITERAL</name>:</label>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <name>d</name> <operator>=</operator> <name>meta</name></expr>;</expr_stmt>

        <comment type="block">/* Remember if \r or \n were explicitly used */</comment>

        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CHAR_CR</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>CHAR_NL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>external_flags</name></name> <operator>|=</operator> <name>PCRE2_HASCRORLF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Process a character range */</comment>

        <if_stmt><if>if <condition>(<expr><name><name>pptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>META_RANGE_LITERAL</name> <operator>||</operator> <name><name>pptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>META_RANGE_ESCAPED</name></expr>)</condition>
          <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EBCDIC</name></cpp:ifdef>
          <decl_stmt><decl><type><name>BOOL</name></type> <name>range_is_literal</name> <init>= <expr><operator>(</operator><name><name>pptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>META_RANGE_LITERAL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>d</name> <operator>=</operator> <operator>*</operator><name>pptr</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <name>META_BIGVALUE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>d</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>++</operator><name>pptr</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

          <comment type="block">/* Remember an explicit \r or \n, and add the range to the class. */</comment>

          <if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <name>CHAR_CR</name> <operator>||</operator> <name>d</name> <operator>==</operator> <name>CHAR_NL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>external_flags</name></name> <operator>|=</operator> <name>PCRE2_HASCRORLF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

          <comment type="block">/* In an EBCDIC environment, Perl treats alphabetic ranges specially
          because there are holes in the encoding, and simply using the range
          A-Z (for example) would include the characters in the holes. This
          applies only to literal ranges; [\xC1-\xE9] is different to [A-Z]. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EBCDIC</name></cpp:ifdef>
          <if_stmt><if>if <condition>(<expr><name>range_is_literal</name> <operator>&amp;&amp;</operator>
               <operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_letter</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
               <operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>ctypes</name><index>[<expr><name>d</name></expr>]</index></name> <operator>&amp;</operator> <name>ctype_letter</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
               <operator>(</operator><name>c</name> <operator>&lt;=</operator> <name>CHAR_z</name><operator>)</operator> <operator>==</operator> <operator>(</operator><name>d</name> <operator>&lt;=</operator> <name>CHAR_z</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
            <decl_stmt><decl><type><name>uint32_t</name></type> <name>uc</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>d</name> <operator>&lt;=</operator> <name>CHAR_z</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">64</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint32_t</name></type> <name>C</name> <init>= <expr><name>c</name> <operator>-</operator> <name>uc</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint32_t</name></type> <name>D</name> <init>= <expr><name>d</name> <operator>-</operator> <name>uc</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>C</name> <operator>&lt;=</operator> <name>CHAR_i</name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><name>class_has_8bitchar</name> <operator>+=</operator>
                <call><name>add_to_class</name><argument_list>(<argument><expr><name>classbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>class_uchardata</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>C</name> <operator>+</operator> <name>uc</name></expr></argument>,
                  <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>D</name> <operator>&lt;</operator> <name>CHAR_i</name><operator>)</operator></expr>?</condition><then> <expr><name>D</name></expr> </then><else>: <expr><name>CHAR_i</name></expr></else></ternary><operator>)</operator> <operator>+</operator> <name>uc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>C</name> <operator>=</operator> <name>CHAR_j</name></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>C</name> <operator>&lt;=</operator> <name>D</name> <operator>&amp;&amp;</operator> <name>C</name> <operator>&lt;=</operator> <name>CHAR_r</name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><name>class_has_8bitchar</name> <operator>+=</operator>
                <call><name>add_to_class</name><argument_list>(<argument><expr><name>classbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>class_uchardata</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>C</name> <operator>+</operator> <name>uc</name></expr></argument>,
                  <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>D</name> <operator>&lt;</operator> <name>CHAR_r</name><operator>)</operator></expr>?</condition><then> <expr><name>D</name></expr> </then><else>: <expr><name>CHAR_r</name></expr></else></ternary><operator>)</operator> <operator>+</operator> <name>uc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>C</name> <operator>=</operator> <name>CHAR_s</name></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>C</name> <operator>&lt;=</operator> <name>D</name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><name>class_has_8bitchar</name> <operator>+=</operator>
                <call><name>add_to_class</name><argument_list>(<argument><expr><name>classbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>class_uchardata</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>C</name> <operator>+</operator> <name>uc</name></expr></argument>,
                  <argument><expr><name>D</name> <operator>+</operator> <name>uc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
          <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <comment type="block">/* Not an EBCDIC special range */</comment>

          <expr_stmt><expr><name>class_has_8bitchar</name> <operator>+=</operator>
            <call><name>add_to_class</name><argument_list>(<argument><expr><name>classbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>class_uchardata</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
          <goto>goto <name>CONTINUE_CLASS</name>;</goto>   <comment type="block">/* Go get the next char in the class */</comment>
          </block_content>}</block></if></if_stmt>  <comment type="block">/* End of range handling */</comment>


        <comment type="block">/* Handle a single character. */</comment>

        <expr_stmt><expr><name>class_has_8bitchar</name> <operator>+=</operator>
          <call><name>add_to_class</name><argument_list>(<argument><expr><name>classbits</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>class_uchardata</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>meta</name></expr></argument>, <argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

      <comment type="block">/* Continue to the next item in the class. */</comment>

      <label><name>CONTINUE_CLASS</name>:</label>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_WIDE_CHARS</name></cpp:ifdef>
      <comment type="block">/* If any wide characters or Unicode properties have been encountered,
      set xclass = TRUE. Then, in the pre-compile phase, accumulate the length
      of the extra data and reset the pointer. This is so that very large
      classes that contain a zillion wide characters or Unicode property tests
      do not overwrite the workspace (which is on the stack). */</comment>

      <if_stmt><if>if <condition>(<expr><name>class_uchardata</name> <operator>&gt;</operator> <name>class_uchardata_base</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>xclass</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>lengthptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>lengthptr</name> <operator>+=</operator> <name>class_uchardata</name> <operator>-</operator> <name>class_uchardata_base</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>class_uchardata</name> <operator>=</operator> <name>class_uchardata_base</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <continue>continue;</continue>  <comment type="block">/* Needed to avoid error when not supporting wide chars */</comment>
      </block_content>}</block></while>   <comment type="block">/* End of main class-processing loop */</comment>

    <comment type="block">/* If this class is the first thing in the branch, there can be no first
    char setting, whatever the repeat count. Any reqcu setting must remain
    unchanged after any kind of repeat. */</comment>

    <if_stmt><if>if <condition>(<expr><name>firstcuflags</name> <operator>==</operator> <name>REQ_UNSET</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>firstcuflags</name> <operator>=</operator> <name>REQ_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zerofirstcu</name> <operator>=</operator> <name>firstcu</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zerofirstcuflags</name> <operator>=</operator> <name>firstcuflags</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zeroreqcu</name> <operator>=</operator> <name>reqcu</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zeroreqcuflags</name> <operator>=</operator> <name>reqcuflags</name></expr>;</expr_stmt>

    <comment type="block">/* If there are characters with values &gt; 255, or Unicode property settings
    (\p or \P), we have to compile an extended class, with its own opcode,
    unless there were no property settings and there was a negated special such
    as \S in the class, and PCRE2_UCP is not set, because in that case all
    characters &gt; 255 are in or not in the class, so any that were explicitly
    given as well can be ignored.

    In the UCP case, if certain negated POSIX classes ([:^ascii:] or
    [^:xdigit:]) were present in a class, we either have to match or not match
    all wide characters (depending on whether the whole class is or is not
    negated). This requirement is indicated by match_all_or_no_wide_chars being
    true. We do this by including an explicit range, which works in both cases.
    This applies only in UTF and 16-bit and 32-bit non-UTF modes, since there
    cannot be any wide characters in 8-bit non-UTF mode.

    When there *are* properties in a positive UTF-8 or any 16-bit or 32_bit
    class where \S etc is present without PCRE2_UCP, causing an extended class
    to be compiled, we make sure that all characters &gt; 255 are included by
    forcing match_all_or_no_wide_chars to be true.

    If, when generating an xclass, there are no characters &lt; 256, we can omit
    the bitmap in the actual compiled code. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_WIDE_CHARS</name></cpp:ifdef>  <comment type="block">/* Defined for 16/32 bits, or 8-bit with Unicode */</comment>
    <if_stmt><if>if <condition>(<expr><name>xclass</name> <operator>&amp;&amp;</operator> <operator>(</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
        <operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <name>xclass_has_prop</name> <operator>||</operator> <operator>!</operator><name>should_flip_negation</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>match_all_or_no_wide_chars</name> <operator>||</operator> <operator>(</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
           <name>utf</name> <operator>&amp;&amp;</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
           <name>should_flip_negation</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>negate_class</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>class_uchardata</name><operator>++</operator> <operator>=</operator> <name>XCL_RANGE</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>   <comment type="block">/* Will always be utf in the 8-bit library */</comment>
          <block>{<block_content>
          <expr_stmt><expr><name>class_uchardata</name> <operator>+=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>ord2utf</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><literal type="number">0x100</literal></expr></argument>, <argument><expr><name>class_uchardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>class_uchardata</name> <operator>+=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>ord2utf</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>MAX_UTF_CODE_POINT</name></expr></argument>, <argument><expr><name>class_uchardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if>
        <else>else       <comment type="block">/* Can only happen for the 16-bit &amp; 32-bit libraries */</comment>
          <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:if>
          <expr_stmt><expr><operator>*</operator><name>class_uchardata</name><operator>++</operator> <operator>=</operator> <literal type="number">0x100</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>class_uchardata</name><operator>++</operator> <operator>=</operator> <literal type="number">0xffffu</literal></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:elif>
          <expr_stmt><expr><operator>*</operator><name>class_uchardata</name><operator>++</operator> <operator>=</operator> <literal type="number">0x100</literal></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>class_uchardata</name><operator>++</operator> <operator>=</operator> <literal type="number">0xffffffffu</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>class_uchardata</name><operator>++</operator> <operator>=</operator> <name>XCL_END</name></expr>;</expr_stmt>    <comment type="block">/* Marks the end of extra data */</comment>
      <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_XCLASS</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>code</name> <operator>+=</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>code</name> <operator>=</operator> <ternary><condition><expr><name>negate_class</name></expr>?</condition><then> <expr><name>XCL_NOT</name></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>xclass_has_prop</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>code</name> <operator>|=</operator> <name>XCL_HASPROP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <comment type="block">/* If the map is required, move up the extra data to make room for it;
      otherwise just move the code pointer to the end of the extra data. */</comment>

      <if_stmt><if>if <condition>(<expr><name>class_has_8bitchar</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>|=</operator> <name>XCL_MAP</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memmove</name><argument_list>(<argument><expr><name>code</name> <operator>+</operator> <operator>(</operator><literal type="number">32</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>, <argument><expr><name>code</name></expr></argument>,
          <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>class_uchardata</name> <operator>-</operator> <name>code</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>negate_class</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>xclass_has_prop</name></expr>)</condition>
          <block>{<block_content>
          <comment type="block">/* Using 255 ^ instead of ~ avoids clang sanitize warning. */</comment>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>classbits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">255</literal> <operator>^</operator> <name><name>classbits</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>classbits</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>code</name> <operator>=</operator> <name>class_uchardata</name> <operator>+</operator> <operator>(</operator><literal type="number">32</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>code</name> <operator>=</operator> <name>class_uchardata</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

      <comment type="block">/* Now fill in the complete length of the item */</comment>

      <expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>previous</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>code</name> <operator>-</operator> <name>previous</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>   <comment type="block">/* End of class handling */</comment>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_WIDE_CHARS */</comment>

    <comment type="block">/* If there are no characters &gt; 255, or they are all to be included or
    excluded, set the opcode to OP_CLASS or OP_NCLASS, depending on whether the
    whole class was negated and whether there were negative specials such as \S
    (non-UCP) in the class. Then copy the 32-byte map into the code vector,
    negating it if necessary. */</comment>

    <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>negate_class</name> <operator>==</operator> <name>should_flip_negation</name><operator>)</operator></expr> ?</condition><then> <expr><name>OP_CLASS</name></expr> </then><else>: <expr><name>OP_NCLASS</name></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>lengthptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>    <comment type="block">/* Save time in the pre-compile phase */</comment>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>negate_class</name></expr>)</condition>
        <block>{<block_content>
       <comment type="block">/* Using 255 ^ instead of ~ avoids clang sanitize warning. */</comment>
       <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>classbits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">255</literal> <operator>^</operator> <name><name>classbits</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
       </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>classbits</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>code</name> <operator>+=</operator> <literal type="number">32</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <break>break;</break>  <comment type="block">/* End of class processing */</comment>


    <comment type="block">/* ===================================================================*/</comment>
    <comment type="block">/* Deal with (*VERB)s. */</comment>

    <comment type="block">/* Check for open captures before ACCEPT and close those that are within
    the same assertion level, also converting ACCEPT to ASSERT_ACCEPT in an
    assertion. In the first pass, just accumulate the length required;
    otherwise hitting (*ACCEPT) inside many nested parentheses can cause
    workspace overflow. Do not set firstcu after *ACCEPT. */</comment>

    <case>case <expr><name>META_ACCEPT</name></expr>:</case>
    <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>had_accept</name></name> <operator>=</operator> <name>had_accept</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>oc</name> <operator>=</operator> <name><name>cb</name><operator>-&gt;</operator><name>open_caps</name></name></expr>;</init>
         <condition><expr><name>oc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>oc</name><operator>-&gt;</operator><name>assert_depth</name></name> <operator>&gt;=</operator> <name><name>cb</name><operator>-&gt;</operator><name>assert_depth</name></name></expr>;</condition>
         <incr><expr><name>oc</name> <operator>=</operator> <name><name>oc</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>lengthptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>lengthptr</name> <operator>+=</operator> <call><name>CU2BYTES</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_CLOSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PUT2INC</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>oc</name><operator>-&gt;</operator><name>number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
    <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>assert_depth</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name>OP_ASSERT_ACCEPT</name></expr> </then><else>: <expr><name>OP_ACCEPT</name></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>firstcuflags</name> <operator>==</operator> <name>REQ_UNSET</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>firstcuflags</name> <operator>=</operator> <name>REQ_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <break>break;</break>

    <case>case <expr><name>META_PRUNE</name></expr>:</case>
    <case>case <expr><name>META_SKIP</name></expr>:</case>
    <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>had_pruneorskip</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <comment type="block">/* Fall through */</comment>
    <case>case <expr><name>META_COMMIT</name></expr>:</case>
    <case>case <expr><name>META_FAIL</name></expr>:</case>
    <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name><name>verbops</name><index>[<expr><operator>(</operator><name>meta</name> <operator>-</operator> <name>META_MARK</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>]</index></name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_THEN</name></expr>:</case>
    <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>external_flags</name></name> <operator>|=</operator> <name>PCRE2_HASTHEN</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_THEN</name></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* Handle verbs with arguments. Arguments can be very long, especially in
    16- and 32-bit modes, and can overflow the workspace in the first pass.
    However, the argument length is constrained to be small enough to fit in
    one code unit. This check happens in parse_regex(). In the first pass,
    instead of putting the argument into memory, we just update the length
    counter and set up an empty argument. */</comment>

    <case>case <expr><name>META_THEN_ARG</name></expr>:</case>
    <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>external_flags</name></name> <operator>|=</operator> <name>PCRE2_HASTHEN</name></expr>;</expr_stmt>
    <goto>goto <name>VERB_ARG</name>;</goto>

    <case>case <expr><name>META_PRUNE_ARG</name></expr>:</case>
    <case>case <expr><name>META_SKIP_ARG</name></expr>:</case>
    <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>had_pruneorskip</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <comment type="block">/* Fall through */</comment>
    <case>case <expr><name>META_MARK</name></expr>:</case>
    <case>case <expr><name>META_COMMIT_ARG</name></expr>:</case>
    <label><name>VERB_ARG</name>:</label>
    <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name><name>verbops</name><index>[<expr><operator>(</operator><name>meta</name> <operator>-</operator> <name>META_MARK</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>]</index></name></expr>;</expr_stmt>
    <comment type="block">/* The length is in characters. */</comment>
    <expr_stmt><expr><name>verbarglen</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>++</operator><name>pptr</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>verbculen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>tempcode</name> <operator>=</operator> <name>code</name><operator>++</operator></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>verbarglen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
      <expr_stmt><expr><name>meta</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>++</operator><name>pptr</name><operator>)</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mclength</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>ord2utf</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>meta</name></expr></argument>, <argument><expr><name>mcbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <block>{<block_content>
        <expr_stmt><expr><name>mclength</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mcbuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>meta</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>lengthptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>lengthptr</name> <operator>+=</operator> <name>mclength</name></expr>;</expr_stmt></block_content></block></if> <else>else
        <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>mcbuffer</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>mclength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>code</name> <operator>+=</operator> <name>mclength</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>verbculen</name> <operator>+=</operator> <name>mclength</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>

    <expr_stmt><expr><operator>*</operator><name>tempcode</name> <operator>=</operator> <name>verbculen</name></expr>;</expr_stmt>   <comment type="block">/* Fill in the code unit length */</comment>
    <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>             <comment type="block">/* Terminating zero */</comment>
    <break>break;</break>


    <comment type="block">/* ===================================================================*/</comment>
    <comment type="block">/* Handle options change. The new setting must be passed back for use in
    subsequent branches. Reset the greedy defaults and the case value for
    firstcu and reqcu. */</comment>

    <case>case <expr><name>META_OPTIONS</name></expr>:</case>
    <expr_stmt><expr><operator>*</operator><name>optionsptr</name> <operator>=</operator> <name>options</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>++</operator><name>pptr</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>greedy_default</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_UNGREEDY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>greedy_non_default</name> <operator>=</operator> <name>greedy_default</name> <operator>^</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>req_caseopt</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_CASELESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name>REQ_CASELESS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <break>break;</break>


    <comment type="block">/* ===================================================================*/</comment>
    <comment type="block">/* Handle conditional subpatterns. The case of (?(Rdigits) is ambiguous
    because it could be a numerical check on recursion, or a name check on a
    group's being set. The pre-pass sets up META_COND_RNUMBER as a name so that
    we can handle it either way. We first try for a name; if not found, process
    the number. */</comment>

    <case>case <expr><name>META_COND_RNUMBER</name></expr>:</case>   <comment type="block">/* (?(Rdigits) */</comment>
    <case>case <expr><name>META_COND_NAME</name></expr>:</case>      <comment type="block">/* (?(name) or (?'name') or ?(&lt;name&gt;) */</comment>
    <case>case <expr><name>META_COND_RNAME</name></expr>:</case>     <comment type="block">/* (?(R&amp;name) - test for recursion */</comment>
    <expr_stmt><expr><name>bravalue</name> <operator>=</operator> <name>OP_COND</name></expr>;</expr_stmt>
      <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>, <decl><type ref="prev"/><name>index</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>name</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>named_group</name> <modifier>*</modifier></type><name>ng</name> <init>= <expr><name><name>cb</name><operator>-&gt;</operator><name>named_groups</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>length</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>++</operator><name>pptr</name><operator>)</operator></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>GETPLUSOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>cb</name><operator>-&gt;</operator><name>start_pattern</name></name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt>

      <comment type="block">/* In the first pass, the names generated in the pre-pass are available,
      but the main name table has not yet been created. Scan the list of names
      generated in the pre-pass in order to get a number and whether or not
      this name is duplicated. If it is not duplicated, we can handle it as a
      numerical group. */</comment>

      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>names_found</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ng</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <name><name>ng</name><operator>-&gt;</operator><name>length</name></name> <operator>&amp;&amp;</operator>
            <call><call><name>PRIV</name><argument_list>(<argument><expr><name>strncmp</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>ng</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ng</name><operator>-&gt;</operator><name>isdup</name></name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name><name>code</name><index>[<expr><literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>meta</name> <operator>==</operator> <name>META_COND_RNAME</name><operator>)</operator></expr>?</condition><then> <expr><name>OP_RREF</name></expr> </then><else>: <expr><name>OP_CREF</name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PUT2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>+</operator><name>LINK_SIZE</name></expr></argument>, <argument><expr><name><name>ng</name><operator>-&gt;</operator><name>number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>ng</name><operator>-&gt;</operator><name>number</name></name> <operator>&gt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>top_backref</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>top_backref</name></name> <operator>=</operator> <name><name>ng</name><operator>-&gt;</operator><name>number</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>skipunits</name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>;</expr_stmt>
            <goto>goto <name>GROUP_PROCESS_NOTE_EMPTY</name>;</goto>
            </block_content>}</block></if></if_stmt>
          <break>break;</break>  <comment type="block">/* Found a duplicated name */</comment>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

      <comment type="block">/* If the name was not found we have a bad reference, unless we are
      dealing with R&lt;digits&gt;, which is treated as a recursion test by number.
      */</comment>

      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>cb</name><operator>-&gt;</operator><name>names_found</name></name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>groupnumber</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>meta</name> <operator>==</operator> <name>META_COND_RNUMBER</name></expr>)</condition>
          <block>{<block_content>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
            <expr_stmt><expr><name>groupnumber</name> <operator>=</operator> <name>groupnumber</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <name><name>name</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name>CHAR_0</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>groupnumber</name> <operator>&gt;</operator> <name>MAX_GROUP_NUMBER</name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR61</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>erroroffset</name></name> <operator>=</operator> <name>offset</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
              <return>return <expr><literal type="number">0</literal></expr>;</return>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
          </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>meta</name> <operator>!=</operator> <name>META_COND_RNUMBER</name> <operator>||</operator> <name>groupnumber</name> <operator>&gt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR15</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>erroroffset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
          <return>return <expr><literal type="number">0</literal></expr>;</return>
          </block_content>}</block></if></if_stmt>

        <comment type="block">/* (?Rdigits) treated as a recursion reference by number. A value of
        zero (which is the result of both (?R) and (?R0)) means "any", and is
        translated into RREF_ANY (which is 0xffff). */</comment>

        <if_stmt><if>if <condition>(<expr><name>groupnumber</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>groupnumber</name> <operator>=</operator> <name>RREF_ANY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>code</name><index>[<expr><literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name></expr>]</index></name> <operator>=</operator> <name>OP_RREF</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PUT2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>+</operator><name>LINK_SIZE</name></expr></argument>, <argument><expr><name>groupnumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>skipunits</name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>;</expr_stmt>
        <goto>goto <name>GROUP_PROCESS_NOTE_EMPTY</name>;</goto>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* A duplicated name was found. Note that if an R&lt;digits&gt; name is found
      (META_COND_RNUMBER), it is a reference test, not a recursion test. */</comment>

      <expr_stmt><expr><name><name>code</name><index>[<expr><literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>meta</name> <operator>==</operator> <name>META_COND_RNAME</name><operator>)</operator></expr>?</condition><then> <expr><name>OP_RREF</name></expr> </then><else>: <expr><name>OP_CREF</name></expr></else></ternary></expr>;</expr_stmt>

      <comment type="block">/* We have a duplicated name. In the compile pass we have to search the
      main table in order to get the index and count values. */</comment>

      <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Values for first pass (avoids compiler warning) */</comment>
      <expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>lengthptr</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>find_dupname_details</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>, <argument><expr><name>errorcodeptr</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

      <comment type="block">/* Add one to the opcode to change CREF/RREF into DNCREF/DNRREF and
      insert appropriate data values. */</comment>

      <expr_stmt><expr><name><name>code</name><index>[<expr><literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>skipunits</name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><literal type="number">2</literal><operator>*</operator><name>IMM2_SIZE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PUT2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>+</operator><name>LINK_SIZE</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PUT2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>+</operator><name>LINK_SIZE</name><operator>+</operator><name>IMM2_SIZE</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block>
    <goto>goto <name>GROUP_PROCESS_NOTE_EMPTY</name>;</goto>

    <comment type="block">/* The DEFINE condition is always false. Its internal groups may never
    be called, so matched_char must remain false, hence the jump to
    GROUP_PROCESS rather than GROUP_PROCESS_NOTE_EMPTY. */</comment>

    <case>case <expr><name>META_COND_DEFINE</name></expr>:</case>
    <expr_stmt><expr><name>bravalue</name> <operator>=</operator> <name>OP_COND</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GETPLUSOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>code</name><index>[<expr><literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name></expr>]</index></name> <operator>=</operator> <name>OP_DEFINE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>skipunits</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <goto>goto <name>GROUP_PROCESS</name>;</goto>

    <comment type="block">/* Conditional test of a group's being set. */</comment>

    <case>case <expr><name>META_COND_NUMBER</name></expr>:</case>
    <expr_stmt><expr><name>bravalue</name> <operator>=</operator> <name>OP_COND</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GETPLUSOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>groupnumber</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>++</operator><name>pptr</name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>groupnumber</name> <operator>&gt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR15</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>erroroffset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>groupnumber</name> <operator>&gt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>top_backref</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>top_backref</name></name> <operator>=</operator> <name>groupnumber</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>offset</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>   <comment type="block">/* Point at initial ( for too many branches error */</comment>
    <expr_stmt><expr><name><name>code</name><index>[<expr><literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name></expr>]</index></name> <operator>=</operator> <name>OP_CREF</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>skipunits</name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><name>IMM2_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PUT2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>+</operator><name>LINK_SIZE</name></expr></argument>, <argument><expr><name>groupnumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>GROUP_PROCESS_NOTE_EMPTY</name>;</goto>

    <comment type="block">/* Test for the PCRE2 version. */</comment>

    <case>case <expr><name>META_COND_VERSION</name></expr>:</case>
    <expr_stmt><expr><name>bravalue</name> <operator>=</operator> <name>OP_COND</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>code</name><index>[<expr><literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>PCRE2_MAJOR</name> <operator>&gt;</operator> <name><name>pptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>PCRE2_MAJOR</name> <operator>==</operator> <name><name>pptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>PCRE2_MINOR</name> <operator>&gt;=</operator> <name><name>pptr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator><operator>)</operator></expr>?</condition><then>
          <expr><name>OP_TRUE</name></expr> </then><else>: <expr><name>OP_FALSE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>code</name><index>[<expr><literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>PCRE2_MAJOR</name> <operator>==</operator> <name><name>pptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>PCRE2_MINOR</name> <operator>==</operator> <name><name>pptr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator></expr>?</condition><then>
        <expr><name>OP_TRUE</name></expr> </then><else>: <expr><name>OP_FALSE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name>skipunits</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <goto>goto <name>GROUP_PROCESS_NOTE_EMPTY</name>;</goto>

    <comment type="block">/* The condition is an assertion, possibly preceded by a callout. */</comment>

    <case>case <expr><name>META_COND_ASSERT</name></expr>:</case>
    <expr_stmt><expr><name>bravalue</name> <operator>=</operator> <name>OP_COND</name></expr>;</expr_stmt>
    <goto>goto <name>GROUP_PROCESS_NOTE_EMPTY</name>;</goto>


    <comment type="block">/* ===================================================================*/</comment>
    <comment type="block">/* Handle all kinds of nested bracketed groups. The non-capturing,
    non-conditional cases are here; others come to GROUP_PROCESS via goto. */</comment>

    <case>case <expr><name>META_LOOKAHEAD</name></expr>:</case>
    <expr_stmt><expr><name>bravalue</name> <operator>=</operator> <name>OP_ASSERT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>assert_depth</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <goto>goto <name>GROUP_PROCESS</name>;</goto>

    <case>case <expr><name>META_LOOKAHEAD_NA</name></expr>:</case>
    <expr_stmt><expr><name>bravalue</name> <operator>=</operator> <name>OP_ASSERT_NA</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>assert_depth</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <goto>goto <name>GROUP_PROCESS</name>;</goto>

    <comment type="block">/* Optimize (?!) to (*FAIL) unless it is quantified - which is a weird
    thing to do, but Perl allows all assertions to be quantified, and when
    they contain capturing parentheses there may be a potential use for
    this feature. Not that that applies to a quantified (?!) but we allow
    it for uniformity. */</comment>

    <case>case <expr><name>META_LOOKAHEADNOT</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>pptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>META_KET</name> <operator>&amp;&amp;</operator>
         <operator>(</operator><name><name>pptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;</operator> <name>META_ASTERISK</name> <operator>||</operator> <name><name>pptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&gt;</operator> <name>META_MINMAX_QUERY</name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_FAIL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pptr</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><name>bravalue</name> <operator>=</operator> <name>OP_ASSERT_NOT</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>assert_depth</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <goto>goto <name>GROUP_PROCESS</name>;</goto>
      </block_content>}</block></else></if_stmt>
    <break>break;</break>

    <case>case <expr><name>META_LOOKBEHIND</name></expr>:</case>
    <expr_stmt><expr><name>bravalue</name> <operator>=</operator> <name>OP_ASSERTBACK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>assert_depth</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <goto>goto <name>GROUP_PROCESS</name>;</goto>

    <case>case <expr><name>META_LOOKBEHINDNOT</name></expr>:</case>
    <expr_stmt><expr><name>bravalue</name> <operator>=</operator> <name>OP_ASSERTBACK_NOT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>assert_depth</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <goto>goto <name>GROUP_PROCESS</name>;</goto>

    <case>case <expr><name>META_LOOKBEHIND_NA</name></expr>:</case>
    <expr_stmt><expr><name>bravalue</name> <operator>=</operator> <name>OP_ASSERTBACK_NA</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>assert_depth</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <goto>goto <name>GROUP_PROCESS</name>;</goto>

    <case>case <expr><name>META_ATOMIC</name></expr>:</case>
    <expr_stmt><expr><name>bravalue</name> <operator>=</operator> <name>OP_ONCE</name></expr>;</expr_stmt>
    <goto>goto <name>GROUP_PROCESS_NOTE_EMPTY</name>;</goto>

    <case>case <expr><name>META_SCRIPT_RUN</name></expr>:</case>
    <expr_stmt><expr><name>bravalue</name> <operator>=</operator> <name>OP_SCRIPT_RUN</name></expr>;</expr_stmt>
    <goto>goto <name>GROUP_PROCESS_NOTE_EMPTY</name>;</goto>

    <case>case <expr><name>META_NOCAPTURE</name></expr>:</case>
    <expr_stmt><expr><name>bravalue</name> <operator>=</operator> <name>OP_BRA</name></expr>;</expr_stmt>
    <comment type="block">/* Fall through */</comment>

    <comment type="block">/* Process nested bracketed regex. The nesting depth is maintained for the
    benefit of the stackguard function. The test for too deep nesting is now
    done in parse_regex(). Assertion and DEFINE groups come to GROUP_PROCESS;
    others come to GROUP_PROCESS_NOTE_EMPTY, to indicate that we need to take
    note of whether or not they may match an empty string. */</comment>

    <label><name>GROUP_PROCESS_NOTE_EMPTY</name>:</label>
    <expr_stmt><expr><name>note_group_empty</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

    <label><name>GROUP_PROCESS</name>:</label>
    <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>parens_depth</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>code</name> <operator>=</operator> <name>bravalue</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pptr</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>tempcode</name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tempreqvary</name> <operator>=</operator> <name><name>cb</name><operator>-&gt;</operator><name>req_varyopt</name></name></expr>;</expr_stmt>        <comment type="block">/* Save value before group */</comment>
    <expr_stmt><expr><name>length_prevgroup</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                 <comment type="block">/* Initialize for pre-compile phase */</comment>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>group_return</name> <operator>=</operator>
         <call><name>compile_regex</name><argument_list>(
         <argument><expr><name>options</name></expr></argument>,                         <comment type="block">/* The option state */</comment>
         <argument><expr><operator>&amp;</operator><name>tempcode</name></expr></argument>,                       <comment type="block">/* Where to put code (updated) */</comment>
         <argument><expr><operator>&amp;</operator><name>pptr</name></expr></argument>,                           <comment type="block">/* Input pointer (updated) */</comment>
         <argument><expr><name>errorcodeptr</name></expr></argument>,                    <comment type="block">/* Where to put an error message */</comment>
         <argument><expr><name>skipunits</name></expr></argument>,                       <comment type="block">/* Skip over bracket number */</comment>
         <argument><expr><operator>&amp;</operator><name>subfirstcu</name></expr></argument>,                     <comment type="block">/* For possible first char */</comment>
         <argument><expr><operator>&amp;</operator><name>subfirstcuflags</name></expr></argument>,
         <argument><expr><operator>&amp;</operator><name>subreqcu</name></expr></argument>,                       <comment type="block">/* For possible last char */</comment>
         <argument><expr><operator>&amp;</operator><name>subreqcuflags</name></expr></argument>,
         <argument><expr><name>bcptr</name></expr></argument>,                           <comment type="block">/* Current branch chain */</comment>
         <argument><expr><name>cb</name></expr></argument>,                              <comment type="block">/* Compile data block */</comment>
         <argument><expr><ternary><condition><expr><operator>(</operator><name>lengthptr</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then> <expr><name>NULL</name></expr> </then><else>:      <comment type="block">/* Actual compile phase */</comment>
           <expr><operator>&amp;</operator><name>length_prevgroup</name></expr></else></ternary></expr></argument>              <comment type="block">/* Pre-compile phase */</comment>
         )</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Error */</comment>

    <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>parens_depth</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* If that was a non-conditional significant group (not an assertion, not a
    DEFINE) that matches at least one character, then the current item matches
    a character. Conditionals are handled below. */</comment>

    <if_stmt><if>if <condition>(<expr><name>note_group_empty</name> <operator>&amp;&amp;</operator> <name>bravalue</name> <operator>!=</operator> <name>OP_COND</name> <operator>&amp;&amp;</operator> <name>group_return</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>matched_char</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* If we've just compiled an assertion, pop the assert depth. */</comment>

    <if_stmt><if>if <condition>(<expr><name>bravalue</name> <operator>&gt;=</operator> <name>OP_ASSERT</name> <operator>&amp;&amp;</operator> <name>bravalue</name> <operator>&lt;=</operator> <name>OP_ASSERTBACK_NA</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>assert_depth</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* At the end of compiling, code is still pointing to the start of the
    group, while tempcode has been updated to point past the end of the group.
    The parsed pattern pointer (pptr) is on the closing META_KET.

    If this is a conditional bracket, check that there are no more than
    two branches in the group, or just one if it's a DEFINE group. We do this
    in the real compile phase, not in the pre-pass, where the whole group may
    not be available. */</comment>

    <if_stmt><if>if <condition>(<expr><name>bravalue</name> <operator>==</operator> <name>OP_COND</name> <operator>&amp;&amp;</operator> <name>lengthptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>tc</name> <init>= <expr><name>code</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>condcount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <do>do <block>{<block_content>
         <expr_stmt><expr><name>condcount</name><operator>++</operator></expr>;</expr_stmt>
         <expr_stmt><expr><name>tc</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>tc</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         </block_content>}</block>
      while <condition>(<expr><operator>*</operator><name>tc</name> <operator>!=</operator> <name>OP_KET</name></expr>)</condition>;</do>

      <comment type="block">/* A DEFINE group is never obeyed inline (the "condition" is always
      false). It must have only one branch. Having checked this, change the
      opcode to OP_FALSE. */</comment>

      <if_stmt><if>if <condition>(<expr><name><name>code</name><index>[<expr><name>LINK_SIZE</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>OP_DEFINE</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>condcount</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>erroroffset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR54</name></expr>;</expr_stmt>
          <return>return <expr><literal type="number">0</literal></expr>;</return>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>code</name><index>[<expr><name>LINK_SIZE</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>OP_FALSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bravalue</name> <operator>=</operator> <name>OP_DEFINE</name></expr>;</expr_stmt>   <comment type="block">/* A flag to suppress char handling below */</comment>
        </block_content>}</block></if>

      <comment type="block">/* A "normal" conditional group. If there is just one branch, we must not
      make use of its firstcu or reqcu, because this is equivalent to an
      empty second branch. Also, it may match an empty string. If there are two
      branches, this item must match a character if the group must. */</comment>

      <else>else
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>condcount</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>erroroffset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR27</name></expr>;</expr_stmt>
          <return>return <expr><literal type="number">0</literal></expr>;</return>
          </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>condcount</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>subfirstcuflags</name> <operator>=</operator> <name>subreqcuflags</name> <operator>=</operator> <name>REQ_NONE</name></expr>;</expr_stmt></block_content></block></if>
          <if type="elseif">else if <condition>(<expr><name>group_return</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>matched_char</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* In the pre-compile phase, update the length by the length of the group,
    less the brackets at either end. Then reduce the compiled code to just a
    set of non-capturing brackets so that it doesn't use much memory if it is
    duplicated by a quantifier.*/</comment>

    <if_stmt><if>if <condition>(<expr><name>lengthptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>OFLOW_MAX</name> <operator>-</operator> <operator>*</operator><name>lengthptr</name> <operator>&lt;</operator> <name>length_prevgroup</name> <operator>-</operator> <literal type="number">2</literal> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR20</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>lengthptr</name> <operator>+=</operator> <name>length_prevgroup</name> <operator>-</operator> <literal type="number">2</literal> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>code</name><operator>++</operator></expr>;</expr_stmt>   <comment type="block">/* This already contains bravalue */</comment>
      <expr_stmt><expr><call><name>PUTINC</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_KET</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PUTINC</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>    <comment type="block">/* No need to waste time with special character handling */</comment>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Otherwise update the main code pointer to the end of the group. */</comment>

    <expr_stmt><expr><name>code</name> <operator>=</operator> <name>tempcode</name></expr>;</expr_stmt>

    <comment type="block">/* For a DEFINE group, required and first character settings are not
    relevant. */</comment>

    <if_stmt><if>if <condition>(<expr><name>bravalue</name> <operator>==</operator> <name>OP_DEFINE</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

    <comment type="block">/* Handle updating of the required and first code units for other types of
    group. Update for normal brackets of all kinds, and conditions with two
    branches (see code above). If the bracket is followed by a quantifier with
    zero repeat, we have to back off. Hence the definition of zeroreqcu and
    zerofirstcu outside the main loop so that they can be accessed for the back
    off. */</comment>

    <expr_stmt><expr><name>zeroreqcu</name> <operator>=</operator> <name>reqcu</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zeroreqcuflags</name> <operator>=</operator> <name>reqcuflags</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zerofirstcu</name> <operator>=</operator> <name>firstcu</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zerofirstcuflags</name> <operator>=</operator> <name>firstcuflags</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>groupsetfirstcu</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>bravalue</name> <operator>&gt;=</operator> <name>OP_ONCE</name></expr>)</condition>  <comment type="block">/* Not an assertion */</comment>
      <block>{<block_content>
      <comment type="block">/* If we have not yet set a firstcu in this branch, take it from the
      subpattern, remembering that it was set here so that a repeat of more
      than one can replicate it as reqcu if necessary. If the subpattern has
      no firstcu, set "none" for the whole branch. In both cases, a zero
      repeat forces firstcu to "none". */</comment>

      <if_stmt><if>if <condition>(<expr><name>firstcuflags</name> <operator>==</operator> <name>REQ_UNSET</name> <operator>&amp;&amp;</operator> <name>subfirstcuflags</name> <operator>!=</operator> <name>REQ_UNSET</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>subfirstcuflags</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>firstcu</name> <operator>=</operator> <name>subfirstcu</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>firstcuflags</name> <operator>=</operator> <name>subfirstcuflags</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>groupsetfirstcu</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>firstcuflags</name> <operator>=</operator> <name>REQ_NONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>zerofirstcuflags</name> <operator>=</operator> <name>REQ_NONE</name></expr>;</expr_stmt>
        </block_content>}</block></if>

      <comment type="block">/* If firstcu was previously set, convert the subpattern's firstcu
      into reqcu if there wasn't one, using the vary flag that was in
      existence beforehand. */</comment>

      <if type="elseif">else if <condition>(<expr><name>subfirstcuflags</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>subreqcuflags</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>subreqcu</name> <operator>=</operator> <name>subfirstcu</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>subreqcuflags</name> <operator>=</operator> <name>subfirstcuflags</name> <operator>|</operator> <name>tempreqvary</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* If the subpattern set a required code unit (or set a first code unit
      that isn't really the first code unit - see above), set it. */</comment>

      <if_stmt><if>if <condition>(<expr><name>subreqcuflags</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>reqcu</name> <operator>=</operator> <name>subreqcu</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>reqcuflags</name> <operator>=</operator> <name>subreqcuflags</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if>

    <comment type="block">/* For a forward assertion, we take the reqcu, if set, provided that the
    group has also set a firstcu. This can be helpful if the pattern that
    follows the assertion doesn't set a different char. For example, it's
    useful for /(?=abcde).+/. We can't set firstcu for an assertion, however
    because it leads to incorrect effect for patterns such as /(?=a)a.+/ when
    the "real" "a" would then become a reqcu instead of a firstcu. This is
    overcome by a scan at the end if there's no firstcu, looking for an
    asserted first char. A similar effect for patterns like /(?=.*X)X$/ means
    we must only take the reqcu when the group also set a firstcu. Otherwise,
    in that example, 'X' ends up set for both. */</comment>

    <if type="elseif">else if <condition>(<expr><operator>(</operator><name>bravalue</name> <operator>==</operator> <name>OP_ASSERT</name> <operator>||</operator> <name>bravalue</name> <operator>==</operator> <name>OP_ASSERT_NA</name><operator>)</operator> <operator>&amp;&amp;</operator>
             <name>subreqcuflags</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>subfirstcuflags</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>reqcu</name> <operator>=</operator> <name>subreqcu</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>reqcuflags</name> <operator>=</operator> <name>subreqcuflags</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <break>break;</break>  <comment type="block">/* End of nested group handling */</comment>


    <comment type="block">/* ===================================================================*/</comment>
    <comment type="block">/* Handle named backreferences and recursions. */</comment>

    <case>case <expr><name>META_BACKREF_BYNAME</name></expr>:</case>
    <case>case <expr><name>META_RECURSE_BYNAME</name></expr>:</case>
      <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>, <decl><type ref="prev"/><name>index</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>name</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BOOL</name></type> <name>is_dupname</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>named_group</name> <modifier>*</modifier></type><name>ng</name> <init>= <expr><name><name>cb</name><operator>-&gt;</operator><name>named_groups</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>length</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>++</operator><name>pptr</name><operator>)</operator></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>GETPLUSOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>cb</name><operator>-&gt;</operator><name>start_pattern</name></name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt>

      <comment type="block">/* In the first pass, the names generated in the pre-pass are available,
      but the main name table has not yet been created. Scan the list of names
      generated in the pre-pass in order to get a number and whether or not
      this name is duplicated. */</comment>

      <expr_stmt><expr><name>groupnumber</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>names_found</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ng</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <name><name>ng</name><operator>-&gt;</operator><name>length</name></name> <operator>&amp;&amp;</operator>
            <call><call><name>PRIV</name><argument_list>(<argument><expr><name>strncmp</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>ng</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>is_dupname</name> <operator>=</operator> <name><name>ng</name><operator>-&gt;</operator><name>isdup</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>groupnumber</name> <operator>=</operator> <name><name>ng</name><operator>-&gt;</operator><name>number</name></name></expr>;</expr_stmt>

          <comment type="block">/* For a recursion, that's all that is needed. We can now go to
          the code that handles numerical recursion, applying it to the first
          group with the given name. */</comment>

          <if_stmt><if>if <condition>(<expr><name>meta</name> <operator>==</operator> <name>META_RECURSE_BYNAME</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>meta_arg</name> <operator>=</operator> <name>groupnumber</name></expr>;</expr_stmt>
            <goto>goto <name>HANDLE_NUMERICAL_RECURSION</name>;</goto>
            </block_content>}</block></if></if_stmt>

          <comment type="block">/* For a back reference, update the back reference map and the
          maximum back reference. */</comment>

          <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>backref_map</name></name> <operator>|=</operator> <ternary><condition><expr><operator>(</operator><name>groupnumber</name> <operator>&lt;</operator> <literal type="number">32</literal><operator>)</operator></expr>?</condition><then> <expr><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>groupnumber</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>groupnumber</name> <operator>&gt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>top_backref</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>top_backref</name></name> <operator>=</operator> <name>groupnumber</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

      <comment type="block">/* If the name was not found we have a bad reference. */</comment>

      <if_stmt><if>if <condition>(<expr><name>groupnumber</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR15</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>erroroffset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* If a back reference name is not duplicated, we can handle it as
      a numerical reference. */</comment>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_dupname</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>meta_arg</name> <operator>=</operator> <name>groupnumber</name></expr>;</expr_stmt>
        <goto>goto <name>HANDLE_SINGLE_REFERENCE</name>;</goto>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* If a back reference name is duplicated, we generate a different
      opcode to a numerical back reference. In the second pass we must
      search for the index and count in the final name table. */</comment>

      <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Values for first pass (avoids compiler warning) */</comment>
      <expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>lengthptr</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>find_dupname_details</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>, <argument><expr><name>errorcodeptr</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>firstcuflags</name> <operator>==</operator> <name>REQ_UNSET</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>firstcuflags</name> <operator>=</operator> <name>REQ_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_CASELESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name>OP_DNREFI</name></expr> </then><else>: <expr><name>OP_DNREF</name></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PUT2INC</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PUT2INC</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block>
    <break>break;</break>


    <comment type="block">/* ===================================================================*/</comment>
    <comment type="block">/* Handle a numerical callout. */</comment>

    <case>case <expr><name>META_CALLOUT_NUMBER</name></expr>:</case>
    <expr_stmt><expr><name><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>OP_CALLOUT</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>               <comment type="block">/* Offset to next pattern item */</comment>
    <expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>, <argument><expr><name><name>pptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Length of next pattern item */</comment>
    <expr_stmt><expr><name><name>code</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr>]</index></name> <operator>=</operator> <name><name>pptr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><name>OP_CALLOUT</name></expr>]</index></expr>;</expr_stmt>
    <break>break;</break>


    <comment type="block">/* ===================================================================*/</comment>
    <comment type="block">/* Handle a callout with a string argument. In the pre-pass we just compute
    the length without generating anything. The length in pptr[3] includes both
    delimiters; in the actual compile only the first one is copied, but a
    terminating zero is added. Any doubled delimiters within the string make
    this an overestimate, but it is not worth bothering about. */</comment>

    <case>case <expr><name>META_CALLOUT_STRING</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>lengthptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>lengthptr</name> <operator>+=</operator> <name><name>pptr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>LINK_SIZE</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SKIPOFFSET</name><argument_list>(<argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>

    <comment type="block">/* In the real compile we can copy the string. The starting delimiter is
     included so that the client can discover it if they want. We also pass the
     start offset to help a script language give better error messages. */</comment>

    <else>else
      <block>{<block_content>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>pp</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>delimiter</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>length</name> <init>= <expr><name><name>pptr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>callout_string</name> <init>= <expr><name>code</name> <operator>+</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <literal type="number">4</literal><operator>*</operator><name>LINK_SIZE</name><operator>)</operator></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>OP_CALLOUT_STR</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>               <comment type="block">/* Offset to next pattern item */</comment>
      <expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>, <argument><expr><name><name>pptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Length of next pattern item */</comment>

      <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETPLUSOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>         <comment type="block">/* Offset to string in pattern */</comment>
      <expr_stmt><expr><name>pp</name> <operator>=</operator> <name><name>cb</name><operator>-&gt;</operator><name>start_pattern</name></name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>delimiter</name> <operator>=</operator> <operator>*</operator><name>callout_string</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>pp</name><operator>++</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>delimiter</name> <operator>==</operator> <name>CHAR_LEFT_CURLY_BRACKET</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>delimiter</name> <operator>=</operator> <name>CHAR_RIGHT_CURLY_BRACKET</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">3</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>offset</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* One after delimiter */</comment>

      <comment type="block">/* The syntax of the pattern was checked in the parsing scan. The length
      includes both delimiters, but we have passed the opening one just above,
      so we reduce length before testing it. The test is for &gt; 1 because we do
      not want to copy the final delimiter. This also ensures that pp[1] is
      accessible. */</comment>

      <while>while <condition>(<expr><operator>--</operator><name>length</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pp</name> <operator>==</operator> <name>delimiter</name> <operator>&amp;&amp;</operator> <name><name>pp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>delimiter</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>callout_string</name><operator>++</operator> <operator>=</operator> <name>delimiter</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>pp</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>length</name><operator>--</operator></expr>;</expr_stmt>
          </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>callout_string</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>pp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></while>
      <expr_stmt><expr><operator>*</operator><name>callout_string</name><operator>++</operator> <operator>=</operator> <name>CHAR_NUL</name></expr>;</expr_stmt>

      <comment type="block">/* Set the length of the entire item, the advance to its end. */</comment>

      <expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>callout_string</name> <operator>-</operator> <name>code</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>code</name> <operator>=</operator> <name>callout_string</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    <break>break;</break>


    <comment type="block">/* ===================================================================*/</comment>
    <comment type="block">/* Handle repetition. The different types are all sorted out in the parsing
    pass. */</comment>

    <case>case <expr><name>META_MINMAX_PLUS</name></expr>:</case>
    <case>case <expr><name>META_MINMAX_QUERY</name></expr>:</case>
    <case>case <expr><name>META_MINMAX</name></expr>:</case>
    <expr_stmt><expr><name>repeat_min</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>++</operator><name>pptr</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>repeat_max</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>++</operator><name>pptr</name><operator>)</operator></expr>;</expr_stmt>
    <goto>goto <name>REPEAT</name>;</goto>

    <case>case <expr><name>META_ASTERISK</name></expr>:</case>
    <case>case <expr><name>META_ASTERISK_PLUS</name></expr>:</case>
    <case>case <expr><name>META_ASTERISK_QUERY</name></expr>:</case>
    <expr_stmt><expr><name>repeat_min</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>repeat_max</name> <operator>=</operator> <name>REPEAT_UNLIMITED</name></expr>;</expr_stmt>
    <goto>goto <name>REPEAT</name>;</goto>

    <case>case <expr><name>META_PLUS</name></expr>:</case>
    <case>case <expr><name>META_PLUS_PLUS</name></expr>:</case>
    <case>case <expr><name>META_PLUS_QUERY</name></expr>:</case>
    <expr_stmt><expr><name>repeat_min</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>repeat_max</name> <operator>=</operator> <name>REPEAT_UNLIMITED</name></expr>;</expr_stmt>
    <goto>goto <name>REPEAT</name>;</goto>

    <case>case <expr><name>META_QUERY</name></expr>:</case>
    <case>case <expr><name>META_QUERY_PLUS</name></expr>:</case>
    <case>case <expr><name>META_QUERY_QUERY</name></expr>:</case>
    <expr_stmt><expr><name>repeat_min</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>repeat_max</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <label><name>REPEAT</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>previous_matched_char</name> <operator>&amp;&amp;</operator> <name>repeat_min</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>matched_char</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Remember whether this is a variable length repeat, and default to
    single-char opcodes. */</comment>

    <expr_stmt><expr><name>reqvary</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>repeat_min</name> <operator>==</operator> <name>repeat_max</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>REQ_VARY</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>op_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Adjust first and required code units for a zero repeat. */</comment>

    <if_stmt><if>if <condition>(<expr><name>repeat_min</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>firstcu</name> <operator>=</operator> <name>zerofirstcu</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>firstcuflags</name> <operator>=</operator> <name>zerofirstcuflags</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>reqcu</name> <operator>=</operator> <name>zeroreqcu</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>reqcuflags</name> <operator>=</operator> <name>zeroreqcuflags</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Note the greediness and possessiveness. */</comment>

    <switch>switch <condition>(<expr><name>meta</name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>META_MINMAX_PLUS</name></expr>:</case>
      <case>case <expr><name>META_ASTERISK_PLUS</name></expr>:</case>
      <case>case <expr><name>META_PLUS_PLUS</name></expr>:</case>
      <case>case <expr><name>META_QUERY_PLUS</name></expr>:</case>
      <expr_stmt><expr><name>repeat_type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                  <comment type="block">/* Force greedy */</comment>
      <expr_stmt><expr><name>possessive_quantifier</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>META_MINMAX_QUERY</name></expr>:</case>
      <case>case <expr><name>META_ASTERISK_QUERY</name></expr>:</case>
      <case>case <expr><name>META_PLUS_QUERY</name></expr>:</case>
      <case>case <expr><name>META_QUERY_QUERY</name></expr>:</case>
      <expr_stmt><expr><name>repeat_type</name> <operator>=</operator> <name>greedy_non_default</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>possessive_quantifier</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <break>break;</break>

      <default>default:</default>
      <expr_stmt><expr><name>repeat_type</name> <operator>=</operator> <name>greedy_default</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>possessive_quantifier</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></switch>

    <comment type="block">/* Save start of previous item, in case we have to move it up in order to
    insert something before it, and remember what it was. */</comment>

    <expr_stmt><expr><name>tempcode</name> <operator>=</operator> <name>previous</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>op_previous</name> <operator>=</operator> <operator>*</operator><name>previous</name></expr>;</expr_stmt>

    <comment type="block">/* Now handle repetition for the different types of item. If the repeat
    minimum and the repeat maximum are both 1, we can ignore the quantifier for
    non-parenthesized items, as they have only one alternative. For anything in
    parentheses, we must not ignore if {1} is possessive. */</comment>

    <switch>switch <condition>(<expr><name>op_previous</name></expr>)</condition>
      <block>{<block_content>
      <comment type="block">/* If previous was a character or negated character match, abolish the
      item and generate a repeat item instead. If a char item has a minimum of
      more than one, ensure that it is set in reqcu - it might not be if a
      sequence such as x{3} is the first thing in a branch because the x will
      have gone into firstcu instead.  */</comment>

      <case>case <expr><name>OP_CHAR</name></expr>:</case>
      <case>case <expr><name>OP_CHARI</name></expr>:</case>
      <case>case <expr><name>OP_NOT</name></expr>:</case>
      <case>case <expr><name>OP_NOTI</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>repeat_max</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>repeat_min</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>END_REPEAT</name>;</goto></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>op_type</name> <operator>=</operator> <name><name>chartypeoffset</name><index>[<expr><name>op_previous</name> <operator>-</operator> <name>OP_CHAR</name></expr>]</index></name></expr>;</expr_stmt>

      <comment type="block">/* Deal with UTF characters that take up more than one code unit. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MAYBE_UTF_MULTI</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <call><name>NOT_FIRSTCU</name><argument_list>(<argument><expr><name><name>code</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>lastchar</name> <init>= <expr><name>code</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>BACKCHAR</name><argument_list>(<argument><expr><name>lastchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mclength</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>code</name> <operator>-</operator> <name>lastchar</name><operator>)</operator></expr>;</expr_stmt>   <comment type="block">/* Length of UTF character */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>mcbuffer</name></expr></argument>, <argument><expr><name>lastchar</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>mclength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Save the char */</comment>
        </block_content>}</block></if>
      <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* MAYBE_UTF_MULTI */</comment>

      <comment type="block">/* Handle the case of a single code unit - either with no UTF support, or
      with UTF disabled, or for a single-code-unit UTF character. */</comment>
        <block>{<block_content>
        <expr_stmt><expr><name><name>mcbuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>code</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>mclength</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>op_previous</name> <operator>&lt;=</operator> <name>OP_CHARI</name> <operator>&amp;&amp;</operator> <name>repeat_min</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>reqcu</name> <operator>=</operator> <name><name>mcbuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>reqcuflags</name> <operator>=</operator> <name>req_caseopt</name> <operator>|</operator> <name><name>cb</name><operator>-&gt;</operator><name>req_varyopt</name></name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      <goto>goto <name>OUTPUT_SINGLE_REPEAT</name>;</goto>  <comment type="block">/* Code shared with single character types */</comment>

      <comment type="block">/* If previous was a character class or a back reference, we put the
      repeat stuff after it, but just skip the item if the repeat was {0,0}. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_WIDE_CHARS</name></cpp:ifdef>
      <case>case <expr><name>OP_XCLASS</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <case>case <expr><name>OP_CLASS</name></expr>:</case>
      <case>case <expr><name>OP_NCLASS</name></expr>:</case>
      <case>case <expr><name>OP_REF</name></expr>:</case>
      <case>case <expr><name>OP_REFI</name></expr>:</case>
      <case>case <expr><name>OP_DNREF</name></expr>:</case>
      <case>case <expr><name>OP_DNREFI</name></expr>:</case>

      <if_stmt><if>if <condition>(<expr><name>repeat_max</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>code</name> <operator>=</operator> <name>previous</name></expr>;</expr_stmt>
        <goto>goto <name>END_REPEAT</name>;</goto>
        </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>repeat_max</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>repeat_min</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>END_REPEAT</name>;</goto></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>repeat_min</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>repeat_max</name> <operator>==</operator> <name>REPEAT_UNLIMITED</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_CRSTAR</name> <operator>+</operator> <name>repeat_type</name></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name>repeat_min</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>repeat_max</name> <operator>==</operator> <name>REPEAT_UNLIMITED</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_CRPLUS</name> <operator>+</operator> <name>repeat_type</name></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name>repeat_min</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>repeat_max</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_CRQUERY</name> <operator>+</operator> <name>repeat_type</name></expr>;</expr_stmt></block_content></block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_CRRANGE</name> <operator>+</operator> <name>repeat_type</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PUT2INC</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>repeat_min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>repeat_max</name> <operator>==</operator> <name>REPEAT_UNLIMITED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>repeat_max</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* 2-byte encoding for max */</comment>
        <expr_stmt><expr><call><name>PUT2INC</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>repeat_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      <break>break;</break>

      <comment type="block">/* If previous is OP_FAIL, it was generated by an empty class []
      (PCRE2_ALLOW_EMPTY_CLASS is set). The other ways in which OP_FAIL can be
      generated, that is by (*FAIL) or (?!), disallow a quantifier at parse
      time. We can just ignore this repeat. */</comment>

      <case>case <expr><name>OP_FAIL</name></expr>:</case>
      <goto>goto <name>END_REPEAT</name>;</goto>

      <comment type="block">/* Prior to 10.30, repeated recursions were wrapped in OP_ONCE brackets
      because pcre2_match() could not handle backtracking into recursively
      called groups. Now that this backtracking is available, we no longer need
      to do this. However, we still need to replicate recursions as we do for
      groups so as to have independent backtracking points. We can replicate
      for the minimum number of repeats directly. For optional repeats we now
      wrap the recursion in OP_BRA brackets and make use of the bracket
      repetition. */</comment>

      <case>case <expr><name>OP_RECURSE</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>repeat_max</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>repeat_min</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>possessive_quantifier</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>END_REPEAT</name>;</goto></block_content></block></if></if_stmt>

      <comment type="block">/* Generate unwrapped repeats for a non-zero minimum, except when the
      minimum is 1 and the maximum unlimited, because that can be handled with
      OP_BRA terminated by OP_KETRMAX/MIN. When the maximum is equal to the
      minimum, we just need to generate the appropriate additional copies.
      Otherwise we need to generate one more, to simulate the situation when
      the minimum is zero. */</comment>

      <if_stmt><if>if <condition>(<expr><name>repeat_min</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>repeat_min</name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <name>repeat_max</name> <operator>!=</operator> <name>REPEAT_UNLIMITED</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>replicate</name> <init>= <expr><name>repeat_min</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>repeat_min</name> <operator>==</operator> <name>repeat_max</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>replicate</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* In the pre-compile phase, we don't actually do the replication. We
        just adjust the length as if we had. Do some paranoid checks for
        potential integer overflow. The INT64_OR_DOUBLE type is a 64-bit
        integer type when available, otherwise double. */</comment>

        <if_stmt><if>if <condition>(<expr><name>lengthptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>delta</name> <init>= <expr><name>replicate</name><operator>*</operator><operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name>INT64_OR_DOUBLE</name><operator>)</operator><name>replicate</name><operator>*</operator>
                <operator>(</operator><name>INT64_OR_DOUBLE</name><operator>)</operator><operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name><operator>)</operator> <operator>&gt;</operator>
                  <operator>(</operator><name>INT64_OR_DOUBLE</name><operator>)</operator><name>INT_MAX</name> <operator>||</operator>
              <name>OFLOW_MAX</name> <operator>-</operator> <operator>*</operator><name>lengthptr</name> <operator>&lt;</operator> <name>delta</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR20</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><operator>*</operator><name>lengthptr</name> <operator>+=</operator> <name>delta</name></expr>;</expr_stmt>
          </block_content>}</block></if>

        <else>else<block type="pseudo"><block_content> <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>replicate</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>previous</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>previous</name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>code</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
          </block_content>}</block></for></block_content></block></else></if_stmt>

        <comment type="block">/* If the number of repeats is fixed, we are done. Otherwise, adjust
        the counts and fall through. */</comment>

        <if_stmt><if>if <condition>(<expr><name>repeat_min</name> <operator>==</operator> <name>repeat_max</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>repeat_max</name> <operator>!=</operator> <name>REPEAT_UNLIMITED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>repeat_max</name> <operator>-=</operator> <name>repeat_min</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>repeat_min</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Wrap the recursion call in OP_BRA brackets. */</comment>

      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memmove</name><argument_list>(<argument><expr><name>previous</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>, <argument><expr><name>previous</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>op_previous</name> <operator>=</operator> <operator>*</operator><name>previous</name> <operator>=</operator> <name>OP_BRA</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>previous</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>previous</name><index>[<expr><literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr>]</index></name> <operator>=</operator> <name>OP_KET</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>previous</name></expr></argument>, <argument><expr><literal type="number">3</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>code</name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>length_prevgroup</name> <operator>=</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">3</literal><operator>*</operator><name>LINK_SIZE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>group_return</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* Set "may match empty string" */</comment>

      <comment type="block">/* Now treat as a repeated OP_BRA. */</comment>
      <comment type="block">/* Fall through */</comment>

      <comment type="block">/* If previous was a bracket group, we may have to replicate it in
      certain cases. Note that at this point we can encounter only the "basic"
      bracket opcodes such as BRA and CBRA, as this is the place where they get
      converted into the more special varieties such as BRAPOS and SBRA.
      Originally, PCRE did not allow repetition of assertions, but now it does,
      for Perl compatibility. */</comment>

      <case>case <expr><name>OP_ASSERT</name></expr>:</case>
      <case>case <expr><name>OP_ASSERT_NOT</name></expr>:</case>
      <case>case <expr><name>OP_ASSERT_NA</name></expr>:</case>
      <case>case <expr><name>OP_ASSERTBACK</name></expr>:</case>
      <case>case <expr><name>OP_ASSERTBACK_NOT</name></expr>:</case>
      <case>case <expr><name>OP_ASSERTBACK_NA</name></expr>:</case>
      <case>case <expr><name>OP_ONCE</name></expr>:</case>
      <case>case <expr><name>OP_SCRIPT_RUN</name></expr>:</case>
      <case>case <expr><name>OP_BRA</name></expr>:</case>
      <case>case <expr><name>OP_CBRA</name></expr>:</case>
      <case>case <expr><name>OP_COND</name></expr>:</case>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>code</name> <operator>-</operator> <name>previous</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>bralink</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>brazeroptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>repeat_max</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>repeat_min</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>possessive_quantifier</name></expr>)</condition><block type="pseudo"><block_content>
          <goto>goto <name>END_REPEAT</name>;</goto></block_content></block></if></if_stmt>

        <comment type="block">/* Repeating a DEFINE group (or any group where the condition is always
        FALSE and there is only one branch) is pointless, but Perl allows the
        syntax, so we just ignore the repeat. */</comment>

        <if_stmt><if>if <condition>(<expr><name>op_previous</name> <operator>==</operator> <name>OP_COND</name> <operator>&amp;&amp;</operator> <name><name>previous</name><index>[<expr><name>LINK_SIZE</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>OP_FALSE</name> <operator>&amp;&amp;</operator>
            <name><name>previous</name><index>[<expr><call><name>GET</name><argument_list>(<argument><expr><name>previous</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>!=</operator> <name>OP_ALT</name></expr>)</condition><block type="pseudo"><block_content>
          <goto>goto <name>END_REPEAT</name>;</goto></block_content></block></if></if_stmt>

        <comment type="block">/* Perl allows all assertions to be quantified, and when they contain
        capturing parentheses and/or are optional there are potential uses for
        this feature. PCRE2 used to force the maximum quantifier to 1 on the
        invalid grounds that further repetition was never useful. This was
        always a bit pointless, since an assertion could be wrapped with a
        repeated group to achieve the effect. General repetition is now
        permitted, but if the maximum is unlimited it is set to one more than
        the minimum. */</comment>

        <if_stmt><if>if <condition>(<expr><name>op_previous</name> <operator>&lt;</operator> <name>OP_ONCE</name></expr>)</condition>    <comment type="block">/* Assertion */</comment>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>repeat_max</name> <operator>==</operator> <name>REPEAT_UNLIMITED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>repeat_max</name> <operator>=</operator> <name>repeat_min</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>

        <comment type="block">/* The case of a zero minimum is special because of the need to stick
        OP_BRAZERO in front of it, and because the group appears once in the
        data, whereas in other cases it appears the minimum number of times. For
        this reason, it is simplest to treat this case separately, as otherwise
        the code gets far too messy. There are several special subcases when the
        minimum is zero. */</comment>

        <if_stmt><if>if <condition>(<expr><name>repeat_min</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <comment type="block">/* If the maximum is also zero, we used to just omit the group from
          the output altogether, like this:

          ** if (repeat_max == 0)
          **   {
          **   code = previous;
          **   goto END_REPEAT;
          **   }

          However, that fails when a group or a subgroup within it is
          referenced as a subroutine from elsewhere in the pattern, so now we
          stick in OP_SKIPZERO in front of it so that it is skipped on
          execution. As we don't have a list of which groups are referenced, we
          cannot do this selectively.

          If the maximum is 1 or unlimited, we just have to stick in the
          BRAZERO and do no more at this point. */</comment>

          <if_stmt><if>if <condition>(<expr><name>repeat_max</name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>||</operator> <name>repeat_max</name> <operator>==</operator> <name>REPEAT_UNLIMITED</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memmove</name><argument_list>(<argument><expr><name>previous</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>previous</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>code</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>repeat_max</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><operator>*</operator><name>previous</name><operator>++</operator> <operator>=</operator> <name>OP_SKIPZERO</name></expr>;</expr_stmt>
              <goto>goto <name>END_REPEAT</name>;</goto>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>brazeroptr</name> <operator>=</operator> <name>previous</name></expr>;</expr_stmt>    <comment type="block">/* Save for possessive optimizing */</comment>
            <expr_stmt><expr><operator>*</operator><name>previous</name><operator>++</operator> <operator>=</operator> <name>OP_BRAZERO</name> <operator>+</operator> <name>repeat_type</name></expr>;</expr_stmt>
            </block_content>}</block></if>

          <comment type="block">/* If the maximum is greater than 1 and limited, we have to replicate
          in a nested fashion, sticking OP_BRAZERO before each set of brackets.
          The first one has to be handled carefully because it's the original
          copy, which has to be moved up. The remainder can be handled by code
          that is common with the non-zero minimum case below. We have to
          adjust the value or repeat_max, since one less copy is required. */</comment>

          <else>else
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>linkoffset</name></decl>;</decl_stmt>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memmove</name><argument_list>(<argument><expr><name>previous</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>, <argument><expr><name>previous</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>code</name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>previous</name><operator>++</operator> <operator>=</operator> <name>OP_BRAZERO</name> <operator>+</operator> <name>repeat_type</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>previous</name><operator>++</operator> <operator>=</operator> <name>OP_BRA</name></expr>;</expr_stmt>

            <comment type="block">/* We chain together the bracket link offset fields that have to be
            filled in later when the ends of the brackets are reached. */</comment>

            <expr_stmt><expr><name>linkoffset</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>bralink</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>previous</name> <operator>-</operator> <name>bralink</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name>bralink</name> <operator>=</operator> <name>previous</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PUTINC</name><argument_list>(<argument><expr><name>previous</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>linkoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

          <if_stmt><if>if <condition>(<expr><name>repeat_max</name> <operator>!=</operator> <name>REPEAT_UNLIMITED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>repeat_max</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></if>

        <comment type="block">/* If the minimum is greater than zero, replicate the group as many
        times as necessary, and adjust the maximum to the number of subsequent
        copies that we need. */</comment>

        <else>else
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>repeat_min</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
            <comment type="block">/* In the pre-compile phase, we don't actually do the replication.
            We just adjust the length as if we had. Do some paranoid checks for
            potential integer overflow. The INT64_OR_DOUBLE type is a 64-bit
            integer type when available, otherwise double. */</comment>

            <if_stmt><if>if <condition>(<expr><name>lengthptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
              <block>{<block_content>
              <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>delta</name> <init>= <expr><operator>(</operator><name>repeat_min</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>*</operator><name>length_prevgroup</name></expr></init></decl>;</decl_stmt>
              <if_stmt><if>if <condition>(<expr><operator>(</operator><name>INT64_OR_DOUBLE</name><operator>)</operator><operator>(</operator><name>repeat_min</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>*</operator>
                    <operator>(</operator><name>INT64_OR_DOUBLE</name><operator>)</operator><name>length_prevgroup</name> <operator>&gt;</operator>
                      <operator>(</operator><name>INT64_OR_DOUBLE</name><operator>)</operator><name>INT_MAX</name> <operator>||</operator>
                  <name>OFLOW_MAX</name> <operator>-</operator> <operator>*</operator><name>lengthptr</name> <operator>&lt;</operator> <name>delta</name></expr>)</condition>
                <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR20</name></expr>;</expr_stmt>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
              <expr_stmt><expr><operator>*</operator><name>lengthptr</name> <operator>+=</operator> <name>delta</name></expr>;</expr_stmt>
              </block_content>}</block></if>

            <comment type="block">/* This is compiling for real. If there is a set first code unit
            for the group, and we have not yet set a "required code unit", set
            it. */</comment>

            <else>else
              <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><name>groupsetfirstcu</name> <operator>&amp;&amp;</operator> <name>reqcuflags</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                <expr_stmt><expr><name>reqcu</name> <operator>=</operator> <name>firstcu</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>reqcuflags</name> <operator>=</operator> <name>firstcuflags</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
              <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>i</name> <operator>&lt;</operator> <name>repeat_min</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>previous</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>code</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
                </block_content>}</block></for>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

          <if_stmt><if>if <condition>(<expr><name>repeat_max</name> <operator>!=</operator> <name>REPEAT_UNLIMITED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>repeat_max</name> <operator>-=</operator> <name>repeat_min</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></else></if_stmt>

        <comment type="block">/* This code is common to both the zero and non-zero minimum cases. If
        the maximum is limited, it replicates the group in a nested fashion,
        remembering the bracket starts on a stack. In the case of a zero
        minimum, the first one was set up above. In all cases the repeat_max
        now specifies the number of additional copies needed. Again, we must
        remember to replicate entries on the forward reference list. */</comment>

        <if_stmt><if>if <condition>(<expr><name>repeat_max</name> <operator>!=</operator> <name>REPEAT_UNLIMITED</name></expr>)</condition>
          <block>{<block_content>
          <comment type="block">/* In the pre-compile phase, we don't actually do the replication. We
          just adjust the length as if we had. For each repetition we must add
          1 to the length for BRAZERO and for all but the last repetition we
          must add 2 + 2*LINKSIZE to allow for the nesting that occurs. Do some
          paranoid checks to avoid integer overflow. The INT64_OR_DOUBLE type
          is a 64-bit integer type when available, otherwise double. */</comment>

          <if_stmt><if>if <condition>(<expr><name>lengthptr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>repeat_max</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>delta</name> <init>= <expr><name>repeat_max</name><operator>*</operator><operator>(</operator><name>length_prevgroup</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name><operator>)</operator> <operator>-</operator>
                        <literal type="number">2</literal> <operator>-</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Last one doesn't nest */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>INT64_OR_DOUBLE</name><operator>)</operator><name>repeat_max</name> <operator>*</operator>
                  <operator>(</operator><name>INT64_OR_DOUBLE</name><operator>)</operator><operator>(</operator><name>length_prevgroup</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name><operator>)</operator>
                    <operator>&gt;</operator> <operator>(</operator><name>INT64_OR_DOUBLE</name><operator>)</operator><name>INT_MAX</name> <operator>||</operator>
                <name>OFLOW_MAX</name> <operator>-</operator> <operator>*</operator><name>lengthptr</name> <operator>&lt;</operator> <name>delta</name></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR20</name></expr>;</expr_stmt>
              <return>return <expr><literal type="number">0</literal></expr>;</return>
              </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><operator>*</operator><name>lengthptr</name> <operator>+=</operator> <name>delta</name></expr>;</expr_stmt>
            </block_content>}</block></if>

          <comment type="block">/* This is compiling for real */</comment>

          <else>else<block type="pseudo"><block_content> <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>repeat_max</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
            <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_BRAZERO</name> <operator>+</operator> <name>repeat_type</name></expr>;</expr_stmt>

            <comment type="block">/* All but the final copy start a new nesting, maintaining the
            chain of brackets outstanding. */</comment>

            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
              <block>{<block_content>
              <decl_stmt><decl><type><name>int</name></type> <name>linkoffset</name></decl>;</decl_stmt>
              <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_BRA</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>linkoffset</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>bralink</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>code</name> <operator>-</operator> <name>bralink</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
              <expr_stmt><expr><name>bralink</name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>PUTINC</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>linkoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>previous</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>code</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></for></block_content></block></else></if_stmt>

          <comment type="block">/* Now chain through the pending brackets, and fill in their length
          fields (which are holding the chain links pro tem). */</comment>

          <while>while <condition>(<expr><name>bralink</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>oldlinkoffset</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>linkoffset</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>code</name> <operator>-</operator> <name>bralink</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>bra</name> <init>= <expr><name>code</name> <operator>-</operator> <name>linkoffset</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>oldlinkoffset</name> <operator>=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>bra</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>bralink</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>oldlinkoffset</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>bralink</name> <operator>-</operator> <name>oldlinkoffset</name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_KET</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PUTINC</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>linkoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>bra</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>linkoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
          </block_content>}</block></if>

        <comment type="block">/* If the maximum is unlimited, set a repeater in the final copy. For
        SCRIPT_RUN and ONCE brackets, that's all we need to do. However,
        possessively repeated ONCE brackets can be converted into non-capturing
        brackets, as the behaviour of (?:xx)++ is the same as (?&gt;xx)++ and this
        saves having to deal with possessive ONCEs specially.

        Otherwise, when we are doing the actual compile phase, check to see
        whether this group is one that could match an empty string. If so,
        convert the initial operator to the S form (e.g. OP_BRA -&gt; OP_SBRA) so
        that runtime checking can be done. [This check is also applied to ONCE
        and SCRIPT_RUN groups at runtime, but in a different way.]

        Then, if the quantifier was possessive and the bracket is not a
        conditional, we convert the BRA code to the POS form, and the KET code
        to KETRPOS. (It turns out to be convenient at runtime to detect this
        kind of subpattern at both the start and at the end.) The use of
        special opcodes makes it possible to reduce greatly the stack usage in
        pcre2_match(). If the group is preceded by OP_BRAZERO, convert this to
        OP_BRAPOSZERO.

        Then, if the minimum number of matches is 1 or 0, cancel the possessive
        flag so that the default action below, of wrapping everything inside
        atomic brackets, does not happen. When the minimum is greater than 1,
        there will be earlier copies of the group, and so we still have to wrap
        the whole thing. */</comment>

        <else>else
          <block>{<block_content>
          <decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>ketcode</name> <init>= <expr><name>code</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>LINK_SIZE</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>bracode</name> <init>= <expr><name>ketcode</name> <operator>-</operator> <call><name>GET</name><argument_list>(<argument><expr><name>ketcode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <comment type="block">/* Convert possessive ONCE brackets to non-capturing */</comment>

          <if_stmt><if>if <condition>(<expr><operator>*</operator><name>bracode</name> <operator>==</operator> <name>OP_ONCE</name> <operator>&amp;&amp;</operator> <name>possessive_quantifier</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>bracode</name> <operator>=</operator> <name>OP_BRA</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

          <comment type="block">/* For non-possessive ONCE and for SCRIPT_RUN brackets, all we need
          to do is to set the KET. */</comment>

          <if_stmt><if>if <condition>(<expr><operator>*</operator><name>bracode</name> <operator>==</operator> <name>OP_ONCE</name> <operator>||</operator> <operator>*</operator><name>bracode</name> <operator>==</operator> <name>OP_SCRIPT_RUN</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>ketcode</name> <operator>=</operator> <name>OP_KETRMAX</name> <operator>+</operator> <name>repeat_type</name></expr>;</expr_stmt></block_content></block></if>

          <comment type="block">/* Handle non-SCRIPT_RUN and non-ONCE brackets and possessive ONCEs
          (which have been converted to non-capturing above). */</comment>

          <else>else
            <block>{<block_content>
            <comment type="block">/* In the compile phase, adjust the opcode if the group can match
            an empty string. For a conditional group with only one branch, the
            value of group_return will not show "could be empty", so we must
            check that separately. */</comment>

            <if_stmt><if>if <condition>(<expr><name>lengthptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
              <block>{<block_content>
              <if_stmt><if>if <condition>(<expr><name>group_return</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>bracode</name> <operator>+=</operator> <name>OP_SBRA</name> <operator>-</operator> <name>OP_BRA</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
              <if_stmt><if>if <condition>(<expr><operator>*</operator><name>bracode</name> <operator>==</operator> <name>OP_COND</name> <operator>&amp;&amp;</operator> <name><name>bracode</name><index>[<expr><call><name>GET</name><argument_list>(<argument><expr><name>bracode</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>!=</operator> <name>OP_ALT</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>bracode</name> <operator>=</operator> <name>OP_SCOND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
              </block_content>}</block></if></if_stmt>

            <comment type="block">/* Handle possessive quantifiers. */</comment>

            <if_stmt><if>if <condition>(<expr><name>possessive_quantifier</name></expr>)</condition>
              <block>{<block_content>
              <comment type="block">/* For COND brackets, we wrap the whole thing in a possessively
              repeated non-capturing bracket, because we have not invented POS
              versions of the COND opcodes. */</comment>

              <if_stmt><if>if <condition>(<expr><operator>*</operator><name>bracode</name> <operator>==</operator> <name>OP_COND</name> <operator>||</operator> <operator>*</operator><name>bracode</name> <operator>==</operator> <name>OP_SCOND</name></expr>)</condition>
                <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>nlen</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>code</name> <operator>-</operator> <name>bracode</name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memmove</name><argument_list>(<argument><expr><name>bracode</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>, <argument><expr><name>bracode</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>nlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>code</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nlen</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>bracode</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name>bracode</name> <operator>==</operator> <name>OP_COND</name><operator>)</operator></expr>?</condition><then> <expr><name>OP_BRAPOS</name></expr> </then><else>: <expr><name>OP_SBRAPOS</name></expr></else></ternary></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_KETRPOS</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PUTINC</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>bracode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>

              <comment type="block">/* For non-COND brackets, we modify the BRA code and use KETRPOS. */</comment>

              <else>else
                <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>bracode</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>              <comment type="block">/* Switch to xxxPOS opcodes */</comment>
                <expr_stmt><expr><operator>*</operator><name>ketcode</name> <operator>=</operator> <name>OP_KETRPOS</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

              <comment type="block">/* If the minimum is zero, mark it as possessive, then unset the
              possessive flag when the minimum is 0 or 1. */</comment>

              <if_stmt><if>if <condition>(<expr><name>brazeroptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>brazeroptr</name> <operator>=</operator> <name>OP_BRAPOSZERO</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
              <if_stmt><if>if <condition>(<expr><name>repeat_min</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>possessive_quantifier</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
              </block_content>}</block></if>

            <comment type="block">/* Non-possessive quantifier */</comment>

            <else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>ketcode</name> <operator>=</operator> <name>OP_KETRMAX</name> <operator>+</operator> <name>repeat_type</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block>
      <break>break;</break>

      <comment type="block">/* If previous was a character type match (\d or similar), abolish it and
      create a suitable repeat item. The code is shared with single-character
      repeats by setting op_type to add a suitable offset into repeat_type.
      Note the the Unicode property types will be present only when
      SUPPORT_UNICODE is defined, but we don't wrap the little bits of code
      here because it just makes it horribly messy. */</comment>

      <default>default:</default>
      <if_stmt><if>if <condition>(<expr><name>op_previous</name> <operator>&gt;=</operator> <name>OP_EODN</name></expr>)</condition>   <comment type="block">/* Not a character type - internal error */</comment>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR10</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>prop_type</name></decl>, <decl><type ref="prev"/><name>prop_value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>oldcode</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>repeat_max</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>repeat_min</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>END_REPEAT</name>;</goto></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>op_type</name> <operator>=</operator> <name>OP_TYPESTAR</name> <operator>-</operator> <name>OP_STAR</name></expr>;</expr_stmt>      <comment type="block">/* Use type opcodes */</comment>
        <expr_stmt><expr><name>mclength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                         <comment type="block">/* Not a character */</comment>

        <if_stmt><if>if <condition>(<expr><name>op_previous</name> <operator>==</operator> <name>OP_PROP</name> <operator>||</operator> <name>op_previous</name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>prop_type</name> <operator>=</operator> <name><name>previous</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>prop_value</name> <operator>=</operator> <name><name>previous</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
          </block_content>}</block></if>
        <else>else
          <block>{<block_content>
          <comment type="block">/* Come here from just above with a character in mcbuffer/mclength. */</comment>
          <label><name>OUTPUT_SINGLE_REPEAT</name>:</label>
          <expr_stmt><expr><name>prop_type</name> <operator>=</operator> <name>prop_value</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>

        <comment type="block">/* At this point, if prop_type == prop_value == -1 we either have a
        character in mcbuffer when mclength is greater than zero, or we have
        mclength zero, in which case there is a non-property character type in
        op_previous. If prop_type/value are not negative, we have a property
        character type in op_previous. */</comment>

        <expr_stmt><expr><name>oldcode</name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>                   <comment type="block">/* Save where we were */</comment>
        <expr_stmt><expr><name>code</name> <operator>=</operator> <name>previous</name></expr>;</expr_stmt>                  <comment type="block">/* Usually overwrite previous item */</comment>

        <comment type="block">/* If the maximum is zero then the minimum must also be zero; Perl allows
        this case, so we do too - by simply omitting the item altogether. */</comment>

        <if_stmt><if>if <condition>(<expr><name>repeat_max</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>END_REPEAT</name>;</goto></block_content></block></if></if_stmt>

        <comment type="block">/* Combine the op_type with the repeat_type */</comment>

        <expr_stmt><expr><name>repeat_type</name> <operator>+=</operator> <name>op_type</name></expr>;</expr_stmt>

        <comment type="block">/* A minimum of zero is handled either as the special case * or ?, or as
        an UPTO, with the maximum given. */</comment>

        <if_stmt><if>if <condition>(<expr><name>repeat_min</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>repeat_max</name> <operator>==</operator> <name>REPEAT_UNLIMITED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_STAR</name> <operator>+</operator> <name>repeat_type</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>repeat_max</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_QUERY</name> <operator>+</operator> <name>repeat_type</name></expr>;</expr_stmt></block_content></block></if>
          <else>else
            <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_UPTO</name> <operator>+</operator> <name>repeat_type</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PUT2INC</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>repeat_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if>

        <comment type="block">/* A repeat minimum of 1 is optimized into some special cases. If the
        maximum is unlimited, we use OP_PLUS. Otherwise, the original item is
        left in place and, if the maximum is greater than 1, we use OP_UPTO with
        one less than the maximum. */</comment>

        <if type="elseif">else if <condition>(<expr><name>repeat_min</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>repeat_max</name> <operator>==</operator> <name>REPEAT_UNLIMITED</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_PLUS</name> <operator>+</operator> <name>repeat_type</name></expr>;</expr_stmt></block_content></block></if>
          <else>else
            <block>{<block_content>
            <expr_stmt><expr><name>code</name> <operator>=</operator> <name>oldcode</name></expr>;</expr_stmt>  <comment type="block">/* Leave previous item in place */</comment>
            <if_stmt><if>if <condition>(<expr><name>repeat_max</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>END_REPEAT</name>;</goto></block_content></block></if></if_stmt>
            <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_UPTO</name> <operator>+</operator> <name>repeat_type</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PUT2INC</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>repeat_max</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
          </block_content>}</block></if>

        <comment type="block">/* The case {n,n} is just an EXACT, while the general case {n,m} is
        handled as an EXACT followed by an UPTO or STAR or QUERY. */</comment>

        <else>else
          <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_EXACT</name> <operator>+</operator> <name>op_type</name></expr>;</expr_stmt>  <comment type="block">/* NB EXACT doesn't have repeat_type */</comment>
          <expr_stmt><expr><call><name>PUT2INC</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>repeat_min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Unless repeat_max equals repeat_min, fill in the data for EXACT,
          and then generate the second opcode. For a repeated Unicode property
          match, there are two extra values that define the required property,
          and mclength is set zero to indicate this. */</comment>

          <if_stmt><if>if <condition>(<expr><name>repeat_max</name> <operator>!=</operator> <name>repeat_min</name></expr>)</condition>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>mclength</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>mcbuffer</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>mclength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>code</name> <operator>+=</operator> <name>mclength</name></expr>;</expr_stmt>
              </block_content>}</block></if>
            <else>else
              <block>{<block_content>
              <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>op_previous</name></expr>;</expr_stmt>
              <if_stmt><if>if <condition>(<expr><name>prop_type</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>prop_type</name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>prop_value</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
              </block_content>}</block></else></if_stmt>

            <comment type="block">/* Now set up the following opcode */</comment>

            <if_stmt><if>if <condition>(<expr><name>repeat_max</name> <operator>==</operator> <name>REPEAT_UNLIMITED</name></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_STAR</name> <operator>+</operator> <name>repeat_type</name></expr>;</expr_stmt></block_content></block></if>
            <else>else
              <block>{<block_content>
              <expr_stmt><expr><name>repeat_max</name> <operator>-=</operator> <name>repeat_min</name></expr>;</expr_stmt>
              <if_stmt><if>if <condition>(<expr><name>repeat_max</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_QUERY</name> <operator>+</operator> <name>repeat_type</name></expr>;</expr_stmt>
                </block_content>}</block></if>
              <else>else
                <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_UPTO</name> <operator>+</operator> <name>repeat_type</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PUT2INC</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>repeat_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
              </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></else></if_stmt>

        <comment type="block">/* Fill in the character or character type for the final opcode. */</comment>

        <if_stmt><if>if <condition>(<expr><name>mclength</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>mcbuffer</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>mclength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>code</name> <operator>+=</operator> <name>mclength</name></expr>;</expr_stmt>
          </block_content>}</block></if>
        <else>else
          <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>op_previous</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>prop_type</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>prop_type</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>prop_value</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
      <break>break;</break>
      </block_content>}</block></switch>  <comment type="block">/* End of switch on different op_previous values */</comment>


    <comment type="block">/* If the character following a repeat is '+', possessive_quantifier is
    TRUE. For some opcodes, there are special alternative opcodes for this
    case. For anything else, we wrap the entire repeated item inside OP_ONCE
    brackets. Logically, the '+' notation is just syntactic sugar, taken from
    Sun's Java package, but the special opcodes can optimize it.

    Some (but not all) possessively repeated subpatterns have already been
    completely handled in the code just above. For them, possessive_quantifier
    is always FALSE at this stage. Note that the repeated item starts at
    tempcode, not at previous, which might be the first part of a string whose
    (former) last char we repeated. */</comment>

    <if_stmt><if>if <condition>(<expr><name>possessive_quantifier</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

      <comment type="block">/* Possessifying an EXACT quantifier has no effect, so we can ignore it.
      However, QUERY, STAR, or UPTO may follow (for quantifiers such as {5,6},
      {5,}, or {5,10}). We skip over an EXACT item; if the length of what
      remains is greater than zero, there's a further opcode that can be
      handled. If not, do nothing, leaving the EXACT alone. */</comment>

      <switch>switch<condition>(<expr><operator>*</operator><name>tempcode</name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>OP_TYPEEXACT</name></expr>:</case>
        <expr_stmt><expr><name>tempcode</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>tempcode</name></expr>]</index> <operator>+</operator>
          <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>tempcode</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>]</index></name> <operator>==</operator> <name>OP_PROP</name>
          <operator>||</operator> <name><name>tempcode</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>]</index></name> <operator>==</operator> <name>OP_NOTPROP</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
        <break>break;</break>

        <comment type="block">/* CHAR opcodes are used for exacts whose count is 1. */</comment>

        <case>case <expr><name>OP_CHAR</name></expr>:</case>
        <case>case <expr><name>OP_CHARI</name></expr>:</case>
        <case>case <expr><name>OP_NOT</name></expr>:</case>
        <case>case <expr><name>OP_NOTI</name></expr>:</case>
        <case>case <expr><name>OP_EXACT</name></expr>:</case>
        <case>case <expr><name>OP_EXACTI</name></expr>:</case>
        <case>case <expr><name>OP_NOTEXACT</name></expr>:</case>
        <case>case <expr><name>OP_NOTEXACTI</name></expr>:</case>
        <expr_stmt><expr><name>tempcode</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>tempcode</name></expr>]</index></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><name><name>tempcode</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>tempcode</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><name><name>tempcode</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <break>break;</break>

        <comment type="block">/* For the class opcodes, the repeat operator appears at the end;
        adjust tempcode to point to it. */</comment>

        <case>case <expr><name>OP_CLASS</name></expr>:</case>
        <case>case <expr><name>OP_NCLASS</name></expr>:</case>
        <expr_stmt><expr><name>tempcode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">32</literal><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>PCRE2_UCHAR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_WIDE_CHARS</name></cpp:ifdef>
        <case>case <expr><name>OP_XCLASS</name></expr>:</case>
        <expr_stmt><expr><name>tempcode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>tempcode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></switch>

      <comment type="block">/* If tempcode is equal to code (which points to the end of the repeated
      item), it means we have skipped an EXACT item but there is no following
      QUERY, STAR, or UPTO; the value of len will be 0, and we do nothing. In
      all other cases, tempcode will be pointing to the repeat opcode, and will
      be less than code, so the value of len will be greater than 0. */</comment>

      <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>code</name> <operator>-</operator> <name>tempcode</name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>repcode</name> <init>= <expr><operator>*</operator><name>tempcode</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* There is a table for possessifying opcodes, all of which are less
        than OP_CALLOUT. A zero entry means there is no possessified version.
        */</comment>

        <if_stmt><if>if <condition>(<expr><name><name>repcode</name> <argument_list type="generic">&lt; <argument><expr><name>OP_CALLOUT</name> <operator>&amp;&amp;</operator> <name><name>opcode_possessify</name><index>[<expr><name>repcode</name></expr>]</index></name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><operator>*</operator><name>tempcode</name> <operator>=</operator> <name><name>opcode_possessify</name><index>[<expr><name>repcode</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>

        <comment type="block">/* For opcode without a special possessified version, wrap the item in
        ONCE brackets. */</comment>

        <else>else
          <block>{<block_content>
          <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memmove</name><argument_list>(<argument><expr><name>tempcode</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>, <argument><expr><name>tempcode</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>code</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>tempcode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>OP_ONCE</name></expr>;</expr_stmt>
          <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_KET</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>PUTINC</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>tempcode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* We set the "follows varying string" flag for subsequently encountered
    reqcus if it isn't already set and we have just passed a varying length
    item. */</comment>

    <label><name>END_REPEAT</name>:</label>
    <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>req_varyopt</name></name> <operator>|=</operator> <name>reqvary</name></expr>;</expr_stmt>
    <break>break;</break>


    <comment type="block">/* ===================================================================*/</comment>
    <comment type="block">/* Handle a 32-bit data character with a value greater than META_END. */</comment>

    <case>case <expr><name>META_BIGVALUE</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name><operator>++</operator></expr>;</expr_stmt>
    <goto>goto <name>NORMAL_CHAR</name>;</goto>


    <comment type="block">/* ===============================================================*/</comment>
    <comment type="block">/* Handle a back reference by number, which is the meta argument. The
    pattern offsets for back references to group numbers less than 10 are held
    in a special vector, to avoid using more than two parsed pattern elements
    in 64-bit environments. We only need the offset to the first occurrence,
    because if that doesn't fail, subsequent ones will also be OK. */</comment>

    <case>case <expr><name>META_BACKREF</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>meta_arg</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>cb</name><operator>-&gt;</operator><name>small_ref_offset</name><index>[<expr><name>meta_arg</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>GETPLUSOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>meta_arg</name> <operator>&gt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>erroroffset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR15</name></expr>;</expr_stmt>  <comment type="block">/* Non-existent subpattern */</comment>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Come here from named backref handling when the reference is to a
    single group (that is, not to a duplicated name). The back reference
    data will have already been updated. We must disable firstcu if not
    set, to cope with cases like (?=(\w+))\1: which would otherwise set ':'
    later. */</comment>

    <label><name>HANDLE_SINGLE_REFERENCE</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>firstcuflags</name> <operator>==</operator> <name>REQ_UNSET</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>zerofirstcuflags</name> <operator>=</operator> <name>firstcuflags</name> <operator>=</operator> <name>REQ_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_CASELESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name>OP_REFI</name></expr> </then><else>: <expr><name>OP_REF</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PUT2INC</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>meta_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Update the map of back references, and keep the highest one. We
    could do this in parse_regex() for numerical back references, but not
    for named back references, because we don't know the numbers to which
    named back references refer. So we do it all in this function. */</comment>

    <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>backref_map</name></name> <operator>|=</operator> <ternary><condition><expr><operator>(</operator><name>meta_arg</name> <operator>&lt;</operator> <literal type="number">32</literal><operator>)</operator></expr>?</condition><then> <expr><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>meta_arg</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>meta_arg</name> <operator>&gt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>top_backref</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>top_backref</name></name> <operator>=</operator> <name>meta_arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <break>break;</break>


    <comment type="block">/* ===============================================================*/</comment>
    <comment type="block">/* Handle recursion by inserting the number of the called group (which is
    the meta argument) after OP_RECURSE. At the end of compiling the pattern is
    scanned and these numbers are replaced by offsets within the pattern. It is
    done like this to avoid problems with forward references and adjusting
    offsets when groups are duplicated and moved (as discovered in previous
    implementations). Note that a recursion does not have a set first
    character. */</comment>

    <case>case <expr><name>META_RECURSE</name></expr>:</case>
    <expr_stmt><expr><call><name>GETPLUSOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>meta_arg</name> <operator>&gt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>erroroffset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR15</name></expr>;</expr_stmt>  <comment type="block">/* Non-existent subpattern */</comment>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    <label><name>HANDLE_NUMERICAL_RECURSION</name>:</label>
    <expr_stmt><expr><operator>*</operator><name>code</name> <operator>=</operator> <name>OP_RECURSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>meta_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>code</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>groupsetfirstcu</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>had_recurse</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>firstcuflags</name> <operator>==</operator> <name>REQ_UNSET</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>firstcuflags</name> <operator>=</operator> <name>REQ_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>zerofirstcu</name> <operator>=</operator> <name>firstcu</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zerofirstcuflags</name> <operator>=</operator> <name>firstcuflags</name></expr>;</expr_stmt>
    <break>break;</break>


    <comment type="block">/* ===============================================================*/</comment>
    <comment type="block">/* Handle capturing parentheses; the number is the meta argument. */</comment>

    <case>case <expr><name>META_CAPTURE</name></expr>:</case>
    <expr_stmt><expr><name>bravalue</name> <operator>=</operator> <name>OP_CBRA</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>skipunits</name> <operator>=</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PUT2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name></expr></argument>, <argument><expr><name>meta_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>lastcapture</name></name> <operator>=</operator> <name>meta_arg</name></expr>;</expr_stmt>
    <goto>goto <name>GROUP_PROCESS_NOTE_EMPTY</name>;</goto>


    <comment type="block">/* ===============================================================*/</comment>
    <comment type="block">/* Handle escape sequence items. For ones like \d, the ESC_values are
    arranged to be the same as the corresponding OP_values in the default case
    when PCRE2_UCP is not set (which is the only case in which they will appear
    here).

    Note: \Q and \E are never seen here, as they were dealt with in
    parse_pattern(). Neither are numerical back references or recursions, which
    were turned into META_BACKREF or META_RECURSE items, respectively. \k and
    \g, when followed by names, are turned into META_BACKREF_BYNAME or
    META_RECURSE_BYNAME. */</comment>

    <case>case <expr><name>META_ESCAPE</name></expr>:</case>

    <comment type="block">/* We can test for escape sequences that consume a character because their
    values lie between ESC_b and ESC_Z; this may have to change if any new ones
    are ever created. For these sequences, we disable the setting of a first
    character if it hasn't already been set. */</comment>

    <if_stmt><if>if <condition>(<expr><name>meta_arg</name> <operator>&gt;</operator> <name>ESC_b</name> <operator>&amp;&amp;</operator> <name>meta_arg</name> <operator>&lt;</operator> <name>ESC_Z</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>matched_char</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>firstcuflags</name> <operator>==</operator> <name>REQ_UNSET</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>firstcuflags</name> <operator>=</operator> <name>REQ_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Set values to reset to if this is followed by a zero repeat. */</comment>

    <expr_stmt><expr><name>zerofirstcu</name> <operator>=</operator> <name>firstcu</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zerofirstcuflags</name> <operator>=</operator> <name>firstcuflags</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zeroreqcu</name> <operator>=</operator> <name>reqcu</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>zeroreqcuflags</name> <operator>=</operator> <name>reqcuflags</name></expr>;</expr_stmt>

    <comment type="block">/* If Unicode is not supported, \P and \p are not allowed and are
    faulted at parse time, so will never appear here. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>meta_arg</name> <operator>==</operator> <name>ESC_P</name> <operator>||</operator> <name>meta_arg</name> <operator>==</operator> <name>ESC_p</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>ptype</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>++</operator><name>pptr</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>pdata</name> <init>= <expr><operator>*</operator><name>pptr</name> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr></init></decl>;</decl_stmt>

      <comment type="block">/* The special case of \p{Any} is compiled to OP_ALLANY so as to benefit
      from the auto-anchoring code. */</comment>

      <if_stmt><if>if <condition>(<expr><name>meta_arg</name> <operator>==</operator> <name>ESC_p</name> <operator>&amp;&amp;</operator> <name>ptype</name> <operator>==</operator> <name>PT_ANY</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_ALLANY</name></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>meta_arg</name> <operator>==</operator> <name>ESC_p</name><operator>)</operator></expr>?</condition><then> <expr><name>OP_PROP</name></expr> </then><else>: <expr><name>OP_NOTPROP</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>ptype</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>pdata</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      <break>break;</break>  <comment type="block">/* End META_ESCAPE */</comment>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* For the rest (including \X when Unicode is supported - if not it's
    faulted at parse time), the OP value is the escape value when PCRE2_UCP is
    not set; if it is set, these escapes do not show up here because they are
    converted into Unicode property tests in parse_regex(). Note that \b and \B
    do a one-character lookbehind, and \A also behaves as if it does. */</comment>

    <if_stmt><if>if <condition>(<expr><name>meta_arg</name> <operator>==</operator> <name>ESC_C</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>external_flags</name></name> <operator>|=</operator> <name>PCRE2_HASBKC</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* Record */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>meta_arg</name> <operator>==</operator> <name>ESC_b</name> <operator>||</operator> <name>meta_arg</name> <operator>==</operator> <name>ESC_B</name> <operator>||</operator> <name>meta_arg</name> <operator>==</operator> <name>ESC_A</name><operator>)</operator> <operator>&amp;&amp;</operator>
         <name><name>cb</name><operator>-&gt;</operator><name>max_lookbehind</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>max_lookbehind</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* In non-UTF mode, and for both 32-bit modes, we turn \C into OP_ALLANY
    instead of OP_ANYBYTE so that it works in DFA mode and in lookbehinds. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
    <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>meta_arg</name> <operator>==</operator> <name>ESC_C</name><operator>)</operator></expr>?</condition><then> <expr><name>OP_ALLANY</name></expr> </then><else>: <expr><name>meta_arg</name></expr></else></ternary></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>!</operator><name>utf</name> <operator>&amp;&amp;</operator> <name>meta_arg</name> <operator>==</operator> <name>ESC_C</name><operator>)</operator></expr>?</condition><then> <expr><name>OP_ALLANY</name></expr> </then><else>: <expr><name>meta_arg</name></expr></else></ternary></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>  <comment type="block">/* End META_ESCAPE */</comment>


    <comment type="block">/* ===================================================================*/</comment>
    <comment type="block">/* Handle an unrecognized meta value. A parsed pattern value less than
    META_END is a literal. Otherwise we have a problem. */</comment>

    <default>default:</default>
    <if_stmt><if>if <condition>(<expr><name>meta</name> <operator>&gt;=</operator> <name>META_END</name></expr>)</condition>
      <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_SHOW_PARSED</name></cpp:ifdef>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"** Unrecognized parsed pattern item 0x%.8x\n"</literal></expr></argument>, <argument><expr><operator>*</operator><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR89</name></expr>;</expr_stmt>  <comment type="block">/* Internal error - unrecognized. */</comment>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Handle a literal character. We come here by goto in the case of a
    32-bit, non-UTF character whose value is greater than META_END. */</comment>

    <label><name>NORMAL_CHAR</name>:</label>
    <expr_stmt><expr><name>meta</name> <operator>=</operator> <operator>*</operator><name>pptr</name></expr>;</expr_stmt>     <comment type="block">/* Get the full 32 bits */</comment>
    <label><name>NORMAL_CHAR_SET</name>:</label>  <comment type="block">/* Character is already in meta */</comment>
    <expr_stmt><expr><name>matched_char</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

    <comment type="block">/* For caseless UTF or UCP mode, check whether this character has more than
    one other case. If so, generate a special OP_PROP item instead of OP_CHARI.
    */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>utf</name><operator>||</operator><name>ucp</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_CASELESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>caseset</name> <init>= <expr><call><name>UCD_CASESET</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>caseset</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_PROP</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>PT_CLIST</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>caseset</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>firstcuflags</name> <operator>==</operator> <name>REQ_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>firstcuflags</name> <operator>=</operator> <name>zerofirstcuflags</name> <operator>=</operator> <name>REQ_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>  <comment type="block">/* End handling this meta item */</comment>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Caseful matches, or caseless and not one of the multicase characters. We
    come here by goto in the case of a positive class that contains only
    case-partners of a character with just two cases; matched_char has already
    been set TRUE and options fudged if necessary. */</comment>

    <label><name>CLASS_CASELESS_CHAR</name>:</label>

    <comment type="block">/* Get the character's code units into mcbuffer, with the length in
    mclength. When not in UTF mode, the length is always 1. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>mclength</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>ord2utf</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>meta</name></expr></argument>, <argument><expr><name>mcbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <block>{<block_content>
      <expr_stmt><expr><name>mclength</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>mcbuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>meta</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

    <comment type="block">/* Generate the appropriate code */</comment>

    <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_CASELESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name>OP_CHARI</name></expr> </then><else>: <expr><name>OP_CHAR</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><name>mcbuffer</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>mclength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>code</name> <operator>+=</operator> <name>mclength</name></expr>;</expr_stmt>

    <comment type="block">/* Remember if \r or \n were seen */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>mcbuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_CR</name> <operator>||</operator> <name><name>mcbuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_NL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>external_flags</name></name> <operator>|=</operator> <name>PCRE2_HASCRORLF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Set the first and required code units appropriately. If no previous
    first code unit, set it from this character, but revert to none on a zero
    repeat. Otherwise, leave the firstcu value alone, and don't change it on
    a zero repeat. */</comment>

    <if_stmt><if>if <condition>(<expr><name>firstcuflags</name> <operator>==</operator> <name>REQ_UNSET</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>zerofirstcuflags</name> <operator>=</operator> <name>REQ_NONE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zeroreqcu</name> <operator>=</operator> <name>reqcu</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zeroreqcuflags</name> <operator>=</operator> <name>reqcuflags</name></expr>;</expr_stmt>

      <comment type="block">/* If the character is more than one code unit long, we can set a single
      firstcu only if it is not to be matched caselessly. Multiple possible
      starting code units may be picked up later in the studying code. */</comment>

      <if_stmt><if>if <condition>(<expr><name>mclength</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>req_caseopt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>firstcu</name> <operator>=</operator> <name><name>mcbuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>firstcuflags</name> <operator>=</operator> <name>req_caseopt</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>mclength</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>reqcu</name> <operator>=</operator> <name><name>code</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>reqcuflags</name> <operator>=</operator> <name><name>cb</name><operator>-&gt;</operator><name>req_varyopt</name></name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>firstcuflags</name> <operator>=</operator> <name>reqcuflags</name> <operator>=</operator> <name>REQ_NONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></if>

    <comment type="block">/* firstcu was previously set; we can set reqcu only if the length is
    1 or the matching is caseful. */</comment>

    <else>else
      <block>{<block_content>
      <expr_stmt><expr><name>zerofirstcu</name> <operator>=</operator> <name>firstcu</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zerofirstcuflags</name> <operator>=</operator> <name>firstcuflags</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zeroreqcu</name> <operator>=</operator> <name>reqcu</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>zeroreqcuflags</name> <operator>=</operator> <name>reqcuflags</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>mclength</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>req_caseopt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>reqcu</name> <operator>=</operator> <name><name>code</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>reqcuflags</name> <operator>=</operator> <name>req_caseopt</name> <operator>|</operator> <name><name>cb</name><operator>-&gt;</operator><name>req_varyopt</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>

    <comment type="block">/* If caselessness was temporarily instated, reset it. */</comment>

    <if_stmt><if>if <condition>(<expr><name>reset_caseful</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>options</name> <operator>&amp;=</operator> <operator>~</operator><name>PCRE2_CASELESS</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>req_caseopt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>reset_caseful</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

    <break>break;</break>    <comment type="block">/* End literal character handling */</comment>
    </block_content>}</block></switch>         <comment type="block">/* End of big switch */</comment>
  </block_content>}</block></for>           <comment type="block">/* End of big loop */</comment>

<comment type="block">/* Control never reaches here. */</comment>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*   Compile regex: a sequence of alternatives    *
*************************************************/</comment>

<comment type="block">/* On entry, pptr is pointing past the bracket meta, but on return it points to
the closing bracket or META_END. The code variable is pointing at the code unit
into which the BRA operator has been stored. This function is used during the
pre-compile phase when we are trying to find out the amount of memory needed,
as well as during the real compile phase. The value of lengthptr distinguishes
the two phases.

Arguments:
  options           option bits, including any changes for this subpattern
  codeptr           -&gt; the address of the current code pointer
  pptrptr           -&gt; the address of the current parsed pattern pointer
  errorcodeptr      -&gt; pointer to error code variable
  skipunits         skip this many code units at start (for brackets and OP_COND)
  firstcuptr        place to put the first required code unit
  firstcuflagsptr   place to put the first code unit flags, or a negative number
  reqcuptr          place to put the last required code unit
  reqcuflagsptr     place to put the last required code unit flags, or a negative number
  bcptr             pointer to the chain of currently open branches
  cb                points to the data block with tables pointers etc.
  lengthptr         NULL during the real compile phase
                    points to length accumulator during pre-compile phase

Returns:            0 There has been an error
                   +1 Success, this group must match at least one character
                   -1 Success, this group may match an empty string
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>compile_regex</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier><modifier>*</modifier></type><name>codeptr</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>pptrptr</name></decl></parameter>,
  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>errorcodeptr</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>skipunits</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>firstcuptr</name></decl></parameter>,
  <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>firstcuflagsptr</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>reqcuptr</name></decl></parameter>,<parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>reqcuflagsptr</name></decl></parameter>,
  <parameter><decl><type><name>branch_chain</name> <modifier>*</modifier></type><name>bcptr</name></decl></parameter>, <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>lengthptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>code</name> <init>= <expr><operator>*</operator><name>codeptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>last_branch</name> <init>= <expr><name>code</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>start_bracket</name> <init>= <expr><name>code</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>lookbehind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>open_capitem</name></type> <name>capitem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>capnumber</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>okreturn</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pptr</name> <init>= <expr><operator>*</operator><name>pptrptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>firstcu</name></decl>, <decl><type ref="prev"/><name>reqcu</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>lookbehindlength</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>firstcuflags</name></decl>, <decl><type ref="prev"/><name>reqcuflags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>branchfirstcu</name></decl>, <decl><type ref="prev"/><name>branchreqcu</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>branchfirstcuflags</name></decl>, <decl><type ref="prev"/><name>branchreqcuflags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>branch_chain</name></type> <name>bc</name></decl>;</decl_stmt>

<comment type="block">/* If set, call the external function that checks for stack availability. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>cx</name><operator>-&gt;</operator><name>stack_guard</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
    <call><name><name>cb</name><operator>-&gt;</operator><name>cx</name><operator>-&gt;</operator><name>stack_guard</name></name><argument_list>(<argument><expr><name><name>cb</name><operator>-&gt;</operator><name>parens_depth</name></name></expr></argument>, <argument><expr><name><name>cb</name><operator>-&gt;</operator><name>cx</name><operator>-&gt;</operator><name>stack_guard_data</name></name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name><operator>=</operator> <name>ERR33</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Miscellaneous initialization */</comment>

<expr_stmt><expr><name><name>bc</name><operator>.</operator><name>outer</name></name> <operator>=</operator> <name>bcptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bc</name><operator>.</operator><name>current_branch</name></name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>

<expr_stmt><expr><name>firstcu</name> <operator>=</operator> <name>reqcu</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>firstcuflags</name> <operator>=</operator> <name>reqcuflags</name> <operator>=</operator> <name>REQ_UNSET</name></expr>;</expr_stmt>

<comment type="block">/* Accumulate the length for use in the pre-compile phase. Start with the
length of the BRA and KET and any extra code units that are required at the
beginning. We accumulate in a local variable to save frequent testing of
lengthptr for NULL. We cannot do this by looking at the value of 'code' at the
start and end of each alternative, because compiled items are discarded during
the pre-compile phase so that the workspace is not exceeded. */</comment>

<expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name> <operator>+</operator> <name>skipunits</name></expr>;</expr_stmt>

<comment type="block">/* Remember if this is a lookbehind assertion, and if it is, save its length
and skip over the pattern offset. */</comment>

<expr_stmt><expr><name>lookbehind</name> <operator>=</operator> <operator>*</operator><name>code</name> <operator>==</operator> <name>OP_ASSERTBACK</name> <operator>||</operator>
             <operator>*</operator><name>code</name> <operator>==</operator> <name>OP_ASSERTBACK_NOT</name> <operator>||</operator>
             <operator>*</operator><name>code</name> <operator>==</operator> <name>OP_ASSERTBACK_NA</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lookbehind</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>lookbehindlength</name> <operator>=</operator> <call><name>META_DATA</name><argument_list>(<argument><expr><name><name>pptr</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <name>SIZEOFFSET</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>lookbehindlength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<comment type="block">/* If this is a capturing subpattern, add to the chain of open capturing items
so that we can detect them if (*ACCEPT) is encountered. Note that only OP_CBRA
need be tested here; changing this opcode to one of its variants, e.g.
OP_SCBRAPOS, happens later, after the group has been compiled. */</comment>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_CBRA</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>capnumber</name> <operator>=</operator> <call><name>GET2</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>capitem</name><operator>.</operator><name>number</name></name> <operator>=</operator> <name>capnumber</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>capitem</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>cb</name><operator>-&gt;</operator><name>open_caps</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>capitem</name><operator>.</operator><name>assert_depth</name></name> <operator>=</operator> <name><name>cb</name><operator>-&gt;</operator><name>assert_depth</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>open_caps</name></name> <operator>=</operator> <operator>&amp;</operator><name>capitem</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Offset is set zero to mark that this bracket is still open */</comment>

<expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>code</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <name>skipunits</name></expr>;</expr_stmt>

<comment type="block">/* Loop for each alternative branch */</comment>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>branch_return</name></decl>;</decl_stmt>

  <comment type="block">/* Insert OP_REVERSE if this is as lookbehind assertion. */</comment>

  <if_stmt><if>if <condition>(<expr><name>lookbehind</name> <operator>&amp;&amp;</operator> <name>lookbehindlength</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_REVERSE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PUTINC</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>lookbehindlength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>length</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Now compile the branch; in the pre-compile phase its length gets added
  into the length. */</comment>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>branch_return</name> <operator>=</operator>
        <call><name>compile_branch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>code</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pptr</name></expr></argument>, <argument><expr><name>errorcodeptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>branchfirstcu</name></expr></argument>,
          <argument><expr><operator>&amp;</operator><name>branchfirstcuflags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>branchreqcu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>branchreqcuflags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bc</name></expr></argument>,
          <argument><expr><name>cb</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>lengthptr</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>&amp;</operator><name>length</name></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* If a branch can match an empty string, so can the whole group. */</comment>

  <if_stmt><if>if <condition>(<expr><name>branch_return</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>okreturn</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* In the real compile phase, there is some post-processing to be done. */</comment>

  <if_stmt><if>if <condition>(<expr><name>lengthptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* If this is the first branch, the firstcu and reqcu values for the
    branch become the values for the regex. */</comment>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>last_branch</name> <operator>!=</operator> <name>OP_ALT</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>firstcu</name> <operator>=</operator> <name>branchfirstcu</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>firstcuflags</name> <operator>=</operator> <name>branchfirstcuflags</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>reqcu</name> <operator>=</operator> <name>branchreqcu</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>reqcuflags</name> <operator>=</operator> <name>branchreqcuflags</name></expr>;</expr_stmt>
      </block_content>}</block></if>

    <comment type="block">/* If this is not the first branch, the first char and reqcu have to
    match the values from all the previous branches, except that if the
    previous value for reqcu didn't have REQ_VARY set, it can still match,
    and we set REQ_VARY for the group from this branch's value. */</comment>

    <else>else
      <block>{<block_content>
      <comment type="block">/* If we previously had a firstcu, but it doesn't match the new branch,
      we have to abandon the firstcu for the regex, but if there was
      previously no reqcu, it takes on the value of the old firstcu. */</comment>

      <if_stmt><if>if <condition>(<expr><name>firstcuflags</name> <operator>!=</operator> <name>branchfirstcuflags</name> <operator>||</operator> <name>firstcu</name> <operator>!=</operator> <name>branchfirstcu</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>firstcuflags</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>reqcuflags</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>reqcu</name> <operator>=</operator> <name>firstcu</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>reqcuflags</name> <operator>=</operator> <name>firstcuflags</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>firstcuflags</name> <operator>=</operator> <name>REQ_NONE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* If we (now or from before) have no firstcu, a firstcu from the
      branch becomes a reqcu if there isn't a branch reqcu. */</comment>

      <if_stmt><if>if <condition>(<expr><name>firstcuflags</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>branchfirstcuflags</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
          <name>branchreqcuflags</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>branchreqcu</name> <operator>=</operator> <name>branchfirstcu</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>branchreqcuflags</name> <operator>=</operator> <name>branchfirstcuflags</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Now ensure that the reqcus match */</comment>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>reqcuflags</name> <operator>&amp;</operator> <operator>~</operator><name>REQ_VARY</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>branchreqcuflags</name> <operator>&amp;</operator> <operator>~</operator><name>REQ_VARY</name><operator>)</operator><operator>)</operator> <operator>||</operator>
          <name>reqcu</name> <operator>!=</operator> <name>branchreqcu</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>reqcuflags</name> <operator>=</operator> <name>REQ_NONE</name></expr>;</expr_stmt></block_content></block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><name>reqcu</name> <operator>=</operator> <name>branchreqcu</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>reqcuflags</name> <operator>|=</operator> <name>branchreqcuflags</name></expr>;</expr_stmt> <comment type="block">/* To "or" REQ_VARY if present */</comment>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Handle reaching the end of the expression, either ')' or end of pattern.
  In the real compile phase, go back through the alternative branches and
  reverse the chain of offsets, with the field in the BRA item now becoming an
  offset to the first alternative. If there are no alternatives, it points to
  the end of the group. The length in the terminating ket is always the length
  of the whole bracketed item. Return leaving the pointer at the terminating
  char. */</comment>

  <if_stmt><if>if <condition>(<expr><call><name>META_CODE</name><argument_list>(<argument><expr><operator>*</operator><name>pptr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>META_ALT</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>lengthptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>branch_length</name> <init>= <expr><name>code</name> <operator>-</operator> <name>last_branch</name></expr></init></decl>;</decl_stmt>
      <do>do
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>prev_length</name> <init>= <expr><call><name>GET</name><argument_list>(<argument><expr><name>last_branch</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>last_branch</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>branch_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>branch_length</name> <operator>=</operator> <name>prev_length</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>last_branch</name> <operator>-=</operator> <name>branch_length</name></expr>;</expr_stmt>
        </block_content>}</block>
      while <condition>(<expr><name>branch_length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Fill in the ket */</comment>

    <expr_stmt><expr><operator>*</operator><name>code</name> <operator>=</operator> <name>OP_KET</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>code</name> <operator>-</operator> <name>start_bracket</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>code</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>

    <comment type="block">/* If it was a capturing subpattern, remove the block from the chain. */</comment>

    <if_stmt><if>if <condition>(<expr><name>capnumber</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>open_caps</name></name> <operator>=</operator> <name><name>cb</name><operator>-&gt;</operator><name>open_caps</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Set values to pass back */</comment>

    <expr_stmt><expr><operator>*</operator><name>codeptr</name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pptrptr</name> <operator>=</operator> <name>pptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>firstcuptr</name> <operator>=</operator> <name>firstcu</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>firstcuflagsptr</name> <operator>=</operator> <name>firstcuflags</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>reqcuptr</name> <operator>=</operator> <name>reqcu</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>reqcuflagsptr</name> <operator>=</operator> <name>reqcuflags</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>lengthptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>OFLOW_MAX</name> <operator>-</operator> <operator>*</operator><name>lengthptr</name> <operator>&lt;</operator> <name>length</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>errorcodeptr</name> <operator>=</operator> <name>ERR20</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>lengthptr</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <return>return <expr><name>okreturn</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Another branch follows. In the pre-compile phase, we can move the code
  pointer back to where it was for the start of the first branch. (That is,
  pretend that each branch is the only one.)

  In the real compile phase, insert an ALT node. Its length field points back
  to the previous branch while the bracket remains open. At the end the chain
  is reversed. It's done like this so that the start of the bracket has a
  zero offset until it is closed, making it possible to detect recursion. */</comment>

  <if_stmt><if>if <condition>(<expr><name>lengthptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>code</name> <operator>=</operator> <operator>*</operator><name>codeptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name> <operator>+</operator> <name>skipunits</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>length</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>code</name> <operator>=</operator> <name>OP_ALT</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>code</name> <operator>-</operator> <name>last_branch</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>bc</name><operator>.</operator><name>current_branch</name></name> <operator>=</operator> <name>last_branch</name> <operator>=</operator> <name>code</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>code</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

  <comment type="block">/* Set the lookbehind length (if not in a lookbehind the value will be zero)
  and then advance past the vertical bar. */</comment>

  <expr_stmt><expr><name>lookbehindlength</name> <operator>=</operator> <call><name>META_DATA</name><argument_list>(<argument><expr><operator>*</operator><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pptr</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
<comment type="block">/* Control never reaches here */</comment>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*          Check for anchored pattern            *
*************************************************/</comment>

<comment type="block">/* Try to find out if this is an anchored regular expression. Consider each
alternative branch. If they all start with OP_SOD or OP_CIRC, or with a bracket
all of whose alternatives start with OP_SOD or OP_CIRC (recurse ad lib), then
it's anchored. However, if this is a multiline pattern, then only OP_SOD will
be found, because ^ generates OP_CIRCM in that mode.

We can also consider a regex to be anchored if OP_SOM starts all its branches.
This is the code for \G, which means "match at start of match position, taking
into account the match offset".

A branch is also implicitly anchored if it starts with .* and DOTALL is set,
because that will try the rest of the pattern at all possible matching points,
so there is no point trying again.... er ....

.... except when the .* appears inside capturing parentheses, and there is a
subsequent back reference to those parentheses. We haven't enough information
to catch that case precisely.

At first, the best we could do was to detect when .* was in capturing brackets
and the highest back reference was greater than or equal to that level.
However, by keeping a bitmap of the first 31 back references, we can catch some
of the more common cases more precisely.

... A second exception is when the .* appears inside an atomic group, because
this prevents the number of characters it matches from being adjusted.

Arguments:
  code           points to start of the compiled pattern
  bracket_map    a bitmap of which brackets we are inside while testing; this
                   handles up to substring 31; after that we just have to take
                   the less precise approach
  cb             points to the compile data block
  atomcount      atomic group level
  inassert       TRUE if in an assertion

Returns:     TRUE or FALSE
*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>is_anchored</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>bracket_map</name></decl></parameter>, <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>atomcount</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>inassert</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<do>do <block>{<block_content>
   <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>scode</name> <init>= <expr><call><name>first_significant_code</name><argument_list>(
     <argument><expr><name>code</name> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>code</name></expr>]</index></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><operator>*</operator><name>scode</name></expr></init></decl>;</decl_stmt>

   <comment type="block">/* Non-capturing brackets */</comment>

   <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>OP_BRA</name>  <operator>||</operator> <name>op</name> <operator>==</operator> <name>OP_BRAPOS</name> <operator>||</operator>
       <name>op</name> <operator>==</operator> <name>OP_SBRA</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>OP_SBRAPOS</name></expr>)</condition>
     <block>{<block_content>
     <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_anchored</name><argument_list>(<argument><expr><name>scode</name></expr></argument>, <argument><expr><name>bracket_map</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>atomcount</name></expr></argument>, <argument><expr><name>inassert</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
       <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
     </block_content>}</block></if>

   <comment type="block">/* Capturing brackets */</comment>

   <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>OP_CBRA</name>  <operator>||</operator> <name>op</name> <operator>==</operator> <name>OP_CBRAPOS</name> <operator>||</operator>
            <name>op</name> <operator>==</operator> <name>OP_SCBRA</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>OP_SCBRAPOS</name></expr>)</condition>
     <block>{<block_content>
     <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>GET2</name><argument_list>(<argument><expr><name>scode</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>int</name></type> <name>new_map</name> <init>= <expr><name>bracket_map</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>n</name> <operator>&lt;</operator> <literal type="number">32</literal><operator>)</operator></expr>?</condition><then> <expr><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>n</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
     <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_anchored</name><argument_list>(<argument><expr><name>scode</name></expr></argument>, <argument><expr><name>new_map</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>atomcount</name></expr></argument>, <argument><expr><name>inassert</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
     </block_content>}</block></if>

   <comment type="block">/* Positive forward assertion */</comment>

   <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>OP_ASSERT</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>OP_ASSERT_NA</name></expr>)</condition>
     <block>{<block_content>
     <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_anchored</name><argument_list>(<argument><expr><name>scode</name></expr></argument>, <argument><expr><name>bracket_map</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>atomcount</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
     </block_content>}</block></if>

   <comment type="block">/* Condition. If there is no second branch, it can't be anchored. */</comment>

   <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>OP_COND</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>OP_SCOND</name></expr>)</condition>
     <block>{<block_content>
     <if_stmt><if>if <condition>(<expr><name><name>scode</name><index>[<expr><call><name>GET</name><argument_list>(<argument><expr><name>scode</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>!=</operator> <name>OP_ALT</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
     <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_anchored</name><argument_list>(<argument><expr><name>scode</name></expr></argument>, <argument><expr><name>bracket_map</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>atomcount</name></expr></argument>, <argument><expr><name>inassert</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
       <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
     </block_content>}</block></if>

   <comment type="block">/* Atomic groups */</comment>

   <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>OP_ONCE</name></expr>)</condition>
     <block>{<block_content>
     <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_anchored</name><argument_list>(<argument><expr><name>scode</name></expr></argument>, <argument><expr><name>bracket_map</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>atomcount</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>inassert</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
       <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
     </block_content>}</block></if>

   <comment type="block">/* .* is not anchored unless DOTALL is set (which generates OP_ALLANY) and
   it isn't in brackets that are or may be referenced or inside an atomic
   group or an assertion. Also the pattern must not contain *PRUNE or *SKIP,
   because these break the feature. Consider, for example, /(?s).*?(*PRUNE)b/
   with the subject "aab", which matches "b", i.e. not at the start of a line.
   There is also an option that disables auto-anchoring. */</comment>

   <if type="elseif">else if <condition>(<expr><operator>(</operator><name>op</name> <operator>==</operator> <name>OP_TYPESTAR</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>OP_TYPEMINSTAR</name> <operator>||</operator>
             <name>op</name> <operator>==</operator> <name>OP_TYPEPOSSTAR</name><operator>)</operator></expr>)</condition>
     <block>{<block_content>
     <if_stmt><if>if <condition>(<expr><name><name>scode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>OP_ALLANY</name> <operator>||</operator> <operator>(</operator><name>bracket_map</name> <operator>&amp;</operator> <name><name>cb</name><operator>-&gt;</operator><name>backref_map</name></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
         <name>atomcount</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>cb</name><operator>-&gt;</operator><name>had_pruneorskip</name></name> <operator>||</operator> <name>inassert</name> <operator>||</operator>
         <operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>external_options</name></name> <operator>&amp;</operator> <name>PCRE2_NO_DOTSTAR_ANCHOR</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
       <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
     </block_content>}</block></if>

   <comment type="block">/* Check for explicit anchoring */</comment>

   <if type="elseif">else if <condition>(<expr><name>op</name> <operator>!=</operator> <name>OP_SOD</name> <operator>&amp;&amp;</operator> <name>op</name> <operator>!=</operator> <name>OP_SOM</name> <operator>&amp;&amp;</operator> <name>op</name> <operator>!=</operator> <name>OP_CIRC</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

   <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block>
while <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>   <comment type="block">/* Loop for each alternative */</comment>
<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*         Check for starting with ^ or .*        *
*************************************************/</comment>

<comment type="block">/* This is called to find out if every branch starts with ^ or .* so that
"first char" processing can be done to speed things up in multiline
matching and for non-DOTALL patterns that start with .* (which must start at
the beginning or after \n). As in the case of is_anchored() (see above), we
have to take account of back references to capturing brackets that contain .*
because in that case we can't make the assumption. Also, the appearance of .*
inside atomic brackets or in an assertion, or in a pattern that contains *PRUNE
or *SKIP does not count, because once again the assumption no longer holds.

Arguments:
  code           points to start of the compiled pattern or a group
  bracket_map    a bitmap of which brackets we are inside while testing; this
                   handles up to substring 31; after that we just have to take
                   the less precise approach
  cb             points to the compile data
  atomcount      atomic group level
  inassert       TRUE if in an assertion

Returns:         TRUE or FALSE
*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>is_startline</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>bracket_map</name></decl></parameter>, <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>atomcount</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>inassert</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<do>do <block>{<block_content>
   <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>scode</name> <init>= <expr><call><name>first_significant_code</name><argument_list>(
     <argument><expr><name>code</name> <operator>+</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><operator>*</operator><name>code</name></expr>]</index></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><operator>*</operator><name>scode</name></expr></init></decl>;</decl_stmt>

   <comment type="block">/* If we are at the start of a conditional assertion group, *both* the
   conditional assertion *and* what follows the condition must satisfy the test
   for start of line. Other kinds of condition fail. Note that there may be an
   auto-callout at the start of a condition. */</comment>

   <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>OP_COND</name></expr>)</condition>
     <block>{<block_content>
     <expr_stmt><expr><name>scode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>

     <if_stmt><if>if <condition>(<expr><operator>*</operator><name>scode</name> <operator>==</operator> <name>OP_CALLOUT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>scode</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><name>OP_CALLOUT</name></expr>]</index></expr>;</expr_stmt></block_content></block></if>
       <if type="elseif">else if <condition>(<expr><operator>*</operator><name>scode</name> <operator>==</operator> <name>OP_CALLOUT_STR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>scode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>scode</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

     <switch>switch <condition>(<expr><operator>*</operator><name>scode</name></expr>)</condition>
       <block>{<block_content>
       <case>case <expr><name>OP_CREF</name></expr>:</case>
       <case>case <expr><name>OP_DNCREF</name></expr>:</case>
       <case>case <expr><name>OP_RREF</name></expr>:</case>
       <case>case <expr><name>OP_DNRREF</name></expr>:</case>
       <case>case <expr><name>OP_FAIL</name></expr>:</case>
       <case>case <expr><name>OP_FALSE</name></expr>:</case>
       <case>case <expr><name>OP_TRUE</name></expr>:</case>
       <return>return <expr><name>FALSE</name></expr>;</return>

       <default>default:</default>     <comment type="block">/* Assertion */</comment>
       <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_startline</name><argument_list>(<argument><expr><name>scode</name></expr></argument>, <argument><expr><name>bracket_map</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>atomcount</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
       <do>do<block type="pseudo"><block_content> <expr_stmt><expr><name>scode</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>scode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block> while <condition>(<expr><operator>*</operator><name>scode</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>
       <expr_stmt><expr><name>scode</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr>;</expr_stmt>
       <break>break;</break>
       </block_content>}</block></switch>
     <expr_stmt><expr><name>scode</name> <operator>=</operator> <call><name>first_significant_code</name><argument_list>(<argument><expr><name>scode</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><name>op</name> <operator>=</operator> <operator>*</operator><name>scode</name></expr>;</expr_stmt>
     </block_content>}</block></if></if_stmt>

   <comment type="block">/* Non-capturing brackets */</comment>

   <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>OP_BRA</name>  <operator>||</operator> <name>op</name> <operator>==</operator> <name>OP_BRAPOS</name> <operator>||</operator>
       <name>op</name> <operator>==</operator> <name>OP_SBRA</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>OP_SBRAPOS</name></expr>)</condition>
     <block>{<block_content>
     <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_startline</name><argument_list>(<argument><expr><name>scode</name></expr></argument>, <argument><expr><name>bracket_map</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>atomcount</name></expr></argument>, <argument><expr><name>inassert</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
       <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
     </block_content>}</block></if>

   <comment type="block">/* Capturing brackets */</comment>

   <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>OP_CBRA</name>  <operator>||</operator> <name>op</name> <operator>==</operator> <name>OP_CBRAPOS</name> <operator>||</operator>
            <name>op</name> <operator>==</operator> <name>OP_SCBRA</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>OP_SCBRAPOS</name></expr>)</condition>
     <block>{<block_content>
     <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>GET2</name><argument_list>(<argument><expr><name>scode</name></expr></argument>, <argument><expr><literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>int</name></type> <name>new_map</name> <init>= <expr><name>bracket_map</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>n</name> <operator>&lt;</operator> <literal type="number">32</literal><operator>)</operator></expr>?</condition><then> <expr><operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>n</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
     <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_startline</name><argument_list>(<argument><expr><name>scode</name></expr></argument>, <argument><expr><name>new_map</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>atomcount</name></expr></argument>, <argument><expr><name>inassert</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
     </block_content>}</block></if>

   <comment type="block">/* Positive forward assertions */</comment>

   <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>OP_ASSERT</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>OP_ASSERT_NA</name></expr>)</condition>
     <block>{<block_content>
     <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_startline</name><argument_list>(<argument><expr><name>scode</name></expr></argument>, <argument><expr><name>bracket_map</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>atomcount</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
       <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
     </block_content>}</block></if>

   <comment type="block">/* Atomic brackets */</comment>

   <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>OP_ONCE</name></expr>)</condition>
     <block>{<block_content>
     <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_startline</name><argument_list>(<argument><expr><name>scode</name></expr></argument>, <argument><expr><name>bracket_map</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>atomcount</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>inassert</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
       <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
     </block_content>}</block></if>

   <comment type="block">/* .* means "start at start or after \n" if it isn't in atomic brackets or
   brackets that may be referenced or an assertion, and as long as the pattern
   does not contain *PRUNE or *SKIP, because these break the feature. Consider,
   for example, /.*?a(*PRUNE)b/ with the subject "aab", which matches "ab",
   i.e. not at the start of a line. There is also an option that disables this
   optimization. */</comment>

   <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>OP_TYPESTAR</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>OP_TYPEMINSTAR</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>OP_TYPEPOSSTAR</name></expr>)</condition>
     <block>{<block_content>
     <if_stmt><if>if <condition>(<expr><name><name>scode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>OP_ANY</name> <operator>||</operator> <operator>(</operator><name>bracket_map</name> <operator>&amp;</operator> <name><name>cb</name><operator>-&gt;</operator><name>backref_map</name></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
         <name>atomcount</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>cb</name><operator>-&gt;</operator><name>had_pruneorskip</name></name> <operator>||</operator> <name>inassert</name> <operator>||</operator>
         <operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>external_options</name></name> <operator>&amp;</operator> <name>PCRE2_NO_DOTSTAR_ANCHOR</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
       <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
     </block_content>}</block></if>

   <comment type="block">/* Check for explicit circumflex; anything else gives a FALSE result. Note
   in particular that this includes atomic brackets OP_ONCE because the number
   of characters matched by .* cannot be adjusted inside them. */</comment>

   <if type="elseif">else if <condition>(<expr><name>op</name> <operator>!=</operator> <name>OP_CIRC</name> <operator>&amp;&amp;</operator> <name>op</name> <operator>!=</operator> <name>OP_CIRCM</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

   <comment type="block">/* Move on to the next alternative */</comment>

   <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block>
while <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>  <comment type="block">/* Loop for each alternative */</comment>
<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*   Scan compiled regex for recursion reference  *
*************************************************/</comment>

<comment type="block">/* This function scans through a compiled pattern until it finds an instance of
OP_RECURSE.

Arguments:
  code        points to start of expression
  utf         TRUE in UTF mode

Returns:      pointer to the opcode for OP_RECURSE, or NULL if not found
*/</comment>

<function><type><specifier>static</specifier> <name>PCRE2_SPTR</name></type>
<name>find_recurse</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>utf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>code</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>OP_END</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>OP_RECURSE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>code</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* XCLASS is used for classes that cannot be represented just by a bit map.
  This includes negated single high-valued characters. CALLOUT_STR is used for
  callouts with string arguments. In both cases the length in the table is
  zero; the actual length is stored in the compiled code. */</comment>

  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>OP_XCLASS</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <name>OP_CALLOUT_STR</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>LINK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

  <comment type="block">/* Otherwise, we can get the item's length from the table, except that for
  repeated character types, we have to test for \p and \P, which have an extra
  two code units of parameters, and for MARK/PRUNE/SKIP/THEN with an argument,
  we must add in its length. */</comment>

  <else>else
    <block>{<block_content>
    <switch>switch<condition>(<expr><name>c</name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>OP_TYPESTAR</name></expr>:</case>
      <case>case <expr><name>OP_TYPEMINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_TYPEPLUS</name></expr>:</case>
      <case>case <expr><name>OP_TYPEMINPLUS</name></expr>:</case>
      <case>case <expr><name>OP_TYPEQUERY</name></expr>:</case>
      <case>case <expr><name>OP_TYPEMINQUERY</name></expr>:</case>
      <case>case <expr><name>OP_TYPEPOSSTAR</name></expr>:</case>
      <case>case <expr><name>OP_TYPEPOSPLUS</name></expr>:</case>
      <case>case <expr><name>OP_TYPEPOSQUERY</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>OP_PROP</name> <operator>||</operator> <name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>code</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_TYPEPOSUPTO</name></expr>:</case>
      <case>case <expr><name>OP_TYPEUPTO</name></expr>:</case>
      <case>case <expr><name>OP_TYPEMINUPTO</name></expr>:</case>
      <case>case <expr><name>OP_TYPEEXACT</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name><name>code</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>]</index></name> <operator>==</operator> <name>OP_PROP</name> <operator>||</operator> <name><name>code</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>IMM2_SIZE</name></expr>]</index></name> <operator>==</operator> <name>OP_NOTPROP</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>code</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>

      <case>case <expr><name>OP_MARK</name></expr>:</case>
      <case>case <expr><name>OP_COMMIT_ARG</name></expr>:</case>
      <case>case <expr><name>OP_PRUNE_ARG</name></expr>:</case>
      <case>case <expr><name>OP_SKIP_ARG</name></expr>:</case>
      <case>case <expr><name>OP_THEN_ARG</name></expr>:</case>
      <expr_stmt><expr><name>code</name> <operator>+=</operator> <name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></switch>

    <comment type="block">/* Add in the fixed length from the table */</comment>

    <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>PRIV</name><argument_list>(<argument><expr><name>OP_lengths</name></expr></argument>)</argument_list></call><index>[<expr><name>c</name></expr>]</index></expr>;</expr_stmt>

    <comment type="block">/* In UTF-8 and UTF-16 modes, opcodes that are followed by a character may
    be followed by a multi-unit character. The length in the table is a
    minimum, so we have to arrange to skip the extra units. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MAYBE_UTF_MULTI</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <switch>switch<condition>(<expr><name>c</name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>OP_CHAR</name></expr>:</case>
      <case>case <expr><name>OP_CHARI</name></expr>:</case>
      <case>case <expr><name>OP_NOT</name></expr>:</case>
      <case>case <expr><name>OP_NOTI</name></expr>:</case>
      <case>case <expr><name>OP_EXACT</name></expr>:</case>
      <case>case <expr><name>OP_EXACTI</name></expr>:</case>
      <case>case <expr><name>OP_NOTEXACT</name></expr>:</case>
      <case>case <expr><name>OP_NOTEXACTI</name></expr>:</case>
      <case>case <expr><name>OP_UPTO</name></expr>:</case>
      <case>case <expr><name>OP_UPTOI</name></expr>:</case>
      <case>case <expr><name>OP_NOTUPTO</name></expr>:</case>
      <case>case <expr><name>OP_NOTUPTOI</name></expr>:</case>
      <case>case <expr><name>OP_MINUPTO</name></expr>:</case>
      <case>case <expr><name>OP_MINUPTOI</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINUPTO</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINUPTOI</name></expr>:</case>
      <case>case <expr><name>OP_POSUPTO</name></expr>:</case>
      <case>case <expr><name>OP_POSUPTOI</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSUPTO</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSUPTOI</name></expr>:</case>
      <case>case <expr><name>OP_STAR</name></expr>:</case>
      <case>case <expr><name>OP_STARI</name></expr>:</case>
      <case>case <expr><name>OP_NOTSTAR</name></expr>:</case>
      <case>case <expr><name>OP_NOTSTARI</name></expr>:</case>
      <case>case <expr><name>OP_MINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_MINSTARI</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINSTAR</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINSTARI</name></expr>:</case>
      <case>case <expr><name>OP_POSSTAR</name></expr>:</case>
      <case>case <expr><name>OP_POSSTARI</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSSTAR</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSSTARI</name></expr>:</case>
      <case>case <expr><name>OP_PLUS</name></expr>:</case>
      <case>case <expr><name>OP_PLUSI</name></expr>:</case>
      <case>case <expr><name>OP_NOTPLUS</name></expr>:</case>
      <case>case <expr><name>OP_NOTPLUSI</name></expr>:</case>
      <case>case <expr><name>OP_MINPLUS</name></expr>:</case>
      <case>case <expr><name>OP_MINPLUSI</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINPLUS</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINPLUSI</name></expr>:</case>
      <case>case <expr><name>OP_POSPLUS</name></expr>:</case>
      <case>case <expr><name>OP_POSPLUSI</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSPLUS</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSPLUSI</name></expr>:</case>
      <case>case <expr><name>OP_QUERY</name></expr>:</case>
      <case>case <expr><name>OP_QUERYI</name></expr>:</case>
      <case>case <expr><name>OP_NOTQUERY</name></expr>:</case>
      <case>case <expr><name>OP_NOTQUERYI</name></expr>:</case>
      <case>case <expr><name>OP_MINQUERY</name></expr>:</case>
      <case>case <expr><name>OP_MINQUERYI</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINQUERY</name></expr>:</case>
      <case>case <expr><name>OP_NOTMINQUERYI</name></expr>:</case>
      <case>case <expr><name>OP_POSQUERY</name></expr>:</case>
      <case>case <expr><name>OP_POSQUERYI</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSQUERY</name></expr>:</case>
      <case>case <expr><name>OP_NOTPOSQUERYI</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>HAS_EXTRALEN</name><argument_list>(<argument><expr><name><name>code</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>GET_EXTRALEN</name><argument_list>(<argument><expr><name><name>code</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
      </block_content>}</block></switch></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>utf</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* Keep compiler happy by referencing function argument */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* MAYBE_UTF_MULTI */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*    Check for asserted fixed first code unit    *
*************************************************/</comment>

<comment type="block">/* During compilation, the "first code unit" settings from forward assertions
are discarded, because they can cause conflicts with actual literals that
follow. However, if we end up without a first code unit setting for an
unanchored pattern, it is worth scanning the regex to see if there is an
initial asserted first code unit. If all branches start with the same asserted
code unit, or with a non-conditional bracket all of whose alternatives start
with the same asserted code unit (recurse ad lib), then we return that code
unit, with the flags set to zero or REQ_CASELESS; otherwise return zero with
REQ_NONE in the flags.

Arguments:
  code       points to start of compiled pattern
  flags      points to the first code unit flags
  inassert   non-zero if in an assertion

Returns:     the fixed first code unit, or 0 with REQ_NONE in flags
*/</comment>

<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>find_firstassertedcu</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>int32_t</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>inassert</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cflags</name> <init>= <expr><name>REQ_NONE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>=</operator> <name>REQ_NONE</name></expr>;</expr_stmt>
<do>do <block>{<block_content>
   <decl_stmt><decl><type><name>uint32_t</name></type> <name>d</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>int</name></type> <name>dflags</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>int</name></type> <name>xl</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_CBRA</name> <operator>||</operator> <operator>*</operator><name>code</name> <operator>==</operator> <name>OP_SCBRA</name> <operator>||</operator>
             <operator>*</operator><name>code</name> <operator>==</operator> <name>OP_CBRAPOS</name> <operator>||</operator> <operator>*</operator><name>code</name> <operator>==</operator> <name>OP_SCBRAPOS</name><operator>)</operator></expr>?</condition><then> <expr><name>IMM2_SIZE</name></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>scode</name> <init>= <expr><call><name>first_significant_code</name><argument_list>(<argument><expr><name>code</name> <operator>+</operator> <literal type="number">1</literal><operator>+</operator><name>LINK_SIZE</name> <operator>+</operator> <name>xl</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name>op</name> <init>= <expr><operator>*</operator><name>scode</name></expr></init></decl>;</decl_stmt>

   <switch>switch<condition>(<expr><name>op</name></expr>)</condition>
     <block>{<block_content>
     <default>default:</default>
     <return>return <expr><literal type="number">0</literal></expr>;</return>

     <case>case <expr><name>OP_BRA</name></expr>:</case>
     <case>case <expr><name>OP_BRAPOS</name></expr>:</case>
     <case>case <expr><name>OP_CBRA</name></expr>:</case>
     <case>case <expr><name>OP_SCBRA</name></expr>:</case>
     <case>case <expr><name>OP_CBRAPOS</name></expr>:</case>
     <case>case <expr><name>OP_SCBRAPOS</name></expr>:</case>
     <case>case <expr><name>OP_ASSERT</name></expr>:</case>
     <case>case <expr><name>OP_ASSERT_NA</name></expr>:</case>
     <case>case <expr><name>OP_ONCE</name></expr>:</case>
     <case>case <expr><name>OP_SCRIPT_RUN</name></expr>:</case>
     <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>find_firstassertedcu</name><argument_list>(<argument><expr><name>scode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dflags</name></expr></argument>, <argument><expr><name>inassert</name> <operator>+</operator>
       <operator>(</operator><ternary><condition><expr><operator>(</operator><name>op</name> <operator>==</operator> <name>OP_ASSERT</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>OP_ASSERT_NA</name><operator>)</operator></expr>?</condition><then><expr><literal type="number">1</literal></expr></then><else>:<expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <if_stmt><if>if <condition>(<expr><name>dflags</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
       <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
     <if_stmt><if>if <condition>(<expr><name>cflags</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <name>d</name></expr>;</expr_stmt> <expr_stmt><expr><name>cflags</name> <operator>=</operator> <name>dflags</name></expr>;</expr_stmt> </block_content>}</block></if>
       <if type="elseif">else if <condition>(<expr><name>c</name> <operator>!=</operator> <name>d</name> <operator>||</operator> <name>cflags</name> <operator>!=</operator> <name>dflags</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
     <break>break;</break>

     <case>case <expr><name>OP_EXACT</name></expr>:</case>
     <expr_stmt><expr><name>scode</name> <operator>+=</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
     <comment type="block">/* Fall through */</comment>

     <case>case <expr><name>OP_CHAR</name></expr>:</case>
     <case>case <expr><name>OP_PLUS</name></expr>:</case>
     <case>case <expr><name>OP_MINPLUS</name></expr>:</case>
     <case>case <expr><name>OP_POSPLUS</name></expr>:</case>
     <if_stmt><if>if <condition>(<expr><name>inassert</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
     <if_stmt><if>if <condition>(<expr><name>cflags</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>scode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name>cflags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> </block_content>}</block></if>
       <if type="elseif">else if <condition>(<expr><name>c</name> <operator>!=</operator> <name><name>scode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
     <break>break;</break>

     <case>case <expr><name>OP_EXACTI</name></expr>:</case>
     <expr_stmt><expr><name>scode</name> <operator>+=</operator> <name>IMM2_SIZE</name></expr>;</expr_stmt>
     <comment type="block">/* Fall through */</comment>

     <case>case <expr><name>OP_CHARI</name></expr>:</case>
     <case>case <expr><name>OP_PLUSI</name></expr>:</case>
     <case>case <expr><name>OP_MINPLUSI</name></expr>:</case>
     <case>case <expr><name>OP_POSPLUSI</name></expr>:</case>
     <if_stmt><if>if <condition>(<expr><name>inassert</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

     <comment type="block">/* If the character is more than one code unit long, we cannot set its
     first code unit when matching caselessly. Later scanning may pick up
     multiple code units. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
     <if_stmt><if>if <condition>(<expr><name><name>scode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:elif>
     <if_stmt><if>if <condition>(<expr><name><name>scode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0xd800</literal> <operator>&amp;&amp;</operator> <name><name>scode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="number">0xdfff</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

     <if_stmt><if>if <condition>(<expr><name>cflags</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>scode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt> <expr_stmt><expr><name>cflags</name> <operator>=</operator> <name>REQ_CASELESS</name></expr>;</expr_stmt> </block_content>}</block></if>
       <if type="elseif">else if <condition>(<expr><name>c</name> <operator>!=</operator> <name><name>scode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
     <break>break;</break>
     </block_content>}</block></switch>

   <expr_stmt><expr><name>code</name> <operator>+=</operator> <call><name>GET</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   </block_content>}</block>
while <condition>(<expr><operator>*</operator><name>code</name> <operator>==</operator> <name>OP_ALT</name></expr>)</condition>;</do>

<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>=</operator> <name>cflags</name></expr>;</expr_stmt>
<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*     Add an entry to the name/number table      *
*************************************************/</comment>

<comment type="block">/* This function is called between compiling passes to add an entry to the
name/number table, maintaining alphabetical order. Checking for permitted
and forbidden duplicates has already been done.

Arguments:
  cb           the compile data block
  name         the name to add
  length       the length of the name
  groupno      the group number
  tablecount   the count of names in the table so far

Returns:       nothing
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_name_to_table</name><parameter_list>(<parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>,
  <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>groupno</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>tablecount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>cb</name><operator>-&gt;</operator><name>name_table</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>tablecount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>crc</name> <init>= <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>slot</name><operator>+</operator><name>IMM2_SIZE</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>crc</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>slot</name><index>[<expr><name>IMM2_SIZE</name><operator>+</operator><name>length</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>crc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* Current name is a substring */</comment>

  <comment type="block">/* Make space in the table and break the loop for an earlier name. For a
  duplicate or later name, carry on. We do this for duplicates so that in the
  simple case (when ?(| is not used) they are in order of their numbers. In all
  cases they are in the order in which they appear in the pattern. */</comment>

  <if_stmt><if>if <condition>(<expr><name>crc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memmove</name><argument_list>(<argument><expr><name>slot</name> <operator>+</operator> <name><name>cb</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>,
      <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><operator>(</operator><name>tablecount</name> <operator>-</operator> <name>i</name><operator>)</operator> <operator>*</operator> <name><name>cb</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Continue the loop for a later or duplicate name */</comment>

  <expr_stmt><expr><name>slot</name> <operator>+=</operator> <name><name>cb</name><operator>-&gt;</operator><name>name_entry_size</name></name></expr>;</expr_stmt>
  </block_content>}</block></for>

<expr_stmt><expr><call><name>PUT2</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>groupno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>slot</name> <operator>+</operator> <name>IMM2_SIZE</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Add a terminating zero and fill the rest of the slot with zeroes so that
the memory is all initialized. Otherwise valgrind moans about uninitialized
memory when saving serialized compiled patterns. */</comment>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>slot</name> <operator>+</operator> <name>IMM2_SIZE</name> <operator>+</operator> <name>length</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
  <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name><name>cb</name><operator>-&gt;</operator><name>name_entry_size</name></name> <operator>-</operator> <name>length</name> <operator>-</operator> <name>IMM2_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*             Skip in parsed pattern             *
*************************************************/</comment>

<comment type="block">/* This function is called to skip parts of the parsed pattern when finding the
length of a lookbehind branch. It is called after (*ACCEPT) and (*FAIL) to find
the end of the branch, it is called to skip over an internal lookaround or
(DEFINE) group, and it is also called to skip to the end of a class, during
which it will never encounter nested groups (but there's no need to have
special code for that).

When called to find the end of a branch or group, pptr must point to the first
meta code inside the branch, not the branch-starting code. In other cases it
can point to the item that causes the function to be called.

Arguments:
  pptr       current pointer to skip from
  skiptype   PSKIP_CLASS when skipping to end of class
             PSKIP_ALT when META_ALT ends the skip
             PSKIP_KET when only META_KET ends the skip

Returns:     new value of pptr
             NULL if META_END is reached - should never occur
               or for an unknown meta value - likewise
*/</comment>

<function><type><specifier>static</specifier> <name>uint32_t</name> <modifier>*</modifier></type>
<name>parsed_skip</name><parameter_list>(<parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pptr</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>skiptype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>nestlevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition> <incr><expr><name>pptr</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>meta</name> <init>= <expr><call><name>META_CODE</name><argument_list>(<argument><expr><operator>*</operator><name>pptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <switch>switch<condition>(<expr><name>meta</name></expr>)</condition>
    <block>{<block_content>
    <default>default:</default>  <comment type="block">/* Just skip over most items */</comment>
    <if_stmt><if>if <condition>(<expr><name>meta</name> <operator>&lt;</operator> <name>META_END</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>  <comment type="block">/* Literal */</comment>
    <break>break;</break>

    <comment type="block">/* This should never occur. */</comment>

    <case>case <expr><name>META_END</name></expr>:</case>
    <return>return <expr><name>NULL</name></expr>;</return>

    <comment type="block">/* The data for these items is variable in length. */</comment>

    <case>case <expr><name>META_BACKREF</name></expr>:</case>  <comment type="block">/* Offset is present only if group &gt;= 10 */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>META_DATA</name><argument_list>(<argument><expr><operator>*</operator><name>pptr</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <name>SIZEOFFSET</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <break>break;</break>

    <case>case <expr><name>META_ESCAPE</name></expr>:</case>   <comment type="block">/* A few escapes are followed by data items. */</comment>
    <switch>switch <condition>(<expr><call><name>META_DATA</name><argument_list>(<argument><expr><operator>*</operator><name>pptr</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>ESC_P</name></expr>:</case>
      <case>case <expr><name>ESC_p</name></expr>:</case>
      <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>ESC_g</name></expr>:</case>
      <case>case <expr><name>ESC_k</name></expr>:</case>
      <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>SIZEOFFSET</name></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></switch>
    <break>break;</break>

    <case>case <expr><name>META_MARK</name></expr>:</case>     <comment type="block">/* Add the length of the name. */</comment>
    <case>case <expr><name>META_COMMIT_ARG</name></expr>:</case>
    <case>case <expr><name>META_PRUNE_ARG</name></expr>:</case>
    <case>case <expr><name>META_SKIP_ARG</name></expr>:</case>
    <case>case <expr><name>META_THEN_ARG</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <name><name>pptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* These are the "active" items in this loop. */</comment>

    <case>case <expr><name>META_CLASS_END</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>skiptype</name> <operator>==</operator> <name>PSKIP_CLASS</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>pptr</name></expr>;</return></block_content></block></if></if_stmt>
    <break>break;</break>

    <case>case <expr><name>META_ATOMIC</name></expr>:</case>
    <case>case <expr><name>META_CAPTURE</name></expr>:</case>
    <case>case <expr><name>META_COND_ASSERT</name></expr>:</case>
    <case>case <expr><name>META_COND_DEFINE</name></expr>:</case>
    <case>case <expr><name>META_COND_NAME</name></expr>:</case>
    <case>case <expr><name>META_COND_NUMBER</name></expr>:</case>
    <case>case <expr><name>META_COND_RNAME</name></expr>:</case>
    <case>case <expr><name>META_COND_RNUMBER</name></expr>:</case>
    <case>case <expr><name>META_COND_VERSION</name></expr>:</case>
    <case>case <expr><name>META_LOOKAHEAD</name></expr>:</case>
    <case>case <expr><name>META_LOOKAHEADNOT</name></expr>:</case>
    <case>case <expr><name>META_LOOKAHEAD_NA</name></expr>:</case>
    <case>case <expr><name>META_LOOKBEHIND</name></expr>:</case>
    <case>case <expr><name>META_LOOKBEHINDNOT</name></expr>:</case>
    <case>case <expr><name>META_LOOKBEHIND_NA</name></expr>:</case>
    <case>case <expr><name>META_NOCAPTURE</name></expr>:</case>
    <case>case <expr><name>META_SCRIPT_RUN</name></expr>:</case>
    <expr_stmt><expr><name>nestlevel</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_ALT</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>nestlevel</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>skiptype</name> <operator>==</operator> <name>PSKIP_ALT</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>pptr</name></expr>;</return></block_content></block></if></if_stmt>
    <break>break;</break>

    <case>case <expr><name>META_KET</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name>nestlevel</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>pptr</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>nestlevel</name><operator>--</operator></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></switch>

  <comment type="block">/* The extra data item length for each meta is in a table. */</comment>

  <expr_stmt><expr><name>meta</name> <operator>=</operator> <operator>(</operator><name>meta</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7fff</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>meta</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>meta_extra_lengths</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <name><name>meta_extra_lengths</name><index>[<expr><name>meta</name></expr>]</index></name></expr>;</expr_stmt>
  </block_content>}</block></for>
<comment type="block">/* Control never reaches here */</comment>
<return>return <expr><name>pptr</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*       Find length of a parsed group            *
*************************************************/</comment>

<comment type="block">/* This is called for nested groups within a branch of a lookbehind whose
length is being computed. If all the branches in the nested group have the same
length, that is OK. On entry, the pointer must be at the first element after
the group initializing code. On exit it points to OP_KET. Caching is used to
improve processing speed when the same capturing group occurs many times.

Arguments:
  pptrptr     pointer to pointer in the parsed pattern
  isinline    FALSE if a reference or recursion; TRUE for inline group
  errcodeptr  pointer to the errorcode
  lcptr       pointer to the loop counter
  group       number of captured group or -1 for a non-capturing group
  recurses    chain of recurse_check to catch mutual recursion
  cb          pointer to the compile data

Returns:      the group length or a negative number
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_grouplength</name><parameter_list>(<parameter><decl><type><name>uint32_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>pptrptr</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>isinline</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>errcodeptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lcptr</name></decl></parameter>,
   <parameter><decl><type><name>int</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>parsed_recurse_check</name> <modifier>*</modifier></type><name>recurses</name></decl></parameter>, <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>branchlength</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>grouplength</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* The cache can be used only if there is no possibility of there being two
groups with the same number. We do not need to set the end pointer for a group
that is being processed as a back reference or recursion, but we must do so for
an inline group. */</comment>

<if_stmt><if>if <condition>(<expr><name>group</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>external_flags</name></name> <operator>&amp;</operator> <name>PCRE2_DUPCAPUSED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>groupinfo</name> <init>= <expr><name><name>cb</name><operator>-&gt;</operator><name>groupinfo</name><index>[<expr><name>group</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>groupinfo</name> <operator>&amp;</operator> <name>GI_NOT_FIXED_LENGTH</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>groupinfo</name> <operator>&amp;</operator> <name>GI_SET_FIXED_LENGTH</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>isinline</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>pptrptr</name> <operator>=</operator> <call><name>parsed_skip</name><argument_list>(<argument><expr><operator>*</operator><name>pptrptr</name></expr></argument>, <argument><expr><name>PSKIP_KET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>groupinfo</name> <operator>&amp;</operator> <name>GI_FIXED_LENGTH_MASK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Scan the group. In this case we find the end pointer of necessity. */</comment>

<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <expr_stmt><expr><name>branchlength</name> <operator>=</operator> <call><name>get_branchlength</name><argument_list>(<argument><expr><name>pptrptr</name></expr></argument>, <argument><expr><name>errcodeptr</name></expr></argument>, <argument><expr><name>lcptr</name></expr></argument>, <argument><expr><name>recurses</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>branchlength</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>ISNOTFIXED</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>grouplength</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>grouplength</name> <operator>=</operator> <name>branchlength</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>grouplength</name> <operator>!=</operator> <name>branchlength</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>ISNOTFIXED</name>;</goto></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>pptrptr</name> <operator>==</operator> <name>META_KET</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>pptrptr</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>   <comment type="block">/* Skip META_ALT */</comment>
  </block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>group</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>groupinfo</name><index>[<expr><name>group</name></expr>]</index></name> <operator>|=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>GI_SET_FIXED_LENGTH</name> <operator>|</operator> <name>grouplength</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>grouplength</name></expr>;</return>

<label><name>ISNOTFIXED</name>:</label>
<if_stmt><if>if <condition>(<expr><name>group</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>groupinfo</name><index>[<expr><name>group</name></expr>]</index></name> <operator>|=</operator> <name>GI_NOT_FIXED_LENGTH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*        Find length of a parsed branch          *
*************************************************/</comment>

<comment type="block">/* Return a fixed length for a branch in a lookbehind, giving an error if the
length is not fixed. On entry, *pptrptr points to the first element inside the
branch. On exit it is set to point to the ALT or KET.

Arguments:
  pptrptr     pointer to pointer in the parsed pattern
  errcodeptr  pointer to error code
  lcptr       pointer to loop counter
  recurses    chain of recurse_check to catch mutual recursion
  cb          pointer to compile block

Returns:      the length, or a negative value on error
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_branchlength</name><parameter_list>(<parameter><decl><type><name>uint32_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>pptrptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>errcodeptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lcptr</name></decl></parameter>,
  <parameter><decl><type><name>parsed_recurse_check</name> <modifier>*</modifier></type><name>recurses</name></decl></parameter>, <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>branchlength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>grouplength</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>lastitemlength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pptr</name> <init>= <expr><operator>*</operator><name>pptrptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>parsed_recurse_check</name></type> <name>this_recurse</name></decl>;</decl_stmt>

<comment type="block">/* A large and/or complex regex can take too long to process. This can happen
more often when (?| groups are present in the pattern because their length
cannot be cached. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>lcptr</name><operator>)</operator><operator>++</operator> <operator>&gt;</operator> <literal type="number">2000</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>errcodeptr</name> <operator>=</operator> <name>ERR35</name></expr>;</expr_stmt>  <comment type="block">/* Lookbehind is too complicated */</comment>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Scan the branch, accumulating the length. */</comment>

<for>for <control>(<init>;</init><condition>;</condition> <incr><expr><name>pptr</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>parsed_recurse_check</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>gptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>gptrend</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>escape</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>group</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>itemlength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pptr</name> <operator>&lt;</operator> <name>META_END</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>itemlength</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>

  <else>else<block type="pseudo"><block_content> <switch>switch <condition>(<expr><call><name>META_CODE</name><argument_list>(<argument><expr><operator>*</operator><name>pptr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>META_KET</name></expr>:</case>
    <case>case <expr><name>META_ALT</name></expr>:</case>
    <goto>goto <name>EXIT</name>;</goto>

    <comment type="block">/* (*ACCEPT) and (*FAIL) terminate the branch, but we must skip to the
    actual termination. */</comment>

    <case>case <expr><name>META_ACCEPT</name></expr>:</case>
    <case>case <expr><name>META_FAIL</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name> <operator>=</operator> <call><name>parsed_skip</name><argument_list>(<argument><expr><name>pptr</name></expr></argument>, <argument><expr><name>PSKIP_ALT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>pptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>PARSED_SKIP_FAILED</name>;</goto></block_content></block></if></if_stmt>
    <goto>goto <name>EXIT</name>;</goto>

    <case>case <expr><name>META_MARK</name></expr>:</case>
    <case>case <expr><name>META_COMMIT_ARG</name></expr>:</case>
    <case>case <expr><name>META_PRUNE_ARG</name></expr>:</case>
    <case>case <expr><name>META_SKIP_ARG</name></expr>:</case>
    <case>case <expr><name>META_THEN_ARG</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <name><name>pptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_CIRCUMFLEX</name></expr>:</case>
    <case>case <expr><name>META_COMMIT</name></expr>:</case>
    <case>case <expr><name>META_DOLLAR</name></expr>:</case>
    <case>case <expr><name>META_PRUNE</name></expr>:</case>
    <case>case <expr><name>META_SKIP</name></expr>:</case>
    <case>case <expr><name>META_THEN</name></expr>:</case>
    <break>break;</break>

    <case>case <expr><name>META_OPTIONS</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_BIGVALUE</name></expr>:</case>
    <expr_stmt><expr><name>itemlength</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_CLASS</name></expr>:</case>
    <case>case <expr><name>META_CLASS_NOT</name></expr>:</case>
    <expr_stmt><expr><name>itemlength</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>pptr</name> <operator>=</operator> <call><name>parsed_skip</name><argument_list>(<argument><expr><name>pptr</name></expr></argument>, <argument><expr><name>PSKIP_CLASS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>pptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>PARSED_SKIP_FAILED</name>;</goto></block_content></block></if></if_stmt>
    <break>break;</break>

    <case>case <expr><name>META_CLASS_EMPTY_NOT</name></expr>:</case>
    <case>case <expr><name>META_DOT</name></expr>:</case>
    <expr_stmt><expr><name>itemlength</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_CALLOUT_NUMBER</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_CALLOUT_STRING</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">3</literal> <operator>+</operator> <name>SIZEOFFSET</name></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* Only some escapes consume a character. Of those, \R and \X are never
    allowed because they might match more than character. \C is allowed only in
    32-bit and non-UTF 8/16-bit modes. */</comment>

    <case>case <expr><name>META_ESCAPE</name></expr>:</case>
    <expr_stmt><expr><name>escape</name> <operator>=</operator> <call><name>META_DATA</name><argument_list>(<argument><expr><operator>*</operator><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>escape</name> <operator>==</operator> <name>ESC_R</name> <operator>||</operator> <name>escape</name> <operator>==</operator> <name>ESC_X</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>escape</name> <operator>&gt;</operator> <name>ESC_b</name> <operator>&amp;&amp;</operator> <name>escape</name> <operator>&lt;</operator> <name>ESC_Z</name></expr>)</condition>
      <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>!=</operator> <literal type="number">32</literal></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>external_options</name></name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>escape</name> <operator>==</operator> <name>ESC_C</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>errcodeptr</name> <operator>=</operator> <name>ERR36</name></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>itemlength</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>escape</name> <operator>==</operator> <name>ESC_p</name> <operator>||</operator> <name>escape</name> <operator>==</operator> <name>ESC_P</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* Skip prop data */</comment>
      </block_content>}</block></if></if_stmt>
    <break>break;</break>

    <comment type="block">/* Lookaheads do not contribute to the length of this branch, but they may
    contain lookbehinds within them whose lengths need to be set. */</comment>

    <case>case <expr><name>META_LOOKAHEAD</name></expr>:</case>
    <case>case <expr><name>META_LOOKAHEADNOT</name></expr>:</case>
    <case>case <expr><name>META_LOOKAHEAD_NA</name></expr>:</case>
    <expr_stmt><expr><operator>*</operator><name>errcodeptr</name> <operator>=</operator> <call><name>check_lookbehinds</name><argument_list>(<argument><expr><name>pptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pptr</name></expr></argument>, <argument><expr><name>recurses</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>errcodeptr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Ignore any qualifiers that follow a lookahead assertion. */</comment>

    <switch>switch <condition>(<expr><name><name>pptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>META_ASTERISK</name></expr>:</case>
      <case>case <expr><name>META_ASTERISK_PLUS</name></expr>:</case>
      <case>case <expr><name>META_ASTERISK_QUERY</name></expr>:</case>
      <case>case <expr><name>META_PLUS</name></expr>:</case>
      <case>case <expr><name>META_PLUS_PLUS</name></expr>:</case>
      <case>case <expr><name>META_PLUS_QUERY</name></expr>:</case>
      <case>case <expr><name>META_QUERY</name></expr>:</case>
      <case>case <expr><name>META_QUERY_PLUS</name></expr>:</case>
      <case>case <expr><name>META_QUERY_QUERY</name></expr>:</case>
      <expr_stmt><expr><name>pptr</name><operator>++</operator></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><name>META_MINMAX</name></expr>:</case>
      <case>case <expr><name>META_MINMAX_PLUS</name></expr>:</case>
      <case>case <expr><name>META_MINMAX_QUERY</name></expr>:</case>
      <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      <break>break;</break>

      <default>default:</default>
      <break>break;</break>
      </block_content>}</block></switch>
    <break>break;</break>

    <comment type="block">/* A nested lookbehind does not contribute any length to this lookbehind,
    but must itself be checked and have its lengths set. */</comment>

    <case>case <expr><name>META_LOOKBEHIND</name></expr>:</case>
    <case>case <expr><name>META_LOOKBEHINDNOT</name></expr>:</case>
    <case>case <expr><name>META_LOOKBEHIND_NA</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>set_lookbehind_lengths</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pptr</name></expr></argument>, <argument><expr><name>errcodeptr</name></expr></argument>, <argument><expr><name>lcptr</name></expr></argument>, <argument><expr><name>recurses</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <break>break;</break>

    <comment type="block">/* Back references and recursions are handled by very similar code. At this
    stage, the names generated in the parsing pass are available, but the main
    name table has not yet been created. So for the named varieties, scan the
    list of names in order to get the number of the first one in the pattern,
    and whether or not this name is duplicated. */</comment>

    <case>case <expr><name>META_BACKREF_BYNAME</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>external_options</name></name> <operator>&amp;</operator> <name>PCRE2_MATCH_UNSET_BACKREF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <goto>goto <name>ISNOTFIXED</name>;</goto></block_content></block></if></if_stmt>
    <comment type="block">/* Fall through */</comment>

    <case>case <expr><name>META_RECURSE_BYNAME</name></expr>:</case>
      <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>name</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>BOOL</name></type> <name>is_dupname</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>named_group</name> <modifier>*</modifier></type><name>ng</name> <init>= <expr><name><name>cb</name><operator>-&gt;</operator><name>named_groups</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>meta_code</name> <init>= <expr><call><name>META_CODE</name><argument_list>(<argument><expr><operator>*</operator><name>pptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>length</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>++</operator><name>pptr</name><operator>)</operator></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>GETPLUSOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>cb</name><operator>-&gt;</operator><name>start_pattern</name></name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>names_found</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ng</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <name><name>ng</name><operator>-&gt;</operator><name>length</name></name> <operator>&amp;&amp;</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>strncmp</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>ng</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>group</name> <operator>=</operator> <name><name>ng</name><operator>-&gt;</operator><name>number</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>is_dupname</name> <operator>=</operator> <name><name>ng</name><operator>-&gt;</operator><name>isdup</name></name></expr>;</expr_stmt>
          <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

      <if_stmt><if>if <condition>(<expr><name>group</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>errcodeptr</name> <operator>=</operator> <name>ERR15</name></expr>;</expr_stmt>  <comment type="block">/* Non-existent subpattern */</comment>
        <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>erroroffset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* A numerical back reference can be fixed length if duplicate capturing
      groups are not being used. A non-duplicate named back reference can also
      be handled. */</comment>

      <if_stmt><if>if <condition>(<expr><name>meta_code</name> <operator>==</operator> <name>META_RECURSE_BYNAME</name> <operator>||</operator>
          <operator>(</operator><operator>!</operator><name>is_dupname</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>external_flags</name></name> <operator>&amp;</operator> <name>PCRE2_DUPCAPUSED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>RECURSE_OR_BACKREF_LENGTH</name>;</goto></block_content></block></if></if_stmt>  <comment type="block">/* Handle as a numbered version. */</comment>
      </block_content>}</block>
    <goto>goto <name>ISNOTFIXED</name>;</goto>                     <comment type="block">/* Duplicate name or number */</comment>

    <comment type="block">/* The offset values for back references &lt; 10 are in a separate vector
    because otherwise they would use more than two parsed pattern elements on
    64-bit systems. */</comment>

    <case>case <expr><name>META_BACKREF</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>external_options</name></name> <operator>&amp;</operator> <name>PCRE2_MATCH_UNSET_BACKREF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
        <operator>(</operator><name><name>cb</name><operator>-&gt;</operator><name>external_flags</name></name> <operator>&amp;</operator> <name>PCRE2_DUPCAPUSED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <goto>goto <name>ISNOTFIXED</name>;</goto></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>META_DATA</name><argument_list>(<argument><expr><operator>*</operator><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>group</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>cb</name><operator>-&gt;</operator><name>small_ref_offset</name><index>[<expr><name>group</name></expr>]</index></name></expr>;</expr_stmt>
      <goto>goto <name>RECURSE_OR_BACKREF_LENGTH</name>;</goto>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Fall through */</comment>
    <comment type="block">/* For groups &gt;= 10 - picking up group twice does no harm. */</comment>

    <comment type="block">/* A true recursion implies not fixed length, but a subroutine call may
    be OK. Back reference "recursions" are also failed. */</comment>

    <case>case <expr><name>META_RECURSE</name></expr>:</case>
    <expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>META_DATA</name><argument_list>(<argument><expr><operator>*</operator><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GETPLUSOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <label><name>RECURSE_OR_BACKREF_LENGTH</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>group</name> <operator>&gt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>bracount</name></name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>erroroffset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>errcodeptr</name> <operator>=</operator> <name>ERR15</name></expr>;</expr_stmt>  <comment type="block">/* Non-existent subpattern */</comment>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>group</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>ISNOTFIXED</name>;</goto></block_content></block></if></if_stmt>  <comment type="block">/* Local recursion */</comment>
    <for>for <control>(<init><expr><name>gptr</name> <operator>=</operator> <name><name>cb</name><operator>-&gt;</operator><name>parsed_pattern</name></name></expr>;</init> <condition><expr><operator>*</operator><name>gptr</name> <operator>!=</operator> <name>META_END</name></expr>;</condition> <incr><expr><name>gptr</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>META_CODE</name><argument_list>(<argument><expr><operator>*</operator><name>gptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>META_BIGVALUE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>gptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>*</operator><name>gptr</name> <operator>==</operator> <operator>(</operator><name>META_CAPTURE</name> <operator>|</operator> <name>group</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
      </block_content>}</block></for>

    <comment type="block">/* We must start the search for the end of the group at the first meta code
    inside the group. Otherwise it will be treated as an enclosed group. */</comment>

    <expr_stmt><expr><name>gptrend</name> <operator>=</operator> <call><name>parsed_skip</name><argument_list>(<argument><expr><name>gptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>PSKIP_KET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>gptrend</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>PARSED_SKIP_FAILED</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>pptr</name> <operator>&gt;</operator> <name>gptr</name> <operator>&amp;&amp;</operator> <name>pptr</name> <operator>&lt;</operator> <name>gptrend</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>ISNOTFIXED</name>;</goto></block_content></block></if></if_stmt>  <comment type="block">/* Local recursion */</comment>
    <for>for <control>(<init><expr><name>r</name> <operator>=</operator> <name>recurses</name></expr>;</init> <condition><expr><name>r</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>r</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control><block type="pseudo"><block_content> <if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>groupptr</name></name> <operator>==</operator> <name>gptr</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
    <if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>ISNOTFIXED</name>;</goto></block_content></block></if></if_stmt>   <comment type="block">/* Mutual recursion */</comment>
    <expr_stmt><expr><name><name>this_recurse</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <name>recurses</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>this_recurse</name><operator>.</operator><name>groupptr</name></name> <operator>=</operator> <name>gptr</name></expr>;</expr_stmt>

    <comment type="block">/* We do not need to know the position of the end of the group, that is,
    gptr is not used after the call to get_grouplength(). Setting the second
    argument FALSE stops it scanning for the end when the length can be found
    in the cache. */</comment>

    <expr_stmt><expr><name>gptr</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>grouplength</name> <operator>=</operator> <call><name>get_grouplength</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gptr</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>errcodeptr</name></expr></argument>, <argument><expr><name>lcptr</name></expr></argument>, <argument><expr><name>group</name></expr></argument>,
      <argument><expr><operator>&amp;</operator><name>this_recurse</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>grouplength</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>errcodeptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>ISNOTFIXED</name>;</goto></block_content></block></if></if_stmt>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>  <comment type="block">/* Error already set */</comment>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>itemlength</name> <operator>=</operator> <name>grouplength</name></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* A (DEFINE) group is never obeyed inline and so it does not contribute to
    the length of this branch. Skip from the following item to the next
    unpaired ket. */</comment>

    <case>case <expr><name>META_COND_DEFINE</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name> <operator>=</operator> <call><name>parsed_skip</name><argument_list>(<argument><expr><name>pptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>PSKIP_KET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* Check other nested groups - advance past the initial data for each type
    and then seek a fixed length with get_grouplength(). */</comment>

    <case>case <expr><name>META_COND_NAME</name></expr>:</case>
    <case>case <expr><name>META_COND_NUMBER</name></expr>:</case>
    <case>case <expr><name>META_COND_RNAME</name></expr>:</case>
    <case>case <expr><name>META_COND_RNUMBER</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <name>SIZEOFFSET</name></expr>;</expr_stmt>
    <goto>goto <name>CHECK_GROUP</name>;</goto>

    <case>case <expr><name>META_COND_ASSERT</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <goto>goto <name>CHECK_GROUP</name>;</goto>

    <case>case <expr><name>META_COND_VERSION</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <goto>goto <name>CHECK_GROUP</name>;</goto>

    <case>case <expr><name>META_CAPTURE</name></expr>:</case>
    <expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>META_DATA</name><argument_list>(<argument><expr><operator>*</operator><name>pptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Fall through */</comment>

    <case>case <expr><name>META_ATOMIC</name></expr>:</case>
    <case>case <expr><name>META_NOCAPTURE</name></expr>:</case>
    <case>case <expr><name>META_SCRIPT_RUN</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name><operator>++</operator></expr>;</expr_stmt>
    <label><name>CHECK_GROUP</name>:</label>
    <expr_stmt><expr><name>grouplength</name> <operator>=</operator> <call><name>get_grouplength</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pptr</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>errcodeptr</name></expr></argument>, <argument><expr><name>lcptr</name></expr></argument>, <argument><expr><name>group</name></expr></argument>,
      <argument><expr><name>recurses</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>grouplength</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>itemlength</name> <operator>=</operator> <name>grouplength</name></expr>;</expr_stmt>
    <break>break;</break>

    <comment type="block">/* Exact repetition is OK; variable repetition is not. A repetition of zero
    must subtract the length that has already been added. */</comment>

    <case>case <expr><name>META_MINMAX</name></expr>:</case>
    <case>case <expr><name>META_MINMAX_PLUS</name></expr>:</case>
    <case>case <expr><name>META_MINMAX_QUERY</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><name><name>pptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>pptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition>
      <block>{<block_content>
      <switch>switch<condition>(<expr><name><name>pptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><literal type="number">0</literal></expr>:</case>
        <expr_stmt><expr><name>branchlength</name> <operator>-=</operator> <name>lastitemlength</name></expr>;</expr_stmt>
        <break>break;</break>

        <case>case <expr><literal type="number">1</literal></expr>:</case>
        <expr_stmt><expr><name>itemlength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <break>break;</break>

        <default>default:</default>  <comment type="block">/* Check for integer overflow */</comment>
        <if_stmt><if>if <condition>(<expr><name>lastitemlength</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>  <comment type="block">/* Should not occur, but just in case */</comment>
            <name>INT_MAX</name><operator>/</operator><name>lastitemlength</name> <operator>&lt;</operator> <name><name>pptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><operator>*</operator><name>errcodeptr</name> <operator>=</operator> <name>ERR87</name></expr>;</expr_stmt>  <comment type="block">/* Integer overflow; lookbehind too big */</comment>
          <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
          </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>itemlength</name> <operator>=</operator> <operator>(</operator><name><name>pptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>lastitemlength</name></expr>;</expr_stmt>
        <break>break;</break>
        </block_content>}</block></switch>
      <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <break>break;</break>
      </block_content>}</block></if></if_stmt>
    <comment type="block">/* Fall through */</comment>

    <comment type="block">/* Any other item means this branch does not have a fixed length. */</comment>

    <default>default:</default>
    <label><name>ISNOTFIXED</name>:</label>
    <expr_stmt><expr><operator>*</operator><name>errcodeptr</name> <operator>=</operator> <name>ERR25</name></expr>;</expr_stmt>   <comment type="block">/* Not fixed length */</comment>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></switch></block_content></block></else></if_stmt>

  <comment type="block">/* Add the item length to the branchlength, checking for integer overflow and
  for the branch length exceeding the limit. */</comment>

  <if_stmt><if>if <condition>(<expr><name>INT_MAX</name> <operator>-</operator> <name><name>branchlength</name> <argument_list type="generic">&lt; <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>itemlength</name> <operator>||</operator>
      <operator>(</operator><name>branchlength</name> <operator>+=</operator> <name>itemlength</name><operator>)</operator></expr></argument> &gt;</argument_list></name> <name>LOOKBEHIND_MAX</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>errcodeptr</name> <operator>=</operator> <name>ERR87</name></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Save this item length for use if the next item is a quantifier. */</comment>

  <expr_stmt><expr><name>lastitemlength</name> <operator>=</operator> <name>itemlength</name></expr>;</expr_stmt>
  </block_content>}</block></for>

<label><name>EXIT</name>:</label>
<expr_stmt><expr><operator>*</operator><name>pptrptr</name> <operator>=</operator> <name>pptr</name></expr>;</expr_stmt>
<return>return <expr><name>branchlength</name></expr>;</return>

<label><name>PARSED_SKIP_FAILED</name>:</label>
<expr_stmt><expr><operator>*</operator><name>errcodeptr</name> <operator>=</operator> <name>ERR90</name></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*        Set lengths in a lookbehind             *
*************************************************/</comment>

<comment type="block">/* This function is called for each lookbehind, to set the lengths in its
branches. An error occurs if any branch does not have a fixed length that is
less than the maximum (65535). On exit, the pointer must be left on the final
ket.

The function also maintains the max_lookbehind value. Any lookbehind branch
that contains a nested lookbehind may actually look further back than the
length of the branch. The additional amount is passed back from
get_branchlength() as an "extra" value.

Arguments:
  pptrptr     pointer to pointer in the parsed pattern
  errcodeptr  pointer to error code
  lcptr       pointer to loop counter
  recurses    chain of recurse_check to catch mutual recursion
  cb          pointer to compile block

Returns:      TRUE if all is well
              FALSE otherwise, with error code and offset set
*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>set_lookbehind_lengths</name><parameter_list>(<parameter><decl><type><name>uint32_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>pptrptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>errcodeptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lcptr</name></decl></parameter>,
  <parameter><decl><type><name>parsed_recurse_check</name> <modifier>*</modifier></type><name>recurses</name></decl></parameter>, <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>branchlength</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>bptr</name> <init>= <expr><operator>*</operator><name>pptrptr</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>READPLUSOFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>bptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Offset for error messages */</comment>
<expr_stmt><expr><operator>*</operator><name>pptrptr</name> <operator>+=</operator> <name>SIZEOFFSET</name></expr>;</expr_stmt>

<do>do
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>pptrptr</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>branchlength</name> <operator>=</operator> <call><name>get_branchlength</name><argument_list>(<argument><expr><name>pptrptr</name></expr></argument>, <argument><expr><name>errcodeptr</name></expr></argument>, <argument><expr><name>lcptr</name></expr></argument>, <argument><expr><name>recurses</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>branchlength</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <comment type="block">/* The errorcode and offset may already be set from a nested lookbehind. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>errcodeptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>errcodeptr</name> <operator>=</operator> <name>ERR25</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>-&gt;</operator><name>erroroffset</name></name> <operator>==</operator> <name>PCRE2_UNSET</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>erroroffset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>branchlength</name> <operator>&gt;</operator> <name><name>cb</name><operator>-&gt;</operator><name>max_lookbehind</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>max_lookbehind</name></name> <operator>=</operator> <name>branchlength</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>bptr</name> <operator>|=</operator> <name>branchlength</name></expr>;</expr_stmt>  <comment type="block">/* branchlength never more than 65535 */</comment>
  <expr_stmt><expr><name>bptr</name> <operator>=</operator> <operator>*</operator><name>pptrptr</name></expr>;</expr_stmt>
  </block_content>}</block>
while <condition>(<expr><operator>*</operator><name>bptr</name> <operator>==</operator> <name>META_ALT</name></expr>)</condition>;</do>

<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*         Check parsed pattern lookbehinds       *
*************************************************/</comment>

<comment type="block">/* This function is called at the end of parsing a pattern if any lookbehinds
were encountered. It scans the parsed pattern for them, calling
set_lookbehind_lengths() for each one. At the start, the errorcode is zero and
the error offset is marked unset. The enables the functions above not to
override settings from deeper nestings.

This function is called recursively from get_branchlength() for lookaheads in
order to process any lookbehinds that they may contain. It stops when it hits a
non-nested closing parenthesis in this case, returning a pointer to it.

Arguments
  pptr      points to where to start (start of pattern or start of lookahead)
  retptr    if not NULL, return the ket pointer here
  recurses  chain of recurse_check to catch mutual recursion
  cb        points to the compile block

Returns:    0 on success, or an errorcode (cb-&gt;erroroffset will be set)
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>check_lookbehinds</name><parameter_list>(<parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pptr</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>retptr</name></decl></parameter>,
  <parameter><decl><type><name>parsed_recurse_check</name> <modifier>*</modifier></type><name>recurses</name></decl></parameter>, <parameter><decl><type><name>compile_block</name> <modifier>*</modifier></type><name>cb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>errorcode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>loopcount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nestlevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>cb</name><operator>-&gt;</operator><name>erroroffset</name></name> <operator>=</operator> <name>PCRE2_UNSET</name></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>pptr</name> <operator>!=</operator> <name>META_END</name></expr>;</condition> <incr><expr><name>pptr</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pptr</name> <operator>&lt;</operator> <name>META_END</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>  <comment type="block">/* Literal */</comment>

  <switch>switch <condition>(<expr><call><name>META_CODE</name><argument_list>(<argument><expr><operator>*</operator><name>pptr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    <default>default:</default>
    <return>return <expr><name>ERR70</name></expr>;</return>  <comment type="block">/* Unrecognized meta code */</comment>

    <case>case <expr><name>META_ESCAPE</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pptr</name> <operator>-</operator> <name>META_ESCAPE</name> <operator>==</operator> <name>ESC_P</name> <operator>||</operator> <operator>*</operator><name>pptr</name> <operator>-</operator> <name>META_ESCAPE</name> <operator>==</operator> <name>ESC_p</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <break>break;</break>

    <case>case <expr><name>META_KET</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>--</operator><name>nestlevel</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>retptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>retptr</name> <operator>=</operator> <name>pptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    <break>break;</break>

    <case>case <expr><name>META_ATOMIC</name></expr>:</case>
    <case>case <expr><name>META_CAPTURE</name></expr>:</case>
    <case>case <expr><name>META_COND_ASSERT</name></expr>:</case>
    <case>case <expr><name>META_LOOKAHEAD</name></expr>:</case>
    <case>case <expr><name>META_LOOKAHEADNOT</name></expr>:</case>
    <case>case <expr><name>META_LOOKAHEAD_NA</name></expr>:</case>
    <case>case <expr><name>META_NOCAPTURE</name></expr>:</case>
    <case>case <expr><name>META_SCRIPT_RUN</name></expr>:</case>
    <expr_stmt><expr><name>nestlevel</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_ACCEPT</name></expr>:</case>
    <case>case <expr><name>META_ALT</name></expr>:</case>
    <case>case <expr><name>META_ASTERISK</name></expr>:</case>
    <case>case <expr><name>META_ASTERISK_PLUS</name></expr>:</case>
    <case>case <expr><name>META_ASTERISK_QUERY</name></expr>:</case>
    <case>case <expr><name>META_BACKREF</name></expr>:</case>
    <case>case <expr><name>META_CIRCUMFLEX</name></expr>:</case>
    <case>case <expr><name>META_CLASS</name></expr>:</case>
    <case>case <expr><name>META_CLASS_EMPTY</name></expr>:</case>
    <case>case <expr><name>META_CLASS_EMPTY_NOT</name></expr>:</case>
    <case>case <expr><name>META_CLASS_END</name></expr>:</case>
    <case>case <expr><name>META_CLASS_NOT</name></expr>:</case>
    <case>case <expr><name>META_COMMIT</name></expr>:</case>
    <case>case <expr><name>META_DOLLAR</name></expr>:</case>
    <case>case <expr><name>META_DOT</name></expr>:</case>
    <case>case <expr><name>META_FAIL</name></expr>:</case>
    <case>case <expr><name>META_PLUS</name></expr>:</case>
    <case>case <expr><name>META_PLUS_PLUS</name></expr>:</case>
    <case>case <expr><name>META_PLUS_QUERY</name></expr>:</case>
    <case>case <expr><name>META_PRUNE</name></expr>:</case>
    <case>case <expr><name>META_QUERY</name></expr>:</case>
    <case>case <expr><name>META_QUERY_PLUS</name></expr>:</case>
    <case>case <expr><name>META_QUERY_QUERY</name></expr>:</case>
    <case>case <expr><name>META_RANGE_ESCAPED</name></expr>:</case>
    <case>case <expr><name>META_RANGE_LITERAL</name></expr>:</case>
    <case>case <expr><name>META_SKIP</name></expr>:</case>
    <case>case <expr><name>META_THEN</name></expr>:</case>
    <break>break;</break>

    <case>case <expr><name>META_RECURSE</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <name>SIZEOFFSET</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_BACKREF_BYNAME</name></expr>:</case>
    <case>case <expr><name>META_RECURSE_BYNAME</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>SIZEOFFSET</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_COND_DEFINE</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <name>SIZEOFFSET</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nestlevel</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_COND_NAME</name></expr>:</case>
    <case>case <expr><name>META_COND_NUMBER</name></expr>:</case>
    <case>case <expr><name>META_COND_RNAME</name></expr>:</case>
    <case>case <expr><name>META_COND_RNUMBER</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>SIZEOFFSET</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nestlevel</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_COND_VERSION</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>nestlevel</name><operator>++</operator></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_CALLOUT_STRING</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">3</literal> <operator>+</operator> <name>SIZEOFFSET</name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_BIGVALUE</name></expr>:</case>
    <case>case <expr><name>META_OPTIONS</name></expr>:</case>
    <case>case <expr><name>META_POSIX</name></expr>:</case>
    <case>case <expr><name>META_POSIX_NEG</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_MINMAX</name></expr>:</case>
    <case>case <expr><name>META_MINMAX_QUERY</name></expr>:</case>
    <case>case <expr><name>META_MINMAX_PLUS</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_CALLOUT_NUMBER</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_MARK</name></expr>:</case>
    <case>case <expr><name>META_COMMIT_ARG</name></expr>:</case>
    <case>case <expr><name>META_PRUNE_ARG</name></expr>:</case>
    <case>case <expr><name>META_SKIP_ARG</name></expr>:</case>
    <case>case <expr><name>META_THEN_ARG</name></expr>:</case>
    <expr_stmt><expr><name>pptr</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name><name>pptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <break>break;</break>

    <case>case <expr><name>META_LOOKBEHIND</name></expr>:</case>
    <case>case <expr><name>META_LOOKBEHINDNOT</name></expr>:</case>
    <case>case <expr><name>META_LOOKBEHIND_NA</name></expr>:</case>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>set_lookbehind_lengths</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>loopcount</name></expr></argument>, <argument><expr><name>recurses</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>errorcode</name></expr>;</return></block_content></block></if></if_stmt>
    <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*     External function to compile a pattern     *
*************************************************/</comment>

<comment type="block">/* This function reads a regular expression in the form of a string and returns
a pointer to a block of store holding a compiled version of the expression.

Arguments:
  pattern       the regular expression
  patlen        the length of the pattern, or PCRE2_ZERO_TERMINATED
  options       option bits
  errorptr      pointer to errorcode
  erroroffset   pointer to error offset
  ccontext      points to a compile context or is NULL

Returns:        pointer to compiled data block, or NULL on error,
                with errorcode and erroroffset set
*/</comment>

<function><type><name>PCRE2_EXP_DEFN</name> <name>pcre2_code</name> <modifier>*</modifier> <name>PCRE2_CALL_CONVENTION</name></type>
<name>pcre2_compile</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>pattern</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>patlen</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>options</name></decl></parameter>,
   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>errorptr</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>erroroffset</name></decl></parameter>, <parameter><decl><type><name>pcre2_compile_context</name> <modifier>*</modifier></type><name>ccontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>BOOL</name></type> <name>utf</name></decl>;</decl_stmt>                             <comment type="block">/* Set TRUE for UTF mode */</comment>
<decl_stmt><decl><type><name>BOOL</name></type> <name>ucp</name></decl>;</decl_stmt>                             <comment type="block">/* Set TRUE for UCP mode */</comment>
<decl_stmt><decl><type><name>BOOL</name></type> <name>has_lookbehind</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>          <comment type="block">/* Set TRUE if a lookbehind is found */</comment>
<decl_stmt><decl><type><name>BOOL</name></type> <name>zero_terminated</name></decl>;</decl_stmt>                 <comment type="block">/* Set TRUE for zero-terminated pattern */</comment>
<decl_stmt><decl><type><name>pcre2_real_code</name> <modifier>*</modifier></type><name>re</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>           <comment type="block">/* What we will return */</comment>
<decl_stmt><decl><type><name>compile_block</name></type> <name>cb</name></decl>;</decl_stmt>                     <comment type="block">/* "Static" compile-time data */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>tables</name></decl>;</decl_stmt>                <comment type="block">/* Char tables base pointer */</comment>

<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>code</name></decl>;</decl_stmt>                    <comment type="block">/* Current pointer in compiled code */</comment>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>codestart</name></decl>;</decl_stmt>                 <comment type="block">/* Start of compiled code */</comment>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>ptr</name></decl>;</decl_stmt>                       <comment type="block">/* Current pointer in pattern */</comment>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>pptr</name></decl>;</decl_stmt>                       <comment type="block">/* Current pointer in parsed pattern */</comment>

<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>length</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* Allow for final END opcode */</comment>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>usedlength</name></decl>;</decl_stmt>                <comment type="block">/* Actual length used */</comment>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>re_blocksize</name></decl>;</decl_stmt>              <comment type="block">/* Size of memory block */</comment>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>big32count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>            <comment type="block">/* 32-bit literals &gt;= 0x80000000 */</comment>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>parsed_size_needed</name></decl>;</decl_stmt>        <comment type="block">/* Needed for parsed pattern */</comment>

<decl_stmt><decl><type><name>int32_t</name></type> <name>firstcuflags</name></decl>, <decl><type ref="prev"/><name>reqcuflags</name></decl>;</decl_stmt>     <comment type="block">/* Type of first/req code unit */</comment>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>firstcu</name></decl>, <decl><type ref="prev"/><name>reqcu</name></decl>;</decl_stmt>              <comment type="block">/* Value of first/req code unit */</comment>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>setflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                <comment type="block">/* NL and BSR set flags */</comment>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>skipatstart</name></decl>;</decl_stmt>                 <comment type="block">/* When checking (*UTF) etc */</comment>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>limit_heap</name>  <init>= <expr><name>UINT32_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>limit_match</name> <init>= <expr><name>UINT32_MAX</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* Unset match limits */</comment>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>limit_depth</name> <init>= <expr><name>UINT32_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>newline</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                      <comment type="block">/* Unset; can be set by the pattern */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>bsr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                          <comment type="block">/* Unset; can be set by the pattern */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>errorcode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                    <comment type="block">/* Initialize to avoid compiler warn */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>regexrc</name></decl>;</decl_stmt>                          <comment type="block">/* Return from compile */</comment>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>                           <comment type="block">/* Local loop counter */</comment>

<comment type="block">/* Comments at the head of this file explain about these variables. */</comment>

<decl_stmt><decl><type><name>uint32_t</name></type> <name><name>stack_groupinfo</name><index>[<expr><name>GROUPINFO_DEFAULT_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name><name>stack_parsed_pattern</name><index>[<expr><name>PARSED_PATTERN_DEFAULT_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>named_group</name></type> <name><name>named_groups</name><index>[<expr><name>NAMED_GROUP_LIST_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/* The workspace is used in different ways in the different compiling phases.
It needs to be 16-bit aligned for the preliminary parsing scan. */</comment>

<decl_stmt><decl><type><name>uint32_t</name></type> <name><name>c16workspace</name><index>[<expr><name>C16_WORK_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>cworkspace</name> <init>= <expr><operator>(</operator><name>PCRE2_UCHAR</name> <operator>*</operator><operator>)</operator><name>c16workspace</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* -------------- Check arguments and set up the pattern ----------------- */</comment>

<comment type="block">/* There must be error code and offset pointers. */</comment>

<if_stmt><if>if <condition>(<expr><name>errorptr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>erroroffset</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>errorptr</name> <operator>=</operator> <name>ERR0</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>erroroffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<comment type="block">/* There must be a pattern! */</comment>

<if_stmt><if>if <condition>(<expr><name>pattern</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>errorptr</name> <operator>=</operator> <name>ERR16</name></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* A NULL compile context means "use a default context" */</comment>

<if_stmt><if>if <condition>(<expr><name>ccontext</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>ccontext</name> <operator>=</operator> <operator>(</operator><name>pcre2_compile_context</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><call><name>PRIV</name><argument_list>(<argument><expr><name>default_compile_context</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* PCRE2_MATCH_INVALID_UTF implies UTF */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_MATCH_INVALID_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_UTF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* Check that all undefined public option bits are zero. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <operator>~</operator><name>PUBLIC_COMPILE_OPTIONS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
    <operator>(</operator><name><name>ccontext</name><operator>-&gt;</operator><name>extra_options</name></name> <operator>&amp;</operator> <operator>~</operator><name>PUBLIC_COMPILE_EXTRA_OPTIONS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>errorptr</name> <operator>=</operator> <name>ERR17</name></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_LITERAL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
    <operator>(</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <operator>~</operator><name>PUBLIC_LITERAL_COMPILE_OPTIONS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
     <operator>(</operator><name><name>ccontext</name><operator>-&gt;</operator><name>extra_options</name></name> <operator>&amp;</operator> <operator>~</operator><name>PUBLIC_LITERAL_COMPILE_EXTRA_OPTIONS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>errorptr</name> <operator>=</operator> <name>ERR92</name></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* A zero-terminated pattern is indicated by the special length value
PCRE2_ZERO_TERMINATED. Check for an overlong pattern. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>zero_terminated</name> <operator>=</operator> <operator>(</operator><name>patlen</name> <operator>==</operator> <name>PCRE2_ZERO_TERMINATED</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>patlen</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>strlen</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>patlen</name> <operator>&gt;</operator> <name><name>ccontext</name><operator>-&gt;</operator><name>max_pattern_length</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>errorptr</name> <operator>=</operator> <name>ERR88</name></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* From here on, all returns from this function should end up going via the
EXIT label. */</comment>


<comment type="block">/* ------------ Initialize the "static" compile data -------------- */</comment>

<expr_stmt><expr><name>tables</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>ccontext</name><operator>-&gt;</operator><name>tables</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then> <expr><name><name>ccontext</name><operator>-&gt;</operator><name>tables</name></name></expr> </then><else>: <expr><call><name>PRIV</name><argument_list>(<argument><expr><name>default_tables</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>lcc</name></name> <operator>=</operator> <name>tables</name> <operator>+</operator> <name>lcc_offset</name></expr>;</expr_stmt>          <comment type="block">/* Individual */</comment>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>fcc</name></name> <operator>=</operator> <name>tables</name> <operator>+</operator> <name>fcc_offset</name></expr>;</expr_stmt>          <comment type="block">/*   character */</comment>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>cbits</name></name> <operator>=</operator> <name>tables</name> <operator>+</operator> <name>cbits_offset</name></expr>;</expr_stmt>      <comment type="block">/*      tables */</comment>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>ctypes</name></name> <operator>=</operator> <name>tables</name> <operator>+</operator> <name>ctypes_offset</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>assert_depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>bracount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>cx</name></name> <operator>=</operator> <name>ccontext</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>dupnames</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>end_pattern</name></name> <operator>=</operator> <name>pattern</name> <operator>+</operator> <name>patlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>erroroffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>external_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>external_options</name></name> <operator>=</operator> <name>options</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>groupinfo</name></name> <operator>=</operator> <name>stack_groupinfo</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>had_recurse</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>lastcapture</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>max_lookbehind</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>name_entry_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>name_table</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>named_groups</name></name> <operator>=</operator> <name>named_groups</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>named_group_list_size</name></name> <operator>=</operator> <name>NAMED_GROUP_LIST_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>names_found</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>open_caps</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>parens_depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>parsed_pattern</name></name> <operator>=</operator> <name>stack_parsed_pattern</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>req_varyopt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>start_code</name></name> <operator>=</operator> <name>cworkspace</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>start_pattern</name></name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>start_workspace</name></name> <operator>=</operator> <name>cworkspace</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>workspace_size</name></name> <operator>=</operator> <name>COMPILE_WORK_SIZE</name></expr>;</expr_stmt>

<comment type="block">/* Maximum back reference and backref bitmap. The bitmap records up to 31 back
references to help in deciding whether (.*) can be treated as anchored or not.
*/</comment>

<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>top_backref</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>backref_map</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<comment type="block">/* Escape sequences \1 to \9 are always back references, but as they are only
two characters long, only two elements can be used in the parsed_pattern
vector. The first contains the reference, and we'd like to use the second to
record the offset in the pattern, so that forward references to non-existent
groups can be diagnosed later with an offset. However, on 64-bit systems,
PCRE2_SIZE won't fit. Instead, we have a vector of offsets for the first
occurrence of \1 to \9, indexed by the second parsed_pattern value. All other
references have enough space for the offset to be put into the parsed pattern.
*/</comment>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>cb</name><operator>.</operator><name>small_ref_offset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>PCRE2_UNSET</name></expr>;</expr_stmt></block_content></block></for>


<comment type="block">/* --------------- Start looking at the pattern --------------- */</comment>

<comment type="block">/* Unless PCRE2_LITERAL is set, check for global one-time option settings at
the start of the pattern, and remember the offset to the actual regex. With
valgrind support, make the terminator of a zero-terminated pattern
inaccessible. This catches bugs that would otherwise only show up for
non-zero-terminated patterns. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_VALGRIND</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>zero_terminated</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_NOACCESS</name><argument_list>(<argument><expr><name>pattern</name> <operator>+</operator> <name>patlen</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
<expr_stmt><expr><name>skipatstart</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_LITERAL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <while>while <condition>(<expr><name>patlen</name> <operator>-</operator> <name>skipatstart</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
         <name><name>ptr</name><index>[<expr><name>skipatstart</name></expr>]</index></name> <operator>==</operator> <name>CHAR_LEFT_PARENTHESIS</name> <operator>&amp;&amp;</operator>
         <name><name>ptr</name><index>[<expr><name>skipatstart</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_ASTERISK</name></expr>)</condition>
    <block>{<block_content>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pso_list</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>pso</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
      <decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>pp</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>pso</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>pso_list</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>patlen</name> <operator>-</operator> <name>skipatstart</name> <operator>-</operator> <literal type="number">2</literal> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>length</name></name> <operator>&amp;&amp;</operator>
          <call><call><name>PRIV</name><argument_list>(<argument><expr><name>strncmp_c8</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name>skipatstart</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator></expr></argument>,
            <argument><expr><name><name>p</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>skipatstart</name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>length</name></name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <switch>switch<condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
          <block>{<block_content>
          <case>case <expr><name>PSO_OPT</name></expr>:</case>
          <expr_stmt><expr><name><name>cb</name><operator>.</operator><name>external_options</name></name> <operator>|=</operator> <name><name>p</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PSO_FLG</name></expr>:</case>
          <expr_stmt><expr><name>setflags</name> <operator>|=</operator> <name><name>p</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PSO_NL</name></expr>:</case>
          <expr_stmt><expr><name>newline</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>setflags</name> <operator>|=</operator> <name>PCRE2_NL_SET</name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PSO_BSR</name></expr>:</case>
          <expr_stmt><expr><name>bsr</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>setflags</name> <operator>|=</operator> <name>PCRE2_BSR_SET</name></expr>;</expr_stmt>
          <break>break;</break>

          <case>case <expr><name>PSO_LIMM</name></expr>:</case>
          <case>case <expr><name>PSO_LIMD</name></expr>:</case>
          <case>case <expr><name>PSO_LIMH</name></expr>:</case>
          <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>pp</name> <operator>=</operator> <name>skipatstart</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_DIGIT</name><argument_list>(<argument><expr><name><name>ptr</name><index>[<expr><name>pp</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR60</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>pp</name></expr>;</expr_stmt>
            <goto>goto <name>HAD_EARLY_ERROR</name>;</goto>
            </block_content>}</block></if></if_stmt>
          <while>while <condition>(<expr><call><name>IS_DIGIT</name><argument_list>(<argument><expr><name><name>ptr</name><index>[<expr><name>pp</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <name>UINT32_MAX</name> <operator>/</operator> <literal type="number">10</literal> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>   <comment type="block">/* Integer overflow */</comment>
            <expr_stmt><expr><name>c</name> <operator>=</operator> <name>c</name><operator>*</operator><literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name><name>ptr</name><index>[<expr><name>pp</name><operator>++</operator></expr>]</index></name> <operator>-</operator> <name>CHAR_0</name><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
          <if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><name>pp</name><operator>++</operator></expr>]</index></name> <operator>!=</operator> <name>CHAR_RIGHT_PARENTHESIS</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR60</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>pp</name></expr>;</expr_stmt>
            <goto>goto <name>HAD_EARLY_ERROR</name>;</goto>
            </block_content>}</block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PSO_LIMH</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>limit_heap</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>PSO_LIMM</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>limit_match</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>limit_depth</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
          <expr_stmt><expr><name>skipatstart</name> <operator>+=</operator> <name>pp</name> <operator>-</operator> <name>skipatstart</name></expr>;</expr_stmt>
          <break>break;</break>
          </block_content>}</block></switch>
        <break>break;</break>   <comment type="block">/* Out of the table scan loop */</comment>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pso_list</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>pso</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>   <comment type="block">/* Out of pso loop */</comment>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* End of pattern-start options; advance to start of real regex. */</comment>

<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>skipatstart</name></expr>;</expr_stmt>

<comment type="block">/* Can't support UTF or UCP if PCRE2 was built without Unicode support. */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifndef>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cb</name><operator>.</operator><name>external_options</name></name> <operator>&amp;</operator> <operator>(</operator><name>PCRE2_UTF</name><operator>|</operator><name>PCRE2_UCP</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR32</name></expr>;</expr_stmt>
  <goto>goto <name>HAD_EARLY_ERROR</name>;</goto>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Check UTF. We have the original options in 'options', with that value as
modified by (*UTF) etc in cb-&gt;external_options. The extra option
PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES is not permitted in UTF-16 mode because the
surrogate code points cannot be represented in UTF-16. */</comment>

<expr_stmt><expr><name>utf</name> <operator>=</operator> <operator>(</operator><name><name>cb</name><operator>.</operator><name>external_options</name></name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NEVER_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR74</name></expr>;</expr_stmt>
    <goto>goto <name>HAD_EARLY_ERROR</name>;</goto>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_NO_UTF_CHECK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
       <operator>(</operator><name>errorcode</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>valid_utf</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>patlen</name></expr></argument>, <argument><expr><name>erroroffset</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <goto>goto <name>HAD_ERROR</name>;</goto></block_content></block></if></if_stmt>  <comment type="block">/* Offset was set by valid_utf() */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ccontext</name><operator>-&gt;</operator><name>extra_options</name></name> <operator>&amp;</operator> <name>PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR91</name></expr>;</expr_stmt>
    <goto>goto <name>HAD_EARLY_ERROR</name>;</goto>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Check UCP lockout. */</comment>

<expr_stmt><expr><name>ucp</name> <operator>=</operator> <operator>(</operator><name><name>cb</name><operator>.</operator><name>external_options</name></name> <operator>&amp;</operator> <name>PCRE2_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ucp</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cb</name><operator>.</operator><name>external_options</name></name> <operator>&amp;</operator> <name>PCRE2_NEVER_UCP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR75</name></expr>;</expr_stmt>
  <goto>goto <name>HAD_EARLY_ERROR</name>;</goto>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Process the BSR setting. */</comment>

<if_stmt><if>if <condition>(<expr><name>bsr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>bsr</name> <operator>=</operator> <name><name>ccontext</name><operator>-&gt;</operator><name>bsr_convention</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* Process the newline setting. */</comment>

<if_stmt><if>if <condition>(<expr><name>newline</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>newline</name> <operator>=</operator> <name><name>ccontext</name><operator>-&gt;</operator><name>newline_convention</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>nltype</name></name> <operator>=</operator> <name>NLTYPE_FIXED</name></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name>newline</name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><name>PCRE2_NEWLINE_CR</name></expr>:</case>
  <expr_stmt><expr><name><name>cb</name><operator>.</operator><name>nllen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>.</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_CR</name></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>PCRE2_NEWLINE_LF</name></expr>:</case>
  <expr_stmt><expr><name><name>cb</name><operator>.</operator><name>nllen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>.</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_NL</name></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>PCRE2_NEWLINE_NUL</name></expr>:</case>
  <expr_stmt><expr><name><name>cb</name><operator>.</operator><name>nllen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>.</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_NUL</name></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>PCRE2_NEWLINE_CRLF</name></expr>:</case>
  <expr_stmt><expr><name><name>cb</name><operator>.</operator><name>nllen</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>.</operator><name>nl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_CR</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>.</operator><name>nl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CHAR_NL</name></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>PCRE2_NEWLINE_ANY</name></expr>:</case>
  <expr_stmt><expr><name><name>cb</name><operator>.</operator><name>nltype</name></name> <operator>=</operator> <name>NLTYPE_ANY</name></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>PCRE2_NEWLINE_ANYCRLF</name></expr>:</case>
  <expr_stmt><expr><name><name>cb</name><operator>.</operator><name>nltype</name></name> <operator>=</operator> <name>NLTYPE_ANYCRLF</name></expr>;</expr_stmt>
  <break>break;</break>

  <default>default:</default>
  <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR56</name></expr>;</expr_stmt>
  <goto>goto <name>HAD_EARLY_ERROR</name>;</goto>
  </block_content>}</block></switch>

<comment type="block">/* Pre-scan the pattern to do two things: (1) Discover the named groups and
their numerical equivalents, so that this information is always available for
the remaining processing. (2) At the same time, parse the pattern and put a
processed version into the parsed_pattern vector. This has escapes interpreted
and comments removed (amongst other things).

In all but one case, when PCRE2_AUTO_CALLOUT is not set, the number of unsigned
32-bit ints in the parsed pattern is bounded by the length of the pattern plus
one (for the terminator) plus four if PCRE2_EXTRA_WORD or PCRE2_EXTRA_LINE is
set. The exceptional case is when running in 32-bit, non-UTF mode, when literal
characters greater than META_END (0x80000000) have to be coded as two units. In
this case, therefore, we scan the pattern to check for such values. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">32</literal></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>utf</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>p</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>ptr</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name><name>cb</name><operator>.</operator><name>end_pattern</name></name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>&gt;=</operator> <name>META_END</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>big32count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Ensure that the parsed pattern buffer is big enough. When PCRE2_AUTO_CALLOUT
is set we have to assume a numerical callout (4 elements) for each character
plus one at the end. This is overkill, but memory is plentiful these days. For
many smaller patterns the vector on the stack (which was set up above) can be
used. */</comment>

<expr_stmt><expr><name>parsed_size_needed</name> <operator>=</operator> <name>patlen</name> <operator>-</operator> <name>skipatstart</name> <operator>+</operator> <name>big32count</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ccontext</name><operator>-&gt;</operator><name>extra_options</name></name> <operator>&amp;</operator>
     <operator>(</operator><name>PCRE2_EXTRA_MATCH_WORD</name><operator>|</operator><name>PCRE2_EXTRA_MATCH_LINE</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>parsed_size_needed</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_AUTO_CALLOUT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>parsed_size_needed</name> <operator>=</operator> <operator>(</operator><name>parsed_size_needed</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">5</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>parsed_size_needed</name> <operator>&gt;=</operator> <name>PARSED_PATTERN_DEFAULT_SIZE</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>heap_parsed_pattern</name> <init>= <expr><call><name><name>ccontext</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>malloc</name></name><argument_list>(
    <argument><expr><operator>(</operator><name>parsed_size_needed</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>ccontext</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>heap_parsed_pattern</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>errorptr</name> <operator>=</operator> <name>ERR21</name></expr>;</expr_stmt>
    <goto>goto <name>EXIT</name>;</goto>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>cb</name><operator>.</operator><name>parsed_pattern</name></name> <operator>=</operator> <name>heap_parsed_pattern</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>parsed_pattern_end</name></name> <operator>=</operator> <name><name>cb</name><operator>.</operator><name>parsed_pattern</name></name> <operator>+</operator> <name>parsed_size_needed</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<comment type="block">/* Do the parsing scan. */</comment>

<expr_stmt><expr><name>errorcode</name> <operator>=</operator> <call><name>parse_regex</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>cb</name><operator>.</operator><name>external_options</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>has_lookbehind</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>errorcode</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>HAD_CB_ERROR</name>;</goto></block_content></block></if></if_stmt>

<comment type="block">/* Workspace is needed to remember information about numbered groups: whether a
group can match an empty string and what its fixed length is. This is done to
avoid the possibility of recursive references causing very long compile times
when checking these features. Unnumbered groups do not have this exposure since
they cannot be referenced. We use an indexed vector for this purpose. If there
are sufficiently few groups, the default vector on the stack, as set up above,
can be used. Otherwise we have to get/free a special vector. The vector must be
initialized to zero. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>.</operator><name>bracount</name></name> <operator>&gt;=</operator> <name>GROUPINFO_DEFAULT_SIZE</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>cb</name><operator>.</operator><name>groupinfo</name></name> <operator>=</operator> <call><name><name>ccontext</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>malloc</name></name><argument_list>(
    <argument><expr><operator>(</operator><name><name>cb</name><operator>.</operator><name>bracount</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>ccontext</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>.</operator><name>groupinfo</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR21</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cb</name><operator>.</operator><name>erroroffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <goto>goto <name>HAD_CB_ERROR</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>cb</name><operator>.</operator><name>groupinfo</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>cb</name><operator>.</operator><name>bracount</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* If there were any lookbehinds, scan the parsed pattern to figure out their
lengths. */</comment>

<if_stmt><if>if <condition>(<expr><name>has_lookbehind</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <call><name>check_lookbehinds</name><argument_list>(<argument><expr><name><name>cb</name><operator>.</operator><name>parsed_pattern</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>errorcode</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>HAD_CB_ERROR</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* For debugging, there is a function that shows the parsed data vector. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_SHOW_PARSED</name></cpp:ifdef>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"+++ Pre-scan complete:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>show_parsed</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* For debugging capturing information this code can be enabled. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_SHOW_CAPTURES</name></cpp:ifdef>
  <block>{<block_content>
  <decl_stmt><decl><type><name>named_group</name> <modifier>*</modifier></type><name>ng</name> <init>= <expr><name><name>cb</name><operator>.</operator><name>named_groups</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"+++Captures: %d\n"</literal></expr></argument>, <argument><expr><name><name>cb</name><operator>.</operator><name>bracount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cb</name><operator>.</operator><name>names_found</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ng</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"+++%3d %.*s\n"</literal></expr></argument>, <argument><expr><name><name>ng</name><operator>-&gt;</operator><name>number</name></name></expr></argument>, <argument><expr><name><name>ng</name><operator>-&gt;</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>ng</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Pretend to compile the pattern while actually just accumulating the amount
of memory required in the 'length' variable. This behaviour is triggered by
passing a non-NULL final argument to compile_regex(). We pass a block of
workspace (cworkspace) for it to compile parts of the pattern into; the
compiled code is discarded when it is no longer needed, so hopefully this
workspace will never overflow, though there is a test for its doing so.

On error, errorcode will be set non-zero, so we don't need to look at the
result of the function. The initial options have been put into the cb block,
but we still have to pass a separate options variable (the first argument)
because the options may change as the pattern is processed. */</comment>

<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>erroroffset</name></name> <operator>=</operator> <name>patlen</name></expr>;</expr_stmt>   <comment type="block">/* For any subsequent errors that do not set it */</comment>
<expr_stmt><expr><name>pptr</name> <operator>=</operator> <name><name>cb</name><operator>.</operator><name>parsed_pattern</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>code</name> <operator>=</operator> <name>cworkspace</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>code</name> <operator>=</operator> <name>OP_BRA</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>compile_regex</name><argument_list>(<argument><expr><name><name>cb</name><operator>.</operator><name>external_options</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>code</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>firstcu</name></expr></argument>,
   <argument><expr><operator>&amp;</operator><name>firstcuflags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reqcu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reqcuflags</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>errorcode</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>HAD_CB_ERROR</name>;</goto></block_content></block></if></if_stmt>  <comment type="block">/* Offset is in cb.erroroffset */</comment>

<comment type="block">/* This should be caught in compile_regex(), but just in case... */</comment>

<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <name>MAX_PATTERN_SIZE</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR20</name></expr>;</expr_stmt>
  <goto>goto <name>HAD_CB_ERROR</name>;</goto>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Compute the size of, and then get and initialize, the data block for storing
the compiled pattern and names table. Integer overflow should no longer be
possible because nowadays we limit the maximum value of cb.names_found and
cb.name_entry_size. */</comment>

<expr_stmt><expr><name>re_blocksize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pcre2_real_code</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
  <call><name>CU2BYTES</name><argument_list>(<argument><expr><name>length</name> <operator>+</operator>
  <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><name><name>cb</name><operator>.</operator><name>names_found</name></name> <operator>*</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><name><name>cb</name><operator>.</operator><name>name_entry_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>re</name> <operator>=</operator> <operator>(</operator><name>pcre2_real_code</name> <operator>*</operator><operator>)</operator>
  <call><name><name>ccontext</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>malloc</name></name><argument_list>(<argument><expr><name>re_blocksize</name></expr></argument>, <argument><expr><name><name>ccontext</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>re</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR21</name></expr>;</expr_stmt>
  <goto>goto <name>HAD_CB_ERROR</name>;</goto>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* The compiler may put padding at the end of the pcre2_real_code structure in
order to round it up to a multiple of 4 or 8 bytes. This means that when a
compiled pattern is copied (for example, when serialized) undefined bytes are
read, and this annoys debuggers such as valgrind. To avoid this, we explicitly
write to the last 8 bytes of the structure before setting the fields. */</comment>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>re</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pcre2_real_code</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>memctl</name></name> <operator>=</operator> <name><name>ccontext</name><operator>-&gt;</operator><name>memctl</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>tables</name></name> <operator>=</operator> <name>tables</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>executable_jit</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>start_bitmap</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">32</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>=</operator> <name>re_blocksize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>magic_number</name></name> <operator>=</operator> <name>MAGIC_NUMBER</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>compile_options</name></name> <operator>=</operator> <name>options</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>=</operator> <name><name>cb</name><operator>.</operator><name>external_options</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>extra_options</name></name> <operator>=</operator> <name><name>ccontext</name><operator>-&gt;</operator><name>extra_options</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>PCRE2_CODE_UNIT_WIDTH</name><operator>/</operator><literal type="number">8</literal> <operator>|</operator> <name><name>cb</name><operator>.</operator><name>external_flags</name></name> <operator>|</operator> <name>setflags</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>limit_heap</name></name> <operator>=</operator> <name>limit_heap</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>limit_match</name></name> <operator>=</operator> <name>limit_match</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>limit_depth</name></name> <operator>=</operator> <name>limit_depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>first_codeunit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>last_codeunit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>bsr_convention</name></name> <operator>=</operator> <name>bsr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>newline_convention</name></name> <operator>=</operator> <name>newline</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>max_lookbehind</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>minlength</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>top_bracket</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>top_backref</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>name_entry_size</name></name> <operator>=</operator> <name><name>cb</name><operator>.</operator><name>name_entry_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>name_count</name></name> <operator>=</operator> <name><name>cb</name><operator>.</operator><name>names_found</name></name></expr>;</expr_stmt>

<comment type="block">/* The basic block is immediately followed by the name table, and the compiled
code follows after that. */</comment>

<expr_stmt><expr><name>codestart</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SPTR</name><operator>)</operator><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>re</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pcre2_real_code</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>+</operator>
  <name><name>re</name><operator>-&gt;</operator><name>name_entry_size</name></name> <operator>*</operator> <name><name>re</name><operator>-&gt;</operator><name>name_count</name></name></expr>;</expr_stmt>

<comment type="block">/* Update the compile data block for the actual compile. The starting points of
the name/number translation table and of the code are passed around in the
compile data block. The start/end pattern and initial options are already set
from the pre-compile phase, as is the name_entry_size field. */</comment>

<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>parens_depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>assert_depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>lastcapture</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>name_table</name></name> <operator>=</operator> <operator>(</operator><name>PCRE2_UCHAR</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>re</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pcre2_real_code</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>start_code</name></name> <operator>=</operator> <name>codestart</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>req_varyopt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>had_accept</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>had_pruneorskip</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cb</name><operator>.</operator><name>open_caps</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<comment type="block">/* If any named groups were found, create the name/number table from the list
created in the pre-pass. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>.</operator><name>names_found</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>named_group</name> <modifier>*</modifier></type><name>ng</name> <init>= <expr><name><name>cb</name><operator>.</operator><name>named_groups</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cb</name><operator>.</operator><name>names_found</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>ng</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>add_name_to_table</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>, <argument><expr><name><name>ng</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>ng</name><operator>-&gt;</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>ng</name><operator>-&gt;</operator><name>number</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Set up a starting, non-extracting bracket, then compile the expression. On
error, errorcode will be set non-zero, so we don't need to look at the result
of the function here. */</comment>

<expr_stmt><expr><name>pptr</name> <operator>=</operator> <name><name>cb</name><operator>.</operator><name>parsed_pattern</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>code</name> <operator>=</operator> <operator>(</operator><name>PCRE2_UCHAR</name> <operator>*</operator><operator>)</operator><name>codestart</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>code</name> <operator>=</operator> <name>OP_BRA</name></expr>;</expr_stmt>
<expr_stmt><expr><name>regexrc</name> <operator>=</operator> <call><name>compile_regex</name><argument_list>(<argument><expr><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>code</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorcode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
  <argument><expr><operator>&amp;</operator><name>firstcu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>firstcuflags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reqcu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reqcuflags</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>regexrc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PCRE2_MATCH_EMPTY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>top_bracket</name></name> <operator>=</operator> <name><name>cb</name><operator>.</operator><name>bracount</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>top_backref</name></name> <operator>=</operator> <name><name>cb</name><operator>.</operator><name>top_backref</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>max_lookbehind</name></name> <operator>=</operator> <name><name>cb</name><operator>.</operator><name>max_lookbehind</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>.</operator><name>had_accept</name></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>reqcu</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                     <comment type="block">/* Must disable after (*ACCEPT) */</comment>
  <expr_stmt><expr><name>reqcuflags</name> <operator>=</operator> <name>REQ_NONE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PCRE2_HASACCEPT</name></expr>;</expr_stmt>  <comment type="block">/* Disables minimum length */</comment>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Fill in the final opcode and check for disastrous overflow. If no overflow,
but the estimated length exceeds the really used length, adjust the value of
re-&gt;blocksize, and if valgrind support is configured, mark the extra allocated
memory as unaddressable, so that any out-of-bound reads can be detected. */</comment>

<expr_stmt><expr><operator>*</operator><name>code</name><operator>++</operator> <operator>=</operator> <name>OP_END</name></expr>;</expr_stmt>
<expr_stmt><expr><name>usedlength</name> <operator>=</operator> <name>code</name> <operator>-</operator> <name>codestart</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>usedlength</name> <operator>&gt;</operator> <name>length</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR23</name></expr>;</expr_stmt></block_content></block></if> <else>else
  <block>{<block_content>
  <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>-=</operator> <call><name>CU2BYTES</name><argument_list>(<argument><expr><name>length</name> <operator>-</operator> <name>usedlength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_VALGRIND</name></cpp:ifdef>
  <expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_NOACCESS</name><argument_list>(<argument><expr><name>code</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><name>length</name> <operator>-</operator> <name>usedlength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></else></if_stmt>

<comment type="block">/* Scan the pattern for recursion/subroutine calls and convert the group
numbers into offsets. Maintain a small cache so that repeated groups containing
recursions are efficiently handled. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RSCAN_CACHE_SIZE</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<if_stmt><if>if <condition>(<expr><name>errorcode</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>cb</name><operator>.</operator><name>had_recurse</name></name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>rcode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>rgroup</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ccount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>start</name> <init>= <expr><name>RSCAN_CACHE_SIZE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>recurse_cache</name></type> <name><name>rc</name><index>[<expr><name>RSCAN_CACHE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>rcode</name> <operator>=</operator> <operator>(</operator><name>PCRE2_UCHAR</name> <operator>*</operator><operator>)</operator><call><name>find_recurse</name><argument_list>(<argument><expr><name>codestart</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>)</argument_list></call></expr>;</init>
       <condition><expr><name>rcode</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
       <incr><expr><name>rcode</name> <operator>=</operator> <operator>(</operator><name>PCRE2_UCHAR</name> <operator>*</operator><operator>)</operator><call><name>find_recurse</name><argument_list>(<argument><expr><name>rcode</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>LINK_SIZE</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>)</argument_list></call></expr></incr>)</control>
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>p</name></decl>, <decl><type ref="prev"/><name>groupnumber</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>groupnumber</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>GET</name><argument_list>(<argument><expr><name>rcode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>groupnumber</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rgroup</name> <operator>=</operator> <name>codestart</name></expr>;</expr_stmt></block_content></block></if> <else>else
      <block>{<block_content>
      <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>search_from</name> <init>= <expr><name>codestart</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>rgroup</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ccount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>p</name> <operator>=</operator> <operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">7</literal></expr></incr>)</control>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>groupnumber</name> <operator>==</operator> <name><name>rc</name><index>[<expr><name>p</name></expr>]</index></name><operator>.</operator><name>groupnumber</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>rgroup</name> <operator>=</operator> <name><name>rc</name><index>[<expr><name>p</name></expr>]</index></name><operator>.</operator><name>group</name></expr>;</expr_stmt>
          <break>break;</break>
          </block_content>}</block></if></if_stmt>

        <comment type="block">/* Group n+1 must always start to the right of group n, so we can save
        search time below when the new group number is greater than any of the
        previously found groups. */</comment>

        <if_stmt><if>if <condition>(<expr><name>groupnumber</name> <operator>&gt;</operator> <name><name>rc</name><index>[<expr><name>p</name></expr>]</index></name><operator>.</operator><name>groupnumber</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>search_from</name> <operator>=</operator> <name><name>rc</name><index>[<expr><name>p</name></expr>]</index></name><operator>.</operator><name>group</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

      <if_stmt><if>if <condition>(<expr><name>rgroup</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>rgroup</name> <operator>=</operator> <call><call><name>PRIV</name><argument_list>(<argument><expr><name>find_bracket</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>search_from</name></expr></argument>, <argument><expr><name>utf</name></expr></argument>, <argument><expr><name>groupnumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>rgroup</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR53</name></expr>;</expr_stmt>
          <break>break;</break>
          </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>--</operator><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>start</name> <operator>=</operator> <name>RSCAN_CACHE_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>rc</name><index>[<expr><name>start</name></expr>]</index></name><operator>.</operator><name>groupnumber</name> <operator>=</operator> <name>groupnumber</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rc</name><index>[<expr><name>start</name></expr>]</index></name><operator>.</operator><name>group</name> <operator>=</operator> <name>rgroup</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ccount</name> <operator>&lt;</operator> <name>RSCAN_CACHE_SIZE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ccount</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PUT</name><argument_list>(<argument><expr><name>rcode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>rgroup</name> <operator>-</operator> <name>codestart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* In rare debugging situations we sometimes need to look at the compiled code
at this stage. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CALL_PRINTINT</name></cpp:ifdef>
<expr_stmt><expr><call><name>pcre2_printint</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Length=%lu Used=%lu\n"</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>usedlength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Unless disabled, check whether any single character iterators can be
auto-possessified. The function overwrites the appropriate opcode values, so
the type of the pointer must be cast. NOTE: the intermediate variable "temp" is
used in this code because at least one compiler gives a warning about loss of
"const" attribute if the cast (PCRE2_UCHAR *)codestart is used directly in the
function call. */</comment>

<if_stmt><if>if <condition>(<expr><name>errorcode</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_NO_AUTO_POSSESS</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>PCRE2_UCHAR</name> <modifier>*</modifier></type><name>temp</name> <init>= <expr><operator>(</operator><name>PCRE2_UCHAR</name> <operator>*</operator><operator>)</operator><name>codestart</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><call><name>PRIV</name><argument_list>(<argument><expr><name>auto_possessify</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR80</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Failed to compile, or error while post-processing. */</comment>

<if_stmt><if>if <condition>(<expr><name>errorcode</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>HAD_CB_ERROR</name>;</goto></block_content></block></if></if_stmt>

<comment type="block">/* Successful compile. If the anchored option was not passed, set it if
we can determine that the pattern is anchored by virtue of ^ characters or \A
or anything else, such as starting with non-atomic .* when DOTALL is set and
there are no occurrences of *PRUNE or *SKIP (though there is an option to
disable this case). */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_ANCHORED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
     <call><name>is_anchored</name><argument_list>(<argument><expr><name>codestart</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>|=</operator> <name>PCRE2_ANCHORED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* Set up the first code unit or startline flag, the required code unit, and
then study the pattern. This code need not be obeyed if PCRE2_NO_START_OPTIMIZE
is set, as the data it would create will not be used. Note that a first code
unit (but not the startline flag) is useful for anchored patterns because it
can still give a quick "no match" and also avoid searching for a last code
unit. */</comment>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_NO_START_OPTIMIZE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>minminlength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* For minimal minlength from first/required CU */</comment>

  <comment type="block">/* If we do not have a first code unit, see if there is one that is asserted
  (these are not saved during the compile because they can cause conflicts with
  actual literals that follow). */</comment>

  <if_stmt><if>if <condition>(<expr><name>firstcuflags</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>firstcu</name> <operator>=</operator> <call><name>find_firstassertedcu</name><argument_list>(<argument><expr><name>codestart</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>firstcuflags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Save the data for a first code unit. The existence of one means the
  minimum length must be at least 1. */</comment>

  <if_stmt><if>if <condition>(<expr><name>firstcuflags</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>first_codeunit</name></name> <operator>=</operator> <name>firstcu</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PCRE2_FIRSTSET</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>minminlength</name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* Handle caseless first code units. */</comment>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>firstcuflags</name> <operator>&amp;</operator> <name>REQ_CASELESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>firstcu</name> <operator>&lt;</operator> <literal type="number">128</literal> <operator>||</operator> <operator>(</operator><operator>!</operator><name>utf</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>ucp</name> <operator>&amp;&amp;</operator> <name>firstcu</name> <operator>&lt;</operator> <literal type="number">255</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>.</operator><name>fcc</name><index>[<expr><name>firstcu</name></expr>]</index></name> <operator>!=</operator> <name>firstcu</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PCRE2_FIRSTCASELESS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>

      <comment type="block">/* The first code unit is &gt; 128 in UTF or UCP mode, or &gt; 255 otherwise.
      In 8-bit UTF mode, codepoints in the range 128-255 are introductory code
      points and cannot have another case, but if UCP is set they may do. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
      <if type="elseif">else if <condition>(<expr><name>ucp</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>utf</name> <operator>&amp;&amp;</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>firstcu</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>firstcu</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PCRE2_FIRSTCASELESS</name></expr>;</expr_stmt></block_content></block></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <if type="elseif">else if <condition>(<expr><operator>(</operator><name>utf</name> <operator>||</operator> <name>ucp</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>firstcu</name> <operator>&lt;=</operator> <name>MAX_UTF_CODE_POINT</name> <operator>&amp;&amp;</operator>
               <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>firstcu</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>firstcu</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PCRE2_FIRSTCASELESS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>

  <comment type="block">/* When there is no first code unit, for non-anchored patterns, see if we can
  set the PCRE2_STARTLINE flag. This is helpful for multiline matches when all
  branches start with ^ and also when all branches start with non-atomic .* for
  non-DOTALL matches when *PRUNE and SKIP are not present. (There is an option
  that disables this case.) */</comment>

  <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_ANCHORED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
           <call><name>is_startline</name><argument_list>(<argument><expr><name>codestart</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cb</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PCRE2_STARTLINE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Handle the "required code unit", if one is set. In the UTF case we can
  increment the minimum minimum length only if we are sure this really is a
  different character and not a non-starting code unit of the first character,
  because the minimum length count is in characters, not code units. */</comment>

  <if_stmt><if>if <condition>(<expr><name>reqcuflags</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">16</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>   <comment type="block">/* Not UTF */</comment>
        <name>firstcuflags</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>                         <comment type="block">/* First not set */</comment>
        <operator>(</operator><name>firstcu</name> <operator>&amp;</operator> <literal type="number">0xf800</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0xd800</literal> <operator>||</operator>             <comment type="block">/* First not surrogate */</comment>
        <operator>(</operator><name>reqcu</name> <operator>&amp;</operator> <literal type="number">0xfc00</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0xdc00</literal></expr>)</condition><block type="pseudo"><block_content>                 <comment type="block">/* Req not low surrogate */</comment>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:elif>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>   <comment type="block">/* Not UTF */</comment>
        <name>firstcuflags</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>                         <comment type="block">/* First not set */</comment>
        <operator>(</operator><name>firstcu</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>                    <comment type="block">/* First is ASCII */</comment>
        <operator>(</operator><name>reqcu</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>                        <comment type="block">/* Req is ASCII */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <block>{<block_content>
      <expr_stmt><expr><name>minminlength</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* In the case of an anchored pattern, set up the value only if it follows
    a variable length item in the pattern. */</comment>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>overall_options</name></name> <operator>&amp;</operator> <name>PCRE2_ANCHORED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
        <operator>(</operator><name>reqcuflags</name> <operator>&amp;</operator> <name>REQ_VARY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>last_codeunit</name></name> <operator>=</operator> <name>reqcu</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PCRE2_LASTSET</name></expr>;</expr_stmt>

      <comment type="block">/* Handle caseless required code units as for first code units (above). */</comment>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>reqcuflags</name> <operator>&amp;</operator> <name>REQ_CASELESS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>reqcu</name> <operator>&lt;</operator> <literal type="number">128</literal> <operator>||</operator> <operator>(</operator><operator>!</operator><name>utf</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>ucp</name> <operator>&amp;&amp;</operator> <name>reqcu</name> <operator>&lt;</operator> <literal type="number">255</literal><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>.</operator><name>fcc</name><index>[<expr><name>reqcu</name></expr>]</index></name> <operator>!=</operator> <name>reqcu</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PCRE2_LASTCASELESS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_UNICODE</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PCRE2_CODE_UNIT_WIDTH</name> <operator>==</operator> <literal type="number">8</literal></expr></cpp:if>
      <if type="elseif">else if <condition>(<expr><name>ucp</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>utf</name> <operator>&amp;&amp;</operator> <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>reqcu</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>reqcu</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PCRE2_LASTCASELESS</name></expr>;</expr_stmt></block_content></block></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <if type="elseif">else if <condition>(<expr><operator>(</operator><name>utf</name> <operator>||</operator> <name>ucp</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>reqcu</name> <operator>&lt;=</operator> <name>MAX_UTF_CODE_POINT</name> <operator>&amp;&amp;</operator>
               <call><name>UCD_OTHERCASE</name><argument_list>(<argument><expr><name>reqcu</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>reqcu</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>PCRE2_LASTCASELESS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_UNICODE */</comment>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Study the compiled pattern to set up information such as a bitmap of
  starting code units and a minimum matching length. */</comment>

  <if_stmt><if>if <condition>(<expr><call><call><name>PRIV</name><argument_list>(<argument><expr><name>study</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name>ERR31</name></expr>;</expr_stmt>
    <goto>goto <name>HAD_CB_ERROR</name>;</goto>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* If study() set a bitmap of starting code units, it implies a minimum
  length of at least one. */</comment>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>re</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PCRE2_FIRSTMAPSET</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>minminlength</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>minminlength</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* If the minimum length set (or not set) by study() is less than the minimum
  implied by required code units, override it. */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>re</name><operator>-&gt;</operator><name>minlength</name></name> <operator>&lt;</operator> <name>minminlength</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>re</name><operator>-&gt;</operator><name>minlength</name></name> <operator>=</operator> <name>minminlength</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>   <comment type="block">/* End of start-of-match optimizations. */</comment>

<comment type="block">/* Control ends up here in all cases. When running under valgrind, make a
pattern's terminating zero defined again. If memory was obtained for the parsed
version of the pattern, free it before returning. Also free the list of named
groups if a larger one had to be obtained, and likewise the group information
vector. */</comment>

<label><name>EXIT</name>:</label>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_VALGRIND</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>zero_terminated</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_DEFINED</name><argument_list>(<argument><expr><name>pattern</name> <operator>+</operator> <name>patlen</name></expr></argument>, <argument><expr><call><name>CU2BYTES</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>.</operator><name>parsed_pattern</name></name> <operator>!=</operator> <name>stack_parsed_pattern</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name><name>ccontext</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>free</name></name><argument_list>(<argument><expr><name><name>cb</name><operator>.</operator><name>parsed_pattern</name></name></expr></argument>, <argument><expr><name><name>ccontext</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>.</operator><name>named_group_list_size</name></name> <operator>&gt;</operator> <name>NAMED_GROUP_LIST_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name><name>ccontext</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>free</name></name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>cb</name><operator>.</operator><name>named_groups</name></name></expr></argument>, <argument><expr><name><name>ccontext</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cb</name><operator>.</operator><name>groupinfo</name></name> <operator>!=</operator> <name>stack_groupinfo</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name><name>ccontext</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>free</name></name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>cb</name><operator>.</operator><name>groupinfo</name></name></expr></argument>, <argument><expr><name><name>ccontext</name><operator>-&gt;</operator><name>memctl</name><operator>.</operator><name>memory_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>re</name></expr>;</return>    <comment type="block">/* Will be NULL after an error */</comment>

<comment type="block">/* Errors discovered in parse_regex() set the offset value in the compile
block. Errors discovered before it is called must compute it from the ptr
value. After parse_regex() is called, the offset in the compile block is set to
the end of the pattern, but certain errors in compile_regex() may reset it if
an offset is available in the parsed pattern. */</comment>

<label><name>HAD_CB_ERROR</name>:</label>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>pattern</name> <operator>+</operator> <name><name>cb</name><operator>.</operator><name>erroroffset</name></name></expr>;</expr_stmt>

<label><name>HAD_EARLY_ERROR</name>:</label>
<expr_stmt><expr><operator>*</operator><name>erroroffset</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <name>pattern</name></expr>;</expr_stmt>

<label><name>HAD_ERROR</name>:</label>
<expr_stmt><expr><operator>*</operator><name>errorptr</name> <operator>=</operator> <name>errorcode</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pcre2_code_free</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>re</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<goto>goto <name>EXIT</name>;</goto>
</block_content>}</block></function>

<comment type="block">/* End of pcre2_compile.c */</comment>
</unit>
