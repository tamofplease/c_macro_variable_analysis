<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/pcre2/src/pcre2demo.c"><comment type="block" format="doxygen">/*************************************************
*           PCRE2 DEMONSTRATION PROGRAM          *
*************************************************/</comment>

<comment type="block">/* This is a demonstration program to illustrate a straightforward way of
using the PCRE2 regular expression library from a C program. See the
pcre2sample documentation for a short discussion ("man pcre2sample" if you have
the PCRE2 man pages installed). PCRE2 is a revised API for the library, and is
incompatible with the original PCRE API.

There are actually three libraries, each supporting a different code unit
width. This demonstration program uses the 8-bit library. The default is to
process each code unit as a separate character, but if the pattern begins with
"(*UTF)", both it and the subject are treated as UTF-8 strings, where
characters may occupy multiple code units.

In Unix-like environments, if PCRE2 is installed in your standard system
libraries, you should be able to compile this program using this command:

cc -Wall pcre2demo.c -lpcre2-8 -o pcre2demo

If PCRE2 is not installed in a standard place, it is likely to be installed
with support for the pkg-config mechanism. If you have pkg-config, you can
compile this program using this command:

cc -Wall pcre2demo.c `pkg-config --cflags --libs libpcre2-8` -o pcre2demo

If you do not have pkg-config, you may have to use something like this:

cc -Wall pcre2demo.c -I/usr/local/include -L/usr/local/lib \
  -R/usr/local/lib -lpcre2-8 -o pcre2demo

Replace "/usr/local/include" and "/usr/local/lib" with wherever the include and
library files for PCRE2 are installed on your system. Only some operating
systems (Solaris is one) use the -R option.

Building under Windows:

If you want to statically link this program against a non-dll .a file, you must
define PCRE2_STATIC before including pcre2.h, so in this environment, uncomment
the following line. */</comment>

<comment type="block">/* #define PCRE2_STATIC */</comment>

<comment type="block">/* The PCRE2_CODE_UNIT_WIDTH macro must be defined before including pcre2.h.
For a program that uses only one code unit width, setting it to 8, 16, or 32
makes it possible to use generic function names such as pcre2_compile(). Note
that just changing 8 to 16 (for example) is not sufficient to convert this
program to process 16-bit characters. Even in a fully 16-bit environment, where
string-handling functions such as strcmp() and printf() work with 16-bit
characters, the code for handling the table of named substrings will still need
to be modified. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CODE_UNIT_WIDTH</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pcre2.h&gt;</cpp:file></cpp:include>


<comment type="block" format="doxygen">/**************************************************************************
* Here is the program. The API includes the concept of "contexts" for     *
* setting up unusual interface requirements for compiling and matching,   *
* such as custom memory managers and non-standard newline definitions.    *
* This program does not do any of this, so it makes no use of contexts,   *
* always passing NULL where a context could be given.                     *
**************************************************************************/</comment>

<function><type><name>int</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pcre2_code</name> <modifier>*</modifier></type><name>re</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>pattern</name></decl>;</decl_stmt>     <comment type="block">/* PCRE2_SPTR is a pointer to unsigned code units of */</comment>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>subject</name></decl>;</decl_stmt>     <comment type="block">/* the appropriate width (in this case, 8 bits). */</comment>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>name_table</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>crlf_is_newline</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>errornumber</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>find_all</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>utf8</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>option_bits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>namecount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>name_entry_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>newline</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>erroroffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>ovector</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>subject_length</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>pcre2_match_data</name> <modifier>*</modifier></type><name>match_data</name></decl>;</decl_stmt>


<comment type="block" format="doxygen">/**************************************************************************
* First, sort out the command line. There is only one possible option at  *
* the moment, "-g" to request repeated matching to find all occurrences,  *
* like Perl's /g option. We set the variable find_all to a non-zero value *
* if the -g option is present.                                            *
**************************************************************************/</comment>

<expr_stmt><expr><name>find_all</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-g"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>find_all</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Unrecognised option %s\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content> <break>break;</break></block_content></block></else></if_stmt>
  </block_content>}</block></for>

<comment type="block">/* After the options, we require exactly two arguments, which are the pattern,
and the subject string. */</comment>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>-</operator> <name>i</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Exactly two arguments required: a regex and a subject string\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Pattern and subject are char arguments, so they can be straightforwardly
cast to PCRE2_SPTR because we are working in 8-bit code units. The subject
length is cast to PCRE2_SIZE for completeness, though PCRE2_SIZE is in fact
defined to be size_t. */</comment>

<expr_stmt><expr><name>pattern</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SPTR</name><operator>)</operator><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>subject</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SPTR</name><operator>)</operator><name><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>subject_length</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>subject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block" format="doxygen">/*************************************************************************
* Now we are going to compile the regular expression pattern, and handle *
* any errors that are detected.                                          *
*************************************************************************/</comment>

<expr_stmt><expr><name>re</name> <operator>=</operator> <call><name>pcre2_compile</name><argument_list>(
  <argument><expr><name>pattern</name></expr></argument>,               <comment type="block">/* the pattern */</comment>
  <argument><expr><name>PCRE2_ZERO_TERMINATED</name></expr></argument>, <comment type="block">/* indicates pattern is zero-terminated */</comment>
  <argument><expr><literal type="number">0</literal></expr></argument>,                     <comment type="block">/* default options */</comment>
  <argument><expr><operator>&amp;</operator><name>errornumber</name></expr></argument>,          <comment type="block">/* for error number */</comment>
  <argument><expr><operator>&amp;</operator><name>erroroffset</name></expr></argument>,          <comment type="block">/* for error offset */</comment>
  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                 <comment type="block">/* use default compile context */</comment>

<comment type="block">/* Compilation failed: print the error message and exit. */</comment>

<if_stmt><if>if <condition>(<expr><name>re</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name><name>buffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>pcre2_get_error_message</name><argument_list>(<argument><expr><name>errornumber</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"PCRE2 compilation failed at offset %d: %s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>erroroffset</name></expr></argument>,
    <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>


<comment type="block" format="doxygen">/*************************************************************************
* If the compilation succeeded, we call PCRE2 again, in order to do a    *
* pattern match against the subject string. This does just ONE match. If *
* further matching is needed, it will be done below. Before running the  *
* match we must set up a match_data block for holding the result. Using  *
* pcre2_match_data_create_from_pattern() ensures that the block is       *
* exactly the right size for the number of capturing parentheses in the  *
* pattern. If you need to know the actual size of a match_data block as  *
* a number of bytes, you can find it like this:                          *
*                                                                        *
* PCRE2_SIZE match_data_size = pcre2_get_match_data_size(match_data);    *
*************************************************************************/</comment>

<expr_stmt><expr><name>match_data</name> <operator>=</operator> <call><name>pcre2_match_data_create_from_pattern</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Now run the match. */</comment>

<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pcre2_match</name><argument_list>(
  <argument><expr><name>re</name></expr></argument>,                   <comment type="block">/* the compiled pattern */</comment>
  <argument><expr><name>subject</name></expr></argument>,              <comment type="block">/* the subject string */</comment>
  <argument><expr><name>subject_length</name></expr></argument>,       <comment type="block">/* the length of the subject */</comment>
  <argument><expr><literal type="number">0</literal></expr></argument>,                    <comment type="block">/* start at offset 0 in the subject */</comment>
  <argument><expr><literal type="number">0</literal></expr></argument>,                    <comment type="block">/* default options */</comment>
  <argument><expr><name>match_data</name></expr></argument>,           <comment type="block">/* block for storing the result */</comment>
  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                <comment type="block">/* use default match context */</comment>

<comment type="block">/* Matching failed: handle error cases */</comment>

<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <switch>switch<condition>(<expr><name>rc</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>PCRE2_ERROR_NOMATCH</name></expr>:</case> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"No match\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <comment type="block">/*
    Handle other special cases if you like
    */</comment>
    <default>default:</default> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Matching error %d\n"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    </block_content>}</block></switch>
  <expr_stmt><expr><call><name>pcre2_match_data_free</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Release memory used for the match */</comment>
  <expr_stmt><expr><call><name>pcre2_code_free</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                 <comment type="block">/*   data and the compiled pattern. */</comment>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Match succeded. Get a pointer to the output vector, where string offsets are
stored. */</comment>

<expr_stmt><expr><name>ovector</name> <operator>=</operator> <call><name>pcre2_get_ovector_pointer</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Match succeeded at offset %d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block" format="doxygen">/*************************************************************************
* We have found the first match within the subject string. If the output *
* vector wasn't big enough, say so. Then output any substrings that were *
* captured.                                                              *
*************************************************************************/</comment>

<comment type="block">/* The output vector wasn't big enough. This should not happen, because we used
pcre2_match_data_create_from_pattern() above. */</comment>

<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ovector was not big enough for all the captured substrings\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* We must guard against patterns such as /(?=.\K)/ that use \K in an assertion
to set the start of a match later than its end. In this demonstration program,
we just detect this case and give up. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\\K was used in an assertion to set the match start after its end.\n"</literal>
    <literal type="string">"From end to start the match was: %.*s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>,
      <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>subject</name> <operator>+</operator> <name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Run abandoned\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pcre2_match_data_free</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pcre2_code_free</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Show substrings stored in the output vector by number. Obviously, in a real
application you might want to do things other than print them. */</comment>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>rc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>substring_start</name> <init>= <expr><name>subject</name> <operator>+</operator> <name><name>ovector</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>substring_length</name> <init>= <expr><name><name>ovector</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>ovector</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%2d: %.*s\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>substring_length</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>substring_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>


<comment type="block" format="doxygen">/**************************************************************************
* That concludes the basic part of this demonstration program. We have    *
* compiled a pattern, and performed a single match. The code that follows *
* shows first how to access named substrings, and then how to code for    *
* repeated matches on the same subject.                                   *
**************************************************************************/</comment>

<comment type="block">/* See if there are any named substrings, and if so, show them by name. First
we have to extract the count of named parentheses from the pattern. */</comment>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcre2_pattern_info</name><argument_list>(
  <argument><expr><name>re</name></expr></argument>,                   <comment type="block">/* the compiled pattern */</comment>
  <argument><expr><name>PCRE2_INFO_NAMECOUNT</name></expr></argument>, <comment type="block">/* get the number of named substrings */</comment>
  <argument><expr><operator>&amp;</operator><name>namecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>          <comment type="block">/* where to put the answer */</comment>

<if_stmt><if>if <condition>(<expr><name>namecount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"No named substrings\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <else>else
  <block>{<block_content>
  <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>tabptr</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Named substrings\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Before we can access the substrings, we must extract the table for
  translating names to numbers, and the size of each entry in the table. */</comment>

  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcre2_pattern_info</name><argument_list>(
    <argument><expr><name>re</name></expr></argument>,                       <comment type="block">/* the compiled pattern */</comment>
    <argument><expr><name>PCRE2_INFO_NAMETABLE</name></expr></argument>,     <comment type="block">/* address of the table */</comment>
    <argument><expr><operator>&amp;</operator><name>name_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>             <comment type="block">/* where to put the answer */</comment>

  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcre2_pattern_info</name><argument_list>(
    <argument><expr><name>re</name></expr></argument>,                       <comment type="block">/* the compiled pattern */</comment>
    <argument><expr><name>PCRE2_INFO_NAMEENTRYSIZE</name></expr></argument>, <comment type="block">/* size of each entry in the table */</comment>
    <argument><expr><operator>&amp;</operator><name>name_entry_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* where to put the answer */</comment>

  <comment type="block">/* Now we can scan the table and, for each entry, print the number, the name,
  and the substring itself. In the 8-bit library the number is held in two
  bytes, most significant first. */</comment>

  <expr_stmt><expr><name>tabptr</name> <operator>=</operator> <name>name_table</name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>namecount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><name><name>tabptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name><name>tabptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"(%d) %*s: %.*s\n"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>name_entry_size</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>tabptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>,
      <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>ovector</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>n</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>ovector</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>n</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>subject</name> <operator>+</operator> <name><name>ovector</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tabptr</name> <operator>+=</operator> <name>name_entry_size</name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>


<comment type="block" format="doxygen">/*************************************************************************
* If the "-g" option was given on the command line, we want to continue  *
* to search for additional matches in the subject string, in a similar   *
* way to the /g option in Perl. This turns out to be trickier than you   *
* might think because of the possibility of matching an empty string.    *
* What happens is as follows:                                            *
*                                                                        *
* If the previous match was NOT for an empty string, we can just start   *
* the next match at the end of the previous one.                         *
*                                                                        *
* If the previous match WAS for an empty string, we can't do that, as it *
* would lead to an infinite loop. Instead, a call of pcre2_match() is    *
* made with the PCRE2_NOTEMPTY_ATSTART and PCRE2_ANCHORED flags set. The *
* first of these tells PCRE2 that an empty string at the start of the    *
* subject is not a valid match; other possibilities must be tried. The   *
* second flag restricts PCRE2 to one match attempt at the initial string *
* position. If this match succeeds, an alternative to the empty string   *
* match has been found, and we can print it and proceed round the loop,  *
* advancing by the length of whatever was found. If this match does not  *
* succeed, we still stay in the loop, advancing by just one character.   *
* In UTF-8 mode, which can be set by (*UTF) in the pattern, this may be  *
* more than one byte.                                                    *
*                                                                        *
* However, there is a complication concerned with newlines. When the     *
* newline convention is such that CRLF is a valid newline, we must       *
* advance by two characters rather than one. The newline convention can  *
* be set in the regex by (*CR), etc.; if not, we must find the default.  *
*************************************************************************/</comment>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>find_all</name></expr>)</condition>     <comment type="block">/* Check for -g */</comment>
  <block>{<block_content>
  <expr_stmt><expr><call><name>pcre2_match_data_free</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* Release the memory that was used */</comment>
  <expr_stmt><expr><call><name>pcre2_code_free</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                <comment type="block">/* for the match data and the pattern. */</comment>
  <return>return <expr><literal type="number">0</literal></expr>;</return>                           <comment type="block">/* Exit the program. */</comment>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Before running the loop, check for UTF-8 and whether CRLF is a valid newline
sequence. First, find the options with which the regex was compiled and extract
the UTF state. */</comment>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcre2_pattern_info</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>PCRE2_INFO_ALLOPTIONS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>option_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>utf8</name> <operator>=</operator> <operator>(</operator><name>option_bits</name> <operator>&amp;</operator> <name>PCRE2_UTF</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<comment type="block">/* Now find the newline convention and see whether CRLF is a valid newline
sequence. */</comment>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcre2_pattern_info</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>PCRE2_INFO_NEWLINE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>crlf_is_newline</name> <operator>=</operator> <name>newline</name> <operator>==</operator> <name>PCRE2_NEWLINE_ANY</name> <operator>||</operator>
                  <name>newline</name> <operator>==</operator> <name>PCRE2_NEWLINE_CRLF</name> <operator>||</operator>
                  <name>newline</name> <operator>==</operator> <name>PCRE2_NEWLINE_ANYCRLF</name></expr>;</expr_stmt>

<comment type="block">/* Loop for second and subsequent matches */</comment>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>options</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>                   <comment type="block">/* Normally no options */</comment>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>start_offset</name> <init>= <expr><name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* Start at end of previous match */</comment>

  <comment type="block">/* If the previous match was for an empty string, we are finished if we are
  at the end of the subject. Otherwise, arrange to run another match at the
  same point to see if a non-empty match can be found. */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>subject_length</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>options</name> <operator>=</operator> <name>PCRE2_NOTEMPTY_ATSTART</name> <operator>|</operator> <name>PCRE2_ANCHORED</name></expr>;</expr_stmt>
    </block_content>}</block></if>

  <comment type="block">/* If the previous match was not an empty string, there is one tricky case to
  consider. If a pattern contains \K within a lookbehind assertion at the
  start, the end of the matched string can be at the offset where the match
  started. Without special action, this leads to a loop that keeps on matching
  the same substring. We must detect this case and arrange to move the start on
  by one character. The pcre2_get_startchar() function returns the starting
  offset that was passed to pcre2_match(). */</comment>

  <else>else
    <block>{<block_content>
    <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>startchar</name> <init>= <expr><call><name>pcre2_get_startchar</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>start_offset</name> <operator>&lt;=</operator> <name>startchar</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>startchar</name> <operator>&gt;=</operator> <name>subject_length</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>   <comment type="block">/* Reached end of subject.   */</comment>
      <expr_stmt><expr><name>start_offset</name> <operator>=</operator> <name>startchar</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>             <comment type="block">/* Advance by one character. */</comment>
      <if_stmt><if>if <condition>(<expr><name>utf8</name></expr>)</condition>                                 <comment type="block">/* If UTF-8, it may be more  */</comment>
        <block>{<block_content>                                       <comment type="block">/*   than one code unit.     */</comment>
        <for>for <control>(<init>;</init> <condition><expr><name>start_offset</name> <operator>&lt;</operator> <name>subject_length</name></expr>;</condition> <incr><expr><name>start_offset</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
          <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>subject</name><index>[<expr><name>start_offset</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

  <comment type="block">/* Run the next matching operation */</comment>

  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pcre2_match</name><argument_list>(
    <argument><expr><name>re</name></expr></argument>,                   <comment type="block">/* the compiled pattern */</comment>
    <argument><expr><name>subject</name></expr></argument>,              <comment type="block">/* the subject string */</comment>
    <argument><expr><name>subject_length</name></expr></argument>,       <comment type="block">/* the length of the subject */</comment>
    <argument><expr><name>start_offset</name></expr></argument>,         <comment type="block">/* starting offset in the subject */</comment>
    <argument><expr><name>options</name></expr></argument>,              <comment type="block">/* options */</comment>
    <argument><expr><name>match_data</name></expr></argument>,           <comment type="block">/* block for storing the result */</comment>
    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                <comment type="block">/* use default match context */</comment>

  <comment type="block">/* This time, a result of NOMATCH isn't an error. If the value in "options"
  is zero, it just means we have found all possible matches, so the loop ends.
  Otherwise, it means we have failed to find a non-empty-string match at a
  point where there was a previous empty-string match. In this case, we do what
  Perl does: advance the matching position by one character, and continue. We
  do this by setting the "end of previous match" offset, because that is picked
  up at the top of the loop as the point at which to start again.

  There are two complications: (a) When CRLF is a valid newline sequence, and
  the current position is just before it, advance by an extra byte. (b)
  Otherwise we must ensure that we skip an entire UTF character if we are in
  UTF mode. */</comment>

  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>PCRE2_ERROR_NOMATCH</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>options</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>                    <comment type="block">/* All matches found */</comment>
    <expr_stmt><expr><name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>start_offset</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>              <comment type="block">/* Advance one code unit */</comment>
    <if_stmt><if>if <condition>(<expr><name>crlf_is_newline</name> <operator>&amp;&amp;</operator>                      <comment type="block">/* If CRLF is a newline &amp; */</comment>
        <name>start_offset</name> <operator>&lt;</operator> <name>subject_length</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>    <comment type="block">/* we are at CRLF, */</comment>
        <name><name>subject</name><index>[<expr><name>start_offset</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal> <operator>&amp;&amp;</operator>
        <name><name>subject</name><index>[<expr><name>start_offset</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>                          <comment type="block">/* Advance by one more. */</comment>
    <if type="elseif">else if <condition>(<expr><name>utf8</name></expr>)</condition>                              <comment type="block">/* Otherwise, ensure we */</comment>
      <block>{<block_content>                                         <comment type="block">/* advance a whole UTF-8 */</comment>
      <while>while <condition>(<expr><name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name>subject_length</name></expr>)</condition>       <comment type="block">/* character. */</comment>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>subject</name><index>[<expr><name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></while>
      </block_content>}</block></if></if_stmt>
    <continue>continue;</continue>    <comment type="block">/* Go round the loop again */</comment>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Other matching errors are not recoverable. */</comment>

  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Matching error %d\n"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcre2_match_data_free</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcre2_code_free</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Match succeded */</comment>

  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nMatch succeeded again at offset %d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The match succeeded, but the output vector wasn't big enough. This
  should not happen. */</comment>

  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ovector was not big enough for all the captured substrings\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* We must guard against patterns such as /(?=.\K)/ that use \K in an
  assertion to set the start of a match later than its end. In this
  demonstration program, we just detect this case and give up. */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\\K was used in an assertion to set the match start after its end.\n"</literal>
      <literal type="string">"From end to start the match was: %.*s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>ovector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>,
        <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>subject</name> <operator>+</operator> <name><name>ovector</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Run abandoned\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcre2_match_data_free</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcre2_code_free</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* As before, show substrings stored in the output vector by number, and then
  also any named substrings. */</comment>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>rc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
    <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>substring_start</name> <init>= <expr><name>subject</name> <operator>+</operator> <name><name>ovector</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>substring_length</name> <init>= <expr><name><name>ovector</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>ovector</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%2d: %.*s\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>substring_length</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>substring_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><name>namecount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"No named substrings\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <else>else
    <block>{<block_content>
    <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>tabptr</name> <init>= <expr><name>name_table</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Named substrings\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>namecount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><name><name>tabptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name><name>tabptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"(%d) %*s: %.*s\n"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>name_entry_size</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>tabptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>,
        <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>ovector</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>n</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>ovector</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>n</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>subject</name> <operator>+</operator> <name><name>ovector</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tabptr</name> <operator>+=</operator> <name>name_entry_size</name></expr>;</expr_stmt>
      </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>      <comment type="block">/* End of loop to find second and subsequent matches */</comment>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pcre2_match_data_free</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pcre2_code_free</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* End of pcre2demo.c */</comment>
</unit>
