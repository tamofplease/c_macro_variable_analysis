<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/MaxScale/pcre2/src/pcre2grep.c"><comment type="block" format="doxygen">/*************************************************
*               pcre2grep program                *
*************************************************/</comment>

<comment type="block">/* This is a grep program that uses the 8-bit PCRE regular expression library
via the PCRE2 updated API to do its pattern matching. On Unix-like, Windows,
and native z/OS systems it can recurse into directories, and in z/OS it can
handle PDS files.

Note that for native z/OS, in addition to defining the NATIVE_ZOS macro, an
additional header is required. That header is not included in the main PCRE2
distribution because other apparatus is needed to compile pcre2grep for z/OS.
The header can be found in the special z/OS distribution, which is available
from www.zaconsultants.net or from www.cbttape.org.

           Copyright (c) 1997-2020 University of Cambridge

-----------------------------------------------------------------------------
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

    * Neither the name of the University of Cambridge nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-----------------------------------------------------------------------------
*/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;locale.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>_WIN32</name> <operator>||</operator> <operator>(</operator><name>defined</name> <name>HAVE_WINDOWS_H</name> <operator>&amp;&amp;</operator> <name>HAVE_WINDOWS_H</name><operator>)</operator><operator>)</operator> \
  <operator>&amp;&amp;</operator> <operator>!</operator><name>defined</name> <name>WIN32</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN32</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Some cmake's define it still */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>WIN32</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> clidef</cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> descrip</cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> lib$routines</cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>                <comment type="block">/* For _setmode() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>             <comment type="block">/* For _O_BINARY */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUPPORT_PCRE2GREP_CALLOUT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SUPPORT_PCRE2GREP_CALLOUT_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;process.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNISTD_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_LIBZ</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;zlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_LIBBZ2</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;bzlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PCRE2_CODE_UNIT_WIDTH</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre2.h"</cpp:file></cpp:include>

<comment type="block">/* Older versions of MSVC lack snprintf(). This define allows for
warning/error-free compilation and testing with MSVC compilers back to at least
MSVC 10/2010. Except for VC6 (which is missing some fundamentals and fails). */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>_MSC_VER</name> <operator>&lt;</operator> <literal type="number">1900</literal><operator>)</operator></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>snprintf</name></cpp:macro> <cpp:value>_snprintf</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* VC and older compilers don't support %td or %zu, and even some that claim to
be C99 don't support it (hence DISABLE_PERCENT_ZT). */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__STDC_VERSION__</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>__STDC_VERSION__</name> <operator>&lt;</operator> <literal type="number">199901L</literal> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>DISABLE_PERCENT_ZT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PTR_FORM</name></cpp:macro> <cpp:value>"lu"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZ_FORM</name></cpp:macro> <cpp:value>"lu"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZ_CAST</name></cpp:macro> <cpp:value>(unsigned long int)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PTR_FORM</name></cpp:macro> <cpp:value>"td"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZ_FORM</name></cpp:macro> <cpp:value>"zu"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZ_CAST</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FALSE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRUE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<typedef>typedef <type><name>int</name></type> <name>BOOL</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_CAPTURE_MAX</name></cpp:macro> <cpp:value>50</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BUFSIZ</name> <operator>&gt;</operator> <literal type="number">8192</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXPATLEN</name></cpp:macro> <cpp:value>BUFSIZ</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXPATLEN</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FNBUFSIZ</name></cpp:macro> <cpp:value>2048</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRBUFSIZ</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>

<comment type="block">/* Values for the "filenames" variable, which specifies options for file name
output. The order is important; it is assumed that a file name is wanted for
all values greater than FN_DEFAULT. */</comment>

<enum>enum <block>{ <decl><name>FN_NONE</name></decl>, <decl><name>FN_DEFAULT</name></decl>, <decl><name>FN_MATCH_ONLY</name></decl>, <decl><name>FN_NOMATCH_ONLY</name></decl>, <decl><name>FN_FORCE</name></decl> }</block>;</enum>

<comment type="block">/* File reading styles */</comment>

<enum>enum <block>{ <decl><name>FR_PLAIN</name></decl>, <decl><name>FR_LIBZ</name></decl>, <decl><name>FR_LIBBZ2</name></decl> }</block>;</enum>

<comment type="block">/* Actions for the -d and -D options */</comment>

<enum>enum <block>{ <decl><name>dee_READ</name></decl>, <decl><name>dee_SKIP</name></decl>, <decl><name>dee_RECURSE</name></decl> }</block>;</enum>
<enum>enum <block>{ <decl><name>DEE_READ</name></decl>, <decl><name>DEE_SKIP</name></decl> }</block>;</enum>

<comment type="block">/* Actions for special processing options (flag bits) */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PO_WORD_MATCH</name></cpp:macro>     <cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PO_LINE_MATCH</name></cpp:macro>     <cpp:value>0x0002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PO_FIXED_STRINGS</name></cpp:macro>  <cpp:value>0x0004</cpp:value></cpp:define>

<comment type="block">/* Binary file options */</comment>

<enum>enum <block>{ <decl><name>BIN_BINARY</name></decl>, <decl><name>BIN_NOMATCH</name></decl>, <decl><name>BIN_TEXT</name></decl> }</block>;</enum>

<comment type="block">/* Return values from decode_dollar_escape() */</comment>

<enum>enum <block>{ <decl><name>DDE_ERROR</name></decl>, <decl><name>DDE_CAPTURE</name></decl>, <decl><name>DDE_CHAR</name></decl> }</block>;</enum>

<comment type="block">/* In newer versions of gcc, with FORTIFY_SOURCE set (the default in some
environments), a warning is issued if the value of fwrite() is ignored.
Unfortunately, casting to (void) does not suppress the warning. To get round
this, we use a macro that compiles a fudge. Oddly, this does not also seem to
apply to fprintf(). */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FWRITE_IGNORE</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (fwrite(a,b,c,d)) {}</cpp:value></cpp:define>

<comment type="block">/* Under Windows, we have to set stdout to be binary, so that it does not
convert \r\n at the ends of output lines to \r\r\n. However, that means that
any messages written to stdout must have \r\n as their line terminator. This is
handled by using STDOUT_NL as the newline string. We also use a normal double
quote for the example, as single quotes aren't usually available. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STDOUT_NL</name></cpp:macro>     <cpp:value>"\r\n"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STDOUT_NL_LEN</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUOT</name></cpp:macro>          <cpp:value>"\""</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STDOUT_NL</name></cpp:macro>      <cpp:value>"\n"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STDOUT_NL_LEN</name></cpp:macro>  <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUOT</name></cpp:macro>           <cpp:value>"'"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* This code is returned from decode_dollar_escape() when $n is encountered,
and used to mean "output STDOUT_NL". It is, of course, not a valid Unicode code
point. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STDOUT_NL_CODE</name></cpp:macro> <cpp:value>0x7fffffffu</cpp:value></cpp:define>



<comment type="block" format="doxygen">/*************************************************
*               Global variables                 *
*************************************************/</comment>

<comment type="block">/* Jeffrey Friedl has some debugging requirements that are not part of the
regular code. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JFRIEDL_DEBUG</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>S_arg</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>jfriedl_XR</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* repeat regex attempt this many times */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>jfriedl_XT</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* replicate text this many times */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>jfriedl_prefix</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>jfriedl_postfix</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colour_string</name> <init>= <expr><literal type="string">"1;31"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colour_option</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dee_option</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>DEE_option</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>locale</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newline_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>om_separator</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stdin_name</name> <init>= <expr><literal type="string">"(standard input)"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>output_text</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>main_buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>after_context</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>before_context</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>binary_files</name> <init>= <expr><name>BIN_BINARY</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>both_context</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>bufthird</name> <init>= <expr><name>PCRE2GREP_BUFSIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>max_bufthird</name> <init>= <expr><name>PCRE2GREP_MAX_BUFSIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>bufsize</name> <init>= <expr><literal type="number">3</literal><operator>*</operator><name>PCRE2GREP_BUFSIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>endlinetype</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>count_limit</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Not long, so that it works with OP_NUMBER */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name> <name>int</name></type> <name>counts_printed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name> <name>int</name></type> <name>total_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>dee_action</name> <init>= <expr><name>dee_SKIP</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>dee_action</name> <init>= <expr><name>dee_READ</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>DEE_action</name> <init>= <expr><name>DEE_READ</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>error_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>filenames</name> <init>= <expr><name>FN_DEFAULT</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2GREP_JIT</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>use_jit</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>use_jit</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>character_tables</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>pcre2_options</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>extra_options</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PCRE2_SIZE</name></type> <name>heap_limit</name> <init>= <expr><name>PCRE2_UNSET</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>match_limit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>depth_limit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_compile_context</name> <modifier>*</modifier></type><name>compile_context</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_match_context</name> <modifier>*</modifier></type><name>match_context</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pcre2_match_data</name> <modifier>*</modifier></type><name>match_data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>offsets</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>offset_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>capture_max</name> <init>= <expr><name>DEFAULT_CAPTURE_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>count_only</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>do_colour</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>do_ansi</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>file_offsets</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>hyphenpending</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>invert</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>line_buffered</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>line_offsets</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>multiline</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>number</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>omit_zero_count</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>resource_error</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>quiet</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>show_total_count</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>silent</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BOOL</name></type> <name>utf</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>uint8_t</name></type> <name><name>utf8_buffer</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>


<comment type="block">/* Structure for list of --only-matching capturing numbers. */</comment>

<typedef>typedef <type><struct>struct <name>omstr</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>omstr</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>groupnum</name></decl>;</decl_stmt>
}</block></struct></type> <name>omstr</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>omstr</name> <modifier>*</modifier></type><name>only_matching</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>omstr</name> <modifier>*</modifier></type><name>only_matching_last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>only_matching_count</name></decl>;</decl_stmt>

<comment type="block">/* Structure for holding the two variables that describe a number chain. */</comment>

<typedef>typedef <type><struct>struct <name>omdatastr</name> <block>{
  <decl_stmt><decl><type><name>omstr</name> <modifier>*</modifier><modifier>*</modifier></type><name>anchor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>omstr</name> <modifier>*</modifier><modifier>*</modifier></type><name>lastptr</name></decl>;</decl_stmt>
}</block></struct></type> <name>omdatastr</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>omdatastr</name></type> <name>only_matching_data</name> <init>= <expr><block>{ <expr><operator>&amp;</operator><name>only_matching</name></expr>, <expr><operator>&amp;</operator><name>only_matching_last</name></expr> }</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Structure for list of file names (for -f and --{in,ex}clude-from) */</comment>

<typedef>typedef <type><struct>struct <name>fnstr</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>fnstr</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
}</block></struct></type> <name>fnstr</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>fnstr</name> <modifier>*</modifier></type><name>exclude_from</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>fnstr</name> <modifier>*</modifier></type><name>exclude_from_last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>fnstr</name> <modifier>*</modifier></type><name>include_from</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>fnstr</name> <modifier>*</modifier></type><name>include_from_last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>fnstr</name> <modifier>*</modifier></type><name>file_lists</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>fnstr</name> <modifier>*</modifier></type><name>file_lists_last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>fnstr</name> <modifier>*</modifier></type><name>pattern_files</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>fnstr</name> <modifier>*</modifier></type><name>pattern_files_last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Structure for holding the two variables that describe a file name chain. */</comment>

<typedef>typedef <type><struct>struct <name>fndatastr</name> <block>{
  <decl_stmt><decl><type><name>fnstr</name> <modifier>*</modifier><modifier>*</modifier></type><name>anchor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fnstr</name> <modifier>*</modifier><modifier>*</modifier></type><name>lastptr</name></decl>;</decl_stmt>
}</block></struct></type> <name>fndatastr</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>fndatastr</name></type> <name>exclude_from_data</name> <init>= <expr><block>{ <expr><operator>&amp;</operator><name>exclude_from</name></expr>, <expr><operator>&amp;</operator><name>exclude_from_last</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>fndatastr</name></type> <name>include_from_data</name> <init>= <expr><block>{ <expr><operator>&amp;</operator><name>include_from</name></expr>, <expr><operator>&amp;</operator><name>include_from_last</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>fndatastr</name></type> <name>file_lists_data</name> <init>= <expr><block>{ <expr><operator>&amp;</operator><name>file_lists</name></expr>, <expr><operator>&amp;</operator><name>file_lists_last</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>fndatastr</name></type> <name>pattern_files_data</name> <init>= <expr><block>{ <expr><operator>&amp;</operator><name>pattern_files</name></expr>, <expr><operator>&amp;</operator><name>pattern_files_last</name></expr> }</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Structure for pattern and its compiled form; used for matching patterns and
also for include/exclude patterns. */</comment>

<typedef>typedef <type><struct>struct <name>patstr</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>patstr</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>length</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>pcre2_code</name> <modifier>*</modifier></type><name>compiled</name></decl>;</decl_stmt>
}</block></struct></type> <name>patstr</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>patstr</name> <modifier>*</modifier></type><name>patterns</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>patstr</name> <modifier>*</modifier></type><name>patterns_last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>patstr</name> <modifier>*</modifier></type><name>include_patterns</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>patstr</name> <modifier>*</modifier></type><name>include_patterns_last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>patstr</name> <modifier>*</modifier></type><name>exclude_patterns</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>patstr</name> <modifier>*</modifier></type><name>exclude_patterns_last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>patstr</name> <modifier>*</modifier></type><name>include_dir_patterns</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>patstr</name> <modifier>*</modifier></type><name>include_dir_patterns_last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>patstr</name> <modifier>*</modifier></type><name>exclude_dir_patterns</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>patstr</name> <modifier>*</modifier></type><name>exclude_dir_patterns_last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Structure holding the two variables that describe a pattern chain. A pointer
to such structures is used for each appropriate option. */</comment>

<typedef>typedef <type><struct>struct <name>patdatastr</name> <block>{
  <decl_stmt><decl><type><name>patstr</name> <modifier>*</modifier><modifier>*</modifier></type><name>anchor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>patstr</name> <modifier>*</modifier><modifier>*</modifier></type><name>lastptr</name></decl>;</decl_stmt>
}</block></struct></type> <name>patdatastr</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>patdatastr</name></type> <name>match_patdata</name> <init>= <expr><block>{ <expr><operator>&amp;</operator><name>patterns</name></expr>, <expr><operator>&amp;</operator><name>patterns_last</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>patdatastr</name></type> <name>include_patdata</name> <init>= <expr><block>{ <expr><operator>&amp;</operator><name>include_patterns</name></expr>, <expr><operator>&amp;</operator><name>include_patterns_last</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>patdatastr</name></type> <name>exclude_patdata</name> <init>= <expr><block>{ <expr><operator>&amp;</operator><name>exclude_patterns</name></expr>, <expr><operator>&amp;</operator><name>exclude_patterns_last</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>patdatastr</name></type> <name>include_dir_patdata</name> <init>= <expr><block>{ <expr><operator>&amp;</operator><name>include_dir_patterns</name></expr>, <expr><operator>&amp;</operator><name>include_dir_patterns_last</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>patdatastr</name></type> <name>exclude_dir_patdata</name> <init>= <expr><block>{ <expr><operator>&amp;</operator><name>exclude_dir_patterns</name></expr>, <expr><operator>&amp;</operator><name>exclude_dir_patterns_last</name></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>patstr</name> <modifier>*</modifier><modifier>*</modifier></type><name><name>incexlist</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{ <expr><operator>&amp;</operator><name>include_patterns</name></expr>, <expr><operator>&amp;</operator><name>exclude_patterns</name></expr>,
                                 <expr><operator>&amp;</operator><name>include_dir_patterns</name></expr>, <expr><operator>&amp;</operator><name>exclude_dir_patterns</name></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>incexname</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="string">"--include"</literal></expr>, <expr><literal type="string">"--exclude"</literal></expr>,
                                    <expr><literal type="string">"--include-dir"</literal></expr>, <expr><literal type="string">"--exclude-dir"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Structure for options and list of them */</comment>

<enum>enum <block>{ <decl><name>OP_NODATA</name></decl>, <decl><name>OP_STRING</name></decl>, <decl><name>OP_OP_STRING</name></decl>, <decl><name>OP_NUMBER</name></decl>, <decl><name>OP_U32NUMBER</name></decl>, <decl><name>OP_SIZE</name></decl>,
       <decl><name>OP_OP_NUMBER</name></decl>, <decl><name>OP_OP_NUMBERS</name></decl>, <decl><name>OP_PATLIST</name></decl>, <decl><name>OP_FILELIST</name></decl>, <decl><name>OP_BINFILES</name></decl> }</block>;</enum>

<typedef>typedef <type><struct>struct <name>option_item</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>one_char</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>dataptr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>long_name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>help_text</name></decl>;</decl_stmt>
}</block></struct></type> <name>option_item</name>;</typedef>

<comment type="block">/* Options without a single-letter equivalent get a negative value. This can be
used to identify them. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_COLOUR</name></cpp:macro>       <cpp:value>(-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_EXCLUDE</name></cpp:macro>      <cpp:value>(-2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_EXCLUDE_DIR</name></cpp:macro>  <cpp:value>(-3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_HELP</name></cpp:macro>         <cpp:value>(-4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_INCLUDE</name></cpp:macro>      <cpp:value>(-5)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_INCLUDE_DIR</name></cpp:macro>  <cpp:value>(-6)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_LABEL</name></cpp:macro>        <cpp:value>(-7)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_LOCALE</name></cpp:macro>       <cpp:value>(-8)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_NULL</name></cpp:macro>         <cpp:value>(-9)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_LOFFSETS</name></cpp:macro>     <cpp:value>(-10)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_FOFFSETS</name></cpp:macro>     <cpp:value>(-11)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_LBUFFER</name></cpp:macro>      <cpp:value>(-12)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_H_LIMIT</name></cpp:macro>      <cpp:value>(-13)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_M_LIMIT</name></cpp:macro>      <cpp:value>(-14)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_M_LIMIT_DEP</name></cpp:macro>  <cpp:value>(-15)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_BUFSIZE</name></cpp:macro>      <cpp:value>(-16)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_NOJIT</name></cpp:macro>        <cpp:value>(-17)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_FILE_LIST</name></cpp:macro>    <cpp:value>(-18)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_BINARY_FILES</name></cpp:macro> <cpp:value>(-19)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_EXCLUDE_FROM</name></cpp:macro> <cpp:value>(-20)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_INCLUDE_FROM</name></cpp:macro> <cpp:value>(-21)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_OM_SEPARATOR</name></cpp:macro> <cpp:value>(-22)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_MAX_BUFSIZE</name></cpp:macro>  <cpp:value>(-23)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_OM_CAPTURE</name></cpp:macro>   <cpp:value>(-24)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>option_item</name></type> <name><name>optionlist</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,     <expr><name>N_NULL</name></expr>,   <expr><name>NULL</name></expr>,              <expr><literal type="string">""</literal></expr>,              <expr><literal type="string">"terminate options"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,     <expr><name>N_HELP</name></expr>,   <expr><name>NULL</name></expr>,              <expr><literal type="string">"help"</literal></expr>,          <expr><literal type="string">"display this help and exit"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NUMBER</name></expr>,     <expr><literal type="char">'A'</literal></expr>,      <expr><operator>&amp;</operator><name>after_context</name></expr>,    <expr><literal type="string">"after-context=number"</literal></expr>, <expr><literal type="string">"set number of following context lines"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,     <expr><literal type="char">'a'</literal></expr>,      <expr><name>NULL</name></expr>,              <expr><literal type="string">"text"</literal></expr>,          <expr><literal type="string">"treat binary files as text"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NUMBER</name></expr>,     <expr><literal type="char">'B'</literal></expr>,      <expr><operator>&amp;</operator><name>before_context</name></expr>,   <expr><literal type="string">"before-context=number"</literal></expr>, <expr><literal type="string">"set number of prior context lines"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_BINFILES</name></expr>,   <expr><name>N_BINARY_FILES</name></expr>, <expr><name>NULL</name></expr>,        <expr><literal type="string">"binary-files=word"</literal></expr>, <expr><literal type="string">"set treatment of binary files"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NUMBER</name></expr>,     <expr><name>N_BUFSIZE</name></expr>,<expr><operator>&amp;</operator><name>bufthird</name></expr>,         <expr><literal type="string">"buffer-size=number"</literal></expr>, <expr><literal type="string">"set processing buffer starting size"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NUMBER</name></expr>,     <expr><name>N_MAX_BUFSIZE</name></expr>,<expr><operator>&amp;</operator><name>max_bufthird</name></expr>, <expr><literal type="string">"max-buffer-size=number"</literal></expr>,  <expr><literal type="string">"set processing buffer maximum size"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_OP_STRING</name></expr>,  <expr><name>N_COLOUR</name></expr>, <expr><operator>&amp;</operator><name>colour_option</name></expr>,    <expr><literal type="string">"color=option"</literal></expr>,  <expr><literal type="string">"matched text color option"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_OP_STRING</name></expr>,  <expr><name>N_COLOUR</name></expr>, <expr><operator>&amp;</operator><name>colour_option</name></expr>,    <expr><literal type="string">"colour=option"</literal></expr>, <expr><literal type="string">"matched text colour option"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NUMBER</name></expr>,     <expr><literal type="char">'C'</literal></expr>,      <expr><operator>&amp;</operator><name>both_context</name></expr>,     <expr><literal type="string">"context=number"</literal></expr>, <expr><literal type="string">"set number of context lines, before &amp; after"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,     <expr><literal type="char">'c'</literal></expr>,      <expr><name>NULL</name></expr>,              <expr><literal type="string">"count"</literal></expr>,         <expr><literal type="string">"print only a count of matching lines per FILE"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_STRING</name></expr>,     <expr><literal type="char">'D'</literal></expr>,      <expr><operator>&amp;</operator><name>DEE_option</name></expr>,       <expr><literal type="string">"devices=action"</literal></expr>,<expr><literal type="string">"how to handle devices, FIFOs, and sockets"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_STRING</name></expr>,     <expr><literal type="char">'d'</literal></expr>,      <expr><operator>&amp;</operator><name>dee_option</name></expr>,       <expr><literal type="string">"directories=action"</literal></expr>, <expr><literal type="string">"how to handle directories"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_PATLIST</name></expr>,    <expr><literal type="char">'e'</literal></expr>,      <expr><operator>&amp;</operator><name>match_patdata</name></expr>,    <expr><literal type="string">"regex(p)=pattern"</literal></expr>, <expr><literal type="string">"specify pattern (may be used more than once)"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,     <expr><literal type="char">'F'</literal></expr>,      <expr><name>NULL</name></expr>,              <expr><literal type="string">"fixed-strings"</literal></expr>, <expr><literal type="string">"patterns are sets of newline-separated strings"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_FILELIST</name></expr>,   <expr><literal type="char">'f'</literal></expr>,      <expr><operator>&amp;</operator><name>pattern_files_data</name></expr>, <expr><literal type="string">"file=path"</literal></expr>,   <expr><literal type="string">"read patterns from file"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_FILELIST</name></expr>,   <expr><name>N_FILE_LIST</name></expr>, <expr><operator>&amp;</operator><name>file_lists_data</name></expr>, <expr><literal type="string">"file-list=path"</literal></expr>,<expr><literal type="string">"read files to search from file"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,     <expr><name>N_FOFFSETS</name></expr>, <expr><name>NULL</name></expr>,            <expr><literal type="string">"file-offsets"</literal></expr>,  <expr><literal type="string">"output file offsets, not text"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,     <expr><literal type="char">'H'</literal></expr>,      <expr><name>NULL</name></expr>,              <expr><literal type="string">"with-filename"</literal></expr>, <expr><literal type="string">"force the prefixing filename on output"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,     <expr><literal type="char">'h'</literal></expr>,      <expr><name>NULL</name></expr>,              <expr><literal type="string">"no-filename"</literal></expr>,   <expr><literal type="string">"suppress the prefixing filename on output"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,     <expr><literal type="char">'I'</literal></expr>,      <expr><name>NULL</name></expr>,              <expr><literal type="string">""</literal></expr>,              <expr><literal type="string">"treat binary files as not matching (ignore)"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,     <expr><literal type="char">'i'</literal></expr>,      <expr><name>NULL</name></expr>,              <expr><literal type="string">"ignore-case"</literal></expr>,   <expr><literal type="string">"ignore case distinctions"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,     <expr><literal type="char">'l'</literal></expr>,      <expr><name>NULL</name></expr>,              <expr><literal type="string">"files-with-matches"</literal></expr>, <expr><literal type="string">"print only FILE names containing matches"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,     <expr><literal type="char">'L'</literal></expr>,      <expr><name>NULL</name></expr>,              <expr><literal type="string">"files-without-match"</literal></expr>,<expr><literal type="string">"print only FILE names not containing matches"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_STRING</name></expr>,     <expr><name>N_LABEL</name></expr>,  <expr><operator>&amp;</operator><name>stdin_name</name></expr>,       <expr><literal type="string">"label=name"</literal></expr>,    <expr><literal type="string">"set name for standard input"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,     <expr><name>N_LBUFFER</name></expr>, <expr><name>NULL</name></expr>,             <expr><literal type="string">"line-buffered"</literal></expr>, <expr><literal type="string">"use line buffering"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,     <expr><name>N_LOFFSETS</name></expr>, <expr><name>NULL</name></expr>,            <expr><literal type="string">"line-offsets"</literal></expr>,  <expr><literal type="string">"output line numbers and offsets, not text"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_STRING</name></expr>,     <expr><name>N_LOCALE</name></expr>, <expr><operator>&amp;</operator><name>locale</name></expr>,           <expr><literal type="string">"locale=locale"</literal></expr>, <expr><literal type="string">"use the named locale"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_SIZE</name></expr>,       <expr><name>N_H_LIMIT</name></expr>, <expr><operator>&amp;</operator><name>heap_limit</name></expr>,      <expr><literal type="string">"heap-limit=number"</literal></expr>,  <expr><literal type="string">"set PCRE2 heap limit option (kibibytes)"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_U32NUMBER</name></expr>,  <expr><name>N_M_LIMIT</name></expr>, <expr><operator>&amp;</operator><name>match_limit</name></expr>,     <expr><literal type="string">"match-limit=number"</literal></expr>, <expr><literal type="string">"set PCRE2 match limit option"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_U32NUMBER</name></expr>,  <expr><name>N_M_LIMIT_DEP</name></expr>, <expr><operator>&amp;</operator><name>depth_limit</name></expr>, <expr><literal type="string">"depth-limit=number"</literal></expr>, <expr><literal type="string">"set PCRE2 depth limit option"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_U32NUMBER</name></expr>,  <expr><name>N_M_LIMIT_DEP</name></expr>, <expr><operator>&amp;</operator><name>depth_limit</name></expr>, <expr><literal type="string">"recursion-limit=number"</literal></expr>, <expr><literal type="string">"obsolete synonym for depth-limit"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,     <expr><literal type="char">'M'</literal></expr>,      <expr><name>NULL</name></expr>,              <expr><literal type="string">"multiline"</literal></expr>,     <expr><literal type="string">"run in multiline mode"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NUMBER</name></expr>,     <expr><literal type="char">'m'</literal></expr>,      <expr><operator>&amp;</operator><name>count_limit</name></expr>,      <expr><literal type="string">"max-count=number"</literal></expr>, <expr><literal type="string">"stop after &lt;number&gt; matched lines"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_STRING</name></expr>,     <expr><literal type="char">'N'</literal></expr>,      <expr><operator>&amp;</operator><name>newline_arg</name></expr>,      <expr><literal type="string">"newline=type"</literal></expr>,  <expr><literal type="string">"set newline type (CR, LF, CRLF, ANYCRLF, ANY, or NUL)"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,     <expr><literal type="char">'n'</literal></expr>,      <expr><name>NULL</name></expr>,              <expr><literal type="string">"line-number"</literal></expr>,   <expr><literal type="string">"print line number with output lines"</literal></expr> }</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2GREP_JIT</name></cpp:ifdef>
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,     <expr><name>N_NOJIT</name></expr>,  <expr><name>NULL</name></expr>,              <expr><literal type="string">"no-jit"</literal></expr>,        <expr><literal type="string">"do not use just-in-time compiler optimization"</literal></expr> }</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,     <expr><name>N_NOJIT</name></expr>,  <expr><name>NULL</name></expr>,              <expr><literal type="string">"no-jit"</literal></expr>,        <expr><literal type="string">"ignored: this pcre2grep does not support JIT"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><block>{ <expr><name>OP_STRING</name></expr>,     <expr><literal type="char">'O'</literal></expr>,      <expr><operator>&amp;</operator><name>output_text</name></expr>,       <expr><literal type="string">"output=text"</literal></expr>,   <expr><literal type="string">"show only this text (possibly expanded)"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_OP_NUMBERS</name></expr>, <expr><literal type="char">'o'</literal></expr>,      <expr><operator>&amp;</operator><name>only_matching_data</name></expr>, <expr><literal type="string">"only-matching=n"</literal></expr>, <expr><literal type="string">"show only the part of the line that matched"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_STRING</name></expr>,     <expr><name>N_OM_SEPARATOR</name></expr>, <expr><operator>&amp;</operator><name>om_separator</name></expr>, <expr><literal type="string">"om-separator=text"</literal></expr>, <expr><literal type="string">"set separator for multiple -o output"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_U32NUMBER</name></expr>,  <expr><name>N_OM_CAPTURE</name></expr>, <expr><operator>&amp;</operator><name>capture_max</name></expr>,  <expr><literal type="string">"om-capture=n"</literal></expr>,  <expr><literal type="string">"set capture count for --only-matching"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,     <expr><literal type="char">'q'</literal></expr>,      <expr><name>NULL</name></expr>,              <expr><literal type="string">"quiet"</literal></expr>,         <expr><literal type="string">"suppress output, just set return code"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,     <expr><literal type="char">'r'</literal></expr>,      <expr><name>NULL</name></expr>,              <expr><literal type="string">"recursive"</literal></expr>,     <expr><literal type="string">"recursively scan sub-directories"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_PATLIST</name></expr>,    <expr><name>N_EXCLUDE</name></expr>,<expr><operator>&amp;</operator><name>exclude_patdata</name></expr>,  <expr><literal type="string">"exclude=pattern"</literal></expr>,<expr><literal type="string">"exclude matching files when recursing"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_PATLIST</name></expr>,    <expr><name>N_INCLUDE</name></expr>,<expr><operator>&amp;</operator><name>include_patdata</name></expr>,  <expr><literal type="string">"include=pattern"</literal></expr>,<expr><literal type="string">"include matching files when recursing"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_PATLIST</name></expr>,    <expr><name>N_EXCLUDE_DIR</name></expr>,<expr><operator>&amp;</operator><name>exclude_dir_patdata</name></expr>, <expr><literal type="string">"exclude-dir=pattern"</literal></expr>,<expr><literal type="string">"exclude matching directories when recursing"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_PATLIST</name></expr>,    <expr><name>N_INCLUDE_DIR</name></expr>,<expr><operator>&amp;</operator><name>include_dir_patdata</name></expr>, <expr><literal type="string">"include-dir=pattern"</literal></expr>,<expr><literal type="string">"include matching directories when recursing"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_FILELIST</name></expr>,   <expr><name>N_EXCLUDE_FROM</name></expr>,<expr><operator>&amp;</operator><name>exclude_from_data</name></expr>, <expr><literal type="string">"exclude-from=path"</literal></expr>, <expr><literal type="string">"read exclude list from file"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_FILELIST</name></expr>,   <expr><name>N_INCLUDE_FROM</name></expr>,<expr><operator>&amp;</operator><name>include_from_data</name></expr>, <expr><literal type="string">"include-from=path"</literal></expr>, <expr><literal type="string">"read include list from file"</literal></expr> }</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JFRIEDL_DEBUG</name></cpp:ifdef>
  <expr><block>{ <expr><name>OP_OP_NUMBER</name></expr>, <expr><literal type="char">'S'</literal></expr>,      <expr><operator>&amp;</operator><name>S_arg</name></expr>,            <expr><literal type="string">"jeffS"</literal></expr>,         <expr><literal type="string">"replace matched (sub)string with X"</literal></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,    <expr><literal type="char">'s'</literal></expr>,      <expr><name>NULL</name></expr>,              <expr><literal type="string">"no-messages"</literal></expr>,   <expr><literal type="string">"suppress error messages"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,    <expr><literal type="char">'t'</literal></expr>,      <expr><name>NULL</name></expr>,              <expr><literal type="string">"total-count"</literal></expr>,   <expr><literal type="string">"print total count of matching lines"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,    <expr><literal type="char">'u'</literal></expr>,      <expr><name>NULL</name></expr>,              <expr><literal type="string">"utf"</literal></expr>,           <expr><literal type="string">"use UTF mode"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,    <expr><literal type="char">'U'</literal></expr>,      <expr><name>NULL</name></expr>,              <expr><literal type="string">"utf-allow-invalid"</literal></expr>, <expr><literal type="string">"use UTF mode, allow for invalid code units"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,    <expr><literal type="char">'V'</literal></expr>,      <expr><name>NULL</name></expr>,              <expr><literal type="string">"version"</literal></expr>,       <expr><literal type="string">"print version information and exit"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,    <expr><literal type="char">'v'</literal></expr>,      <expr><name>NULL</name></expr>,              <expr><literal type="string">"invert-match"</literal></expr>,  <expr><literal type="string">"select non-matching lines"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,    <expr><literal type="char">'w'</literal></expr>,      <expr><name>NULL</name></expr>,              <expr><literal type="string">"word-regex(p)"</literal></expr>, <expr><literal type="string">"force patterns to match only as words"</literal></expr>  }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,    <expr><literal type="char">'x'</literal></expr>,      <expr><name>NULL</name></expr>,              <expr><literal type="string">"line-regex(p)"</literal></expr>, <expr><literal type="string">"force patterns to match only whole lines"</literal></expr> }</block></expr>,
  <expr><block>{ <expr><name>OP_NODATA</name></expr>,    <expr><literal type="number">0</literal></expr>,        <expr><name>NULL</name></expr>,               <expr><name>NULL</name></expr>,            <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Table of names for newline types. Must be kept in step with the definitions
of PCRE2_NEWLINE_xx in pcre2.h. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>newlines</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="string">"DEFAULT"</literal></expr>, <expr><literal type="string">"CR"</literal></expr>, <expr><literal type="string">"LF"</literal></expr>, <expr><literal type="string">"CRLF"</literal></expr>, <expr><literal type="string">"ANY"</literal></expr>, <expr><literal type="string">"ANYCRLF"</literal></expr>, <expr><literal type="string">"NUL"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* UTF-8 tables  */</comment>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>utf8_table1</name><index>[]</index></name> <init>=
  <expr><block>{ <expr><literal type="number">0x7f</literal></expr>, <expr><literal type="number">0x7ff</literal></expr>, <expr><literal type="number">0xffff</literal></expr>, <expr><literal type="number">0x1fffff</literal></expr>, <expr><literal type="number">0x3ffffff</literal></expr>, <expr><literal type="number">0x7fffffff</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>utf8_table1_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>utf8_table1</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>utf8_table2</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>,    <expr><literal type="number">0xc0</literal></expr>, <expr><literal type="number">0xe0</literal></expr>, <expr><literal type="number">0xf0</literal></expr>, <expr><literal type="number">0xf8</literal></expr>, <expr><literal type="number">0xfc</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>utf8_table3</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">0xff</literal></expr>, <expr><literal type="number">0x1f</literal></expr>, <expr><literal type="number">0x0f</literal></expr>, <expr><literal type="number">0x07</literal></expr>, <expr><literal type="number">0x03</literal></expr>, <expr><literal type="number">0x01</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>utf8_table4</name><index>[]</index></name> <init>= <expr><block>{
  <expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,
  <expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">1</literal></expr>,
  <expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>,
  <expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr> }</block></expr></init></decl>;</decl_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>VPCOMPAT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MEMMOVE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block" format="doxygen">/*************************************************
*    Emulated memmove() for systems without it   *
*************************************************/</comment>

<comment type="block">/* This function can make use of bcopy() if it is available. Otherwise do it by
steam, as there are some non-Unix environments that lack both memmove() and
bcopy(). */</comment>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>emulated_memmove</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BCOPY</name></cpp:ifdef>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>d</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>dest</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>d</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>s</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dest</name> <operator>&gt;</operator> <name>src</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>dest</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>src</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>--</operator><name>dest</name><operator>)</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>--</operator><name>src</name><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
  <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>dest</name></expr>;</return>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>dest</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>src</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
  <return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>dest</name> <operator>-</operator> <name>n</name><operator>)</operator></expr>;</return>
  </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* not HAVE_BCOPY */</comment>
</block_content>}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>memmove</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>memmove</name><parameter_list>(<parameter><type><name>d</name></type></parameter>,<parameter><type><name>s</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>emulated_memmove(d,s,n)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* not VPCOMPAT &amp;&amp; not HAVE_MEMMOVE */</comment>



<comment type="block" format="doxygen">/*************************************************
*           Convert code point to UTF-8          *
*************************************************/</comment>

<comment type="block">/* A static buffer is used. Returns the number of bytes. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>ord2utf8</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>utf8bytes</name> <init>= <expr><name>utf8_buffer</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>utf8_table1_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
  <if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>utf8_table1</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
<expr_stmt><expr><name>utf8bytes</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>utf8bytes</name><operator>--</operator> <operator>=</operator> <literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>value</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>value</name> <operator>&gt;&gt;=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
  </block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>utf8bytes</name> <operator>=</operator> <name><name>utf8_table2</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|</operator> <name>value</name></expr>;</expr_stmt>
<return>return <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*         Case-independent string compare        *
*************************************************/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>strcmpic</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c1</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>*</operator><name>str1</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><name>str2</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>c1</name> <operator>=</operator> <call><name>tolower</name><argument_list>(<argument><expr><operator>*</operator><name>str1</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>tolower</name><argument_list>(<argument><expr><operator>*</operator><name>str2</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>c1</name> <operator>!=</operator> <name>c2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>(</operator><operator>(</operator><name>c1</name> <operator>&gt;</operator> <name>c2</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></while>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*         Parse GREP_COLORS                      *
*************************************************/</comment>

<comment type="block">/* Extract ms or mt from GREP_COLORS.

Argument:  the string, possibly NULL
Returns:   the value of ms or mt, or NULL if neither present
*/</comment>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>parse_grep_colors</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>seq</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>len</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>gc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><literal type="string">"ms="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>col</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><literal type="string">"mt="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>col</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>col</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>col</name> <operator>!=</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>col</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>len</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>seq</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>col</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name><name>seq</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>seq</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*         Exit from the program                  *
*************************************************/</comment>

<comment type="block">/* If there has been a resource error, give a suitable message.

Argument:  the return code
Returns:   does not return
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pcre2grep_exit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* VMS does exit codes differently: both exit(1) and exit(0) return with a
status of 1, which is not helpful. To help with this problem, define a symbol
(akin to an environment variable) called "PCRE2GREP_RC" and put the exit code
therein. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__VMS</name></cpp:ifdef>
  <decl_stmt><decl><type><name>char</name></type> <name><name>val_buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>$DESCRIPTOR</name><argument_list>(<argument><expr><name>sym_nam</name></expr></argument>, <argument><expr><literal type="string">"PCRE2GREP_RC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>$DESCRIPTOR</name><argument_list>(<argument><expr><name>sym_val</name></expr></argument>, <argument><expr><name>val_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>val_buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>sym_val</name><operator>.</operator><name>dsc$w_length</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>val_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lib$set_symbol</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sym_nam</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>resource_error</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Error %d, %d, %d or %d means that a resource "</literal>
    <literal type="string">"limit was exceeded.\n"</literal></expr></argument>, <argument><expr><name>PCRE2_ERROR_JIT_STACKLIMIT</name></expr></argument>, <argument><expr><name>PCRE2_ERROR_MATCHLIMIT</name></expr></argument>,
    <argument><expr><name>PCRE2_ERROR_DEPTHLIMIT</name></expr></argument>, <argument><expr><name>PCRE2_ERROR_HEAPLIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Check your regex for nested unlimited loops.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*          Add item to chain of patterns         *
*************************************************/</comment>

<comment type="block">/* Used to add an item onto a chain, or just return an unconnected item if the
"after" argument is NULL.

Arguments:
  s          pattern string to add
  patlen     length of pattern
  after      if not NULL points to item to insert after

Returns:     new pattern block or NULL on error
*/</comment>

<function><type><specifier>static</specifier> <name>patstr</name> <modifier>*</modifier></type>
<name>add_pattern</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>patlen</name></decl></parameter>, <parameter><decl><type><name>patstr</name> <modifier>*</modifier></type><name>after</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>patstr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>patstr</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>patstr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: malloc failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pcre2grep_exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>patlen</name> <operator>&gt;</operator> <name>MAXPATLEN</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: pattern is too long (limit is %d bytes)\n"</literal></expr></argument>,
    <argument><expr><name>MAXPATLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>string</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <name>patlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>compiled</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>after</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>after</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>after</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*           Free chain of patterns               *
*************************************************/</comment>

<comment type="block">/* Used for several chains of patterns.

Argument: pointer to start of chain
Returns:  nothing
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_pattern_chain</name><parameter_list>(<parameter><decl><type><name>patstr</name> <modifier>*</modifier></type><name>pc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><name>pc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>patstr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>pc</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>pc</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>compiled</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pcre2_code_free</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>compiled</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*           Free chain of file names             *
*************************************************/</comment>

<comment type="block">/*
Argument: pointer to start of chain
Returns:  nothing
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_file_chain</name><parameter_list>(<parameter><decl><type><name>fnstr</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><name>fn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>fnstr</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name>fn</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>fn</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*            OS-specific functions               *
*************************************************/</comment>

<comment type="block">/* These definitions are needed in all Windows environments, even those where
Unix-style directory scanning can be used (see below). */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>STRICT</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>STRICT</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32_LEAN_AND_MEAN</name></cpp:ifndef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>WIN32_LEAN_AND_MEAN</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>iswild</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(strpbrk(name, "*?") != NULL)</cpp:value></cpp:define>

<comment type="block">/* Convert ANSI BGR format to RGB used by Windows */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BGR_RGB</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x &amp; 1 ? 4 : 0) | (x &amp; 2) | (x &amp; 4 ? 1 : 0))</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>HANDLE</name></type> <name>hstdout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>CONSOLE_SCREEN_BUFFER_INFO</name></type> <name>csbi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>WORD</name></type> <name>match_colour</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>WORD</name></type>
<name>decode_ANSI_colour</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>WORD</name></type> <name>result</name> <init>= <expr><name><name>csbi</name><operator>.</operator><name>wAttributes</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>*</operator><name>cs</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>cs</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>code</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>code</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>result</name> <operator>|=</operator> <literal type="number">0x08</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>code</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>result</name> <operator>|=</operator> <literal type="number">0x8000</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>code</name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>result</name> <operator>|=</operator> <literal type="number">0x80</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>code</name> <operator>&gt;=</operator> <literal type="number">30</literal> <operator>&amp;&amp;</operator> <name>code</name> <operator>&lt;=</operator> <literal type="number">37</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>&amp;</operator> <literal type="number">0xF8</literal><operator>)</operator> <operator>|</operator> <call><name>BGR_RGB</name><argument_list>(<argument><expr><name>code</name> <operator>-</operator> <literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>code</name> <operator>==</operator> <literal type="number">39</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>&amp;</operator> <literal type="number">0xF0</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>csbi</name><operator>.</operator><name>wAttributes</name></name> <operator>&amp;</operator> <literal type="number">0x0F</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>code</name> <operator>&gt;=</operator> <literal type="number">40</literal> <operator>&amp;&amp;</operator> <name>code</name> <operator>&lt;=</operator> <literal type="number">47</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>&amp;</operator> <literal type="number">0x8F</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><call><name>BGR_RGB</name><argument_list>(<argument><expr><name>code</name> <operator>-</operator> <literal type="number">40</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>code</name> <operator>==</operator> <literal type="number">49</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>&amp;</operator> <literal type="number">0x0F</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>csbi</name><operator>.</operator><name>wAttributes</name></name> <operator>&amp;</operator> <literal type="number">0xF0</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
    <comment type="block">/* aixterm high intensity colour codes */</comment>
    <if type="elseif">else if <condition>(<expr><name>code</name> <operator>&gt;=</operator> <literal type="number">90</literal> <operator>&amp;&amp;</operator> <name>code</name> <operator>&lt;=</operator> <literal type="number">97</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>&amp;</operator> <literal type="number">0xF0</literal><operator>)</operator> <operator>|</operator> <call><name>BGR_RGB</name><argument_list>(<argument><expr><name>code</name> <operator>-</operator> <literal type="number">90</literal></expr></argument>)</argument_list></call> <operator>|</operator> <literal type="number">0x08</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>code</name> <operator>&gt;=</operator> <literal type="number">100</literal> <operator>&amp;&amp;</operator> <name>code</name> <operator>&lt;=</operator> <literal type="number">107</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>result</name> <operator>&amp;</operator> <literal type="number">0x0F</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><call><name>BGR_RGB</name><argument_list>(<argument><expr><name>code</name> <operator>-</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>|</operator> <literal type="number">0x80</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>cs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cs</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cs</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cs</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></while>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_colour_output</name><parameter_list>()</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>do_colour</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>hstdout</name> <operator>=</operator> <call><name>GetStdHandle</name><argument_list>(<argument><expr><name>STD_OUTPUT_HANDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* This fails when redirected to con; try again if so. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetConsoleScreenBufferInfo</name><argument_list>(<argument><expr><name>hstdout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>csbi</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>do_ansi</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>HANDLE</name></type> <name>hcon</name> <init>= <expr><call><name>CreateFile</name><argument_list>(<argument><expr><literal type="string">"CONOUT$"</literal></expr></argument>, <argument><expr><name>GENERIC_READ</name> <operator>|</operator> <name>GENERIC_WRITE</name></expr></argument>,
      <argument><expr><name>FILE_SHARE_WRITE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>OPEN_EXISTING</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>GetConsoleScreenBufferInfo</name><argument_list>(<argument><expr><name>hcon</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>csbi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hcon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>match_colour</name> <operator>=</operator> <call><name>decode_ANSI_colour</name><argument_list>(<argument><expr><name>colour_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* No valid colour found - turn off colouring */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>match_colour</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>do_colour</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* WIN32 */</comment>


<comment type="block">/* The following sets of functions are defined so that they can be made system
specific. At present there are versions for Unix-style environments, Windows,
native z/OS, and "no support". */</comment>


<comment type="block" format="doxygen">/************* Directory scanning Unix-style and z/OS ***********/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>defined</name> <name>HAVE_SYS_STAT_H</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>HAVE_DIRENT_H</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>HAVE_SYS_TYPES_H</name><operator>)</operator> <operator>||</operator> <name>defined</name> <name>NATIVE_ZOS</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NATIVE_ZOS</name></expr></cpp:if>
<comment type="block" format="doxygen">/************* Directory and PDS/E scanning for z/OS ***********/</comment>
<comment type="block" format="doxygen">/************* z/OS looks mostly like Unix with USS ************/</comment>
<comment type="block">/* However, z/OS needs the #include statements in this header */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcrzosfs.h"</cpp:file></cpp:include>
<comment type="block">/* That header is not included in the main PCRE distribution because
   other apparatus is needed to compile pcre2grep for z/OS. The header
   can be found in the special z/OS distribution, which is available
   from www.zaconsultants.net or from www.cbttape.org. */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name>DIR</name></type> <name>directory_type</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILESEP</name></cpp:macro> <cpp:value>'/'</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>isdirectory</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>        <comment type="block">/* In the expectation that opening as a file will fail */</comment>
<return>return <expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>directory_type</name> <modifier>*</modifier></type>
<name>opendirectory</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>opendir</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>readdirectory</name><parameter_list>(<parameter><decl><type><name>directory_type</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>dent</name> <init>= <expr><call><name>readdir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>dent</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>dent</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>dent</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name><name>dent</name><operator>-&gt;</operator><name>d_name</name></name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
<comment type="block">/* Control never reaches here */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>closedirectory</name><parameter_list>(<parameter><decl><type><name>directory_type</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/************* Test for regular file, Unix-style **********/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>isregfile</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>        <comment type="block">/* In the expectation that opening as a file will fail */</comment>
<return>return <expr><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>statbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NATIVE_ZOS</name></expr></cpp:if>
<comment type="block" format="doxygen">/************* Test for a terminal in z/OS **********/</comment>
<comment type="block">/* isatty() does not work in a TSO environment, so always give FALSE.*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>is_stdout_tty</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>is_file_tty</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/************* Test for a terminal, Unix-style **********/</comment>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>is_stdout_tty</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>is_file_tty</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block" format="doxygen">/************* Print optionally coloured match Unix-style and z/OS **********/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_match</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>do_colour</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%c[%sm"</literal></expr></argument>, <argument><expr><literal type="number">0x1b</literal></expr></argument>, <argument><expr><name>colour_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>FWRITE_IGNORE</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>do_colour</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%c[0m"</literal></expr></argument>, <argument><expr><literal type="number">0x1b</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* End of Unix-style or native z/OS environment functions. */</comment>


<comment type="block" format="doxygen">/************* Directory scanning in Windows ***********/</comment>

<comment type="block">/* I (Philip Hazel) have no means of testing this code. It was contributed by
Lionel Fourquaux. David Burgess added a patch to define INVALID_FILE_ATTRIBUTES
when it did not exist. David Byron added a patch that moved the #include of
&lt;windows.h&gt; to before the INVALID_FILE_ATTRIBUTES definition rather than after.
*/</comment>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>WIN32</name></expr></cpp:elif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>INVALID_FILE_ATTRIBUTES</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_FILE_ATTRIBUTES</name></cpp:macro> <cpp:value>0xFFFFFFFF</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct <name>directory_type</name>
<block>{
<decl_stmt><decl><type><name>HANDLE</name></type> <name>handle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>first</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WIN32_FIND_DATA</name></type> <name>data</name></decl>;</decl_stmt>
}</block></struct></type> <name>directory_type</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILESEP</name></cpp:macro> <cpp:value>'/'</cpp:value></cpp:define>

<function><type><name>int</name></type>
<name>isdirectory</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>DWORD</name></type> <name>attr</name> <init>= <expr><call><name>GetFileAttributes</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>attr</name> <operator>==</operator> <name>INVALID_FILE_ATTRIBUTES</name></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>attr</name> <operator>&amp;</operator> <name>FILE_ATTRIBUTE_DIRECTORY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>directory_type</name> <modifier>*</modifier></type>
<name>opendirectory</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pattern</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>directory_type</name> <modifier>*</modifier></type><name>dir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>err</name></decl>;</decl_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pattern</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dir</name> <operator>=</operator> <operator>(</operator><name>directory_type</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>dir</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pattern</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>dir</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: malloc failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pcre2grep_exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>iswild</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name><name>pattern</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pattern</name><index>[<expr><name>len</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"\\*"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>handle</name></name> <operator>=</operator> <call><name>FindFirstFile</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dir</name><operator>-&gt;</operator><name>handle</name></name> <operator>!=</operator> <name>INVALID_HANDLE_VALUE</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <return>return <expr><name>dir</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>err</name> <operator>==</operator> <name>ERROR_ACCESS_DENIED</name><operator>)</operator></expr> ?</condition><then> <expr><name>EACCES</name></expr> </then><else>: <expr><name>ENOENT</name></expr></else></ternary></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>readdirectory</name><parameter_list>(<parameter><decl><type><name>directory_type</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dir</name><operator>-&gt;</operator><name>first</name></name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FindNextFile</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>dir</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><name><name>dir</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>cFileName</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>cFileName</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name><name>dir</name><operator>-&gt;</operator><name>data</name><operator>.</operator><name>cFileName</name></name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_MSC_VER</name></cpp:ifndef>
<return>return <expr><name>NULL</name></expr>;</return>   <comment type="block">/* Keep compiler happy; never executed */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>closedirectory</name><parameter_list>(<parameter><decl><type><name>directory_type</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>FindClose</name><argument_list>(<argument><expr><name><name>dir</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/************* Test for regular file in Windows **********/</comment>

<comment type="block">/* I don't know how to do this, or if it can be done; assume all paths are
regular if they are not directories. */</comment>

<function><type><name>int</name></type> <name>isregfile</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>!</operator><call><name>isdirectory</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/************* Test for a terminal in Windows **********/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>is_stdout_tty</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>_isatty</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>is_file_tty</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>_isatty</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/************* Print optionally coloured match in Windows **********/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_match</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>do_colour</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>do_ansi</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%c[%sm"</literal></expr></argument>, <argument><expr><literal type="number">0x1b</literal></expr></argument>, <argument><expr><name>colour_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>SetConsoleTextAttribute</name><argument_list>(<argument><expr><name>hstdout</name></expr></argument>, <argument><expr><name>match_colour</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>FWRITE_IGNORE</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>do_colour</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>do_ansi</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%c[0m"</literal></expr></argument>, <argument><expr><literal type="number">0x1b</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>SetConsoleTextAttribute</name><argument_list>(<argument><expr><name>hstdout</name></expr></argument>, <argument><expr><name><name>csbi</name><operator>.</operator><name>wAttributes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* End of Windows functions */</comment>


<comment type="block" format="doxygen">/************* Directory scanning when we can't do it ***********/</comment>

<comment type="block">/* The type is void, and apart from isdirectory(), the functions do nothing. */</comment>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILESEP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<typedef>typedef <type><name>void</name></type> <name>directory_type</name>;</typedef>

<function><type><name>int</name></type> <name>isdirectory</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><literal type="number">0</literal></expr>;</return> </block_content>}</block></function>
<function><type><name>directory_type</name> <modifier>*</modifier></type> <name>opendirectory</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>directory_type</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr>;</return></block_content>}</block></function>
<function><type><name>char</name> <modifier>*</modifier></type><name>readdirectory</name><parameter_list>(<parameter><decl><type><name>directory_type</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="number">0</literal></expr>;</return></block_content>}</block></function>
<function><type><name>void</name></type> <name>closedirectory</name><parameter_list>(<parameter><decl><type><name>directory_type</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>


<comment type="block" format="doxygen">/************* Test for regular file when we can't do it **********/</comment>

<comment type="block">/* Assume all files are regular. */</comment>

<function><type><name>int</name></type> <name>isregfile</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><literal type="number">1</literal></expr>;</return> </block_content>}</block></function>


<comment type="block" format="doxygen">/************* Test for a terminal when we can't do it **********/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>is_stdout_tty</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>is_file_tty</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/************* Print optionally coloured match when we can't do it **********/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_match</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>FWRITE_IGNORE</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* End of system-specific functions */</comment>



<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_STRERROR</name></cpp:ifndef>
<comment type="block" format="doxygen">/*************************************************
*     Provide strerror() for non-ANSI libraries  *
*************************************************/</comment>

<comment type="block">/* Some old-fashioned systems still around (e.g. SunOS4) don't have strerror()
in their libraries, but can provide the same facility by this simple
alternative function. */</comment>

<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type>   <name>sys_nerr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name><name>sys_errlist</name><index>[]</index></name></decl>;</decl_stmt>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>strerror</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>&gt;=</operator> <name>sys_nerr</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="string">"unknown error number"</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name><name>sys_errlist</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_STRERROR */</comment>



<comment type="block" format="doxygen">/*************************************************
*                Usage function                  *
*************************************************/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>usage</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>rc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>option_item</name> <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Usage: pcre2grep [-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>op</name> <operator>=</operator> <name>optionlist</name></expr>;</init> <condition><expr><name><name>op</name><operator>-&gt;</operator><name>one_char</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>op</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>one_char</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>one_char</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"] [long options] [pattern] [files]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Type \"pcre2grep --help\" for more information and the long "</literal>
  <literal type="string">"options.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*                Help function                   *
*************************************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>help</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>option_item</name> <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Usage: pcre2grep [OPTION]... [PATTERN] [FILE1 FILE2 ...]"</literal> <name>STDOUT_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Search for PATTERN in each FILE or standard input."</literal> <name>STDOUT_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"PATTERN must be present if neither -e nor -f is used."</literal> <name>STDOUT_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2GREP_CALLOUT</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2GREP_CALLOUT_FORK</name></cpp:ifdef>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"All callout scripts in patterns are supported."</literal> <name>STDOUT_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Non-fork callout scripts in patterns are supported."</literal> <name>STDOUT_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Callout scripts are not supported in this pcre2grep."</literal> <name>STDOUT_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\"-\" can be used as a file name to mean STDIN."</literal> <name>STDOUT_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_LIBZ</name></cpp:ifdef>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Files whose names end in .gz are read using zlib."</literal> <name>STDOUT_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_LIBBZ2</name></cpp:ifdef>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Files whose names end in .bz2 are read using bzlib2."</literal> <name>STDOUT_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_LIBZ</name> <operator>||</operator> <name>defined</name> <name>SUPPORT_LIBBZ2</name></expr></cpp:if>
<macro><name>printf</name><argument_list>(<argument><literal type="string">"Other files and the standard input are read as plain files."</literal> STDOUT_NL STDOUT_NL</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<macro><name>printf</name><argument_list>(<argument><literal type="string">"All files are read as plain files, without any interpretation."</literal> STDOUT_NL STDOUT_NL</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>printf</name><argument_list>(<argument><literal type="string">"Example: pcre2grep -i "</literal> QUOT <literal type="string">"hello.*world"</literal> QUOT <literal type="string">" menu.h main.c"</literal> STDOUT_NL STDOUT_NL</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Options:"</literal> <name>STDOUT_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>op</name> <operator>=</operator> <name>optionlist</name></expr>;</init> <condition><expr><name><name>op</name><operator>-&gt;</operator><name>one_char</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>op</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>s</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>one_char</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>long_name</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">31</literal> <operator>-</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -%c"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>one_char</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>one_char</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"-%c,"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>one_char</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"   "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">31</literal> <operator>-</operator> <call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  %s --%s"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%.*s%s"</literal> <name>STDOUT_NL</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"                           "</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>help_text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><name>STDOUT_NL</name> <literal type="string">"Numbers may be followed by K or M, e.g. --max-buffer-size=100K."</literal> <name>STDOUT_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"The default value for --buffer-size is %d."</literal> <name>STDOUT_NL</name></expr></argument>, <argument><expr><name>PCRE2GREP_BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"The default value for --max-buffer-size is %d."</literal> <name>STDOUT_NL</name></expr></argument>, <argument><expr><name>PCRE2GREP_MAX_BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"When reading patterns or file names from a file, trailing white"</literal> <name>STDOUT_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"space is removed and blank lines are ignored."</literal> <name>STDOUT_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"The maximum size of any pattern is %d bytes."</literal> <name>STDOUT_NL</name></expr></argument>, <argument><expr><name>MAXPATLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><name>STDOUT_NL</name> <literal type="string">"With no FILEs, read standard input. If fewer than two FILEs given, assume -h."</literal> <name>STDOUT_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Exit status is 0 if any matches, 1 if no matches, and 2 if trouble."</literal> <name>STDOUT_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*            Test exclude/includes               *
*************************************************/</comment>

<comment type="block">/* If any exclude pattern matches, the path is excluded. Otherwise, unless
there are no includes, the path must match an include pattern.

Arguments:
  path      the path to be matched
  ip        the chain of include patterns
  ep        the chain of exclude patterns

Returns:    TRUE if the path is not excluded
*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>test_incexc</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>patstr</name> <modifier>*</modifier></type><name>ip</name></decl></parameter>, <parameter><decl><type><name>patstr</name> <modifier>*</modifier></type><name>ep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>plen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>ep</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ep</name> <operator>=</operator> <name><name>ep</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>pcre2_match</name><argument_list>(<argument><expr><name><name>ep</name><operator>-&gt;</operator><name>compiled</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PCRE2_SPTR</name><operator>)</operator><name>path</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>ip</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>ip</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ip</name> <operator>=</operator> <name><name>ip</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>pcre2_match</name><argument_list>(<argument><expr><name><name>ip</name><operator>-&gt;</operator><name>compiled</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PCRE2_SPTR</name><operator>)</operator><name>path</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>

<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*         Decode integer argument value          *
*************************************************/</comment>

<comment type="block">/* Integer arguments can be followed by K or M. Avoid the use of strtoul()
because SunOS4 doesn't have it. This is used only for unpicking arguments, so
just keep it simple.

Arguments:
  option_data   the option data string
  op            the option item (for error messages)
  longop        TRUE if option given in long form

Returns:        a long integer
*/</comment>

<function><type><specifier>static</specifier> <name>long</name> <name>int</name></type>
<name>decode_number</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>option_data</name></decl></parameter>, <parameter><decl><type><name>option_item</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>longop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endptr</name> <init>= <expr><name>option_data</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><operator>*</operator><name>endptr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><operator>*</operator><name>endptr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <name>n</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>*</operator><name>endptr</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><call><name>toupper</name><argument_list>(<argument><expr><operator>*</operator><name>endptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'K'</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>n</name> <operator>*=</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>toupper</name><argument_list>(<argument><expr><operator>*</operator><name>endptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'M'</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>n</name> <operator>*=</operator> <literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>   <comment type="block">/* Error */</comment>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>longop</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>equals</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nlen</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>equals</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then> <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
      <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>equals</name> <operator>-</operator> <name><name>op</name><operator>-&gt;</operator><name>long_name</name></name><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Malformed number \"%s\" after --%.*s\n"</literal></expr></argument>,
      <argument><expr><name>option_data</name></expr></argument>, <argument><expr><name>nlen</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Malformed number \"%s\" after -%c\n"</literal></expr></argument>,
      <argument><expr><name>option_data</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>one_char</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><call><name>pcre2grep_exit</name><argument_list>(<argument><expr><call><name>usage</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*       Add item to a chain of numbers           *
*************************************************/</comment>

<comment type="block">/* Used to add an item onto a chain, or just return an unconnected item if the
"after" argument is NULL.

Arguments:
  n          the number to add
  after      if not NULL points to item to insert after

Returns:     new number block
*/</comment>

<function><type><specifier>static</specifier> <name>omstr</name> <modifier>*</modifier></type>
<name>add_number</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>omstr</name> <modifier>*</modifier></type><name>after</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>omstr</name> <modifier>*</modifier></type><name>om</name> <init>= <expr><operator>(</operator><name>omstr</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>omstr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>om</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: malloc failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pcre2grep_exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>om</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>om</name><operator>-&gt;</operator><name>groupnum</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>after</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>om</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>after</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>after</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>om</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<return>return <expr><name>om</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*            Read one line of input              *
*************************************************/</comment>

<comment type="block">/* Normally, input that is to be scanned is read using fread() (or gzread, or
BZ2_read) into a large buffer, so many lines may be read at once. However,
doing this for tty input means that no output appears until a lot of input has
been typed. Instead, tty input is handled line by line. We cannot use fgets()
for this, because it does not stop at a binary zero, and therefore there is no
way of telling how many characters it has read, because there may be binary
zeros embedded in the data. This function is also used for reading patterns
from files (the -f option).

Arguments:
  buffer     the buffer to read into
  length     the maximum number of characters to read
  f          the file

Returns:     the number of characters read, zero at end of file
*/</comment>

<function><type><specifier>static</specifier> <name>PCRE2_SIZE</name></type>
<name>read_one_line</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yield</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>yield</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <name>yield</name> <operator>&gt;=</operator> <name>length</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></while>
<return>return <expr><name>yield</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*             Find end of line                   *
*************************************************/</comment>

<comment type="block">/* The length of the endline sequence that is found is set via lenptr. This may
be zero at the very end of the file if there is no line-ending sequence there.

Arguments:
  p         current position in line
  endptr    end of available data
  lenptr    where to put the length of the eol sequence

Returns:    pointer after the last byte of the line,
            including the newline byte(s)
*/</comment>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>end_of_line</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>endptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>lenptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch<condition>(<expr><name>endlinetype</name></expr>)</condition>
  <block>{<block_content>
  <default>default:</default>      <comment type="block">/* Just in case */</comment>
  <case>case <expr><name>PCRE2_NEWLINE_LF</name></expr>:</case>
  <while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>endptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>endptr</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>lenptr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>lenptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>endptr</name></expr>;</return>

  <case>case <expr><name>PCRE2_NEWLINE_CR</name></expr>:</case>
  <while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>endptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>endptr</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>lenptr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>lenptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>endptr</name></expr>;</return>

  <case>case <expr><name>PCRE2_NEWLINE_NUL</name></expr>:</case>
  <while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>endptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>endptr</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>lenptr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>lenptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><name>endptr</name></expr>;</return>

  <case>case <expr><name>PCRE2_NEWLINE_CRLF</name></expr>:</case>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
    <while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>endptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if <condition>(<expr><operator>++</operator><name>p</name> <operator>&gt;=</operator> <name>endptr</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>lenptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <return>return <expr><name>endptr</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>lenptr</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <return>return <expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  <break>break;</break>

  <case>case <expr><name>PCRE2_NEWLINE_ANYCRLF</name></expr>:</case>
  <while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>endptr</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>extra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&gt;=</operator> <literal type="number">0xc0</literal></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>gcii</name></decl>, <decl><type ref="prev"/><name>gcss</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>extra</name> <operator>=</operator> <name><name>utf8_table4</name><index>[<expr><name>c</name> <operator>&amp;</operator> <literal type="number">0x3f</literal></expr>]</index></name></expr>;</expr_stmt>  <comment type="block">/* Number of additional bytes */</comment>
      <expr_stmt><expr><name>gcss</name> <operator>=</operator> <literal type="number">6</literal><operator>*</operator><name>extra</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <name><name>utf8_table3</name><index>[<expr><name>extra</name></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <name>gcss</name></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>gcii</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>gcii</name> <operator>&lt;=</operator> <name>extra</name></expr>;</condition> <incr><expr><name>gcii</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <expr_stmt><expr><name>gcss</name> <operator>-=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> <operator>|=</operator> <operator>(</operator><name><name>p</name><index>[<expr><name>gcii</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>gcss</name></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>extra</name></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><literal type="char">'\n'</literal></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>lenptr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <return>return <expr><name>p</name></expr>;</return>

      <case>case <expr><literal type="char">'\r'</literal></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>endptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>lenptr</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>lenptr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <return>return <expr><name>p</name></expr>;</return>

      <default>default:</default>
      <break>break;</break>
      </block_content>}</block></switch>
    </block_content>}</block></while>   <comment type="block">/* End of loop for ANYCRLF case */</comment>

  <expr_stmt><expr><operator>*</operator><name>lenptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Must have hit the end */</comment>
  <return>return <expr><name>endptr</name></expr>;</return>

  <case>case <expr><name>PCRE2_NEWLINE_ANY</name></expr>:</case>
  <while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>endptr</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>extra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>p</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&gt;=</operator> <literal type="number">0xc0</literal></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>gcii</name></decl>, <decl><type ref="prev"/><name>gcss</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>extra</name> <operator>=</operator> <name><name>utf8_table4</name><index>[<expr><name>c</name> <operator>&amp;</operator> <literal type="number">0x3f</literal></expr>]</index></name></expr>;</expr_stmt>  <comment type="block">/* Number of additional bytes */</comment>
      <expr_stmt><expr><name>gcss</name> <operator>=</operator> <literal type="number">6</literal><operator>*</operator><name>extra</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <name><name>utf8_table3</name><index>[<expr><name>extra</name></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <name>gcss</name></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>gcii</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>gcii</name> <operator>&lt;=</operator> <name>extra</name></expr>;</condition> <incr><expr><name>gcii</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <expr_stmt><expr><name>gcss</name> <operator>-=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> <operator>|=</operator> <operator>(</operator><name><name>p</name><index>[<expr><name>gcii</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>gcss</name></expr>;</expr_stmt>
        </block_content>}</block></for>
      </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <name>extra</name></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><literal type="char">'\n'</literal></expr>:</case>    <comment type="block">/* LF */</comment>
      <case>case <expr><literal type="char">'\v'</literal></expr>:</case>    <comment type="block">/* VT */</comment>
      <case>case <expr><literal type="char">'\f'</literal></expr>:</case>    <comment type="block">/* FF */</comment>
      <expr_stmt><expr><operator>*</operator><name>lenptr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <return>return <expr><name>p</name></expr>;</return>

      <case>case <expr><literal type="char">'\r'</literal></expr>:</case>    <comment type="block">/* CR */</comment>
      <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>endptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>lenptr</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>lenptr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <return>return <expr><name>p</name></expr>;</return>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EBCDIC</name></cpp:ifndef>
      <case>case <expr><literal type="number">0x85</literal></expr>:</case>    <comment type="block">/* Unicode NEL */</comment>
      <expr_stmt><expr><operator>*</operator><name>lenptr</name> <operator>=</operator> <ternary><condition><expr><name>utf</name></expr>?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
      <return>return <expr><name>p</name></expr>;</return>

      <case>case <expr><literal type="number">0x2028</literal></expr>:</case>  <comment type="block">/* Unicode LS */</comment>
      <case>case <expr><literal type="number">0x2029</literal></expr>:</case>  <comment type="block">/* Unicode PS */</comment>
      <expr_stmt><expr><operator>*</operator><name>lenptr</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
      <return>return <expr><name>p</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* Not EBCDIC */</comment>

      <default>default:</default>
      <break>break;</break>
      </block_content>}</block></switch>
    </block_content>}</block></while>   <comment type="block">/* End of loop for ANY case */</comment>

  <expr_stmt><expr><operator>*</operator><name>lenptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Must have hit the end */</comment>
  <return>return <expr><name>endptr</name></expr>;</return>
  </block_content>}</block></switch>     <comment type="block">/* End of overall switch */</comment>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*         Find start of previous line            *
*************************************************/</comment>

<comment type="block">/* This is called when looking back for before lines to print.

Arguments:
  p         start of the subsequent line
  startptr  start of available data

Returns:    pointer to the start of the previous line
*/</comment>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>previous_line</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>startptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch<condition>(<expr><name>endlinetype</name></expr>)</condition>
  <block>{<block_content>
  <default>default:</default>      <comment type="block">/* Just in case */</comment>
  <case>case <expr><name>PCRE2_NEWLINE_LF</name></expr>:</case>
  <expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>startptr</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
  <return>return <expr><name>p</name></expr>;</return>

  <case>case <expr><name>PCRE2_NEWLINE_CR</name></expr>:</case>
  <expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>startptr</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
  <return>return <expr><name>p</name></expr>;</return>

  <case>case <expr><name>PCRE2_NEWLINE_NUL</name></expr>:</case>
  <expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>startptr</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
  <return>return <expr><name>p</name></expr>;</return>

  <case>case <expr><name>PCRE2_NEWLINE_CRLF</name></expr>:</case>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>startptr</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&lt;=</operator> <name>startptr</name> <operator>+</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>p</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>p</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  <comment type="block">/* Control can never get here */</comment>

  <case>case <expr><name>PCRE2_NEWLINE_ANY</name></expr>:</case>
  <case>case <expr><name>PCRE2_NEWLINE_ANYCRLF</name></expr>:</case>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><operator>--</operator><name>p</name><operator>)</operator> <operator>==</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name>p</name> <operator>&gt;</operator> <name>startptr</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <while>while <condition>(<expr><operator>(</operator><operator>*</operator><name>p</name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while></block_content></block></if></if_stmt>

  <while>while <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>startptr</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pp</name> <init>= <expr><name>p</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>extra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><operator>(</operator><operator>*</operator><name>pp</name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>pp</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pp</name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">0xc0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>gcii</name></decl>, <decl><type ref="prev"/><name>gcss</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>extra</name> <operator>=</operator> <name><name>utf8_table4</name><index>[<expr><name>c</name> <operator>&amp;</operator> <literal type="number">0x3f</literal></expr>]</index></name></expr>;</expr_stmt>  <comment type="block">/* Number of additional bytes */</comment>
        <expr_stmt><expr><name>gcss</name> <operator>=</operator> <literal type="number">6</literal><operator>*</operator><name>extra</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <name><name>utf8_table3</name><index>[<expr><name>extra</name></expr>]</index></name><operator>)</operator> <operator>&lt;&lt;</operator> <name>gcss</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>gcii</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>gcii</name> <operator>&lt;=</operator> <name>extra</name></expr>;</condition> <incr><expr><name>gcii</name><operator>++</operator></expr></incr>)</control>
          <block>{<block_content>
          <expr_stmt><expr><name>gcss</name> <operator>-=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name>c</name> <operator>|=</operator> <operator>(</operator><name><name>pp</name><index>[<expr><name>gcii</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>gcss</name></expr>;</expr_stmt>
          </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>pp</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>endlinetype</name> <operator>==</operator> <name>PCRE2_NEWLINE_ANYCRLF</name></expr>)</condition><block type="pseudo"><block_content> <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><literal type="char">'\n'</literal></expr>:</case>    <comment type="block">/* LF */</comment>
      <case>case <expr><literal type="char">'\r'</literal></expr>:</case>    <comment type="block">/* CR */</comment>
      <return>return <expr><name>p</name></expr>;</return>

      <default>default:</default>
      <break>break;</break>
      </block_content>}</block></switch></block_content></block></if>

    <else>else<block type="pseudo"><block_content> <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><literal type="char">'\n'</literal></expr>:</case>    <comment type="block">/* LF */</comment>
      <case>case <expr><literal type="char">'\v'</literal></expr>:</case>    <comment type="block">/* VT */</comment>
      <case>case <expr><literal type="char">'\f'</literal></expr>:</case>    <comment type="block">/* FF */</comment>
      <case>case <expr><literal type="char">'\r'</literal></expr>:</case>    <comment type="block">/* CR */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EBCDIC</name></cpp:ifndef>
      <case>case <expr><literal type="number">0x85</literal></expr>:</case>    <comment type="block">/* Unicode NEL */</comment>
      <case>case <expr><literal type="number">0x2028</literal></expr>:</case>  <comment type="block">/* Unicode LS */</comment>
      <case>case <expr><literal type="number">0x2029</literal></expr>:</case>  <comment type="block">/* Unicode PS */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* Not EBCDIC */</comment>
      <return>return <expr><name>p</name></expr>;</return>

      <default>default:</default>
      <break>break;</break>
      </block_content>}</block></switch></block_content></block></else></if_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pp</name></expr>;</expr_stmt>  <comment type="block">/* Back one character */</comment>
    </block_content>}</block></while>        <comment type="block">/* End of loop for ANY case */</comment>

  <return>return <expr><name>startptr</name></expr>;</return>  <comment type="block">/* Hit start of data */</comment>
  </block_content>}</block></switch>     <comment type="block">/* End of overall switch */</comment>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*              Output newline at end             *
*************************************************/</comment>

<comment type="block">/* This function is called if the final line of a file has been written to
stdout, but it does not have a terminating newline.

Arguments:  none
Returns:    nothing
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_final_newline</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch<condition>(<expr><name>endlinetype</name></expr>)</condition>
  <block>{<block_content>
  <default>default:</default>      <comment type="block">/* Just in case */</comment>
  <case>case <expr><name>PCRE2_NEWLINE_LF</name></expr>:</case>
  <case>case <expr><name>PCRE2_NEWLINE_ANY</name></expr>:</case>
  <case>case <expr><name>PCRE2_NEWLINE_ANYCRLF</name></expr>:</case>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>PCRE2_NEWLINE_CR</name></expr>:</case>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"\r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>PCRE2_NEWLINE_CRLF</name></expr>:</case>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>

  <case>case <expr><name>PCRE2_NEWLINE_NUL</name></expr>:</case>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>
  </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*       Print the previous "after" lines         *
*************************************************/</comment>

<comment type="block">/* This is called if we are about to lose said lines because of buffer filling,
and at the end of the file. The data in the line is written using fwrite() so
that a binary zero does not terminate it.

Arguments:
  lastmatchnumber   the number of the last matching line, plus one
  lastmatchrestart  where we restarted after the last match
  endptr            end of available data
  printname         filename for printing

Returns:            nothing
*/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_after_lines</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name> <name>int</name></type> <name>lastmatchnumber</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>lastmatchrestart</name></decl></parameter>,
  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>endptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>printname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>after_context</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>lastmatchnumber</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ellength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>lastmatchrestart</name> <operator>&lt;</operator> <name>endptr</name> <operator>&amp;&amp;</operator> <name>count</name> <operator>&lt;</operator> <name>after_context</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pp</name> <init>= <expr><call><name>end_of_line</name><argument_list>(<argument><expr><name>lastmatchrestart</name></expr></argument>, <argument><expr><name>endptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ellength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ellength</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pp</name> <operator>==</operator> <name>main_buffer</name> <operator>+</operator> <name>bufsize</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>printname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%s-"</literal></expr></argument>, <argument><expr><name>printname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>number</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%lu-"</literal></expr></argument>, <argument><expr><name>lastmatchnumber</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>FWRITE_IGNORE</name><argument_list>(<argument><expr><name>lastmatchrestart</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pp</name> <operator>-</operator> <name>lastmatchrestart</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lastmatchrestart</name> <operator>=</operator> <name>pp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

  <comment type="block">/* If we have printed any lines, arrange for a hyphen separator if anything
  else follows. Also, if the last line is the final line in the file and it had
  no newline, add one. */</comment>

  <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>hyphenpending</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ellength</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>lastmatchrestart</name> <operator>&gt;=</operator> <name>endptr</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>write_final_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*   Apply patterns to subject till one matches   *
*************************************************/</comment>

<comment type="block">/* This function is called to run through all patterns, looking for a match. It
is used multiple times for the same subject when colouring is enabled, in order
to find all possible matches.

Arguments:
  matchptr     the start of the subject
  length       the length of the subject to match
  options      options for pcre_exec
  startoffset  where to start matching
  mrc          address of where to put the result of pcre2_match()

Returns:      TRUE if there was a match
              FALSE if there was no match
              invert if there was a non-fatal error
*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>match_patterns</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>matchptr</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>length</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>options</name></decl></parameter>,
  <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>startoffset</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>mrc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>slen</name> <init>= <expr><name>length</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>patstr</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>patterns</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><literal type="string">"this text:\n\n"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&gt;</operator> <literal type="number">200</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>slen</name> <operator>=</operator> <literal type="number">200</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">"text that starts:\n\n"</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>mrc</name> <operator>=</operator> <call><name>pcre2_match</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>compiled</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PCRE2_SPTR</name><operator>)</operator><name>matchptr</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>length</name></expr></argument>,
    <argument><expr><name>startoffset</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>match_data</name></expr></argument>, <argument><expr><name>match_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>mrc</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>mrc</name> <operator>==</operator> <name>PCRE2_ERROR_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: pcre2_match() gave error %d while matching "</literal></expr></argument>, <argument><expr><operator>*</operator><name>mrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>patterns</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pattern number %d to "</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>FWRITE_IGNORE</name><argument_list>(<argument><expr><name>matchptr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* In case binary zero included */</comment>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>mrc</name> <operator>&lt;=</operator> <name>PCRE2_ERROR_UTF8_ERR1</name> <operator>&amp;&amp;</operator>
      <operator>*</operator><name>mrc</name> <operator>&gt;=</operator> <name>PCRE2_ERROR_UTF8_ERR21</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>mbuffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>startchar</name> <init>= <expr><call><name>pcre2_get_startchar</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcre2_get_error_message</name><argument_list>(<argument><expr><operator>*</operator><name>mrc</name></expr></argument>, <argument><expr><name>mbuffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mbuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>fprintf</name><argument_list>(<argument>stderr</argument>, <argument><literal type="string">"%s at offset %"</literal> SIZ_FORM <literal type="string">"\n\n"</literal></argument>, <argument>mbuffer</argument>,
      <argument>SIZ_CAST startchar</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>mrc</name> <operator>==</operator> <name>PCRE2_ERROR_MATCHLIMIT</name> <operator>||</operator> <operator>*</operator><name>mrc</name> <operator>==</operator> <name>PCRE2_ERROR_DEPTHLIMIT</name> <operator>||</operator>
      <operator>*</operator><name>mrc</name> <operator>==</operator> <name>PCRE2_ERROR_HEAPLIMIT</name> <operator>||</operator> <operator>*</operator><name>mrc</name> <operator>==</operator> <name>PCRE2_ERROR_JIT_STACKLIMIT</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>resource_error</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>error_count</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">20</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Too many errors - abandoned.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pcre2grep_exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <return>return <expr><name>invert</name></expr>;</return>    <comment type="block">/* No more matching; don't show the line again */</comment>
  </block_content>}</block></for>

<return>return <expr><name>FALSE</name></expr>;</return>  <comment type="block">/* No match, no errors */</comment>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*          Decode dollar escape sequence         *
*************************************************/</comment>

<comment type="block">/* Called from various places to decode $ escapes in output strings. The escape
sequences are as follows:

$&lt;digits&gt; or ${&lt;digits&gt;} returns a capture number. However, if callout is TRUE,
zero is never returned; '0' is substituted.

$a returns bell.
$b returns backspace.
$e returns escape.
$f returns form feed.
$n returns newline.
$r returns carriage return.
$t returns tab.
$v returns vertical tab.
$o&lt;digits&gt; returns the character represented by the given octal
  number; up to three digits are processed.
$o{&lt;digits&gt;} does the same, up to 7 digits, but gives an error for mode-invalid
  code points.
$x&lt;digits&gt; returns the character represented by the given hexadecimal
  number; up to two digits are processed.
$x{&lt;digits} does the same, up to 6 digits, but gives an error for mode-invalid
  code points.
Any other character is substituted by itself. E.g: $$ is replaced by a single
dollar.

Arguments:
  begin      the start of the whole string
  string     points to the $
  callout    TRUE if in a callout (inhibits error messages)
  value      where to return a value
  last       where to return pointer to the last used character

Returns:     DDE_ERROR    after a syntax error
             DDE_CAPTURE  if *value is a capture number
             DDE_CHAR     if *value is a character code
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>decode_dollar_escape</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>begin</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>string</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>callout</name></decl></parameter>,
  <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name> <modifier>*</modifier></type><name>last</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dcount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>DDE_CHAR</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>brace</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><operator>*</operator><operator>(</operator><operator>++</operator><name>string</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><literal type="number">0</literal></expr>:</case>   <comment type="block">/* Syntax error: a character must be present after $. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>callout</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Error in output text at offset %d: %s\n"</literal></expr></argument>,
      <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>string</name> <operator>-</operator> <name>begin</name><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"no character after $"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>last</name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
  <return>return <expr><name>DDE_ERROR</name></expr>;</return>

  <case>case <expr><literal type="char">'{'</literal></expr>:</case>
  <expr_stmt><expr><name>brace</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>string</name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>*</operator><name>string</name></expr></argument>)</argument_list></call></expr>)</condition>  <comment type="block">/* Syntax error: a decimal number required. */</comment>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>callout</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Error in output text at offset %d: %s\n"</literal></expr></argument>,
        <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>string</name> <operator>-</operator> <name>begin</name><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"decimal number expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>DDE_ERROR</name></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Fall through */</comment>

  <comment type="block">/* The maximum capture number is 65535, so any number greater than that will
  always be an unknown capture number. We just stop incrementing, in order to
  avoid overflow. */</comment>

  <case>case <expr><literal type="char">'0'</literal></expr>:</case> <case>case <expr><literal type="char">'1'</literal></expr>:</case> <case>case <expr><literal type="char">'2'</literal></expr>:</case> <case>case <expr><literal type="char">'3'</literal></expr>:</case> <case>case <expr><literal type="char">'4'</literal></expr>:</case>
  <case>case <expr><literal type="char">'5'</literal></expr>:</case> <case>case <expr><literal type="char">'6'</literal></expr>:</case> <case>case <expr><literal type="char">'7'</literal></expr>:</case> <case>case <expr><literal type="char">'8'</literal></expr>:</case> <case>case <expr><literal type="char">'9'</literal></expr>:</case>
  <do>do
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <literal type="number">65535</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>c</name> <operator>=</operator> <name>c</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>string</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>string</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>
  while <condition>(<expr><operator>*</operator><name>string</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>string</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition>;</do>
  <expr_stmt><expr><name>string</name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* Point to last digit */</comment>

  <comment type="block">/* In a callout, capture number 0 is not available. No error can be given,
  so just return the character '0'. */</comment>

  <if_stmt><if>if <condition>(<expr><name>callout</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>DDE_CAPTURE</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  <break>break;</break>

  <comment type="block">/* Limit octal numbers to 3 digits without braces, or up to 7 with braces,
  for valid Unicode code points. */</comment>

  <case>case <expr><literal type="char">'o'</literal></expr>:</case>
  <expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>string</name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>string</name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>brace</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>string</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>dcount</name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>dcount</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>dcount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>dcount</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>string</name> <argument_list type="generic">&lt; <argument><expr><literal type="char">'0'</literal> <operator>||</operator> <operator>*</operator><name>string</name></expr></argument> &gt;</argument_list></name> <literal type="char">'7'</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <name>c</name> <operator>*</operator> <literal type="number">8</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>string</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>string</name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* Point to last digit */</comment>
  <break>break;</break>

  <comment type="block">/* Limit hex numbers to 2 digits without braces, or up to 6 with braces,
  for valid Unicode code points. */</comment>

  <case>case <expr><literal type="char">'x'</literal></expr>:</case>
  <expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>string</name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>string</name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>brace</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>string</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>dcount</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>dcount</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>dcount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>dcount</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isxdigit</name><argument_list>(<argument><expr><operator>*</operator><name>string</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>string</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>string</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <name>c</name> <operator>*</operator><literal type="number">16</literal> <operator>+</operator> <operator>*</operator><name>string</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <name>c</name> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>string</name><operator>++</operator> <operator>|</operator> <literal type="number">0x20</literal><operator>)</operator> <operator>-</operator> <literal type="char">'a'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>string</name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* Point to last digit */</comment>
  <break>break;</break>

  <case>case <expr><literal type="char">'a'</literal></expr>:</case> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <literal type="char">'\a'</literal></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'b'</literal></expr>:</case> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <literal type="char">'\b'</literal></expr>;</expr_stmt> <break>break;</break>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EBCDIC</name></cpp:ifndef>
  <case>case <expr><literal type="char">'e'</literal></expr>:</case> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <literal type="char">'\033'</literal></expr>;</expr_stmt> <break>break;</break>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <case>case <expr><literal type="char">'e'</literal></expr>:</case> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <literal type="char">'\047'</literal></expr>;</expr_stmt> <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <case>case <expr><literal type="char">'f'</literal></expr>:</case> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <literal type="char">'\f'</literal></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'n'</literal></expr>:</case> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>STDOUT_NL_CODE</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'r'</literal></expr>:</case> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'t'</literal></expr>:</case> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <literal type="char">'\t'</literal></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'v'</literal></expr>:</case> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <literal type="char">'\v'</literal></expr>;</expr_stmt> <break>break;</break>

  <default>default:</default> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>*</operator><name>string</name></expr>;</expr_stmt> <break>break;</break>
  </block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>brace</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>string</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'}'</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>DDE_ERROR</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>callout</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>base</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'7'</literal><operator>)</operator> <operator>||</operator>
          <operator>(</operator><name>base</name> <operator>==</operator> <literal type="number">16</literal> <operator>&amp;&amp;</operator> <call><name>isxdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Error in output text at offset %d: "</literal>
          <literal type="string">"too many %s digits\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>string</name> <operator>-</operator> <name>begin</name><operator>)</operator></expr></argument>,
          <argument><expr><ternary><condition><expr><operator>(</operator><name>base</name> <operator>==</operator> <literal type="number">8</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">"octal"</literal></expr> </then><else>: <expr><literal type="string">"hex"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Error in output text at offset %d: %s\n"</literal></expr></argument>,
          <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>string</name> <operator>-</operator> <name>begin</name><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"missing closing brace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>string</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Check maximum code point values, but take note of STDOUT_NL_CODE. */</comment>

<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <name>DDE_CHAR</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>value</name> <operator>!=</operator> <name>STDOUT_NL_CODE</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>max</name> <init>= <expr><ternary><condition><expr><name>utf</name></expr>?</condition><then> <expr><literal type="number">0x0010ffffu</literal></expr> </then><else>: <expr><literal type="number">0xffu</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>value</name> <operator>&gt;</operator> <name>max</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>callout</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Error in output text at offset %d: "</literal>
        <literal type="string">"code point greater than 0x%x is invalid\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>string</name> <operator>-</operator> <name>begin</name><operator>)</operator></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>DDE_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>last</name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*          Check output text for errors          *
*************************************************/</comment>

<comment type="block">/* Called early, to get errors before doing anything for -O text; also called
from callouts to check before outputting.

Arguments:
  string    an --output text string
  callout   TRUE if in a callout (stops printing errors)

Returns:    TRUE if OK, FALSE on error
*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>syntax_check_output_text</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>string</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>callout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>begin</name> <init>= <expr><name>string</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>string</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>string</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>string</name> <operator>==</operator> <literal type="char">'$'</literal> <operator>&amp;&amp;</operator>
    <call><name>decode_dollar_escape</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>callout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>string</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DDE_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>

<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*************************************************
*              Display output text               *
*************************************************/</comment>

<comment type="block">/* Display the output text, which is assumed to have already been syntax
checked. Output may contain escape sequences started by the dollar sign.

Arguments:
  string:       the output text
  callout:      TRUE for the builtin callout, FALSE for --output
  subject       the start of the subject
  ovector:      capture offsets
  capture_top:  number of captures

Returns:        TRUE if something was output, other than newline
                FALSE if nothing was output, or newline was last output
*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>display_output_text</name><parameter_list>(<parameter><decl><type><name>PCRE2_SPTR</name></type> <name>string</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>callout</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SPTR</name></type> <name>subject</name></decl></parameter>,
  <parameter><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>ovector</name></decl></parameter>, <parameter><decl><type><name>PCRE2_SIZE</name></type> <name>capture_top</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>printed</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>begin</name> <init>= <expr><name>string</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>string</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>string</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>string</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition>
    <block>{<block_content>
    <switch>switch<condition>(<expr><call><name>decode_dollar_escape</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>callout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>string</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>DDE_CHAR</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>STDOUT_NL_CODE</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>STDOUT_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>printed</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
        <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>  <comment type="block">/* Will print value */</comment>

      <case>case <expr><name>DDE_CAPTURE</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;</operator> <name>capture_top</name></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>capturesize</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>value</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>capturesize</name> <operator>=</operator> <name><name>ovector</name><index>[<expr><name>value</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>ovector</name><index>[<expr><name>value</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>capturesize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>print_match</name><argument_list>(<argument><expr><name>subject</name> <operator>+</operator> <name><name>ovector</name><index>[<expr><name>value</name></expr>]</index></name></expr></argument>, <argument><expr><name>capturesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>printed</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      <continue>continue;</continue>

      <default>default:</default>  <comment type="block">/* Should not occur */</comment>
      <break>break;</break>
      </block_content>}</block></switch>
    </block_content>}</block></if>

  <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>*</operator><name>string</name></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* Not a $ escape */</comment>

  <if_stmt><if>if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <name>value</name> <operator>&lt;=</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><operator>*</operator><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <else>else
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>ord2utf8</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><name><name>utf8_buffer</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name>printed</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  </block_content>}</block></for>

<return>return <expr><name>printed</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2GREP_CALLOUT</name></cpp:ifdef>

<comment type="block" format="doxygen">/*************************************************
*        Parse and execute callout scripts       *
*************************************************/</comment>

<comment type="block">/* If SUPPORT_PCRE2GREP_CALLOUT_FORK is defined, this function parses a callout
string block and executes the program specified by the string. The string is a
list of substrings separated by pipe characters. The first substring represents
the executable name, and the following substrings specify the arguments:

  program_name|param1|param2|...

Any substring (including the program name) can contain escape sequences
started by the dollar character. The escape sequences are substituted as
follows:

  $&lt;digits&gt; or ${&lt;digits&gt;} is replaced by the captured substring of the given
  decimal number, which must be greater than zero. If the number is greater
  than the number of capturing substrings, or if the capture is unset, the
  replacement is empty.

  Any other character is substituted by itself. E.g: $$ is replaced by a single
  dollar or $| replaced by a pipe character.

Alternatively, if string starts with pipe, the remainder is taken as an output
string, same as --output. This is the only form that is supported if
SUPPORT_PCRE2GREP_FORK is not defined. In this case, --om-separator is used to
separate each callout, defaulting to newline.

Example:

  echo -e "abcde\n12345" | pcre2grep \
    '(.)(..(.))(?C"/bin/echo|Arg1: [$1] [$2] [$3]|Arg2: $|${1}$| ($4)")()' -

  Output:

    Arg1: [a] [bcd] [d] Arg2: |a| ()
    abcde
    Arg1: [1] [234] [4] Arg2: |1| ()
    12345

Arguments:
  blockptr     the callout block

Returns:       currently it always returns with 0
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcre2grep_callout</name><parameter_list>(<parameter><decl><type><name>pcre2_callout_block</name> <modifier>*</modifier></type><name>calloutptr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>unused</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>length</name> <init>= <expr><name><name>calloutptr</name><operator>-&gt;</operator><name>callout_string_length</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>string</name> <init>= <expr><name><name>calloutptr</name><operator>-&gt;</operator><name>callout_string</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>subject</name> <init>= <expr><name><name>calloutptr</name><operator>-&gt;</operator><name>subject</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name> <modifier>*</modifier></type><name>ovector</name> <init>= <expr><name><name>calloutptr</name><operator>-&gt;</operator><name>offset_vector</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>capture_top</name> <init>= <expr><name><name>calloutptr</name><operator>-&gt;</operator><name>capture_top</name></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2GREP_CALLOUT_FORK</name></cpp:ifdef>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>argsvectorlen</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>argslen</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>argsptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argsvector</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argsvectorptr</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_PCRE2GREP_CALLOUT_FORK */</comment>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>unused</name></expr>;</expr_stmt>   <comment type="block">/* Avoid compiler warning */</comment>

<comment type="block">/* Only callouts with strings are supported. */</comment>

<if_stmt><if>if <condition>(<expr><name>string</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>length</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* If there's no command, output the remainder directly. */</comment>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>string</name> <operator>==</operator> <literal type="char">'|'</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>string</name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>syntax_check_output_text</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>display_output_text</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>subject</name></expr></argument>, <argument><expr><name>ovector</name></expr></argument>, <argument><expr><name>capture_top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SUPPORT_PCRE2GREP_CALLOUT_FORK</name></cpp:ifndef>
<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<comment type="block">/* Checking syntax and compute the number of string fragments. Callout strings
are silently ignored in the event of a syntax error. */</comment>

<while>while <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>string</name> <operator>==</operator> <literal type="char">'|'</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>argsvectorlen</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>argsvectorlen</name> <operator>&gt;</operator> <literal type="number">10000</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* Too many args */</comment>
    </block_content>}</block></if>

  <if type="elseif">else if <condition>(<expr><operator>*</operator><name>string</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>begin</name> <init>= <expr><name>string</name></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><call><name>decode_dollar_escape</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>string</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>DDE_CAPTURE</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;</operator> <name>capture_top</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><name>value</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>argslen</name> <operator>+=</operator> <name><name>ovector</name><index>[<expr><name>value</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>ovector</name><index>[<expr><name>value</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>argslen</name><operator>--</operator></expr>;</expr_stmt>   <comment type="block">/* Negate the effect of argslen++ below. */</comment>
      <break>break;</break>

      <case>case <expr><name>DDE_CHAR</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>STDOUT_NL_CODE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>argslen</name> <operator>+=</operator> <name>STDOUT_NL_LEN</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <name>value</name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>argslen</name> <operator>+=</operator> <call><name>ord2utf8</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>

      <default>default:</default>         <comment type="block">/* Should not occur */</comment>
      <case>case <expr><name>DDE_ERROR</name></expr>:</case>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></switch>

    <expr_stmt><expr><name>length</name> <operator>-=</operator> <operator>(</operator><name>string</name> <operator>-</operator> <name>begin</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>string</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>length</name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>argslen</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

<comment type="block">/* Get memory for the argument vector and its strings. */</comment>

<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>argslen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>args</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>argsvector</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>argsvectorlen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>argsvector</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Now reprocess the string and set up the arguments. */</comment>

<expr_stmt><expr><name>argsptr</name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
<expr_stmt><expr><name>argsvectorptr</name> <operator>=</operator> <name>argsvector</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>argsvectorptr</name><operator>++</operator> <operator>=</operator> <name>argsptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>length</name> <operator>=</operator> <name><name>calloutptr</name><operator>-&gt;</operator><name>callout_string_length</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>string</name> <operator>=</operator> <name><name>calloutptr</name><operator>-&gt;</operator><name>callout_string</name></name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>string</name> <operator>==</operator> <literal type="char">'|'</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>argsptr</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>argsvectorptr</name><operator>++</operator> <operator>=</operator> <name>argsptr</name></expr>;</expr_stmt>
    </block_content>}</block></if>

  <if type="elseif">else if <condition>(<expr><operator>*</operator><name>string</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>uint32_t</name></type> <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PCRE2_SPTR</name></type> <name>begin</name> <init>= <expr><name>string</name></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><call><name>decode_dollar_escape</name><argument_list>(<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>string</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>DDE_CAPTURE</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;</operator> <name>capture_top</name></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>capturesize</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>value</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>capturesize</name> <operator>=</operator> <name><name>ovector</name><index>[<expr><name>value</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>ovector</name><index>[<expr><name>value</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>argsptr</name></expr></argument>, <argument><expr><name>subject</name> <operator>+</operator> <name><name>ovector</name><index>[<expr><name>value</name></expr>]</index></name></expr></argument>, <argument><expr><name>capturesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>argsptr</name> <operator>+=</operator> <name>capturesize</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <break>break;</break>

      <case>case <expr><name>DDE_CHAR</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>STDOUT_NL_CODE</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>argsptr</name></expr></argument>, <argument><expr><name>STDOUT_NL</name></expr></argument>, <argument><expr><name>STDOUT_NL_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>argsptr</name> <operator>+=</operator> <name>STDOUT_NL_LEN</name></expr>;</expr_stmt>
        </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>utf</name> <operator>&amp;&amp;</operator> <name>value</name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>ord2utf8</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>argsptr</name></expr></argument>, <argument><expr><name>utf8_buffer</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>argsptr</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
        </block_content>}</block></if>
      <else>else
        <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>argsptr</name><operator>++</operator> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      <break>break;</break>

      <default>default:</default>         <comment type="block">/* Even though this should not occur, the string having */</comment>
      <case>case <expr><name>DDE_ERROR</name></expr>:</case>  <comment type="block">/* been checked above, we need to include the free() */</comment>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* calls so that source checkers do not complain. */</comment>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>argsvector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></switch>

    <expr_stmt><expr><name>length</name> <operator>-=</operator> <operator>(</operator><name>string</name> <operator>-</operator> <name>begin</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if>

  <else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>argsptr</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>string</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <comment type="block">/* Advance along the string */</comment>

  <expr_stmt><expr><name>string</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>length</name><operator>--</operator></expr>;</expr_stmt>
  </block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>argsptr</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>argsvectorptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<comment type="block">/* Running an external command is system-dependent. Handle Windows and VMS as
necessary, otherwise assume fork(). */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>_spawnvp</name><argument_list>(<argument><expr><name>_P_WAIT</name></expr></argument>, <argument><expr><name><name>argsvector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name>argsvector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>__VMS</name></expr></cpp:elif>
  <block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>cmdbuf</name><index>[<expr><literal type="number">500</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>short</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>CLI$M_NOCLISYM</name><operator>|</operator><name>CLI$M_NOLOGNAM</name><operator>|</operator><name>CLI$M_NOKEYPAD</name></expr></init></decl>, <decl><type ref="prev"/><name>status</name></decl>, <decl><type ref="prev"/><name>retstat</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>$DESCRIPTOR</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>cmdbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>cmdbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while <condition>(<expr><name><name>argsvector</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
  <block>{<block_content>
    <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>cmdbuf</name></expr></argument>, <argument><expr><name><name>argsvector</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>cmdbuf</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><name><name>cmd</name><operator>.</operator><name>dsc$w_length</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cmdbuf</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>lib$spawn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>retstat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>status</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><name>retstat</name> <operator>&amp;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* Neither Windows nor VMS */</comment>
<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>fork</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>execv</name><argument_list>(<argument><expr><name><name>argsvector</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>argsvector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Control gets here if there is an error, e.g. a non-existent program */</comment>
  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>pid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>waitpid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* End Windows/VMS/other handling */</comment>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>argsvector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Currently negative return values are not supported, only zero (match
continues) or non-zero (match fails). */</comment>

<return>return <expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_PCRE2GREP_CALLOUT_FORK */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SUPPORT_PCRE2GREP_CALLOUT */</comment>



<comment type="block" format="doxygen">/*************************************************
*     Read a portion of the file into buffer     *
*************************************************/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>fill_buffer</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>frtype</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>,
  <parameter><decl><type><name>BOOL</name></type> <name>input_line_buffered</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>frtype</name></expr>;</expr_stmt>  <comment type="block">/* Avoid warning when not used */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_LIBZ</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>frtype</name> <operator>==</operator> <name>FR_LIBZ</name></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><call><name>gzread</name><argument_list>(<argument><expr><operator>(</operator><name>gzFile</name><operator>)</operator><name>handle</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_LIBBZ2</name></cpp:ifdef>
if <condition>(<expr><name>frtype</name> <operator>==</operator> <name>FR_LIBBZ2</name></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><call><name>BZ2_bzread</name><argument_list>(<argument><expr><operator>(</operator><name>BZFILE</name> <operator>*</operator><operator>)</operator><name>handle</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><operator>(</operator><ternary><condition><expr><name>input_line_buffered</name></expr> ?</condition><then>
  <expr><call><name>read_one_line</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><operator>(</operator><name>FILE</name> <operator>*</operator><operator>)</operator><name>handle</name></expr></argument>)</argument_list></call></expr> </then><else>:
  <expr><call><name>fread</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><operator>(</operator><name>FILE</name> <operator>*</operator><operator>)</operator><name>handle</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*            Grep an individual file             *
*************************************************/</comment>

<comment type="block">/* This is called from grep_or_recurse() below. It uses a buffer that is three
times the value of bufthird. The matching point is never allowed to stray into
the top third of the buffer, thus keeping more of the file available for
context printing or for multiline scanning. For large files, the pointer will
be in the middle third most of the time, so the bottom third is available for
"before" context printing.

Arguments:
  handle       the fopened FILE stream for a normal file
               the gzFile pointer when reading is via libz
               the BZFILE pointer when reading is via libbz2
  frtype       FR_PLAIN, FR_LIBZ, or FR_LIBBZ2
  filename     the file name or NULL (for errors)
  printname    the file name if it is to be printed for each match
               or NULL if the file name is not to be printed
               it cannot be NULL if filenames[_nomatch]_only is set

Returns:       0 if there was at least one match
               1 otherwise (no matches)
               2 if an overlong line is encountered
               3 if there is a read error on a .bz2 file
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pcre2grep</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>frtype</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>printname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>filepos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>int</name></type> <name>linenumber</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>int</name></type> <name>lastmatchnumber</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>int</name></type> <name>count_matched_lines</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lastmatchrestart</name> <init>= <expr><name>main_buffer</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>main_buffer</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>bufflength</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>binary</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>endhyphenpending</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>lines_printed</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>input_line_buffered</name> <init>= <expr><name>line_buffered</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>                    <comment type="block">/* Ensure initialized */</comment>

<comment type="block">/* Do the first read into the start of the buffer and set up the pointer to end
of what we have. In the case of libz, a non-zipped .gz file will be read as a
plain file. However, if a .bz2 file isn't actually bzipped, the first read will
fail. */</comment>

<if_stmt><if>if <condition>(<expr><name>frtype</name> <operator>!=</operator> <name>FR_LIBZ</name> <operator>&amp;&amp;</operator> <name>frtype</name> <operator>!=</operator> <name>FR_LIBBZ2</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>in</name> <operator>=</operator> <operator>(</operator><name>FILE</name> <operator>*</operator><operator>)</operator><name>handle</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>is_file_tty</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>input_line_buffered</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>input_line_buffered</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>bufflength</name> <operator>=</operator> <call><name>fill_buffer</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>frtype</name></expr></argument>, <argument><expr><name>main_buffer</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
  <argument><expr><name>input_line_buffered</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_LIBBZ2</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>frtype</name> <operator>==</operator> <name>FR_LIBBZ2</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>bufflength</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>   <comment type="block">/* Gotcha: bufflength is PCRE2_SIZE */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>main_buffer</name> <operator>+</operator> <name>bufflength</name></expr>;</expr_stmt>

<comment type="block">/* Unless binary-files=text, see if we have a binary file. This uses the same
rule as GNU grep, namely, a search for a binary zero byte near the start of the
file. However, when the newline convention is binary zero, we can't do this. */</comment>

<if_stmt><if>if <condition>(<expr><name>binary_files</name> <operator>!=</operator> <name>BIN_TEXT</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>endlinetype</name> <operator>!=</operator> <name>PCRE2_NEWLINE_NUL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>binary</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>main_buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>bufflength</name> <operator>&gt;</operator> <literal type="number">1024</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1024</literal></expr> </then><else>: <expr><name>bufflength</name></expr></else></ternary></expr></argument>)</argument_list></call>
      <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>binary</name> <operator>&amp;&amp;</operator> <name>binary_files</name> <operator>==</operator> <name>BIN_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Loop while the current pointer is not at the end of the file. For large
files, endptr will be at the end of the buffer when we are in the middle of the
file, but ptr will never get there, because as soon as it gets over 2/3 of the
way, the buffer is shifted left and re-filled. */</comment>

<while>while <condition>(<expr><name>ptr</name> <operator>&lt;</operator> <name>endptr</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>endlinelength</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mrc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>options</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>match</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>line_matched</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>length</name></decl>, <decl><type ref="prev"/><name>linelength</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>startoffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If the -m option set a limit for the number of matched or non-matched
  lines, check it here. A limit of zero means that no matching is ever done.
  For stdin from a file, set the file position. */</comment>

  <if_stmt><if>if <condition>(<expr><name>count_limit</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>count_matched_lines</name> <operator>&gt;=</operator> <name>count_limit</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>frtype</name> <operator>==</operator> <name>FR_PLAIN</name> <operator>&amp;&amp;</operator> <name>filename</name> <operator>==</operator> <name>stdin_name</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_file_tty</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fseek</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>int</name><operator>)</operator><name>filepos</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>count_limit</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
    <break>break;</break>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* At this point, ptr is at the start of a line. We need to find the length
  of the subject string to pass to pcre2_match(). In multiline mode, it is the
  length remainder of the data in the buffer. Otherwise, it is the length of
  the next line, excluding the terminating newline. After matching, we always
  advance by the length of the next line. In multiline mode the PCRE2_FIRSTLINE
  option is used for compiling, so that any match is constrained to be in the
  first line. */</comment>

  <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>end_of_line</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>endptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endlinelength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>linelength</name> <operator>=</operator> <name>t</name> <operator>-</operator> <name>ptr</name> <operator>-</operator> <name>endlinelength</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>length</name> <operator>=</operator> <ternary><condition><expr><name>multiline</name></expr>?</condition><then> <expr><operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>endptr</name> <operator>-</operator> <name>ptr</name><operator>)</operator></expr> </then><else>: <expr><name>linelength</name></expr></else></ternary></expr>;</expr_stmt>

  <comment type="block">/* Check to see if the line we are looking at extends right to the very end
  of the buffer without a line terminator. This means the line is too long to
  handle at the current buffer size. Until the buffer reaches its maximum size,
  try doubling it and reading more data. */</comment>

  <if_stmt><if>if <condition>(<expr><name>endlinelength</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>t</name> <operator>==</operator> <name>main_buffer</name> <operator>+</operator> <name>bufsize</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>bufthird</name> <operator>&lt;</operator> <name>max_bufthird</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_buffer</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>new_bufthird</name> <init>= <expr><literal type="number">2</literal><operator>*</operator><name>bufthird</name></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>new_bufthird</name> <operator>&gt;</operator> <name>max_bufthird</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>new_bufthird</name> <operator>=</operator> <name>max_bufthird</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>new_buffer</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><literal type="number">3</literal><operator>*</operator><name>new_bufthird</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>new_buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
          <argument><expr><literal type="string">"pcre2grep: line %lu%s%s is too long for the internal buffer\n"</literal>
          <literal type="string">"pcre2grep: not enough memory to increase the buffer size to %d\n"</literal></expr></argument>,
          <argument><expr><name>linenumber</name></expr></argument>,
          <argument><expr><ternary><condition><expr><operator>(</operator><name>filename</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" of file "</literal></expr></else></ternary></expr></argument>,
          <argument><expr><ternary><condition><expr><operator>(</operator><name>filename</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><name>filename</name></expr></else></ternary></expr></argument>,
          <argument><expr><name>new_bufthird</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">2</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Copy the data and adjust pointers to the new buffer location. */</comment>

      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_buffer</name></expr></argument>, <argument><expr><name>main_buffer</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bufthird</name> <operator>=</operator> <name>new_bufthird</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>bufsize</name> <operator>=</operator> <literal type="number">3</literal><operator>*</operator><name>bufthird</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>new_buffer</name> <operator>+</operator> <operator>(</operator><name>ptr</name> <operator>-</operator> <name>main_buffer</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>lastmatchrestart</name> <operator>=</operator> <name>new_buffer</name> <operator>+</operator> <operator>(</operator><name>lastmatchrestart</name> <operator>-</operator> <name>main_buffer</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>main_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>main_buffer</name> <operator>=</operator> <name>new_buffer</name></expr>;</expr_stmt>

      <comment type="block">/* Read more data into the buffer and then try to find the line ending
      again. */</comment>

      <expr_stmt><expr><name>bufflength</name> <operator>+=</operator> <call><name>fill_buffer</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>frtype</name></expr></argument>, <argument><expr><name>main_buffer</name> <operator>+</operator> <name>bufflength</name></expr></argument>,
        <argument><expr><name>bufsize</name> <operator>-</operator> <name>bufflength</name></expr></argument>, <argument><expr><name>input_line_buffered</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>main_buffer</name> <operator>+</operator> <name>bufflength</name></expr>;</expr_stmt>
      <continue>continue;</continue>
      </block_content>}</block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
        <argument><expr><literal type="string">"pcre2grep: line %lu%s%s is too long for the internal buffer\n"</literal>
        <literal type="string">"pcre2grep: the maximum buffer size is %d\n"</literal>
        <literal type="string">"pcre2grep: use the --max-buffer-size option to change it\n"</literal></expr></argument>,
        <argument><expr><name>linenumber</name></expr></argument>,
        <argument><expr><ternary><condition><expr><operator>(</operator><name>filename</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" of file "</literal></expr></else></ternary></expr></argument>,
        <argument><expr><ternary><condition><expr><operator>(</operator><name>filename</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><name>filename</name></expr></else></ternary></expr></argument>,
        <argument><expr><name>bufthird</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">2</literal></expr>;</return>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Extra processing for Jeffrey Friedl's debugging. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JFRIEDL_DEBUG</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>jfriedl_XT</name> <operator>||</operator> <name>jfriedl_XR</name></expr>)</condition>
  <block>{<block_content>
<cpp:include>#     <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#     <cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
      <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>start_time</name></decl>, <decl><type ref="prev"/><name>end_time</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>struct</name> <name>timezone</name></name></type> <name>dummy</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>jfriedl_XT</name></expr>)</condition>
      <block>{<block_content>
          <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>newlen</name> <init>= <expr><name>length</name> <operator>*</operator> <name>jfriedl_XT</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>jfriedl_prefix</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>jfriedl_postfix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>newlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition> <block>{<block_content>
                  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><call><name>pcre2grep_exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>endptr</name></expr></argument>, <argument><expr><name>jfriedl_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>endptr</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>jfriedl_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>jfriedl_XT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
                  <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>endptr</name></expr></argument>, <argument><expr><name>orig</name></expr></argument>,  <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><name>endptr</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
          </block_content>}</block></for>
          <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>endptr</name></expr></argument>, <argument><expr><name>jfriedl_postfix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>endptr</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>jfriedl_postfix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>length</name> <operator>=</operator> <name>newlen</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"bad gettimeofday"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>jfriedl_XR</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
          <expr_stmt><expr><name>match</name> <operator>=</operator> <operator>(</operator><call><name>pcre_exec</name><argument_list>(<argument><expr><name><name>patterns</name><operator>-&gt;</operator><name>compiled</name></name></expr></argument>, <argument><expr><name><name>patterns</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
              <argument><expr><name>PCRE2_NOTEMPTY</name></expr></argument>, <argument><expr><name>offsets</name></expr></argument>, <argument><expr><name>offset_size</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>

      <if_stmt><if>if <condition>(<expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>end_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
              <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"bad gettimeofday"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <decl_stmt><decl><type><name>double</name></type> <name>delta</name> <init>= <expr><operator>(</operator><operator>(</operator><name><name>end_time</name><operator>.</operator><name>tv_sec</name></name> <operator>+</operator> <operator>(</operator><name><name>end_time</name><operator>.</operator><name>tv_usec</name></name> <operator>/</operator> <literal type="number">1000000.0</literal><operator>)</operator><operator>)</operator>
                      <operator>-</operator>
                      <operator>(</operator><name><name>start_time</name><operator>.</operator><name>tv_sec</name></name> <operator>+</operator> <operator>(</operator><name><name>start_time</name><operator>.</operator><name>tv_usec</name></name> <operator>/</operator> <literal type="number">1000000.0</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s TIMER[%.4f]\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>match</name></expr> ?</condition><then> <expr><literal type="string">"MATCH"</literal></expr> </then><else>: <expr><literal type="string">"FAIL"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* We come back here after a match when only_matching_count is non-zero, in
  order to find any further matches in the same line. This applies to
  --only-matching, --file-offsets, and --line-offsets. */</comment>

  <label><name>ONLY_MATCHING_RESTART</name>:</label>

  <comment type="block">/* Run through all the patterns until one matches or there is an error other
  than NOMATCH. This code is in a subroutine so that it can be re-used for
  finding subsequent matches when colouring matched lines. After finding one
  match, set PCRE2_NOTEMPTY to disable any further matches of null strings in
  this line. */</comment>

  <expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>match_patterns</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>startoffset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>options</name> <operator>=</operator> <name>PCRE2_NOTEMPTY</name></expr>;</expr_stmt>

  <comment type="block">/* If it's a match or a not-match (as required), do what's wanted. NOTE: Use
  only FWRITE_IGNORE() - which is just a packaged fwrite() that ignores its
  return code - to output data lines, so that binary zeroes are treated as just
  another data character. */</comment>

  <if_stmt><if>if <condition>(<expr><name>match</name> <operator>!=</operator> <name>invert</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>BOOL</name></type> <name>hyphenprinted</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* We've failed if we want a file that doesn't have any matches. */</comment>

    <if_stmt><if>if <condition>(<expr><name>filenames</name> <operator>==</operator> <name>FN_NOMATCH_ONLY</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Remember that this line matched (for counting matched lines) */</comment>

    <expr_stmt><expr><name>line_matched</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

    <comment type="block">/* If all we want is a yes/no answer, we can return immediately. */</comment>

    <if_stmt><if>if <condition>(<expr><name>quiet</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>

    <comment type="block">/* Just count if just counting is wanted. */</comment>

    <if type="elseif">else if <condition>(<expr><name>count_only</name> <operator>||</operator> <name>show_total_count</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>

    <comment type="block">/* When handling a binary file and binary-files==binary, the "binary"
    variable will be set true (it's false in all other cases). In this
    situation we just want to output the file name. No need to scan further. */</comment>

    <if type="elseif">else if <condition>(<expr><name>binary</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"Binary file %s matches"</literal> <name>STDOUT_NL</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if>

    <comment type="block">/* Likewise, if all we want is a file name, there is no need to scan any
    more lines in the file. */</comment>

    <if type="elseif">else if <condition>(<expr><name>filenames</name> <operator>==</operator> <name>FN_MATCH_ONLY</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal> <name>STDOUT_NL</name></expr></argument>, <argument><expr><name>printname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if>

    <comment type="block">/* The --only-matching option prints just the substring that matched,
    and/or one or more captured portions of it, as long as these strings are
    not empty. The --file-offsets and --line-offsets options output offsets for
    the matching substring (all three set only_matching_count non-zero). None
    of these mutually exclusive options prints any context. Afterwards, adjust
    the start and then jump back to look for further matches in the same line.
    If we are in invert mode, however, nothing is printed and we do not restart
    - this could still be useful because the return code is set. */</comment>

    <if type="elseif">else if <condition>(<expr><name>only_matching_count</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>invert</name></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>oldstartoffset</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>printname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%s:"</literal></expr></argument>, <argument><expr><name>printname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>number</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%lu:"</literal></expr></argument>, <argument><expr><name>linenumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Handle --line-offsets */</comment>

        <if_stmt><if>if <condition>(<expr><name>line_offsets</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%d,%d"</literal> <name>STDOUT_NL</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>+</operator> <name><name>offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name>ptr</name><operator>)</operator></expr></argument>,
            <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

        <comment type="block">/* Handle --file-offsets */</comment>

        <if type="elseif">else if <condition>(<expr><name>file_offsets</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%d,%d"</literal> <name>STDOUT_NL</name></expr></argument>,
            <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>filepos</name> <operator>+</operator> <name>ptr</name> <operator>+</operator> <name><name>offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name>ptr</name><operator>)</operator></expr></argument>,
            <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

        <comment type="block">/* Handle --output (which has already been syntax checked) */</comment>

        <if type="elseif">else if <condition>(<expr><name>output_text</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><call><name>display_output_text</name><argument_list>(<argument><expr><operator>(</operator><name>PCRE2_SPTR</name><operator>)</operator><name>output_text</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
              <argument><expr><operator>(</operator><name>PCRE2_SPTR</name><operator>)</operator><name>ptr</name></expr></argument>, <argument><expr><name>offsets</name></expr></argument>, <argument><expr><name>mrc</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>printname</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
              <name>number</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>STDOUT_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></if>

        <comment type="block">/* Handle --only-matching, which may occur many times */</comment>

        <else>else
          <block>{<block_content>
          <decl_stmt><decl><type><name>BOOL</name></type> <name>printed</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>omstr</name> <modifier>*</modifier></type><name>om</name></decl>;</decl_stmt>

          <for>for <control>(<init><expr><name>om</name> <operator>=</operator> <name>only_matching</name></expr>;</init> <condition><expr><name>om</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>om</name> <operator>=</operator> <name><name>om</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
            <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>om</name><operator>-&gt;</operator><name>groupnum</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>&lt;</operator> <name>mrc</name></expr>)</condition>
              <block>{<block_content>
              <decl_stmt><decl><type><name>int</name></type> <name>plen</name> <init>= <expr><name><name>offsets</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>offsets</name><index>[<expr><literal type="number">2</literal><operator>*</operator><name>n</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
              <if_stmt><if>if <condition>(<expr><name>plen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>printed</name> <operator>&amp;&amp;</operator> <name>om_separator</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>om_separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>print_match</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name><name>offsets</name><index>[<expr><name>n</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>printed</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

          <if_stmt><if>if <condition>(<expr><name>printed</name> <operator>||</operator> <name>printname</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>number</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>STDOUT_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          </block_content>}</block></else></if_stmt>

        <comment type="block">/* Prepare to repeat to find the next match in the line. */</comment>

        <expr_stmt><expr><name>match</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>line_buffered</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>                      <comment type="block">/* Had some success */</comment>

        <comment type="block">/* If the pattern contained a lookbehind that included \K, it is
        possible that the end of the match might be at or before the actual
        starting offset we have just used. In this case, start one character
        further on. */</comment>

        <expr_stmt><expr><name>startoffset</name> <operator>=</operator> <name><name>offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>    <comment type="block">/* Restart after the match */</comment>
        <expr_stmt><expr><name>oldstartoffset</name> <operator>=</operator> <call><name>pcre2_get_startchar</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>startoffset</name> <operator>&lt;=</operator> <name>oldstartoffset</name></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>startoffset</name> <operator>&gt;=</operator> <name>length</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>END_ONE_MATCH</name>;</goto></block_content></block></if></if_stmt>  <comment type="block">/* Were at end */</comment>
          <expr_stmt><expr><name>startoffset</name> <operator>=</operator> <name>oldstartoffset</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <while>while <condition>(<expr><operator>(</operator><name><name>ptr</name><index>[<expr><name>startoffset</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>startoffset</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>

        <comment type="block">/* If the current match ended past the end of the line (only possible
        in multiline mode), we must move on to the line in which it did end
        before searching for more matches. */</comment>

        <while>while <condition>(<expr><name>startoffset</name> <operator>&gt;</operator> <name>linelength</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>linelength</name> <operator>+</operator> <name>endlinelength</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>filepos</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>linelength</name> <operator>+</operator> <name>endlinelength</name><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>linenumber</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>startoffset</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>linelength</name> <operator>+</operator> <name>endlinelength</name><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>end_of_line</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>endptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endlinelength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>linelength</name> <operator>=</operator> <name>t</name> <operator>-</operator> <name>ptr</name> <operator>-</operator> <name>endlinelength</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>endptr</name> <operator>-</operator> <name>ptr</name><operator>)</operator></expr>;</expr_stmt>
          </block_content>}</block></while>

        <goto>goto <name>ONLY_MATCHING_RESTART</name>;</goto>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if>

    <comment type="block">/* This is the default case when none of the above options is set. We print
    the matching lines(s), possibly preceded and/or followed by other lines of
    context. */</comment>

    <else>else
      <block>{<block_content>
      <expr_stmt><expr><name>lines_printed</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

      <comment type="block">/* See if there is a requirement to print some "after" lines from a
      previous match. We never print any overlaps. */</comment>

      <if_stmt><if>if <condition>(<expr><name>after_context</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>lastmatchnumber</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>ellength</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>linecount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>lastmatchrestart</name></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>ptr</name> <operator>&amp;&amp;</operator> <name>linecount</name> <operator>&lt;</operator> <name>after_context</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>end_of_line</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ellength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>linecount</name><operator>++</operator></expr>;</expr_stmt>
          </block_content>}</block></while>

        <comment type="block">/* It is important to advance lastmatchrestart during this printing so
        that it interacts correctly with any "before" printing below. Print
        each line's data using fwrite() in case there are binary zeroes. */</comment>

        <while>while <condition>(<expr><name>lastmatchrestart</name> <operator>&lt;</operator> <name>p</name></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pp</name> <init>= <expr><name>lastmatchrestart</name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>printname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%s-"</literal></expr></argument>, <argument><expr><name>printname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>number</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%lu-"</literal></expr></argument>, <argument><expr><name>lastmatchnumber</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>pp</name> <operator>=</operator> <call><name>end_of_line</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>endptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ellength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>FWRITE_IGNORE</name><argument_list>(<argument><expr><name>lastmatchrestart</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pp</name> <operator>-</operator> <name>lastmatchrestart</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>lastmatchrestart</name> <operator>=</operator> <name>pp</name></expr>;</expr_stmt>
          </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>lastmatchrestart</name> <operator>!=</operator> <name>ptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hyphenpending</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* If there were non-contiguous lines printed above, insert hyphens. */</comment>

      <if_stmt><if>if <condition>(<expr><name>hyphenpending</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"--"</literal> <name>STDOUT_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>hyphenpending</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>hyphenprinted</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* See if there is a requirement to print some "before" lines for this
      match. Again, don't print overlaps. */</comment>

      <if_stmt><if>if <condition>(<expr><name>before_context</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>linecount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>main_buffer</name> <operator>&amp;&amp;</operator>
               <operator>(</operator><name>lastmatchnumber</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>p</name> <operator>&gt;</operator> <name>lastmatchrestart</name><operator>)</operator> <operator>&amp;&amp;</operator>
               <name>linecount</name> <operator>&lt;</operator> <name>before_context</name></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><name>linecount</name><operator>++</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>previous_line</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>main_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></while>

        <if_stmt><if>if <condition>(<expr><name>lastmatchnumber</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p</name> <operator>&gt;</operator> <name>lastmatchrestart</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hyphenprinted</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"--"</literal> <name>STDOUT_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>ptr</name></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>ellength</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pp</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>printname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%s-"</literal></expr></argument>, <argument><expr><name>printname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <if_stmt><if>if <condition>(<expr><name>number</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%lu-"</literal></expr></argument>, <argument><expr><name>linenumber</name> <operator>-</operator> <name>linecount</name><operator>--</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>pp</name> <operator>=</operator> <call><name>end_of_line</name><argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>endptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ellength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>FWRITE_IGNORE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pp</name> <operator>-</operator> <name>p</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pp</name></expr>;</expr_stmt>
          </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>

      <comment type="block">/* Now print the matching line(s); ensure we set hyphenpending at the end
      of the file if any context lines are being output. */</comment>

      <if_stmt><if>if <condition>(<expr><name>after_context</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>before_context</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>endhyphenpending</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>printname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%s:"</literal></expr></argument>, <argument><expr><name>printname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>number</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%lu:"</literal></expr></argument>, <argument><expr><name>linenumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <comment type="block">/* This extra option, for Jeffrey Friedl's debugging requirements,
      replaces the matched string, or a specific captured string if it exists,
      with X. When this happens, colouring is ignored. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JFRIEDL_DEBUG</name></cpp:ifdef>
      <if_stmt><if>if <condition>(<expr><name>S_arg</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>S_arg</name> <operator>&lt;</operator> <name>mrc</name></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>first</name> <init>= <expr><name>S_arg</name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>last</name>  <init>= <expr><name>first</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>FWRITE_IGNORE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>offsets</name><index>[<expr><name>first</name></expr>]</index></name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"X"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FWRITE_IGNORE</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name><name>offsets</name><index>[<expr><name>last</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>linelength</name> <operator>-</operator> <name><name>offsets</name><index>[<expr><name>last</name></expr>]</index></name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
      <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <comment type="block">/* In multiline mode, or if colouring, we have to split the line(s) up
      and search for further matches, but not of course if the line is a
      non-match. In multiline mode this is necessary in case there is another
      match that spans the end of the current line. When colouring we want to
      colour all matches. */</comment>

      if <condition>(<expr><operator>(</operator><name>multiline</name> <operator>||</operator> <name>do_colour</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>invert</name></expr>)</condition>
        <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>plength</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>endprevious</name></decl>;</decl_stmt>

        <comment type="block">/* The use of \K may make the end offset earlier than the start. In
        this situation, swap them round. */</comment>

        <if_stmt><if>if <condition>(<expr><name><name>offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <name><name>offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
          <block>{<block_content>
          <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>temp</name> <init>= <expr><name><name>offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>FWRITE_IGNORE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>print_match</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name><name>offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
          <block>{<block_content>
          <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>oldstartoffset</name> <init>= <expr><call><name>pcre2_get_startchar</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><name>endprevious</name> <operator>=</operator> <name><name>offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>startoffset</name> <operator>=</operator> <name>endprevious</name></expr>;</expr_stmt>  <comment type="block">/* Advance after previous match. */</comment>

          <comment type="block">/* If the pattern contained a lookbehind that included \K, it is
          possible that the end of the match might be at or before the actual
          starting offset we have just used. In this case, start one character
          further on. */</comment>

          <if_stmt><if>if <condition>(<expr><name>startoffset</name> <operator>&lt;=</operator> <name>oldstartoffset</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>startoffset</name> <operator>=</operator> <name>oldstartoffset</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>utf</name></expr>)</condition><block type="pseudo"><block_content> <while>while <condition>(<expr><operator>(</operator><name><name>ptr</name><index>[<expr><name>startoffset</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>startoffset</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

          <comment type="block">/* If the current match ended past the end of the line (only possible
          in multiline mode), we must move on to the line in which it did end
          before searching for more matches. Because the PCRE2_FIRSTLINE option
          is set, the start of the match will always be before the first
          newline sequence. */</comment>

          <while>while <condition>(<expr><name>startoffset</name> <operator>&gt;</operator> <name>linelength</name> <operator>+</operator> <name>endlinelength</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>linelength</name> <operator>+</operator> <name>endlinelength</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>filepos</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>linelength</name> <operator>+</operator> <name>endlinelength</name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>linenumber</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>startoffset</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>linelength</name> <operator>+</operator> <name>endlinelength</name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>endprevious</name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>linelength</name> <operator>+</operator> <name>endlinelength</name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>end_of_line</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>endptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endlinelength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>linelength</name> <operator>=</operator> <name>t</name> <operator>-</operator> <name>ptr</name> <operator>-</operator> <name>endlinelength</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><operator>(</operator><name>endptr</name> <operator>-</operator> <name>ptr</name><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></while>

          <comment type="block">/* If startoffset is at the exact end of the line it means this
          complete line was the final part of the match, so there is nothing
          more to do. */</comment>

          <if_stmt><if>if <condition>(<expr><name>startoffset</name> <operator>==</operator> <name>linelength</name> <operator>+</operator> <name>endlinelength</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

          <comment type="block">/* Otherwise, run a match from within the final line, and if found,
          loop for any that may follow. */</comment>

          <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>match_patterns</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>startoffset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mrc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

          <comment type="block">/* The use of \K may make the end offset earlier than the start. In
          this situation, swap them round. */</comment>

          <if_stmt><if>if <condition>(<expr><name><name>offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <name><name>offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
            <decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>temp</name> <init>= <expr><name><name>offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

          <expr_stmt><expr><call><name>FWRITE_IGNORE</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name>endprevious</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name>endprevious</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>print_match</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name><name>offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>offsets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>

        <comment type="block">/* In multiline mode, we may have already printed the complete line
        and its line-ending characters (if they matched the pattern), so there
        may be no more to print. */</comment>

        <expr_stmt><expr><name>plength</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>linelength</name> <operator>+</operator> <name>endlinelength</name><operator>)</operator> <operator>-</operator> <name>endprevious</name><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>plength</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>FWRITE_IGNORE</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name>endprevious</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>plength</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>

      <comment type="block">/* Not colouring or multiline; no need to search for further matches. */</comment>

      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>FWRITE_IGNORE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>linelength</name> <operator>+</operator> <name>endlinelength</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      </block_content>}</block></else></if_stmt>

    <comment type="block">/* End of doing what has to be done for a match. If --line-buffered was
    given, flush the output. */</comment>

    <if_stmt><if>if <condition>(<expr><name>line_buffered</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* Had some success */</comment>

    <comment type="block">/* Remember where the last match happened for after_context. We remember
    where we are about to restart, and that line's number. */</comment>

    <expr_stmt><expr><name>lastmatchrestart</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <name>linelength</name> <operator>+</operator> <name>endlinelength</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>lastmatchnumber</name> <operator>=</operator> <name>linenumber</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* If a line was printed and we are now at the end of the file and the last
    line had no newline, output one. */</comment>

    <if_stmt><if>if <condition>(<expr><name>lines_printed</name> <operator>&amp;&amp;</operator> <name>lastmatchrestart</name> <operator>&gt;=</operator> <name>endptr</name> <operator>&amp;&amp;</operator> <name>endlinelength</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>write_final_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* For a match in multiline inverted mode (which of course did not cause
  anything to be printed), we have to move on to the end of the match before
  proceeding. */</comment>

  <if_stmt><if>if <condition>(<expr><name>multiline</name> <operator>&amp;&amp;</operator> <name>invert</name> <operator>&amp;&amp;</operator> <name>match</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ellength</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endmatch</name> <init>= <expr><name>ptr</name> <operator>+</operator> <name><name>offsets</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>t</name> <operator>&lt;</operator> <name>endmatch</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>end_of_line</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>endptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ellength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;=</operator> <name>endmatch</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>linenumber</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if> <else>else<block type="pseudo"><block_content> <break>break;</break></block_content></block></else></if_stmt>
      </block_content>}</block></while>
    <expr_stmt><expr><name>endmatch</name> <operator>=</operator> <call><name>end_of_line</name><argument_list>(<argument><expr><name>endmatch</name></expr></argument>, <argument><expr><name>endptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ellength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>linelength</name> <operator>=</operator> <name>endmatch</name> <operator>-</operator> <name>ptr</name> <operator>-</operator> <name>ellength</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Advance to after the newline and increment the line number. The file
  offset to the current line is maintained in filepos. */</comment>

  <label><name>END_ONE_MATCH</name>:</label>
  <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>linelength</name> <operator>+</operator> <name>endlinelength</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>filepos</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>linelength</name> <operator>+</operator> <name>endlinelength</name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>linenumber</name><operator>++</operator></expr>;</expr_stmt>

  <comment type="block">/* If there was at least one match (or a non-match, as required) in the line,
  increment the count for the -m option. */</comment>

  <if_stmt><if>if <condition>(<expr><name>line_matched</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count_matched_lines</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* If input is line buffered, and the buffer is not yet full, read another
  line and add it into the buffer. */</comment>

  <if_stmt><if>if <condition>(<expr><name>input_line_buffered</name> <operator>&amp;&amp;</operator> <name>bufflength</name> <operator>&lt;</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><name>bufsize</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>add</name> <init>= <expr><call><name>read_one_line</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>bufsize</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <name>main_buffer</name><operator>)</operator></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>bufflength</name> <operator>+=</operator> <name>add</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>endptr</name> <operator>+=</operator> <name>add</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* If we haven't yet reached the end of the file (the buffer is full), and
  the current point is in the top 1/3 of the buffer, slide the buffer down by
  1/3 and refill it. Before we do this, if some unprinted "after" lines are
  about to be lost, print them. */</comment>

  <if_stmt><if>if <condition>(<expr><name>bufflength</name> <operator>&gt;=</operator> <operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><name>bufsize</name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>&gt;</operator> <name>main_buffer</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>bufthird</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>after_context</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <name>lastmatchnumber</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <name>lastmatchrestart</name> <operator>&lt;</operator> <name>main_buffer</name> <operator>+</operator> <name>bufthird</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>do_after_lines</name><argument_list>(<argument><expr><name>lastmatchnumber</name></expr></argument>, <argument><expr><name>lastmatchrestart</name></expr></argument>, <argument><expr><name>endptr</name></expr></argument>, <argument><expr><name>printname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>lastmatchnumber</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* Indicates no after lines pending */</comment>
      </block_content>}</block></if></if_stmt>

    <comment type="block">/* Now do the shuffle */</comment>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memmove</name><argument_list>(<argument><expr><name>main_buffer</name></expr></argument>, <argument><expr><name>main_buffer</name> <operator>+</operator> <name>bufthird</name></expr></argument>, <argument><expr><literal type="number">2</literal><operator>*</operator><name>bufthird</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>-=</operator> <name>bufthird</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>bufflength</name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><name>bufthird</name> <operator>+</operator> <call><name>fill_buffer</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>frtype</name></expr></argument>,
      <argument><expr><name>main_buffer</name> <operator>+</operator> <literal type="number">2</literal><operator>*</operator><name>bufthird</name></expr></argument>, <argument><expr><name>bufthird</name></expr></argument>, <argument><expr><name>input_line_buffered</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>main_buffer</name> <operator>+</operator> <name>bufflength</name></expr>;</expr_stmt>

    <comment type="block">/* Adjust any last match point */</comment>

    <if_stmt><if>if <condition>(<expr><name>lastmatchnumber</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lastmatchrestart</name> <operator>-=</operator> <name>bufthird</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>     <comment type="block">/* Loop through the whole file */</comment>

<comment type="block">/* End of file; print final "after" lines if wanted; do_after_lines sets
hyphenpending if it prints something. */</comment>

<if_stmt><if>if <condition>(<expr><name>only_matching_count</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>count_only</name><operator>|</operator><name>show_total_count</name><operator>)</operator></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>do_after_lines</name><argument_list>(<argument><expr><name>lastmatchnumber</name></expr></argument>, <argument><expr><name>lastmatchrestart</name></expr></argument>, <argument><expr><name>endptr</name></expr></argument>, <argument><expr><name>printname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>hyphenpending</name> <operator>|=</operator> <name>endhyphenpending</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Print the file name if we are looking for those without matches and there
were none. If we found a match, we won't have got this far. */</comment>

<if_stmt><if>if <condition>(<expr><name>filenames</name> <operator>==</operator> <name>FN_NOMATCH_ONLY</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal> <name>STDOUT_NL</name></expr></argument>, <argument><expr><name>printname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Print the match count if wanted */</comment>

<if_stmt><if>if <condition>(<expr><name>count_only</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>quiet</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>omit_zero_count</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>printname</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>filenames</name> <operator>!=</operator> <name>FN_NONE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%s:"</literal></expr></argument>, <argument><expr><name>printname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%lu"</literal> <name>STDOUT_NL</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>counts_printed</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>total_count</name> <operator>+=</operator> <name>count</name></expr>;</expr_stmt>   <comment type="block">/* Can be set without count_only */</comment>
<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*     Grep a file or recurse into a directory    *
*************************************************/</comment>

<comment type="block">/* Given a path name, if it's a directory, scan all the files if we are
recursing; if it's a file, grep it.

Arguments:
  pathname          the path to investigate
  dir_recurse       TRUE if recursing is wanted (-r or -drecurse)
  only_one_at_top   TRUE if the path is the only one at toplevel

Returns:  -1 the file/directory was skipped
           0 if there was at least one match
           1 if there were no matches
           2 there was some kind of error

However, file opening failures are suppressed if "silent" is set.
*/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>grep_or_recurse</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>dir_recurse</name></decl></parameter>, <parameter><decl><type><name>BOOL</name></type> <name>only_one_at_top</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>frtype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>handle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lastcomp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>           <comment type="block">/* Ensure initialized */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_LIBZ</name></cpp:ifdef>
<decl_stmt><decl><type><name>gzFile</name></type> <name>ingz</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_LIBBZ2</name></cpp:ifdef>
<decl_stmt><decl><type><name>BZFILE</name> <modifier>*</modifier></type><name>inbz2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_LIBZ</name> <operator>||</operator> <name>defined</name> <name>SUPPORT_LIBBZ2</name></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>pathlen</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NATIVE_ZOS</name></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>zos_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>zos_test_file</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* If the file name is "-" we scan stdin */</comment>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <return>return <expr><call><name>pcre2grep</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>, <argument><expr><name>FR_PLAIN</name></expr></argument>, <argument><expr><name>stdin_name</name></expr></argument>,
    <argument><expr><ternary><condition><expr><operator>(</operator><name>filenames</name> <operator>&gt;</operator> <name>FN_DEFAULT</name> <operator>||</operator> <operator>(</operator><name>filenames</name> <operator>==</operator> <name>FN_DEFAULT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>only_one_at_top</name><operator>)</operator><operator>)</operator></expr>?</condition><then>
      <expr><name>stdin_name</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Inclusion and exclusion: --include-dir and --exclude-dir apply only to
directories, whereas --include and --exclude apply to everything else. The test
is against the final component of the path. */</comment>

<expr_stmt><expr><name>lastcomp</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>FILESEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lastcomp</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>lastcomp</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then> <expr><name>pathname</name></expr> </then><else>: <expr><name>lastcomp</name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<comment type="block">/* If the file is a directory, skip if not recursing or if explicitly excluded.
Otherwise, scan the directory and recurse for each path within it. The scanning
code is localized so it can be made system-specific. */</comment>


<comment type="block">/* For z/OS, determine the file type. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NATIVE_ZOS</name></expr></cpp:if>
<expr_stmt><expr><name>zos_test_file</name> <operator>=</operator>  <call><name>fopen</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>,<argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>zos_test_file</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
   <block>{<block_content>
   <if_stmt><if>if <condition>(<expr><operator>!</operator><name>silent</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: failed to test next file %s\n"</literal></expr></argument>,
     <argument><expr><name>pathname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
   <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
   </block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>zos_type</name> <operator>=</operator> <call><name>identifyzosfiletype</name> <argument_list>(<argument><expr><name>zos_test_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name> <argument_list>(<argument><expr><name>zos_test_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Handle a PDS in separate code */</comment>

<if_stmt><if>if <condition>(<expr><name>zos_type</name> <operator>==</operator> <name>__ZOS_PDS</name> <operator>||</operator> <name>zos_type</name> <operator>==</operator> <name>__ZOS_PDSE</name></expr>)</condition>
   <block>{<block_content>
   <return>return <expr><call><name>travelonpdsdir</name> <argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>only_one_at_top</name></expr></argument>)</argument_list></call></expr>;</return>
   </block_content>}</block></if>

<comment type="block">/* Deal with regular files in the normal way below. These types are:
   zos_type == __ZOS_PDS_MEMBER
   zos_type == __ZOS_PS
   zos_type == __ZOS_VSAM_KSDS
   zos_type == __ZOS_VSAM_ESDS
   zos_type == __ZOS_VSAM_RRDS
*/</comment>

<comment type="block">/* Handle a z/OS directory using common code. */</comment>

<if type="elseif">else if <condition>(<expr><name>zos_type</name> <operator>==</operator> <name>__ZOS_HFS</name></expr>)</condition>
 <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* NATIVE_ZOS */</comment>


<comment type="block">/* Handle directories: common code for all OS */</comment>

<if_stmt><if>if <condition>(<expr><call><name>isdirectory</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>dee_action</name> <operator>==</operator> <name>dee_SKIP</name> <operator>||</operator>
      <operator>!</operator><call><name>test_incexc</name><argument_list>(<argument><expr><name>lastcomp</name></expr></argument>, <argument><expr><name>include_dir_patterns</name></expr></argument>, <argument><expr><name>exclude_dir_patterns</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>dee_action</name> <operator>==</operator> <name>dee_RECURSE</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>FNBUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nextfile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>directory_type</name> <modifier>*</modifier></type><name>dir</name> <init>= <expr><call><name>opendirectory</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>silent</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Failed to open directory %s: %s\n"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>,
          <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <return>return <expr><literal type="number">2</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>nextfile</name> <operator>=</operator> <call><name>readdirectory</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>frc</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>fnlength</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>nextfile</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>fnlength</name> <operator>&gt;</operator> <name>FNBUFSIZ</name></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: recursive filename is too long\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <break>break;</break>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"%s%c%s"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>FILESEP</name></expr></argument>, <argument><expr><name>nextfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>frc</name> <operator>=</operator> <call><name>grep_or_recurse</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>dir_recurse</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>frc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>frc</name></expr>;</expr_stmt></block_content></block></if>
       <if type="elseif">else if <condition>(<expr><name>frc</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></while>

    <expr_stmt><expr><call><name>closedirectory</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rc</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><call><name>iswild</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nextfile</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>directory_type</name> <modifier>*</modifier></type><name>dir</name> <init>= <expr><call><name>opendirectory</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <for>for <control>(<init><expr><name>nextfile</name> <operator>=</operator> <name>name</name> <operator>=</operator> <name>pathname</name></expr>;</init> <condition><expr><operator>*</operator><name>nextfile</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>nextfile</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>nextfile</name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <operator>*</operator><name>nextfile</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>name</name> <operator>=</operator> <name>nextfile</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
  <expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <while>while <condition>(<expr><operator>(</operator><name>nextfile</name> <operator>=</operator> <call><name>readdirectory</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>frc</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"%.512s%.128s"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>nextfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>frc</name> <operator>=</operator> <call><name>grep_or_recurse</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>dir_recurse</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>frc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>frc</name></expr>;</expr_stmt></block_content></block></if>
     <if type="elseif">else if <condition>(<expr><name>frc</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>

  <expr_stmt><expr><call><name>closedirectory</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>rc</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NATIVE_ZOS</name></expr></cpp:if>
 </block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* If the file is not a directory, check for a regular file, and if it is not,
skip it if that's been requested. Otherwise, check for an explicit inclusion or
exclusion. */</comment>

<if type="elseif">else if <condition>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>NATIVE_ZOS</name></expr></cpp:if>
        <expr><operator>(</operator><name>zos_type</name> <operator>==</operator> <name>__ZOS_NOFILE</name> <operator>&amp;&amp;</operator> <name>DEE_action</name> <operator>==</operator> <name>DEE_SKIP</name><operator>)</operator> <operator>||</operator>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* all other OS */</comment>
        <operator>(</operator><operator>!</operator><call><name>isregfile</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>DEE_action</name> <operator>==</operator> <name>DEE_SKIP</name><operator>)</operator> <operator>||</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <operator>!</operator><call><name>test_incexc</name><argument_list>(<argument><expr><name>lastcomp</name></expr></argument>, <argument><expr><name>include_patterns</name></expr></argument>, <argument><expr><name>exclude_patterns</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* File skipped */</comment>

<comment type="block">/* Control reaches here if we have a regular file, or if we have a directory
and recursion or skipping was not requested, or if we have anything else and
skipping was not requested. The scan proceeds. If this is the first and only
argument at top level, we don't show the file name, unless we are only showing
the file name, or the filename was forced (-H). */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUPPORT_LIBZ</name> <operator>||</operator> <name>defined</name> <name>SUPPORT_LIBBZ2</name></expr></cpp:if>
<expr_stmt><expr><name>pathlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Open using zlib if it is supported and the file name ends with .gz. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_LIBZ</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>pathlen</name> <operator>&gt;</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>pathname</name> <operator>+</operator> <name>pathlen</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">".gz"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>ingz</name> <operator>=</operator> <call><name>gzopen</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>ingz</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>silent</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Failed to open %s: %s\n"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>,
        <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">2</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>handle</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>ingz</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>frtype</name> <operator>=</operator> <name>FR_LIBZ</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Otherwise open with bz2lib if it is supported and the name ends with .bz2. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_LIBBZ2</name></cpp:ifdef>
if <condition>(<expr><name>pathlen</name> <operator>&gt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>pathname</name> <operator>+</operator> <name>pathlen</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">".bz2"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>inbz2</name> <operator>=</operator> <call><name>BZ2_bzopen</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>handle</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>inbz2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>frtype</name> <operator>=</operator> <name>FR_LIBBZ2</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Otherwise use plain fopen(). The label is so that we can come back here if
an attempt to read a .bz2 file indicates that it really is a plain file. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_LIBBZ2</name></cpp:ifdef>
<label><name>PLAIN_FILE</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
  <expr_stmt><expr><name>in</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>handle</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>in</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>frtype</name> <operator>=</operator> <name>FR_PLAIN</name></expr>;</expr_stmt>
  </block_content>}</block></block_content></block></else></if_stmt>

<comment type="block">/* All the opening methods return errno when they fail. */</comment>

<if_stmt><if>if <condition>(<expr><name>handle</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>silent</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Failed to open %s: %s\n"</literal></expr></argument>, <argument><expr><name>pathname</name></expr></argument>,
      <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">2</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Now grep the file */</comment>

<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pcre2grep</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>frtype</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>filenames</name> <operator>&gt;</operator> <name>FN_DEFAULT</name> <operator>||</operator>
  <operator>(</operator><name>filenames</name> <operator>==</operator> <name>FN_DEFAULT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>only_one_at_top</name><operator>)</operator><operator>)</operator></expr>?</condition><then> <expr><name>pathname</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Close in an appropriate manner. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_LIBZ</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>frtype</name> <operator>==</operator> <name>FR_LIBZ</name></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>gzclose</name><argument_list>(<argument><expr><name>ingz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* If it is a .bz2 file and the result is 3, it means that the first attempt to
read failed. If the error indicates that the file isn't in fact bzipped, try
again as a normal file. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_LIBBZ2</name></cpp:ifdef>
if <condition>(<expr><name>frtype</name> <operator>==</operator> <name>FR_LIBBZ2</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>errnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name> <init>= <expr><call><name>BZ2_bzerror</name><argument_list>(<argument><expr><name>inbz2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>errnum</name> <operator>==</operator> <name>BZ_DATA_ERROR_MAGIC</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>BZ2_bzclose</name><argument_list>(<argument><expr><name>inbz2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>PLAIN_FILE</name>;</goto>
      </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><name>silent</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Failed to read %s using bzlib: %s\n"</literal></expr></argument>,
        <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>    <comment type="block">/* The normal "something went wrong" code */</comment>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>BZ2_bzclose</name><argument_list>(<argument><expr><name>inbz2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Normal file close */</comment>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<comment type="block">/* Pass back the yield from pcre2grep(). */</comment>

<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*    Handle a single-letter, no data option      *
*************************************************/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>handle_option</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>letter</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch<condition>(<expr><name>letter</name></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><name>N_FOFFSETS</name></expr>:</case> <expr_stmt><expr><name>file_offsets</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>N_HELP</name></expr>:</case> <expr_stmt><expr><call><name>help</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>pcre2grep_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break> <comment type="block">/* Stops compiler warning */</comment>
  <case>case <expr><name>N_LBUFFER</name></expr>:</case> <expr_stmt><expr><name>line_buffered</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>N_LOFFSETS</name></expr>:</case> <expr_stmt><expr><name>line_offsets</name> <operator>=</operator> <name>number</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><name>N_NOJIT</name></expr>:</case> <expr_stmt><expr><name>use_jit</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'a'</literal></expr>:</case> <expr_stmt><expr><name>binary_files</name> <operator>=</operator> <name>BIN_TEXT</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'c'</literal></expr>:</case> <expr_stmt><expr><name>count_only</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'F'</literal></expr>:</case> <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_LITERAL</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'H'</literal></expr>:</case> <expr_stmt><expr><name>filenames</name> <operator>=</operator> <name>FN_FORCE</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'I'</literal></expr>:</case> <expr_stmt><expr><name>binary_files</name> <operator>=</operator> <name>BIN_NOMATCH</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'h'</literal></expr>:</case> <expr_stmt><expr><name>filenames</name> <operator>=</operator> <name>FN_NONE</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'i'</literal></expr>:</case> <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_CASELESS</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'l'</literal></expr>:</case> <expr_stmt><expr><name>omit_zero_count</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <expr_stmt><expr><name>filenames</name> <operator>=</operator> <name>FN_MATCH_ONLY</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'L'</literal></expr>:</case> <expr_stmt><expr><name>filenames</name> <operator>=</operator> <name>FN_NOMATCH_ONLY</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'M'</literal></expr>:</case> <expr_stmt><expr><name>multiline</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_MULTILINE</name><operator>|</operator><name>PCRE2_FIRSTLINE</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'n'</literal></expr>:</case> <expr_stmt><expr><name>number</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break>

  <case>case <expr><literal type="char">'o'</literal></expr>:</case>
  <expr_stmt><expr><name>only_matching_last</name> <operator>=</operator> <call><name>add_number</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>only_matching_last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>only_matching</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>only_matching</name> <operator>=</operator> <name>only_matching_last</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <break>break;</break>

  <case>case <expr><literal type="char">'q'</literal></expr>:</case> <expr_stmt><expr><name>quiet</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'r'</literal></expr>:</case> <expr_stmt><expr><name>dee_action</name> <operator>=</operator> <name>dee_RECURSE</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'s'</literal></expr>:</case> <expr_stmt><expr><name>silent</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'t'</literal></expr>:</case> <expr_stmt><expr><name>show_total_count</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'u'</literal></expr>:</case> <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_UTF</name></expr>;</expr_stmt> <expr_stmt><expr><name>utf</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'U'</literal></expr>:</case> <expr_stmt><expr><name>options</name> <operator>|=</operator> <name>PCRE2_UTF</name><operator>|</operator><name>PCRE2_MATCH_INVALID_UTF</name></expr>;</expr_stmt> <expr_stmt><expr><name>utf</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'v'</literal></expr>:</case> <expr_stmt><expr><name>invert</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'w'</literal></expr>:</case> <expr_stmt><expr><name>extra_options</name> <operator>|=</operator> <name>PCRE2_EXTRA_MATCH_WORD</name></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="char">'x'</literal></expr>:</case> <expr_stmt><expr><name>extra_options</name> <operator>|=</operator> <name>PCRE2_EXTRA_MATCH_LINE</name></expr>;</expr_stmt> <break>break;</break>

  <case>case <expr><literal type="char">'V'</literal></expr>:</case>
    <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcre2_config</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_VERSION</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep version %s"</literal> <name>STDOUT_NL</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
  <expr_stmt><expr><call><name>pcre2grep_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <break>break;</break>

  <default>default:</default>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Unknown option -%c\n"</literal></expr></argument>, <argument><expr><name>letter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pcre2grep_exit</name><argument_list>(<argument><expr><call><name>usage</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></switch>

<return>return <expr><name>options</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*          Construct printed ordinal             *
*************************************************/</comment>

<comment type="block">/* This turns a number into "1st", "3rd", etc. */</comment>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ordin</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">14</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name>n</name> <operator>%=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <literal type="number">11</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;=</operator> <literal type="number">13</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name>n</name><operator>%</operator><literal type="number">10</literal></expr>)</condition>
  <block>{<block_content>
  <case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"st"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"nd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"rd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  <default>default:</default> <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"th"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
  </block_content>}</block></switch>
<return>return <expr><name>buffer</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*          Compile a single pattern              *
*************************************************/</comment>

<comment type="block">/* Do nothing if the pattern has already been compiled. This is the case for
include/exclude patterns read from a file.

When the -F option has been used, each "pattern" may be a list of strings,
separated by line breaks. They will be matched literally. We split such a
string and compile the first substring, inserting an additional block into the
pattern chain.

Arguments:
  p              points to the pattern block
  options        the PCRE options
  fromfile       TRUE if the pattern was read from a file
  fromtext       file name or identifying text (e.g. "include")
  count          0 if this is the only command line pattern, or
                 number of the command line pattern, or
                 linenumber for a pattern from a file

Returns:         TRUE on success, FALSE after an error
*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>compile_pattern</name><parameter_list>(<parameter><decl><type><name>patstr</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fromfile</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fromtext</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ps</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>errcode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>patlen</name></decl>, <decl><type ref="prev"/><name>erroffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_UCHAR</name></type> <name><name>errmessbuffer</name><index>[<expr><name>ERRBUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>compiled</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ps</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>string</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>patlen</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>PCRE2_LITERAL</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ellength</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eop</name> <init>= <expr><name>ps</name> <operator>+</operator> <name>patlen</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pe</name> <init>= <expr><call><name>end_of_line</name><argument_list>(<argument><expr><name>ps</name></expr></argument>, <argument><expr><name>eop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ellength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>ellength</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>patlen</name> <operator>=</operator> <name>pe</name> <operator>-</operator> <name>ps</name> <operator>-</operator> <name>ellength</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>add_pattern</name><argument_list>(<argument><expr><name>pe</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>length</name></name><operator>-</operator><name>patlen</name><operator>-</operator><name>ellength</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>compiled</name></name> <operator>=</operator> <call><name>pcre2_compile</name><argument_list>(<argument><expr><operator>(</operator><name>PCRE2_SPTR</name><operator>)</operator><name>ps</name></expr></argument>, <argument><expr><name>patlen</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errcode</name></expr></argument>,
  <argument><expr><operator>&amp;</operator><name>erroffset</name></expr></argument>, <argument><expr><name>compile_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Handle successful compile. Try JIT-compiling if supported and enabled. We
ignore any JIT compiler errors, relying falling back to interpreting if
anything goes wrong with JIT. */</comment>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>compiled</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2GREP_JIT</name></cpp:ifdef>
  <if_stmt><if>if <condition>(<expr><name>use_jit</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcre2_jit_compile</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>compiled</name></name></expr></argument>, <argument><expr><name>PCRE2_JIT_COMPLETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Handle compile errors */</comment>

<if_stmt><if>if <condition>(<expr><name>erroffset</name> <operator>&gt;</operator> <name>patlen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>erroffset</name> <operator>=</operator> <name>patlen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>pcre2_get_error_message</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>, <argument><expr><name>errmessbuffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errmessbuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fromfile</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Error in regex in line %d of %s "</literal>
    <literal type="string">"at offset %d: %s\n"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>fromtext</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>erroffset</name></expr></argument>, <argument><expr><name>errmessbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Error in %s regex at offset %d: %s\n"</literal></expr></argument>,
      <argument><expr><name>fromtext</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>erroffset</name></expr></argument>, <argument><expr><name>errmessbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Error in %s %s regex at offset %d: %s\n"</literal></expr></argument>,
      <argument><expr><call><name>ordin</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fromtext</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>erroffset</name></expr></argument>, <argument><expr><name>errmessbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*     Read and compile a file of patterns        *
*************************************************/</comment>

<comment type="block">/* This is used for --filelist, --include-from, and --exclude-from.

Arguments:
  name         the name of the file; "-" is stdin
  patptr       pointer to the pattern chain anchor
  patlastptr   pointer to the last pattern pointer

Returns:       TRUE if all went well
*/</comment>

<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>read_pattern_file</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>patstr</name> <modifier>*</modifier><modifier>*</modifier></type><name>patptr</name></decl></parameter>, <parameter><decl><type><name>patstr</name> <modifier>*</modifier><modifier>*</modifier></type><name>patlastptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>linenumber</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PCRE2_SIZE</name></type> <name>patlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>MAXPATLEN</name><operator>+</operator><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>f</name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>filename</name> <operator>=</operator> <name>stdin_name</name></expr>;</expr_stmt>
  </block_content>}</block></if>
<else>else
  <block>{<block_content>
  <expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Failed to open %s: %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>filename</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>patlen</name> <operator>=</operator> <call><name>read_one_line</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <while>while <condition>(<expr><name>patlen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>(</operator><name><name>buffer</name><index>[<expr><name>patlen</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>patlen</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><name>linenumber</name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>patlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>   <comment type="block">/* Skip blank lines */</comment>

  <comment type="block">/* Note: this call to add_pattern() puts a pointer to the local variable
  "buffer" into the pattern chain. However, that pointer is used only when
  compiling the pattern, which happens immediately below, so we flatten it
  afterwards, as a precaution against any later code trying to use it. */</comment>

  <expr_stmt><expr><operator>*</operator><name>patlastptr</name> <operator>=</operator> <call><name>add_pattern</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>patlen</name></expr></argument>, <argument><expr><operator>*</operator><name>patlastptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>patlastptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>f</name> <operator>!=</operator> <name>stdin</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>patptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>patptr</name> <operator>=</operator> <operator>*</operator><name>patlastptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* This loop is needed because compiling a "pattern" when -F is set may add
  on additional literal patterns if the original contains a newline. In the
  common case, it never will, because read_one_line() stops at a newline.
  However, the -N option can be used to give pcre2grep a different newline
  setting. */</comment>

  <for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>compile_pattern</name><argument_list>(<argument><expr><operator>*</operator><name>patlastptr</name></expr></argument>, <argument><expr><name>pcre2_options</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>,
        <argument><expr><name>linenumber</name></expr></argument>)</argument_list></call></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>f</name> <operator>!=</operator> <name>stdin</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>patlastptr</name><operator>)</operator><operator>-&gt;</operator><name>string</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>            <comment type="block">/* Insurance */</comment>
    <if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>patlastptr</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>patlastptr</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>patlastptr</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>f</name> <operator>!=</operator> <name>stdin</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>



<comment type="block" format="doxygen">/*************************************************
*                Main program                    *
*************************************************/</comment>

<comment type="block">/* Returns 0 if something matched, 1 if nothing matched, 2 after an error. */</comment>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>only_one_at_top</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>patstr</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>fnstr</name> <modifier>*</modifier></type><name>fn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>omstr</name> <modifier>*</modifier></type><name>om</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>locale_from</name> <init>= <expr><literal type="string">"--locale"</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2GREP_JIT</name></cpp:ifdef>
<decl_stmt><decl><type><name>pcre2_jit_stack</name> <modifier>*</modifier></type><name>jit_stack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* In Windows, stdout is set up as a text stream, which means that \n is
converted to \r\n. This causes output lines that are copied from the input to
change from ....\r\n to ....\r\r\n, which is not right. We therefore ensure
that stdout is a binary stream. Note that this means all other output to stdout
must use STDOUT_NL to terminate lines. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<expr_stmt><expr><call><name>_setmode</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>_O_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Process the options */</comment>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>option_item</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>option_data</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><literal type="string">""</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* default to keep compiler happy */</comment>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>longop</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>longopwasequals</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

  <comment type="block">/* If we hit an argument that is just "-", it may be a reference to STDIN,
  but only if we have previously had -e or -f to define the patterns. */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>pattern_files</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>patterns</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>pcre2grep_exit</name><argument_list>(<argument><expr><call><name>usage</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Handle a long name option, or -- to terminate the options */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>argequals</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>    <comment type="block">/* -- terminates options */</comment>
      <block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
      <break>break;</break>                <comment type="block">/* out of the options-handling loop */</comment>
      </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>longop</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

    <comment type="block">/* Some long options have data that follows after =, for example file=name.
    Some options have variations in the long name spelling: specifically, we
    allow "regexp" because GNU grep allows it, though I personally go along
    with Jeffrey Friedl and Larry Wall in preferring "regex" without the "p".
    These options are entered in the table as "regex(p)". Options can be in
    both these categories. */</comment>

    <for>for <control>(<init><expr><name>op</name> <operator>=</operator> <name>optionlist</name></expr>;</init> <condition><expr><name><name>op</name><operator>-&gt;</operator><name>one_char</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>op</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opbra</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>equals</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Handle options with only one spelling of the name */</comment>

      <if_stmt><if>if <condition>(<expr><name>opbra</name> <operator>==</operator> <name>NULL</name></expr>)</condition>     <comment type="block">/* Does not contain '(' */</comment>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>equals</name> <operator>==</operator> <name>NULL</name></expr>)</condition>  <comment type="block">/* Not thing=data case */</comment>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
          </block_content>}</block></if>
        <else>else                 <comment type="block">/* Special case xxx=data */</comment>
          <block>{<block_content>
          <decl_stmt><decl><type><name>int</name></type> <name>oplen</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>equals</name> <operator>-</operator> <name><name>op</name><operator>-&gt;</operator><name>long_name</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>arglen</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>argequals</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then>
            <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>argequals</name> <operator>-</operator> <name>arg</name><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>oplen</name> <operator>==</operator> <name>arglen</name> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>, <argument><expr><name>oplen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>option_data</name> <operator>=</operator> <name>arg</name> <operator>+</operator> <name>arglen</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>option_data</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><name>option_data</name><operator>++</operator></expr>;</expr_stmt>
              <expr_stmt><expr><name>longopwasequals</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            <break>break;</break>
            </block_content>}</block></if></if_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>

      <comment type="block">/* Handle options with an alternate spelling of the name */</comment>

      <else>else
        <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>buff1</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>buff2</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>baselen</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>opbra</name> <operator>-</operator> <name><name>op</name><operator>-&gt;</operator><name>long_name</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>fulllen</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>op</name><operator>-&gt;</operator><name>long_name</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>arglen</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>argequals</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>equals</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then>
          <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>argequals</name> <operator>-</operator> <name>arg</name><operator>)</operator></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buff1</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff1</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%.*s"</literal></expr></argument>, <argument><expr><name>baselen</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name><name>ret</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>ret</name></expr></argument> &gt;</argument_list></name> <argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></call><sizeof>sizeof<argument_list>(<argument><expr><name>buff1</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name>ret</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buff2</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff2</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s%.*s"</literal></expr></argument>, <argument><expr><name>buff1</name></expr></argument>,
                     <argument><expr><name>fulllen</name> <operator>-</operator> <name>baselen</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>opbra</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name><name>ret</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>ret</name></expr></argument> &gt;</argument_list></name> <argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></call><sizeof>sizeof<argument_list>(<argument><expr><name>buff2</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition>
          <block>{<block_content>
          <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Buffer overflow when parsing %s option\n"</literal></expr></argument>,
            <argument><expr><name><name>op</name><operator>-&gt;</operator><name>long_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>pcre2grep_exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>buff1</name></expr></argument>, <argument><expr><name>arglen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
           <call><name>strncmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>buff2</name></expr></argument>, <argument><expr><name>arglen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
          <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>equals</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>argequals</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
            <expr_stmt><expr><name>option_data</name> <operator>=</operator> <name>argequals</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>option_data</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition>
              <block>{<block_content>
              <expr_stmt><expr><name>option_data</name><operator>++</operator></expr>;</expr_stmt>
              <expr_stmt><expr><name>longopwasequals</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
          <break>break;</break>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>one_char</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Unknown option %s\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pcre2grep_exit</name><argument_list>(<argument><expr><call><name>usage</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>

  <comment type="block">/* Jeffrey Friedl's debugging harness uses these additional options which
  are not in the right form for putting in the option table because they use
  only one hyphen, yet are more than one character long. By putting them
  separately here, they will not get displayed as part of the help() output,
  but I don't think Jeffrey will care about that. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JFRIEDL_DEBUG</name></cpp:ifdef>
  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-pre"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>jfriedl_prefix</name> <operator>=</operator> <name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
          <continue>continue;</continue>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-post"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>jfriedl_postfix</name> <operator>=</operator> <name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
          <continue>continue;</continue>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-XT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>sscanf</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>jfriedl_XT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-XR"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>sscanf</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>jfriedl_XR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
  </block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


  <comment type="block">/* One-char options; many that have no data may be in a single argument; we
  continue till we hit the last one or one that needs data. */</comment>

  <else>else
    <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>longop</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <for>for <control>(<init><expr><name>op</name> <operator>=</operator> <name>optionlist</name></expr>;</init> <condition><expr><name><name>op</name><operator>-&gt;</operator><name>one_char</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>op</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name><name>op</name><operator>-&gt;</operator><name>one_char</name></name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></for>
      <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>one_char</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Unknown option letter '%c' in \"%s\"\n"</literal></expr></argument>,
          <argument><expr><operator>*</operator><name>s</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pcre2grep_exit</name><argument_list>(<argument><expr><call><name>usage</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>option_data</name> <operator>=</operator> <name>s</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>

      <comment type="block">/* Break out if this is the last character in the string; it's handled
      below like a single multi-char option. */</comment>

      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>option_data</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>

      <comment type="block">/* Check for a single-character option that has data: OP_OP_NUMBER(S)
      are used for ones that either have a numerical number or defaults, i.e.
      the data is optional. If a digit follows, there is data; if not, carry on
      with other single-character options in the same string. */</comment>

      <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OP_OP_NUMBER</name> <operator>||</operator> <name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OP_OP_NUMBERS</name></expr>)</condition>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></if>
      <else>else   <comment type="block">/* Check for an option with data */</comment>
        <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OP_NODATA</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

      <comment type="block">/* Handle a single-character option with no data, then loop for the
      next character in the string. */</comment>

      <expr_stmt><expr><name>pcre2_options</name> <operator>=</operator> <call><name>handle_option</name><argument_list>(<argument><expr><operator>*</operator><name>s</name><operator>++</operator></expr></argument>, <argument><expr><name>pcre2_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>

  <comment type="block">/* At this point we should have op pointing to a matched option. If the type
  is NO_DATA, it means that there is no data, and the option might set
  something in the PCRE options. */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OP_NODATA</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><name>pcre2_options</name> <operator>=</operator> <call><name>handle_option</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>one_char</name></name></expr></argument>, <argument><expr><name>pcre2_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the option type is OP_OP_STRING or OP_OP_NUMBER(S), it's an option that
  either has a value or defaults to something. It cannot have data in a
  separate item. At the moment, the only such options are "colo(u)r",
  "only-matching", and Jeffrey Friedl's special -S debugging option. */</comment>

  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>option_data</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
      <operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OP_OP_STRING</name> <operator>||</operator> <name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OP_OP_NUMBER</name> <operator>||</operator>
       <name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OP_OP_NUMBERS</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
    <switch>switch <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>one_char</name></name></expr>)</condition>
      <block>{<block_content>
      <case>case <expr><name>N_COLOUR</name></expr>:</case>
      <expr_stmt><expr><name>colour_option</name> <operator>=</operator> <literal type="string">"auto"</literal></expr>;</expr_stmt>
      <break>break;</break>

      <case>case <expr><literal type="char">'o'</literal></expr>:</case>
      <expr_stmt><expr><name>only_matching_last</name> <operator>=</operator> <call><name>add_number</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>only_matching_last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>only_matching</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>only_matching</name> <operator>=</operator> <name>only_matching_last</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JFRIEDL_DEBUG</name></cpp:ifdef>
      <case>case <expr><literal type="char">'S'</literal></expr>:</case>
      <expr_stmt><expr><name>S_arg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></switch>
    <continue>continue;</continue>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Otherwise, find the data string for the option. */</comment>

  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>option_data</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>argc</name> <operator>-</operator> <literal type="number">1</literal> <operator>||</operator> <name>longopwasequals</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Data missing after %s\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pcre2grep_exit</name><argument_list>(<argument><expr><call><name>usage</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>option_data</name> <operator>=</operator> <name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* If the option type is OP_OP_NUMBERS, the value is a number that is to be
  added to a chain of numbers. */</comment>

  <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OP_OP_NUMBERS</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>int</name></type> <name>n</name> <init>= <expr><call><name>decode_number</name><argument_list>(<argument><expr><name>option_data</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>longop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>omdatastr</name> <modifier>*</modifier></type><name>omd</name> <init>= <expr><operator>(</operator><name>omdatastr</name> <operator>*</operator><operator>)</operator><name><name>op</name><operator>-&gt;</operator><name>dataptr</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>omd</name><operator>-&gt;</operator><name>lastptr</name></name><operator>)</operator> <operator>=</operator> <call><name>add_number</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>n</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name><name>omd</name><operator>-&gt;</operator><name>lastptr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name><name>omd</name><operator>-&gt;</operator><name>anchor</name></name><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>omd</name><operator>-&gt;</operator><name>anchor</name></name><operator>)</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><name><name>omd</name><operator>-&gt;</operator><name>lastptr</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>

  <comment type="block">/* If the option type is OP_PATLIST, it's the -e option, or one of the
  include/exclude options, which can be called multiple times to create lists
  of patterns. */</comment>

  <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OP_PATLIST</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>patdatastr</name> <modifier>*</modifier></type><name>pd</name> <init>= <expr><operator>(</operator><name>patdatastr</name> <operator>*</operator><operator>)</operator><name><name>op</name><operator>-&gt;</operator><name>dataptr</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>pd</name><operator>-&gt;</operator><name>lastptr</name></name><operator>)</operator> <operator>=</operator> <call><name>add_pattern</name><argument_list>(<argument><expr><name>option_data</name></expr></argument>, <argument><expr><operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>option_data</name></expr></argument>)</argument_list></call></expr></argument>,
      <argument><expr><operator>*</operator><operator>(</operator><name><name>pd</name><operator>-&gt;</operator><name>lastptr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name><name>pd</name><operator>-&gt;</operator><name>lastptr</name></name><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>EXIT2</name>;</goto></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name><name>pd</name><operator>-&gt;</operator><name>anchor</name></name><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>pd</name><operator>-&gt;</operator><name>anchor</name></name><operator>)</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><name><name>pd</name><operator>-&gt;</operator><name>lastptr</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>

  <comment type="block">/* If the option type is OP_FILELIST, it's one of the options that names a
  file. */</comment>

  <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OP_FILELIST</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>fndatastr</name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><operator>(</operator><name>fndatastr</name> <operator>*</operator><operator>)</operator><name><name>op</name><operator>-&gt;</operator><name>dataptr</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>fn</name> <operator>=</operator> <operator>(</operator><name>fnstr</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fnstr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: malloc failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>EXIT2</name>;</goto>
      </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>fn</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fn</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>option_data</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name><name>fd</name><operator>-&gt;</operator><name>anchor</name></name><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>fd</name><operator>-&gt;</operator><name>anchor</name></name><operator>)</operator> <operator>=</operator> <name>fn</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><operator>(</operator><operator>*</operator><operator>(</operator><name><name>fd</name><operator>-&gt;</operator><name>lastptr</name></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>next</name> <operator>=</operator> <name>fn</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>fd</name><operator>-&gt;</operator><name>lastptr</name></name><operator>)</operator> <operator>=</operator> <name>fn</name></expr>;</expr_stmt>
    </block_content>}</block></if>

  <comment type="block">/* Handle OP_BINARY_FILES */</comment>

  <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OP_BINFILES</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>option_data</name></expr></argument>, <argument><expr><literal type="string">"binary"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>binary_files</name> <operator>=</operator> <name>BIN_BINARY</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>option_data</name></expr></argument>, <argument><expr><literal type="string">"without-match"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>binary_files</name> <operator>=</operator> <name>BIN_NOMATCH</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>option_data</name></expr></argument>, <argument><expr><literal type="string">"text"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>binary_files</name> <operator>=</operator> <name>BIN_TEXT</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: unknown value \"%s\" for binary-files\n"</literal></expr></argument>,
        <argument><expr><name>option_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>pcre2grep_exit</name><argument_list>(<argument><expr><call><name>usage</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>

  <comment type="block">/* Otherwise, deal with a single string or numeric data value. */</comment>

  <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OP_NUMBER</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OP_U32NUMBER</name> <operator>&amp;&amp;</operator>
           <name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OP_OP_NUMBER</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OP_SIZE</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>op</name><operator>-&gt;</operator><name>dataptr</name></name><operator>)</operator> <operator>=</operator> <name>option_data</name></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>int</name></type> <name>n</name> <init>= <expr><call><name>decode_number</name><argument_list>(<argument><expr><name>option_data</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>longop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OP_U32NUMBER</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name><name>op</name><operator>-&gt;</operator><name>dataptr</name></name><operator>)</operator> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OP_SIZE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>PCRE2_SIZE</name> <operator>*</operator><operator>)</operator><name><name>op</name><operator>-&gt;</operator><name>dataptr</name></name><operator>)</operator> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name><name>op</name><operator>-&gt;</operator><name>dataptr</name></name><operator>)</operator> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

<comment type="block">/* Options have been decoded. If -C was used, its value is used as a default
for -A and -B. */</comment>

<if_stmt><if>if <condition>(<expr><name>both_context</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>after_context</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>after_context</name> <operator>=</operator> <name>both_context</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>before_context</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>before_context</name> <operator>=</operator> <name>both_context</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Only one of --only-matching, --output, --file-offsets, or --line-offsets is
permitted. They display, each in their own way, only the data that has matched.
*/</comment>

<expr_stmt><expr><name>only_matching_count</name> <operator>=</operator> <operator>(</operator><name>only_matching</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>output_text</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>+</operator>
  <name>file_offsets</name> <operator>+</operator> <name>line_offsets</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>only_matching_count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Cannot mix --only-matching, --output, "</literal>
    <literal type="string">"--file-offsets and/or --line-offsets\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pcre2grep_exit</name><argument_list>(<argument><expr><call><name>usage</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>


<comment type="block">/* Check that there is a big enough ovector for all -o settings. */</comment>

<for>for <control>(<init><expr><name>om</name> <operator>=</operator> <name>only_matching</name></expr>;</init> <condition><expr><name>om</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>om</name> <operator>=</operator> <name><name>om</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>om</name><operator>-&gt;</operator><name>groupnum</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>capture_max</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Requested group %d cannot be captured.\n"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Use --om-capture to increase the size of the capture vector.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>EXIT2</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

<comment type="block">/* Check the text supplied to --output for errors. */</comment>

<if_stmt><if>if <condition>(<expr><name>output_text</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
    <operator>!</operator><call><name>syntax_check_output_text</name><argument_list>(<argument><expr><operator>(</operator><name>PCRE2_SPTR</name><operator>)</operator><name>output_text</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
  <goto>goto <name>EXIT2</name>;</goto></block_content></block></if></if_stmt>

<comment type="block">/* Set up default compile and match contexts and a match data block. */</comment>

<expr_stmt><expr><name>offset_size</name> <operator>=</operator> <name>capture_max</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>compile_context</name> <operator>=</operator> <call><name>pcre2_compile_context_create</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>match_context</name> <operator>=</operator> <call><name>pcre2_match_context_create</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>match_data</name> <operator>=</operator> <call><name>pcre2_match_data_create</name><argument_list>(<argument><expr><name>offset_size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offsets</name> <operator>=</operator> <call><name>pcre2_get_ovector_pointer</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* If string (script) callouts are supported, set up the callout processing
function. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2GREP_CALLOUT</name></cpp:ifdef>
<expr_stmt><expr><call><name>pcre2_set_callout</name><argument_list>(<argument><expr><name>match_context</name></expr></argument>, <argument><expr><name>pcre2grep_callout</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Put limits into the match data block. */</comment>

<if_stmt><if>if <condition>(<expr><name>heap_limit</name> <operator>!=</operator> <name>PCRE2_UNSET</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pcre2_set_heap_limit</name><argument_list>(<argument><expr><name>match_context</name></expr></argument>, <argument><expr><name>heap_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>match_limit</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pcre2_set_match_limit</name><argument_list>(<argument><expr><name>match_context</name></expr></argument>, <argument><expr><name>match_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>depth_limit</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pcre2_set_depth_limit</name><argument_list>(<argument><expr><name>match_context</name></expr></argument>, <argument><expr><name>depth_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<comment type="block">/* If a locale has not been provided as an option, see if the LC_CTYPE or
LC_ALL environment variable is set, and if so, use it. */</comment>

<if_stmt><if>if <condition>(<expr><name>locale</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>locale</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"LC_ALL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>locale_from</name> <operator>=</operator> <literal type="string">"LC_ALL"</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>locale</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>locale</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"LC_CTYPE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>locale_from</name> <operator>=</operator> <literal type="string">"LC_CTYPE"</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* If a locale is set, use it to generate the tables the PCRE needs. Passing
NULL to pcre2_maketables() means that malloc() is used to get the memory. */</comment>

<if_stmt><if>if <condition>(<expr><name>locale</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_CTYPE</name></expr></argument>, <argument><expr><name>locale</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Failed to set locale %s (obtained from %s)\n"</literal></expr></argument>,
      <argument><expr><name>locale</name></expr></argument>, <argument><expr><name>locale_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>EXIT2</name>;</goto>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>character_tables</name> <operator>=</operator> <call><name>pcre2_maketables</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>pcre2_set_character_tables</name><argument_list>(<argument><expr><name>compile_context</name></expr></argument>, <argument><expr><name>character_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Sort out colouring */</comment>

<if_stmt><if>if <condition>(<expr><name>colour_option</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>colour_option</name></expr></argument>, <argument><expr><literal type="string">"never"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>colour_option</name></expr></argument>, <argument><expr><literal type="string">"always"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <expr_stmt><expr><name>do_ansi</name> <operator>=</operator> <operator>!</operator><call><name>is_stdout_tty</name><argument_list>()</argument_list></call></expr><operator>,</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><name>do_colour</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>colour_option</name></expr></argument>, <argument><expr><literal type="string">"auto"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>do_colour</name> <operator>=</operator> <call><name>is_stdout_tty</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Unknown colour setting \"%s\"\n"</literal></expr></argument>,
      <argument><expr><name>colour_option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>EXIT2</name>;</goto>
    </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>do_colour</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cs</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PCRE2GREP_COLOUR"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>cs</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cs</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PCRE2GREP_COLOR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>cs</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cs</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PCREGREP_COLOUR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>cs</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cs</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PCREGREP_COLOR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>cs</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cs</name> <operator>=</operator> <call><name>parse_grep_colors</name><argument_list>(<argument><expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"GREP_COLORS"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>cs</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>cs</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"GREP_COLOR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>cs</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>strspn</name><argument_list>(<argument><expr><name>cs</name></expr></argument>, <argument><expr><literal type="string">";0123456789"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>colour_string</name> <operator>=</operator> <name>cs</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <expr_stmt><expr><call><name>init_colour_output</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Sort out a newline setting. */</comment>

<if_stmt><if>if <condition>(<expr><name>newline_arg</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <for>for <control>(<init><expr><name>endlinetype</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>endlinetype</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>newlines</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</condition>
       <incr><expr><name>endlinetype</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>strcmpic</name><argument_list>(<argument><expr><name>newline_arg</name></expr></argument>, <argument><expr><name><name>newlines</name><index>[<expr><name>endlinetype</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><name>endlinetype</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>newlines</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>pcre2_set_newline</name><argument_list>(<argument><expr><name>compile_context</name></expr></argument>, <argument><expr><name>endlinetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Invalid newline specifier \"%s\"\n"</literal></expr></argument>,
      <argument><expr><name>newline_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>EXIT2</name>;</goto>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>

<comment type="block">/* Find default newline convention */</comment>

<else>else
  <block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcre2_config</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_NEWLINE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endlinetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

<comment type="block">/* Interpret the text values for -d and -D */</comment>

<if_stmt><if>if <condition>(<expr><name>dee_option</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>dee_option</name></expr></argument>, <argument><expr><literal type="string">"read"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dee_action</name> <operator>=</operator> <name>dee_READ</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>dee_option</name></expr></argument>, <argument><expr><literal type="string">"recurse"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dee_action</name> <operator>=</operator> <name>dee_RECURSE</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>dee_option</name></expr></argument>, <argument><expr><literal type="string">"skip"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>dee_action</name> <operator>=</operator> <name>dee_SKIP</name></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Invalid value \"%s\" for -d\n"</literal></expr></argument>, <argument><expr><name>dee_option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>EXIT2</name>;</goto>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>DEE_option</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>DEE_option</name></expr></argument>, <argument><expr><literal type="string">"read"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>DEE_action</name> <operator>=</operator> <name>DEE_READ</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>DEE_option</name></expr></argument>, <argument><expr><literal type="string">"skip"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>DEE_action</name> <operator>=</operator> <name>DEE_SKIP</name></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Invalid value \"%s\" for -D\n"</literal></expr></argument>, <argument><expr><name>DEE_option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <goto>goto <name>EXIT2</name>;</goto>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Set the extra options */</comment>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcre2_set_compile_extra_options</name><argument_list>(<argument><expr><name>compile_context</name></expr></argument>, <argument><expr><name>extra_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Check the values for Jeffrey Friedl's debugging options. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>JFRIEDL_DEBUG</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>S_arg</name> <operator>&gt;</operator> <literal type="number">9</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: bad value for -S option\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">2</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>jfriedl_XT</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>jfriedl_XR</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>jfriedl_XT</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>jfriedl_XT</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>jfriedl_XR</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>jfriedl_XR</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* If use_jit is set, check whether JIT is available. If not, do not try
to use JIT. */</comment>

<if_stmt><if>if <condition>(<expr><name>use_jit</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>answer</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcre2_config</name><argument_list>(<argument><expr><name>PCRE2_CONFIG_JIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>answer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>answer</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>use_jit</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Get memory for the main buffer. */</comment>

<if_stmt><if>if <condition>(<expr><name>bufthird</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: --buffer-size must be greater than zero\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <goto>goto <name>EXIT2</name>;</goto>
  </block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>bufsize</name> <operator>=</operator> <literal type="number">3</literal><operator>*</operator><name>bufthird</name></expr>;</expr_stmt>
<expr_stmt><expr><name>main_buffer</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>main_buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: malloc failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <goto>goto <name>EXIT2</name>;</goto>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* If no patterns were provided by -e, and there are no files provided by -f,
the first argument is the one and only pattern, and it must exist. */</comment>

<if_stmt><if>if <condition>(<expr><name>patterns</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>pattern_files</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>argc</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>usage</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>patterns</name> <operator>=</operator> <name>patterns_last</name> <operator>=</operator> <call><name>add_pattern</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>PCRE2_SIZE</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>patterns</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>EXIT2</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* Compile the patterns that were provided on the command line, either by
multiple uses of -e or as a single unkeyed pattern. We cannot do this until
after all the command-line options are read so that we know which PCRE options
to use. When -F is used, compile_pattern() may add another block into the
chain, so we must not access the next pointer till after the compile. */</comment>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>cp</name> <operator>=</operator> <name>patterns</name></expr>;</init> <condition><expr><name>cp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr><operator>,</operator> <expr><name>cp</name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>compile_pattern</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>pcre2_options</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><literal type="string">"command-line"</literal></expr></argument>,
       <argument><expr><ternary><condition><expr><operator>(</operator><name>j</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>patterns</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>j</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <goto>goto <name>EXIT2</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></for>

<comment type="block">/* Read and compile the regular expressions that are provided in files. */</comment>

<for>for <control>(<init><expr><name>fn</name> <operator>=</operator> <name>pattern_files</name></expr>;</init> <condition><expr><name>fn</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>fn</name> <operator>=</operator> <name><name>fn</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_pattern_file</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>patterns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>patterns_last</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>EXIT2</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></for>

<comment type="block">/* Unless JIT has been explicitly disabled, arrange a stack for it to use. */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2GREP_JIT</name></cpp:ifdef>
<if_stmt><if>if <condition>(<expr><name>use_jit</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>jit_stack</name> <operator>=</operator> <call><name>pcre2_jit_stack_create</name><argument_list>(<argument><expr><literal type="number">32</literal><operator>*</operator><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>jit_stack</name> <operator>!=</operator> <name>NULL</name></expr>                        )</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>pcre2_jit_stack_assign</name><argument_list>(<argument><expr><name>match_context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>jit_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* -F, -w, and -x do not apply to include or exclude patterns, so we must
adjust the options. */</comment>

<expr_stmt><expr><name>pcre2_options</name> <operator>&amp;=</operator> <operator>~</operator><name>PCRE2_LITERAL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pcre2_set_compile_extra_options</name><argument_list>(<argument><expr><name>compile_context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* If there are include or exclude patterns read from the command line, compile
them. */</comment>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>cp</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name><name>incexlist</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr>;</init> <condition><expr><name>cp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr><operator>,</operator> <expr><name>cp</name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>compile_pattern</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>pcre2_options</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name><name>incexname</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
         <argument><expr><ternary><condition><expr><operator>(</operator><name>k</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>cp</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>k</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <goto>goto <name>EXIT2</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></for>

<comment type="block">/* Read and compile include/exclude patterns from files. */</comment>

<for>for <control>(<init><expr><name>fn</name> <operator>=</operator> <name>include_from</name></expr>;</init> <condition><expr><name>fn</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>fn</name> <operator>=</operator> <name><name>fn</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_pattern_file</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>include_patterns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>include_patterns_last</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <goto>goto <name>EXIT2</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></for>

<for>for <control>(<init><expr><name>fn</name> <operator>=</operator> <name>exclude_from</name></expr>;</init> <condition><expr><name>fn</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>fn</name> <operator>=</operator> <name><name>fn</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_pattern_file</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exclude_patterns</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exclude_patterns_last</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <goto>goto <name>EXIT2</name>;</goto></block_content></block></if></if_stmt>
  </block_content>}</block></for>

<comment type="block">/* If there are no files that contain lists of files to search, and there are
no file arguments, search stdin, and then exit. */</comment>

<if_stmt><if>if <condition>(<expr><name>file_lists</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <name>argc</name></expr>)</condition>
  <block>{<block_content>
  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>pcre2grep</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>, <argument><expr><name>FR_PLAIN</name></expr></argument>, <argument><expr><name>stdin_name</name></expr></argument>,
    <argument><expr><ternary><condition><expr><operator>(</operator><name>filenames</name> <operator>&gt;</operator> <name>FN_DEFAULT</name><operator>)</operator></expr>?</condition><then> <expr><name>stdin_name</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <goto>goto <name>EXIT</name>;</goto>
  </block_content>}</block></if></if_stmt>

<comment type="block">/* If any files that contains a list of files to search have been specified,
read them line by line and search the given files. */</comment>

<for>for <control>(<init><expr><name>fn</name> <operator>=</operator> <name>file_lists</name></expr>;</init> <condition><expr><name>fn</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>fn</name> <operator>=</operator> <name><name>fn</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>FNBUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fl</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>fl</name> <operator>=</operator> <name>stdin</name></expr>;</expr_stmt></block_content></block></if> <else>else
    <block>{<block_content>
    <expr_stmt><expr><name>fl</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fl</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"pcre2grep: Failed to open %s: %s\n"</literal></expr></argument>, <argument><expr><name><name>fn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
        <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>EXIT2</name>;</goto>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
  <while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fl</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>frc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>buffer</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>end</name> <operator>&gt;</operator> <name>buffer</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><name><name>end</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>end</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>buffer</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
      <expr_stmt><expr><name>frc</name> <operator>=</operator> <call><name>grep_or_recurse</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>dee_action</name> <operator>==</operator> <name>dee_RECURSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>frc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>frc</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>frc</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
  <if_stmt><if>if <condition>(<expr><name>fl</name> <operator>!=</operator> <name>stdin</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>

<comment type="block">/* After handling file-list, work through remaining arguments. Pass in the fact
that there is only one argument at top level - this suppresses the file name if
the argument is not a directory and filenames are not otherwise forced. */</comment>

<expr_stmt><expr><name>only_one_at_top</name> <operator>=</operator> <name>i</name> <operator>==</operator> <name>argc</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>file_lists</name> <operator>==</operator> <name>NULL</name></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
  <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>frc</name> <init>= <expr><call><name>grep_or_recurse</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>dee_action</name> <operator>==</operator> <name>dee_RECURSE</name></expr></argument>,
    <argument><expr><name>only_one_at_top</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>frc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>frc</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>frc</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2GREP_CALLOUT</name></cpp:ifdef>
<comment type="block">/* If separating builtin echo callouts by implicit newline, add one more for
the final item. */</comment>

<if_stmt><if>if <condition>(<expr><name>om_separator</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>om_separator</name></expr></argument>, <argument><expr><name>STDOUT_NL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>STDOUT_NL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Show the total number of matches if requested, but not if only one file's
count was printed. */</comment>

<if_stmt><if>if <condition>(<expr><name>show_total_count</name> <operator>&amp;&amp;</operator> <name>counts_printed</name> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>filenames</name> <operator>!=</operator> <name>FN_NOMATCH_ONLY</name></expr>)</condition>
  <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>counts_printed</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>filenames</name> <operator>&gt;=</operator> <name>FN_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"TOTAL:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">"%lu"</literal> <name>STDOUT_NL</name></expr></argument>, <argument><expr><name>total_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>EXIT</name>:</label>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SUPPORT_PCRE2GREP_JIT</name></cpp:ifdef>
<expr_stmt><expr><call><name>pcre2_jit_free_unused_memory</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>jit_stack</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pcre2_jit_stack_free</name><argument_list>(<argument><expr><name>jit_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>main_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>character_tables</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pcre2_maketables_free</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>character_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>pcre2_compile_context_free</name><argument_list>(<argument><expr><name>compile_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pcre2_match_context_free</name><argument_list>(<argument><expr><name>match_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pcre2_match_data_free</name><argument_list>(<argument><expr><name>match_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_pattern_chain</name><argument_list>(<argument><expr><name>patterns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_pattern_chain</name><argument_list>(<argument><expr><name>include_patterns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_pattern_chain</name><argument_list>(<argument><expr><name>include_dir_patterns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_pattern_chain</name><argument_list>(<argument><expr><name>exclude_patterns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_pattern_chain</name><argument_list>(<argument><expr><name>exclude_dir_patterns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_file_chain</name><argument_list>(<argument><expr><name>exclude_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_file_chain</name><argument_list>(<argument><expr><name>include_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_file_chain</name><argument_list>(<argument><expr><name>pattern_files</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free_file_chain</name><argument_list>(<argument><expr><name>file_lists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>only_matching</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
  <block>{<block_content>
  <decl_stmt><decl><type><name>omstr</name> <modifier>*</modifier></type><name>this</name> <init>= <expr><name>only_matching</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>only_matching</name> <operator>=</operator> <name><name>this</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>

<expr_stmt><expr><call><name>pcre2grep_exit</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>EXIT2</name>:</label>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<goto>goto <name>EXIT</name>;</goto>
</block_content>}</block></function>

<comment type="block">/* End of pcre2grep */</comment>
</unit>
