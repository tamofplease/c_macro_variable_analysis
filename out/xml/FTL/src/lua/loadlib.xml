<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/lua/loadlib.c"><comment type="block">/*
** $Id: loadlib.c $
** Dynamic library loader for Lua
** See Copyright Notice in lua.h
**
** This module contains an implementation of loadlib for Unix systems
** that have dlfcn, an implementation for Windows, and a stub for other
** systems.
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>loadlib_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_LIB</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lprefix.h"</cpp:file></cpp:include>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lua.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lauxlib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lualib.h"</cpp:file></cpp:include>


<comment type="block">/*
** LUA_IGMARK is a mark to ignore all before it when building the
** luaopen_ function name.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>LUA_IGMARK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_IGMARK</name></cpp:macro>		<cpp:value>"-"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** LUA_CSUBSEP is the character that replaces dots in submodule names
** when searching for a C loader.
** LUA_LSUBSEP is the character that replaces dots in submodule names
** when searching for a Lua loader.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LUA_CSUBSEP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CSUBSEP</name></cpp:macro>		<cpp:value>LUA_DIRSEP</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LUA_LSUBSEP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_LSUBSEP</name></cpp:macro>		<cpp:value>LUA_DIRSEP</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* prefix for open functions in C libraries */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_POF</name></cpp:macro>		<cpp:value>"luaopen_"</cpp:value></cpp:define>

<comment type="block">/* separator for open functions in C libraries */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_OFSEP</name></cpp:macro>	<cpp:value>"_"</cpp:value></cpp:define>


<comment type="block">/*
** key for table in the registry that keeps handles
** for all loaded C libraries
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name>CLIBS</name> <init>= <expr><literal type="string">"_CLIBS"</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIB_FAIL</name></cpp:macro>	<cpp:value>"open"</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setprogdir</name><parameter_list>(<parameter><type><name>L</name></type></parameter>)</parameter_list></cpp:macro>           <cpp:value>((void)0)</cpp:value></cpp:define>


<comment type="block">/*
** Special type equivalent to '(void*)' for functions in gcc
** (to suppress warnings when converting function pointers)
*/</comment>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>voidf</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>


<comment type="block">/*
** system-dependent functions
*/</comment>

<comment type="block">/*
** unload library 'lib'
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lsys_unloadlib</name> <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>lib</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** load C library in file 'path'. If 'seeglb', load with all names in
** the library global.
** Returns the library; in case of error, returns NULL plus an
** error string in the stack.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>lsys_load</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>seeglb</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
** Try to find a function named 'sym' in library 'lib'.
** Returns the function; in case of error, returns NULL plus an
** error string in the stack.
*/</comment>
<function_decl><type><specifier>static</specifier> <name>lua_CFunction</name></type> <name>lsys_sym</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>lib</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>)</parameter_list>;</function_decl>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LUA_USE_DLOPEN</name></expr></argument>)</argument_list></call></expr></cpp:if>	<comment type="block">/* { */</comment>
<comment type="block">/*
** {========================================================================
** This is an implementation of loadlib based on the dlfcn interface.
** The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,
** NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least
** as an emulation layer on top of native functions.
** =========================================================================
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dlfcn.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
** Macro to convert pointer-to-void* to pointer-to-function. This cast
** is undefined according to ISO C, but POSIX assumes that it works.
** (The '__extension__' in gnu compilers is only to avoid warnings.)
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cast_func</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(__extension__ (lua_CFunction)(p))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cast_func</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((lua_CFunction)(p))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><specifier>static</specifier> <name>void</name></type> <name>lsys_unloadlib</name> <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>lib</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>dlclose</name><argument_list>(<argument><expr><name>lib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>lsys_load</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>seeglb</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>lib</name> <init>= <expr><call><name>dlopen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>RTLD_NOW</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>seeglb</name></expr> ?</condition><then> <expr><name>RTLD_GLOBAL</name></expr> </then><else>: <expr><name>RTLD_LOCAL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>lib</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>dlerror</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>lib</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>lua_CFunction</name></type> <name>lsys_sym</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>lib</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_CFunction</name></type> <name>f</name> <init>= <expr><call><name>cast_func</name><argument_list>(<argument><expr><call><name>dlsym</name><argument_list>(<argument><expr><name>lib</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>dlerror</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>f</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }====================================================== */</comment>



<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LUA_DL_DLL</name></expr></argument>)</argument_list></call></expr></cpp:elif>	<comment type="block">/* }{ */</comment>
<comment type="block">/*
** {======================================================================
** This is an implementation of loadlib for Windows using native functions.
** =======================================================================
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>


<comment type="block">/*
** optional flags for LoadLibraryEx
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LUA_LLE_FLAGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_LLE_FLAGS</name></cpp:macro>	<cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>setprogdir</name></cpp:undef>


<comment type="block">/*
** Replace in the path (on the top of the stack) any occurrence
** of LUA_EXEC_DIR with the executable's path.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setprogdir</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><name>MAX_PATH</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>nsize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>n</name> <init>= <expr><call><name>GetModuleFileNameA</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* get exec. name */</comment>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>==</operator> <name>nsize</name> <operator>||</operator> <operator>(</operator><name>lb</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"unable to get ModuleFileName"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>lb</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>  <comment type="block">/* cut name on the last '\\' to get the path */</comment>
    <expr_stmt><expr><call><name>luaL_gsub</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LUA_EXEC_DIR</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_remove</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remove original string */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>pusherror</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>FormatMessageA</name><argument_list>(<argument><expr><name>FORMAT_MESSAGE_IGNORE_INSERTS</name> <operator>|</operator> <name>FORMAT_MESSAGE_FROM_SYSTEM</name></expr></argument>,
      <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>error</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"system error %d\n"</literal></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>lsys_unloadlib</name> <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>lib</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><operator>(</operator><name>HMODULE</name><operator>)</operator><name>lib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>lsys_load</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>seeglb</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>HMODULE</name></type> <name>lib</name> <init>= <expr><call><name>LoadLibraryExA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>LUA_LLE_FLAGS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>seeglb</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* not used: symbols are 'global' by default */</comment>
  <if_stmt><if>if <condition>(<expr><name>lib</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pusherror</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>lib</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>lua_CFunction</name></type> <name>lsys_sym</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>lib</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_CFunction</name></type> <name>f</name> <init>= <expr><operator>(</operator><name>lua_CFunction</name><operator>)</operator><operator>(</operator><name>voidf</name><operator>)</operator><call><name>GetProcAddress</name><argument_list>(<argument><expr><operator>(</operator><name>HMODULE</name><operator>)</operator><name>lib</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>pusherror</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>f</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }====================================================== */</comment>


<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>				<comment type="block">/* }{ */</comment>
<comment type="block">/*
** {======================================================
** Fallback for other systems
** =======================================================
*/</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LIB_FAIL</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIB_FAIL</name></cpp:macro>	<cpp:value>"absent"</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DLMSG</name></cpp:macro>	<cpp:value>"dynamic libraries not enabled; check your Lua installation"</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>void</name></type> <name>lsys_unloadlib</name> <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>lib</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>lib</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* not used */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>lsys_load</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>seeglb</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>path</name><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>seeglb</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* not used */</comment>
  <expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>DLMSG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>lua_CFunction</name></type> <name>lsys_sym</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>lib</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>lib</name><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><name>sym</name><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* not used */</comment>
  <expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>DLMSG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }====================================================== */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>				<comment type="block">/* } */</comment>


<comment type="block">/*
** {==================================================================
** Set Paths
** ===================================================================
*/</comment>

<comment type="block">/*
** LUA_PATH_VAR and LUA_CPATH_VAR are the names of the environment
** variables that Lua check to set its paths.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LUA_PATH_VAR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_PATH_VAR</name></cpp:macro>    <cpp:value>"LUA_PATH"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LUA_CPATH_VAR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CPATH_VAR</name></cpp:macro>   <cpp:value>"LUA_CPATH"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<comment type="block">/*
** return registry.LUA_NOENV as a boolean
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>noenv</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>b</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_REGISTRYINDEX</name></expr></argument>, <argument><expr><literal type="string">"LUA_NOENV"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>lua_toboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remove value */</comment>
  <return>return <expr><name>b</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Set a path
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setpath</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fieldname</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>envname</name></decl></parameter>,
                                   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dft</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dftmark</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nver</name> <init>= <expr><call><name>lua_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>envname</name></expr></argument>, <argument><expr><name>LUA_VERSUFFIX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><name>nver</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* try versioned name */</comment>
  <if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* no versioned environment variable? */</comment>
    <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><name>envname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* try unversioned name */</comment>
  <if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>noenv</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* no environment variable? */</comment>
    <expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>dft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* use default */</comment>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name>dftmark</name> <operator>=</operator> <macro><name>strstr</name><argument_list>(<argument>path</argument>, <argument>LUA_PATH_SEP LUA_PATH_SEP</argument>)</argument_list></macro><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* nothing to change */</comment>
  <else>else <block>{<block_content>  <comment type="block">/* path contains a ";;": insert default path in its place */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>luaL_Buffer</name></type> <name>b</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>luaL_buffinit</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>path</name> <operator>&lt;</operator> <name>dftmark</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* is there a prefix before ';;'? */</comment>
      <expr_stmt><expr><call><name>luaL_addlstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>dftmark</name> <operator>-</operator> <name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* add it */</comment>
      <expr_stmt><expr><call><name>luaL_addchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><operator>*</operator><name>LUA_PATH_SEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>luaL_addstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name>dft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* add default */</comment>
    <if_stmt><if>if <condition>(<expr><name>dftmark</name> <operator>&lt;</operator> <name>path</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* is there a suffix after ';;'? */</comment>
      <expr_stmt><expr><call><name>luaL_addchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><operator>*</operator><name>LUA_PATH_SEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>luaL_addlstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name>dftmark</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>path</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>-</operator> <name>dftmark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>luaL_pushresult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>setprogdir</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>, <argument><expr><name>fieldname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* package[fieldname] = path value */</comment>
  <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* pop versioned variable name ('nver') */</comment>
</block_content>}</block></function>

<comment type="block">/* }================================================================== */</comment>


<comment type="block">/*
** return registry.CLIBS[path]
*/</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>checkclib</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>plib</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_REGISTRYINDEX</name></expr></argument>, <argument><expr><name>CLIBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>plib</name> <operator>=</operator> <call><name>lua_touserdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* plib = CLIBS[path] */</comment>
  <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* pop CLIBS table and 'plib' */</comment>
  <return>return <expr><name>plib</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** registry.CLIBS[path] = plib        -- for queries
** registry.CLIBS[#CLIBS + 1] = plib  -- also keep a list of all libraries
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>addtoclib</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>plib</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_REGISTRYINDEX</name></expr></argument>, <argument><expr><name>CLIBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_pushlightuserdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>plib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* CLIBS[path] = plib */</comment>
  <expr_stmt><expr><call><name>lua_rawseti</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><call><name>luaL_len</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* CLIBS[#CLIBS + 1] = plib */</comment>
  <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* pop CLIBS table */</comment>
</block_content>}</block></function>


<comment type="block">/*
** __gc tag method for CLIBS table: calls 'lsys_unloadlib' for all lib
** handles in list CLIBS
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>gctm</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_Integer</name></type> <name>n</name> <init>= <expr><call><name>luaL_len</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>n</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>n</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>  <comment type="block">/* for each handle, in reverse order */</comment>
    <expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* get handle CLIBS[n] */</comment>
    <expr_stmt><expr><call><name>lsys_unloadlib</name><argument_list>(<argument><expr><call><name>lua_touserdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* pop handle */</comment>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<comment type="block">/* error codes for 'lookforfunc' */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRLIB</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRFUNC</name></cpp:macro>		<cpp:value>2</cpp:value></cpp:define>

<comment type="block">/*
** Look for a C function named 'sym' in a dynamically loaded library
** 'path'.
** First, check whether the library is already loaded; if not, try
** to load it.
** Then, if 'sym' is '*', return true (as library has been loaded).
** Otherwise, look for symbol 'sym' in the library and push a
** C function with that symbol.
** Return 0 and 'true' or a function in the stack; in case of
** errors, return an error code and an error message in the stack.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lookforfunc</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>reg</name> <init>= <expr><call><name>checkclib</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* check loaded C libraries */</comment>
  <if_stmt><if>if <condition>(<expr><name>reg</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* must load library? */</comment>
    <expr_stmt><expr><name>reg</name> <operator>=</operator> <call><name>lsys_load</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><operator>*</operator><name>sym</name> <operator>==</operator> <literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* global symbols if 'sym'=='*' */</comment>
    <if_stmt><if>if <condition>(<expr><name>reg</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>ERRLIB</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* unable to load library */</comment>
    <expr_stmt><expr><call><name>addtoclib</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>sym</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* loading only library (no function)? */</comment>
    <expr_stmt><expr><call><name>lua_pushboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* return 'true' */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* no errors */</comment>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>lua_CFunction</name></type> <name>f</name> <init>= <expr><call><name>lsys_sym</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>ERRFUNC</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* unable to find function */</comment>
    <expr_stmt><expr><call><name>lua_pushcfunction</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* else create new function */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* no errors */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>ll_loadlib</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>luaL_checkstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>init</name> <init>= <expr><call><name>luaL_checkstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>stat</name> <init>= <expr><call><name>lookforfunc</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>init</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>stat</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* no errors? */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>  <comment type="block">/* return the loaded function */</comment>
  <else>else <block>{<block_content>  <comment type="block">/* error; error message is on stack top */</comment>
    <expr_stmt><expr><call><name>luaL_pushfail</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_insert</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>stat</name> <operator>==</operator> <name>ERRLIB</name><operator>)</operator></expr> ?</condition><then>  <expr><name>LIB_FAIL</name></expr> </then><else>: <expr><literal type="string">"init"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">3</literal></expr>;</return>  <comment type="block">/* return fail, error message, and where */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>



<comment type="block">/*
** {======================================================
** 'require' function
** =======================================================
*/</comment>


<function><type><specifier>static</specifier> <name>int</name></type> <name>readable</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* try to open file */</comment>
  <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* open failed */</comment>
  <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Get the next name in '*path' = 'name1;name2;name3;...', changing
** the ending ';' to '\0' to create a zero-terminated string. Return
** NULL when list ends.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getnextfilename</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><operator>*</operator><name>path</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if>  <comment type="block">/* no more names */</comment>
  <if type="elseif">else if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* from previous iteration? */</comment>
    <expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <operator>*</operator><name>LUA_PATH_SEP</name></expr>;</expr_stmt>  <comment type="block">/* restore separator */</comment>
    <expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* skip it */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>sep</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>*</operator><name>LUA_PATH_SEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* find next separator */</comment>
  <if_stmt><if>if <condition>(<expr><name>sep</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* separator not found? */</comment>
    <expr_stmt><expr><name>sep</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* name goes until the end */</comment>
  <expr_stmt><expr><operator>*</operator><name>sep</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>  <comment type="block">/* finish file name */</comment>
  <expr_stmt><expr><operator>*</operator><name>path</name> <operator>=</operator> <name>sep</name></expr>;</expr_stmt>  <comment type="block">/* will start next search from here */</comment>
  <return>return <expr><name>name</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Given a path such as ";blabla.so;blublu.so", pushes the string
**
** no file 'blabla.so'
**	no file 'blublu.so'
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pusherrornotfound</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>luaL_Buffer</name></type> <name>b</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaL_buffinit</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaL_addstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><literal type="string">"no file '"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaL_addgsub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>LUA_PATH_SEP</name></expr></argument>, <argument><expr><literal type="string">"'\n\tno file '"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaL_addstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><literal type="string">"'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaL_pushresult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>searchpath</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
                                             <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
                                             <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name></decl></parameter>,
                                             <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dirsep</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>luaL_Buffer</name></type> <name>buff</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pathname</name></decl>;</decl_stmt>  <comment type="block">/* path with name inserted */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endpathname</name></decl>;</decl_stmt>  <comment type="block">/* its end */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
  <comment type="block">/* separator is non-empty and appears in 'name'? */</comment>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>sep</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>*</operator><name>sep</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>luaL_gsub</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>dirsep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* replace it by 'dirsep' */</comment>
  <expr_stmt><expr><call><name>luaL_buffinit</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* add path to the buffer, replacing marks ('?') with the file name */</comment>
  <expr_stmt><expr><call><name>luaL_addgsub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>LUA_PATH_MARK</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaL_addchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pathname</name> <operator>=</operator> <call><name>luaL_buffaddr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* writable list of file names */</comment>
  <expr_stmt><expr><name>endpathname</name> <operator>=</operator> <name>pathname</name> <operator>+</operator> <call><name>luaL_bufflen</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <while>while <condition>(<expr><operator>(</operator><name>filename</name> <operator>=</operator> <call><name>getnextfilename</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pathname</name></expr></argument>, <argument><expr><name>endpathname</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>readable</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* does file exist and is readable? */</comment>
      <return>return <expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* save and return name */</comment>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>luaL_pushresult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* push path to create error message */</comment>
  <expr_stmt><expr><call><name>pusherrornotfound</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* create error message */</comment>
  <return>return <expr><name>NULL</name></expr>;</return>  <comment type="block">/* not found */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>ll_searchpath</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>searchpath</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>luaL_checkstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>luaL_checkstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>luaL_optstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>luaL_optstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>LUA_DIRSEP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>f</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
  <else>else <block>{<block_content>  <comment type="block">/* error message is on top of the stack */</comment>
    <expr_stmt><expr><call><name>luaL_pushfail</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_insert</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">2</literal></expr>;</return>  <comment type="block">/* return fail + error message */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>findfile</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
                                           <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pname</name></decl></parameter>,
                                           <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dirsep</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"'package.%s' must be a string"</literal></expr></argument>, <argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><call><name>searchpath</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><name>dirsep</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>checkload</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>stat</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>stat</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* module loaded successfully? */</comment>
    <expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* will be 2nd argument to module */</comment>
    <return>return <expr><literal type="number">2</literal></expr>;</return>  <comment type="block">/* return open function and file name */</comment>
  </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"error loading module '%s' from file '%s':\n\t%s"</literal></expr></argument>,
                          <argument><expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>searcher_Lua</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>luaL_checkstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>findfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"path"</literal></expr></argument>, <argument><expr><name>LUA_LSUBSEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>filename</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* module not found in this path */</comment>
  <return>return <expr><call><name>checkload</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>(</operator><call><name>luaL_loadfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LUA_OK</name><operator>)</operator></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Try to find a load function for module 'modname' at file 'filename'.
** First, change '.' to '_' in 'modname'; then, if 'modname' has
** the form X-Y (that is, it has an "ignore mark"), build a function
** name "luaopen_X" and look for it. (For compatibility, if that
** fails, it also tries "luaopen_Y".) If there is no ignore mark,
** look for a function named "luaopen_modname".
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>loadfunc</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>modname</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>openfunc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mark</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>modname</name> <operator>=</operator> <call><name>luaL_gsub</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>modname</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><name>LUA_OFSEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mark</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>modname</name></expr></argument>, <argument><expr><operator>*</operator><name>LUA_IGMARK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>mark</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>stat</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>openfunc</name> <operator>=</operator> <call><name>lua_pushlstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>modname</name></expr></argument>, <argument><expr><name>mark</name> <operator>-</operator> <name>modname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>openfunc</name> <operator>=</operator> <call><name>lua_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_POF</name><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>openfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>stat</name> <operator>=</operator> <call><name>lookforfunc</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>openfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>stat</name> <operator>!=</operator> <name>ERRFUNC</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>stat</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>modname</name> <operator>=</operator> <name>mark</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* else go ahead and try old-style name */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>openfunc</name> <operator>=</operator> <call><name>lua_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_POF</name><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>modname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>lookforfunc</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>openfunc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>searcher_C</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>luaL_checkstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><call><name>findfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"cpath"</literal></expr></argument>, <argument><expr><name>LUA_CSUBSEP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>filename</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* module not found in this path */</comment>
  <return>return <expr><call><name>checkload</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>(</operator><call><name>loadfunc</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>searcher_Croot</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>luaL_checkstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>stat</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* is root */</comment>
  <expr_stmt><expr><call><name>lua_pushlstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>findfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"cpath"</literal></expr></argument>, <argument><expr><name>LUA_CSUBSEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>filename</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* root not found */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>stat</name> <operator>=</operator> <call><name>loadfunc</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>stat</name> <operator>!=</operator> <name>ERRFUNC</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><call><name>checkload</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>  <comment type="block">/* real error */</comment>
    <else>else <block>{<block_content>  <comment type="block">/* open function not found */</comment>
      <expr_stmt><expr><call><name>lua_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"no module '%s' in file '%s'"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* will be 2nd argument to module */</comment>
  <return>return <expr><literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>searcher_preload</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>luaL_checkstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_REGISTRYINDEX</name></expr></argument>, <argument><expr><name>LUA_PRELOAD_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LUA_TNIL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* not found? */</comment>
    <expr_stmt><expr><call><name>lua_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"no field package.preload['%s']"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">":preload:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">2</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>findloader</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>luaL_Buffer</name></type> <name>msg</name></decl>;</decl_stmt>  <comment type="block">/* to build error message */</comment>
  <comment type="block">/* push 'package.searchers' to index 3 in the stack */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"searchers"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>LUA_TTABLE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"'package.searchers' must be a table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>luaL_buffinit</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/*  iterate over available searchers to find a loader */</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><call><name>luaL_addstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="string">"\n\t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* error-message prefix */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LUA_TNIL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* no more searchers? */</comment>
      <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remove nil */</comment>
      <expr_stmt><expr><call><name>luaL_buffsub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remove prefix */</comment>
      <expr_stmt><expr><call><name>luaL_pushresult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* create error message */</comment>
      <expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"module '%s' not found:%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_call</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* call it */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>lua_isfunction</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* did it find a loader? */</comment>
      <return>return;</return></block_content></block></if>  <comment type="block">/* module loader found */</comment>
    <if type="elseif">else if <condition>(<expr><call><name>lua_isstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* searcher returned error message? */</comment>
      <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remove extra return */</comment>
      <expr_stmt><expr><call><name>luaL_addvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* concatenate error message */</comment>
    </block_content>}</block></if>
    <else>else <block>{<block_content>  <comment type="block">/* no error message */</comment>
      <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remove both returns */</comment>
      <expr_stmt><expr><call><name>luaL_buffsub</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remove prefix */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>ll_require</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>luaL_checkstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_settop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* LOADED table will be at index 2 */</comment>
  <expr_stmt><expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_REGISTRYINDEX</name></expr></argument>, <argument><expr><name>LUA_LOADED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* LOADED[name] */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>lua_toboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* is it there? */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* package is already loaded */</comment>
  <comment type="block">/* else must load package */</comment>
  <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remove 'getfield' result */</comment>
  <expr_stmt><expr><call><name>findloader</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_rotate</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* function &lt;-&gt; loader data */</comment>
  <expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* name is 1st argument to module loader */</comment>
  <expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* loader data is 2nd argument */</comment>
  <comment type="block">/* stack: ...; loader data; loader function; mod. name; loader data */</comment>
  <expr_stmt><expr><call><name>lua_call</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* run loader to load module */</comment>
  <comment type="block">/* stack: ...; loader data; result from loader */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lua_isnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* non-nil return? */</comment>
    <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* LOADED[name] = returned value */</comment>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* pop nil */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LUA_TNIL</name></expr>)</condition> <block>{<block_content>   <comment type="block">/* module set no value? */</comment>
    <expr_stmt><expr><call><name>lua_pushboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* use true as result */</comment>
    <expr_stmt><expr><call><name>lua_copy</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* replace loader result */</comment>
    <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* LOADED[name] = true */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lua_rotate</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* loader data &lt;-&gt; module result  */</comment>
  <return>return <expr><literal type="number">2</literal></expr>;</return>  <comment type="block">/* return module result and loader data */</comment>
</block_content>}</block></function>

<comment type="block">/* }====================================================== */</comment>




<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>luaL_Reg</name></type> <name><name>pk_funcs</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{<expr><literal type="string">"loadlib"</literal></expr>, <expr><name>ll_loadlib</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"searchpath"</literal></expr>, <expr><name>ll_searchpath</name></expr>}</block></expr>,
  <comment type="block">/* placeholders */</comment>
  <expr><block>{<expr><literal type="string">"preload"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"cpath"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"path"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"searchers"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"loaded"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
  <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>luaL_Reg</name></type> <name><name>ll_funcs</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{<expr><literal type="string">"require"</literal></expr>, <expr><name>ll_require</name></expr>}</block></expr>,
  <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>void</name></type> <name>createsearcherstable</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>lua_CFunction</name></type> <name><name>searchers</name><index>[]</index></name> <init>=
    <expr><block>{<expr><name>searcher_preload</name></expr>, <expr><name>searcher_Lua</name></expr>, <expr><name>searcher_C</name></expr>, <expr><name>searcher_Croot</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <comment type="block">/* create 'searchers' table */</comment>
  <expr_stmt><expr><call><name>lua_createtable</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>searchers</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>searchers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* fill it with predefined searchers */</comment>
  <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name><name>searchers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* set 'package' as upvalue for all searchers */</comment>
    <expr_stmt><expr><call><name>lua_pushcclosure</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>searchers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_rawseti</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"searchers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* put it in field 'searchers' */</comment>
</block_content>}</block></function>


<comment type="block">/*
** create table CLIBS to keep track of loaded C libraries,
** setting a finalizer to close all libraries when closing state.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>createclibstable</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>luaL_getsubtable</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_REGISTRYINDEX</name></expr></argument>, <argument><expr><name>CLIBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* create CLIBS table */</comment>
  <expr_stmt><expr><call><name>lua_createtable</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* create metatable for CLIBS */</comment>
  <expr_stmt><expr><call><name>lua_pushcfunction</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>gctm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"__gc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* set finalizer for CLIBS table */</comment>
  <expr_stmt><expr><call><name>lua_setmetatable</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>LUAMOD_API</name> <name>int</name></type> <name>luaopen_package</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>createclibstable</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaL_newlib</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>pk_funcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* create 'package' table */</comment>
  <expr_stmt><expr><call><name>createsearcherstable</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* set paths */</comment>
  <expr_stmt><expr><call><name>setpath</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"path"</literal></expr></argument>, <argument><expr><name>LUA_PATH_VAR</name></expr></argument>, <argument><expr><name>LUA_PATH_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setpath</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"cpath"</literal></expr></argument>, <argument><expr><name>LUA_CPATH_VAR</name></expr></argument>, <argument><expr><name>LUA_CPATH_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* store config information */</comment>
  <expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_DIRSEP</name> <literal type="string">"\n"</literal> <name>LUA_PATH_SEP</name> <literal type="string">"\n"</literal> <name>LUA_PATH_MARK</name> <literal type="string">"\n"</literal>
                     <name>LUA_EXEC_DIR</name> <literal type="string">"\n"</literal> <name>LUA_IGMARK</name> <literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"config"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* set field 'loaded' */</comment>
  <expr_stmt><expr><call><name>luaL_getsubtable</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_REGISTRYINDEX</name></expr></argument>, <argument><expr><name>LUA_LOADED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"loaded"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* set field 'preload' */</comment>
  <expr_stmt><expr><call><name>luaL_getsubtable</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_REGISTRYINDEX</name></expr></argument>, <argument><expr><name>LUA_PRELOAD_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"preload"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_pushglobaltable</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* set 'package' as upvalue for next lib */</comment>
  <expr_stmt><expr><call><name>luaL_setfuncs</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ll_funcs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* open lib into global table */</comment>
  <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* pop global table */</comment>
  <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* return 'package' table */</comment>
</block_content>}</block></function>

</unit>
