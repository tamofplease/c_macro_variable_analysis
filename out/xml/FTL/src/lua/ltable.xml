<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/lua/ltable.c"><comment type="block">/*
** $Id: ltable.c $
** Lua tables (hash)
** See Copyright Notice in lua.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ltable_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lprefix.h"</cpp:file></cpp:include>


<comment type="block">/*
** Implementation of tables (aka arrays, objects, or hash tables).
** Tables keep its elements in two parts: an array part and a hash part.
** Non-negative integer keys are all candidates to be kept in the array
** part. The actual size of the array is the largest 'n' such that
** more than half the slots between 1 and n are in use.
** Hash uses a mix of chained scatter table with Brent's variation.
** A main invariant of these tables is that, if an element is not
** in its main position (i.e. the 'original' position that its hash gives
** to it), then the colliding element is in its own main position.
** Hence even when the load factor reaches 100%, performance remains good.
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lua.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ldebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ldo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lgc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lstate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lstring.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ltable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lvm.h"</cpp:file></cpp:include>


<comment type="block">/*
** MAXABITS is the largest integer such that MAXASIZE fits in an
** unsigned int.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXABITS</name></cpp:macro>	<cpp:value>cast_int(sizeof(int) * CHAR_BIT - 1)</cpp:value></cpp:define>


<comment type="block">/*
** MAXASIZE is the maximum size of the array part. It is the minimum
** between 2^MAXABITS and the maximum size that, measured in bytes,
** fits in a 'size_t'.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXASIZE</name></cpp:macro>	<cpp:value>luaM_limitN(1u &lt;&lt; MAXABITS, TValue)</cpp:value></cpp:define>

<comment type="block">/*
** MAXHBITS is the largest integer such that 2^MAXHBITS fits in a
** signed int.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXHBITS</name></cpp:macro>	<cpp:value>(MAXABITS - 1)</cpp:value></cpp:define>


<comment type="block">/*
** MAXHSIZE is the maximum size of the hash part. It is the minimum
** between 2^MAXHBITS and the maximum size such that, measured in bytes,
** it fits in a 'size_t'.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXHSIZE</name></cpp:macro>	<cpp:value>luaM_limitN(1u &lt;&lt; MAXHBITS, Node)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hashpow2</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(gnode(t, lmod((n), sizenode(t))))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hashstr</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>hashpow2(t, (str)-&gt;hash)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hashboolean</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>hashpow2(t, p)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hashint</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>hashpow2(t, i)</cpp:value></cpp:define>


<comment type="block">/*
** for some types, it is better to avoid modulus by power of 2, as
** they tend to have many 2 factors.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hashmod</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(gnode(t, ((n) % ((sizenode(t)-1)|1))))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hashpointer</name><parameter_list>(<parameter><type><name>t</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>hashmod(t, point2uint(p))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dummynode</name></cpp:macro>		<cpp:value>(&amp;dummynode_)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Node</name></type> <name>dummynode_</name> <init>= <expr><block>{
  <expr><block>{<expr><block>{<expr><name>NULL</name></expr>}</block></expr>, <expr><name>LUA_VEMPTY</name></expr>,  <comment type="block">/* value's value and type */</comment>
   <expr><name>LUA_VNIL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><block>{<expr><name>NULL</name></expr>}</block></expr>}</block></expr>  <comment type="block">/* key type, next, and key value */</comment>
}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TValue</name></type> <name>absentkey</name> <init>= <expr><block>{<expr><name>ABSTKEYCONSTANT</name></expr>}</block></expr></init></decl>;</decl_stmt>



<comment type="block">/*
** Hash for floating-point numbers.
** The main computation should be just
**     n = frexp(n, &amp;i); return (n * INT_MAX) + i
** but there are some numerical subtleties.
** In a two-complement representation, INT_MAX does not has an exact
** representation as a float, but INT_MIN does; because the absolute
** value of 'frexp' is smaller than 1 (unless 'n' is inf/NaN), the
** absolute value of the product 'frexp * -INT_MIN' is smaller or equal
** to INT_MAX. Next, the use of 'unsigned int' avoids overflows when
** adding 'i'; the use of '~u' (instead of '-u') avoids problems with
** INT_MIN.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>l_hashfloat</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type> <name>l_hashfloat</name> <parameter_list>(<parameter><decl><type><name>lua_Number</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Integer</name></type> <name>ni</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><call><name>l_mathop</name><argument_list>(<argument><expr><name>frexp</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call> <operator>*</operator> <operator>-</operator><call><name>cast_num</name><argument_list>(<argument><expr><name>INT_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lua_numbertointeger</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ni</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* is 'n' inf/-inf/NaN? */</comment>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>luai_numisnan</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><call><name>l_mathop</name><argument_list>(<argument><expr><name>fabs</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>cast_num</name><argument_list>(<argument><expr><name>HUGE_VAL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if>
  <else>else <block>{<block_content>  <comment type="block">/* normal case */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>u</name> <init>= <expr><call><name>cast_uint</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>cast_uint</name><argument_list>(<argument><expr><name>ni</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>cast_int</name><argument_list>(<argument><expr><ternary><condition><expr><name>u</name> <operator>&lt;=</operator> <call><name>cast_uint</name><argument_list>(<argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>u</name></expr> </then><else>: <expr><operator>~</operator><name>u</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** returns the 'main' position of an element in a table (that is,
** the index of its hash value). The key comes broken (tag in 'ktt'
** and value in 'vkl') so that we can call it on keys inserted into
** nodes.
*/</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>mainposition</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ktt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Value</name> <modifier>*</modifier></type><name>kvl</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><call><name>withvariant</name><argument_list>(<argument><expr><name>ktt</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LUA_VNUMINT</name></expr>:</case>
      <return>return <expr><call><name>hashint</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>ivalueraw</name><argument_list>(<argument><expr><operator>*</operator><name>kvl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_VNUMFLT</name></expr>:</case>
      <return>return <expr><call><name>hashmod</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>l_hashfloat</name><argument_list>(<argument><expr><call><name>fltvalueraw</name><argument_list>(<argument><expr><operator>*</operator><name>kvl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_VSHRSTR</name></expr>:</case>
      <return>return <expr><call><name>hashstr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>tsvalueraw</name><argument_list>(<argument><expr><operator>*</operator><name>kvl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_VLNGSTR</name></expr>:</case>
      <return>return <expr><call><name>hashpow2</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>luaS_hashlongstr</name><argument_list>(<argument><expr><call><name>tsvalueraw</name><argument_list>(<argument><expr><operator>*</operator><name>kvl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_VFALSE</name></expr>:</case>
      <return>return <expr><call><name>hashboolean</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_VTRUE</name></expr>:</case>
      <return>return <expr><call><name>hashboolean</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_VLIGHTUSERDATA</name></expr>:</case>
      <return>return <expr><call><name>hashpointer</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>pvalueraw</name><argument_list>(<argument><expr><operator>*</operator><name>kvl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_VLCF</name></expr>:</case>
      <return>return <expr><call><name>hashpointer</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>fvalueraw</name><argument_list>(<argument><expr><operator>*</operator><name>kvl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    <default>default:</default>
      <return>return <expr><call><name>hashpointer</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>gcvalueraw</name><argument_list>(<argument><expr><operator>*</operator><name>kvl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
** Returns the main position of an element given as a 'TValue'
*/</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>mainpositionTV</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>mainposition</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>rawtt</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>valraw</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Check whether key 'k1' is equal to the key in node 'n2'.
** This equality is raw, so there are no metamethods. Floats
** with integer values have been normalized, so integers cannot
** be equal to floats. It is assumed that 'eqshrstr' is simply
** pointer equality, so that short strings are handled in the
** default case.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>equalkey</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>k1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Node</name> <modifier>*</modifier></type><name>n2</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>rawtt</name><argument_list>(<argument><expr><name>k1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>keytt</name><argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* not the same variants? */</comment>
   <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* cannot be same key */</comment>
  <switch>switch <condition>(<expr><call><name>ttypetag</name><argument_list>(<argument><expr><name>k1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LUA_VNIL</name></expr>:</case> <case>case <expr><name>LUA_VFALSE</name></expr>:</case> <case>case <expr><name>LUA_VTRUE</name></expr>:</case>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    <case>case <expr><name>LUA_VNUMINT</name></expr>:</case>
      <return>return <expr><operator>(</operator><call><name>ivalue</name><argument_list>(<argument><expr><name>k1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>keyival</name><argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
    <case>case <expr><name>LUA_VNUMFLT</name></expr>:</case>
      <return>return <expr><call><name>luai_numeq</name><argument_list>(<argument><expr><call><name>fltvalue</name><argument_list>(<argument><expr><name>k1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>fltvalueraw</name><argument_list>(<argument><expr><call><name>keyval</name><argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_VLIGHTUSERDATA</name></expr>:</case>
      <return>return <expr><call><name>pvalue</name><argument_list>(<argument><expr><name>k1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>pvalueraw</name><argument_list>(<argument><expr><call><name>keyval</name><argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_VLCF</name></expr>:</case>
      <return>return <expr><call><name>fvalue</name><argument_list>(<argument><expr><name>k1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>fvalueraw</name><argument_list>(<argument><expr><call><name>keyval</name><argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_VLNGSTR</name></expr>:</case>
      <return>return <expr><call><name>luaS_eqlngstr</name><argument_list>(<argument><expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>k1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>keystrval</name><argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    <default>default:</default>
      <return>return <expr><call><name>gcvalue</name><argument_list>(<argument><expr><name>k1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>gcvalueraw</name><argument_list>(<argument><expr><call><name>keyval</name><argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
** True if value of 'alimit' is equal to the real size of the array
** part of table 't'. (Otherwise, the array part must be larger than
** 'alimit'.)
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>limitequalsasize</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(isrealasize(t) || ispow2((t)-&gt;alimit))</cpp:value></cpp:define>


<comment type="block">/*
** Returns the real size of the 'array' array
*/</comment>
<function><type><name>LUAI_FUNC</name> <name>unsigned</name> <name>int</name></type> <name>luaH_realasize</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>limitequalsasize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name><name>t</name><operator>-&gt;</operator><name>alimit</name></name></expr>;</return></block_content></block></if>  <comment type="block">/* this is the size */</comment>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name> <init>= <expr><name><name>t</name><operator>-&gt;</operator><name>alimit</name></name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* compute the smallest power of 2 not smaller than 'n' */</comment>
    <expr_stmt><expr><name>size</name> <operator>|=</operator> <operator>(</operator><name>size</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>|=</operator> <operator>(</operator><name>size</name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>|=</operator> <operator>(</operator><name>size</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>|=</operator> <operator>(</operator><name>size</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>|=</operator> <operator>(</operator><name>size</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>UINT_MAX</name> <operator>&gt;</operator><name>&gt;</name> <literal type="number">30</literal><operator>)</operator> <operator>&gt;</operator> <literal type="number">3</literal></expr></cpp:if>
    <expr_stmt><expr><name>size</name> <operator>|=</operator> <operator>(</operator><name>size</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* unsigned int has more than 32 bits */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>size</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ispow2</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>size</name><operator>/</operator><literal type="number">2</literal> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>alimit</name></name> <operator>&amp;&amp;</operator> <name><name>t</name><operator>-&gt;</operator><name>alimit</name></name> <operator>&lt;</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>size</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Check whether real size of the array is a power of 2.
** (If it is not, 'alimit' cannot be changed to any other value
** without changing the real size.)
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ispow2realasize</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><operator>!</operator><call><name>isrealasize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ispow2</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>alimit</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>setlimittosize</name> <parameter_list>(<parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>alimit</name></name> <operator>=</operator> <call><name>luaH_realasize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setrealasize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>t</name><operator>-&gt;</operator><name>alimit</name></name></expr>;</return>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>limitasasize</name><parameter_list>(<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>check_exp(isrealasize(t), t-&gt;alimit)</cpp:value></cpp:define>



<comment type="block">/*
** "Generic" get version. (Not that generic: not valid for integers,
** which may be in array part, nor for floats with integral values.)
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>getgeneric</name> <parameter_list>(<parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>mainpositionTV</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>  <comment type="block">/* check whether 'key' is somewhere in the chain */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>equalkey</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>  <comment type="block">/* that's it */</comment>
    <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nx</name> <init>= <expr><call><name>gnext</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>nx</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>&amp;</operator><name>absentkey</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* not found */</comment>
      <expr_stmt><expr><name>n</name> <operator>+=</operator> <name>nx</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
** returns the index for 'k' if 'k' is an appropriate key to live in
** the array part of a table, 0 otherwise.
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>arrayindex</name> <parameter_list>(<parameter><decl><type><name>lua_Integer</name></type> <name>k</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>l_castS2U</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1u</literal> <operator>&lt;</operator> <name>MAXASIZE</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* 'k' in [1, MAXASIZE]? */</comment>
    <return>return <expr><call><name>cast_uint</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>  <comment type="block">/* 'key' is an appropriate array index */</comment>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** returns the index of a 'key' for table traversals. First goes all
** elements in the array part, then elements in the hash part. The
** beginning of a traversal is signaled by 0.
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>findindex</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
                               <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>asize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ttisnil</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* first iteration */</comment>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><call><name>ttisinteger</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>arrayindex</name><argument_list>(<argument><expr><call><name>ivalue</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>i</name> <operator>-</operator> <literal type="number">1u</literal> <operator>&lt;</operator> <name>asize</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* is 'key' inside array part? */</comment>
    <return>return <expr><name>i</name></expr>;</return></block_content></block></if>  <comment type="block">/* yes; that's the index */</comment>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>getgeneric</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>isabstkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"invalid key to 'next'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* key not found */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>cast_int</name><argument_list>(<argument><expr><call><name>nodefromval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>gnode</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* key index in hash table */</comment>
    <comment type="block">/* hash elements are numbered after array ones */</comment>
    <return>return <expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name>asize</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>luaH_next</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>asize</name> <init>= <expr><call><name>luaH_realasize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><call><name>findindex</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>asize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* find original key */</comment>
  <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>asize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>  <comment type="block">/* try first array part */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isempty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* a non-empty entry? */</comment>
      <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setobj2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>key</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <for>for <control>(<init><expr><name>i</name> <operator>-=</operator> <name>asize</name></expr>;</init> <condition><expr><call><name>cast_int</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>sizenode</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>  <comment type="block">/* hash part */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isempty</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><call><name>gnode</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* a non-empty entry? */</comment>
      <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>gnode</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>getnodekey</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setobj2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>key</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* no more elements */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>freehash</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdummy</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaM_freearray</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><call><name>cast_sizet</name><argument_list>(<argument><expr><call><name>sizenode</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** {=============================================================
** Rehash
** ==============================================================
*/</comment>

<comment type="block">/*
** Compute the optimal size for the array part of table 't'. 'nums' is a
** "count array" where 'nums[i]' is the number of integers in the table
** between 2^(i - 1) + 1 and 2^i. 'pna' enters with the total number of
** integer keys in the table and leaves with the number of keys that
** will go to the array part; return the optimal size.  (The condition
** 'twotoi &gt; 0' in the for loop stops the loop if 'twotoi' overflows.)
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>computesizes</name> <parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name><name>nums</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>pna</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>twotoi</name></decl>;</decl_stmt>  <comment type="block">/* 2^i (candidate for optimal size) */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>a</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* number of elements smaller than 2^i */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>na</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* number of elements to go to array part */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>optimal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* optimal size for array part */</comment>
  <comment type="block">/* loop while keys can fill more than half of total size */</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>twotoi</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init>
       <condition><expr><name>twotoi</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>pna</name> <operator>&gt;</operator> <name>twotoi</name> <operator>/</operator> <literal type="number">2</literal></expr>;</condition>
       <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>twotoi</name> <operator>*=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name>a</name> <operator>+=</operator> <name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>a</name> <operator>&gt;</operator> <name>twotoi</name><operator>/</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* more than half elements present? */</comment>
      <expr_stmt><expr><name>optimal</name> <operator>=</operator> <name>twotoi</name></expr>;</expr_stmt>  <comment type="block">/* optimal size (till now) */</comment>
      <expr_stmt><expr><name>na</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>  <comment type="block">/* all elements up to 'optimal' will go to array part */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><name>optimal</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>optimal</name> <operator>/</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name>na</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>na</name> <operator>&lt;=</operator> <name>optimal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>pna</name> <operator>=</operator> <name>na</name></expr>;</expr_stmt>
  <return>return <expr><name>optimal</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>countint</name> <parameter_list>(<parameter><decl><type><name>lua_Integer</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>nums</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>k</name> <init>= <expr><call><name>arrayindex</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* is 'key' an appropriate array index? */</comment>
    <expr_stmt><expr><name><name>nums</name><index>[<expr><call><name>luaO_ceillog2</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* count as such */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Count keys in array part of table 't': Fill 'nums[i]' with
** number of keys that will go into corresponding slice and return
** total number of non-nil keys.
*/</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>numusearray</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>nums</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>lg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ttlg</name></decl>;</decl_stmt>  <comment type="block">/* 2^lg */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>ause</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* summation of 'nums' */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* count to traverse all array keys */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>asize</name> <init>= <expr><call><name>limitasasize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* real array size */</comment>
  <comment type="block">/* traverse each slice */</comment>
  <for>for <control>(<init><expr><name>lg</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>ttlg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>lg</name> <operator>&lt;=</operator> <name>MAXABITS</name></expr>;</condition> <incr><expr><name>lg</name><operator>++</operator></expr><operator>,</operator> <expr><name>ttlg</name> <operator>*=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>lc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* counter */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>lim</name> <init>= <expr><name>ttlg</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>lim</name> <operator>&gt;</operator> <name>asize</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>lim</name> <operator>=</operator> <name>asize</name></expr>;</expr_stmt>  <comment type="block">/* adjust upper limit */</comment>
      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>lim</name></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* no more elements to count */</comment>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* count elements in range (2^(lg - 1), 2^lg] */</comment>
    <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>lim</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isempty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>lc</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>nums</name><index>[<expr><name>lg</name></expr>]</index></name> <operator>+=</operator> <name>lc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ause</name> <operator>+=</operator> <name>lc</name></expr>;</expr_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>ause</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>numusehash</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>nums</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>pna</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>totaluse</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* total number of elements */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ause</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* elements added to 'nums' (can go to array part) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>sizenode</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>i</name><operator>--</operator></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>node</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isempty</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>keyisinteger</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ause</name> <operator>+=</operator> <call><name>countint</name><argument_list>(<argument><expr><call><name>keyival</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>totaluse</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><operator>*</operator><name>pna</name> <operator>+=</operator> <name>ause</name></expr>;</expr_stmt>
  <return>return <expr><name>totaluse</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Creates an array for the hash part of a table with the given
** size, or reuses the dummy node if size is zero.
** The computation for size overflow is in two steps: the first
** comparison ensures that the shift in the second one does not
** overflow.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setnodevector</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* no elements to hash part? */</comment>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <call><name>cast</name><argument_list>(<argument><expr><name>Node</name> <operator>*</operator></expr></argument>, <argument><expr><name>dummynode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* use common 'dummynode' */</comment>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>lsizenode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>lastfree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>  <comment type="block">/* signal that it is using dummy node */</comment>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>lsize</name> <init>= <expr><call><name>luaO_ceillog2</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>lsize</name> <operator>&gt;</operator> <name>MAXHBITS</name> <operator>||</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>lsize</name><operator>)</operator> <operator>&gt;</operator> <name>MAXHSIZE</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"table overflow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>twoto</name><argument_list>(<argument><expr><name>lsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <call><name>luaM_newvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>gnode</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>gnext</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setnilkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setempty</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>lsizenode</name></name> <operator>=</operator> <call><name>cast_byte</name><argument_list>(<argument><expr><name>lsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>lastfree</name></name> <operator>=</operator> <call><name>gnode</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* all positions are free */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** (Re)insert all elements from the hash part of 'ot' into table 't'.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>reinsert</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>ot</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><call><name>sizenode</name><argument_list>(<argument><expr><name>ot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>old</name> <init>= <expr><call><name>gnode</name><argument_list>(<argument><expr><name>ot</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isempty</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="block">/* doesn't need barrier/invalidate cache, as entry was
         already present in the table */</comment>
      <decl_stmt><decl><type><name>TValue</name></type> <name>k</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>getnodekey</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setobjt2t</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>luaH_set</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
** Exchange the hash part of 't1' and 't2'.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>exchangehashpart</name> <parameter_list>(<parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t1</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t2</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lu_byte</name></type> <name>lsizenode</name> <init>= <expr><name><name>t1</name><operator>-&gt;</operator><name>lsizenode</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>t1</name><operator>-&gt;</operator><name>node</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>lastfree</name> <init>= <expr><name><name>t1</name><operator>-&gt;</operator><name>lastfree</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>t1</name><operator>-&gt;</operator><name>lsizenode</name></name> <operator>=</operator> <name><name>t2</name><operator>-&gt;</operator><name>lsizenode</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t1</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name><name>t2</name><operator>-&gt;</operator><name>node</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t1</name><operator>-&gt;</operator><name>lastfree</name></name> <operator>=</operator> <name><name>t2</name><operator>-&gt;</operator><name>lastfree</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t2</name><operator>-&gt;</operator><name>lsizenode</name></name> <operator>=</operator> <name>lsizenode</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t2</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t2</name><operator>-&gt;</operator><name>lastfree</name></name> <operator>=</operator> <name>lastfree</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Resize table 't' for the new given sizes. Both allocations (for
** the hash part and for the array part) can fail, which creates some
** subtleties. If the first allocation, for the hash part, fails, an
** error is raised and that is it. Otherwise, it copies the elements from
** the shrinking part of the array (if it is shrinking) into the new
** hash. Then it reallocates the array part.  If that fails, the table
** is in its original state; the function frees the new hash part and then
** raises the allocation error. Otherwise, it sets the new hash part
** into the table, initializes the new part of the array (if any) with
** nils and reinserts the elements of the old hash back into the new
** parts of the table.
*/</comment>
<function><type><name>void</name></type> <name>luaH_resize</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>newasize</name></decl></parameter>,
                                          <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nhsize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name></type> <name>newt</name></decl>;</decl_stmt>  <comment type="block">/* to keep the new hash part */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>oldasize</name> <init>= <expr><call><name>setlimittosize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>newarray</name></decl>;</decl_stmt>
  <comment type="block">/* create new hash part with appropriate size into 'newt' */</comment>
  <expr_stmt><expr><call><name>setnodevector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newt</name></expr></argument>, <argument><expr><name>nhsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>newasize</name> <operator>&lt;</operator> <name>oldasize</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* will array shrink? */</comment>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>alimit</name></name> <operator>=</operator> <name>newasize</name></expr>;</expr_stmt>  <comment type="block">/* pretend array has new size... */</comment>
    <expr_stmt><expr><call><name>exchangehashpart</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* and new hash */</comment>
    <comment type="block">/* re-insert into the new hash the elements from vanishing slice */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>newasize</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>oldasize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isempty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>luaH_setint</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>alimit</name></name> <operator>=</operator> <name>oldasize</name></expr>;</expr_stmt>  <comment type="block">/* restore current size... */</comment>
    <expr_stmt><expr><call><name>exchangehashpart</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* and hash (in case of errors) */</comment>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* allocate new array */</comment>
  <expr_stmt><expr><name>newarray</name> <operator>=</operator> <call><name>luaM_reallocvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name></expr></argument>, <argument><expr><name>oldasize</name></expr></argument>, <argument><expr><name>newasize</name></expr></argument>, <argument><expr><name>TValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>newarray</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>newasize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* allocation failed? */</comment>
    <expr_stmt><expr><call><name>freehash</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* release new hash part */</comment>
    <expr_stmt><expr><call><name>luaM_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* raise error (with array unchanged) */</comment>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* allocation ok; initialize new part of the array */</comment>
  <expr_stmt><expr><call><name>exchangehashpart</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* 't' has the new hash ('newt' has the old) */</comment>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name> <operator>=</operator> <name>newarray</name></expr>;</expr_stmt>  <comment type="block">/* set new array part */</comment>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>alimit</name></name> <operator>=</operator> <name>newasize</name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>oldasize</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>newasize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* clear new slice of the array */</comment>
     <expr_stmt><expr><call><name>setempty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <comment type="block">/* re-insert elements from old hash part into new parts */</comment>
  <expr_stmt><expr><call><name>reinsert</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newt</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* 'newt' now has the old hash */</comment>
  <expr_stmt><expr><call><name>freehash</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* free old hash part */</comment>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>luaH_resizearray</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>nasize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nsize</name> <init>= <expr><call><name>allocsizenode</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaH_resize</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>nasize</name></expr></argument>, <argument><expr><name>nsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
** nums[i] = number of keys 'k' where 2^(i - 1) &lt; k &lt;= 2^i
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rehash</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>ek</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>asize</name></decl>;</decl_stmt>  <comment type="block">/* optimal size for array part */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>na</name></decl>;</decl_stmt>  <comment type="block">/* number of keys in the array part */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name><name>nums</name><index>[<expr><name>MAXABITS</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>totaluse</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>MAXABITS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content> <expr_stmt><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>  <comment type="block">/* reset counts */</comment>
  <expr_stmt><expr><call><name>setlimittosize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>na</name> <operator>=</operator> <call><name>numusearray</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>nums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* count keys in array part */</comment>
  <expr_stmt><expr><name>totaluse</name> <operator>=</operator> <name>na</name></expr>;</expr_stmt>  <comment type="block">/* all those keys are integer keys */</comment>
  <expr_stmt><expr><name>totaluse</name> <operator>+=</operator> <call><name>numusehash</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>nums</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>na</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* count keys in hash part */</comment>
  <comment type="block">/* count extra key */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ttisinteger</name><argument_list>(<argument><expr><name>ek</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>na</name> <operator>+=</operator> <call><name>countint</name><argument_list>(<argument><expr><call><name>ivalue</name><argument_list>(<argument><expr><name>ek</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>totaluse</name><operator>++</operator></expr>;</expr_stmt>
  <comment type="block">/* compute new size for array part */</comment>
  <expr_stmt><expr><name>asize</name> <operator>=</operator> <call><name>computesizes</name><argument_list>(<argument><expr><name>nums</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>na</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* resize the table to new computed sizes */</comment>
  <expr_stmt><expr><call><name>luaH_resize</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>asize</name></expr></argument>, <argument><expr><name>totaluse</name> <operator>-</operator> <name>na</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block">/*
** }=============================================================
*/</comment>


<function><type><name>Table</name> <modifier>*</modifier></type><name>luaH_new</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>luaC_newobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_VTABLE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>gco2t</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>metatable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <call><name>cast_byte</name><argument_list>(<argument><expr><name>maskflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* table has no metamethod fields */</comment>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>alimit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setnodevector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>luaH_free</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>freehash</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_freearray</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name></expr></argument>, <argument><expr><call><name>luaH_realasize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_free</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>getfreepos</name> <parameter_list>(<parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdummy</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <while>while <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>lastfree</name></name> <operator>&gt;</operator> <name><name>t</name><operator>-&gt;</operator><name>node</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>lastfree</name></name><operator>--</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>keyisnil</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>lastfree</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name><name>t</name><operator>-&gt;</operator><name>lastfree</name></name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>  <comment type="block">/* could not find a free place */</comment>
</block_content>}</block></function>



<comment type="block">/*
** inserts a new key into a hash table; first, check whether key's main
** position is free. If not, check whether colliding node is in its main
** position or not: if it is not, move colliding node to an empty place and
** put new key in its main position; otherwise (colliding node is in its main
** position), new key goes to an empty position.
*/</comment>
<function><type><name>TValue</name> <modifier>*</modifier></type><name>luaH_newkey</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>mp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name></type> <name>aux</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>ttisnil</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"table index is nil"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>ttisfloat</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Number</name></type> <name>f</name> <init>= <expr><call><name>fltvalue</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>lua_Integer</name></type> <name>k</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>luaV_flttointeger</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>, <argument><expr><name>F2Ieq</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* does key fit in an integer? */</comment>
      <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aux</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>key</name> <operator>=</operator> <operator>&amp;</operator><name>aux</name></expr>;</expr_stmt>  <comment type="block">/* insert it as an integer */</comment>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>luai_numisnan</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"table index is NaN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>mp</name> <operator>=</operator> <call><name>mainpositionTV</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isempty</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isdummy</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* main position is taken? */</comment>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>othern</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>getfreepos</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* get a free place */</comment>
    <if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* cannot find a free place? */</comment>
      <expr_stmt><expr><call><name>rehash</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* grow table */</comment>
      <comment type="block">/* whatever called 'newkey' takes care of TM cache */</comment>
      <return>return <expr><call><name>luaH_set</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* insert key into grown table */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isdummy</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>othern</name> <operator>=</operator> <call><name>mainposition</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>keytt</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>keyval</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>othern</name> <operator>!=</operator> <name>mp</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* is colliding node out of its main position? */</comment>
      <comment type="block">/* yes; move colliding node into free position */</comment>
      <while>while <condition>(<expr><name>othern</name> <operator>+</operator> <call><name>gnext</name><argument_list>(<argument><expr><name>othern</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>mp</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* find previous */</comment>
        <expr_stmt><expr><name>othern</name> <operator>+=</operator> <call><name>gnext</name><argument_list>(<argument><expr><name>othern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
      <expr_stmt><expr><call><name>gnext</name><argument_list>(<argument><expr><name>othern</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>cast_int</name><argument_list>(<argument><expr><name>f</name> <operator>-</operator> <name>othern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* rechain to point to 'f' */</comment>
      <expr_stmt><expr><operator>*</operator><name>f</name> <operator>=</operator> <operator>*</operator><name>mp</name></expr>;</expr_stmt>  <comment type="block">/* copy colliding node into free pos. (mp-&gt;next also goes) */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>gnext</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>gnext</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>+=</operator> <call><name>cast_int</name><argument_list>(<argument><expr><name>mp</name> <operator>-</operator> <name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* correct 'next' */</comment>
        <expr_stmt><expr><call><name>gnext</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* now 'mp' is free */</comment>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>setempty</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>  <comment type="block">/* colliding node is in its own main position */</comment>
      <comment type="block">/* new node will go into free position */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>gnext</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>gnext</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>cast_int</name><argument_list>(<argument><expr><operator>(</operator><name>mp</name> <operator>+</operator> <call><name>gnext</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>-</operator> <name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* chain new position */</comment>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>gnext</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <expr_stmt><expr><call><name>gnext</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>cast_int</name><argument_list>(<argument><expr><name>f</name> <operator>-</operator> <name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mp</name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>setnodekey</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>mp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaC_barrierback</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>isempty</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>gval</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Search function for integers. If integer is inside 'alimit', get it
** directly from the array part. Otherwise, if 'alimit' is not equal to
** the real size of the array, key still can be in the array part. In
** this case, try to avoid a call to 'luaH_realasize' when key is just
** one more than the limit (so that it can be incremented without
** changing the real size of the array).
*/</comment>
<function><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>luaH_getint</name> <parameter_list>(<parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>lua_Integer</name></type> <name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>l_castS2U</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1u</literal> <operator>&lt;</operator> <name><name>t</name><operator>-&gt;</operator><name>alimit</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* 'key' in [1, t-&gt;alimit]? */</comment>
    <return>return <expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>key</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>limitequalsasize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>  <comment type="block">/* key still may be in the array part? */</comment>
           <operator>(</operator><call><name>l_castS2U</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>t</name><operator>-&gt;</operator><name>alimit</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>||</operator>
            <call><name>l_castS2U</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1u</literal> <operator>&lt;</operator> <call><name>luaH_realasize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>alimit</name></name> <operator>=</operator> <call><name>cast_uint</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* probably '#t' is here now */</comment>
    <return>return <expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>key</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>hashint</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>  <comment type="block">/* check whether 'key' is somewhere in the chain */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>keyisinteger</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>keyival</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>key</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>  <comment type="block">/* that's it */</comment>
      <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nx</name> <init>= <expr><call><name>gnext</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>nx</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>n</name> <operator>+=</operator> <name>nx</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><operator>&amp;</operator><name>absentkey</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** search function for short strings
*/</comment>
<function><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>luaH_getshortstr</name> <parameter_list>(<parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>hashstr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>tt</name></name> <operator>==</operator> <name>LUA_VSHRSTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>  <comment type="block">/* check whether 'key' is somewhere in the chain */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>keyisshrstr</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>eqshrstr</name><argument_list>(<argument><expr><call><name>keystrval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>  <comment type="block">/* that's it */</comment>
    <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>nx</name> <init>= <expr><call><name>gnext</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>nx</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>&amp;</operator><name>absentkey</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* not found */</comment>
      <expr_stmt><expr><name>n</name> <operator>+=</operator> <name>nx</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>luaH_getstr</name> <parameter_list>(<parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>tt</name></name> <operator>==</operator> <name>LUA_VSHRSTR</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>luaH_getshortstr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <else>else <block>{<block_content>  <comment type="block">/* for long strings, use generic case */</comment>
    <decl_stmt><decl><type><name>TValue</name></type> <name>ko</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setsvalue</name><argument_list>(<argument><expr><call><name>cast</name><argument_list>(<argument><expr><name>lua_State</name> <operator>*</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ko</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>getgeneric</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ko</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** main search function
*/</comment>
<function><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>luaH_get</name> <parameter_list>(<parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><call><name>ttypetag</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LUA_VSHRSTR</name></expr>:</case> <return>return <expr><call><name>luaH_getshortstr</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_VNUMINT</name></expr>:</case> <return>return <expr><call><name>luaH_getint</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>ivalue</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_VNIL</name></expr>:</case> <return>return <expr><operator>&amp;</operator><name>absentkey</name></expr>;</return>
    <case>case <expr><name>LUA_VNUMFLT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>lua_Integer</name></type> <name>k</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>luaV_flttointeger</name><argument_list>(<argument><expr><call><name>fltvalue</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>, <argument><expr><name>F2Ieq</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* integral index? */</comment>
        <return>return <expr><call><name>luaH_getint</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* use specialized version */</comment>
      <comment type="block">/* else... */</comment>
    </block_content>}</block>  <comment type="block">/* FALLTHROUGH */</comment>
    <default>default:</default>
      <return>return <expr><call><name>getgeneric</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
** beware: when using this function you probably need to check a GC
** barrier and invalidate the TM cache.
*/</comment>
<function><type><name>TValue</name> <modifier>*</modifier></type><name>luaH_set</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>luaH_get</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isabstkey</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>cast</name><argument_list>(<argument><expr><name>TValue</name> <operator>*</operator></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content> <return>return <expr><call><name>luaH_newkey</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>luaH_setint</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>lua_Integer</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>luaH_getint</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isabstkey</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>cell</name> <operator>=</operator> <call><name>cast</name><argument_list>(<argument><expr><name>TValue</name> <operator>*</operator></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>TValue</name></type> <name>k</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>k</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cell</name> <operator>=</operator> <call><name>luaH_newkey</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>setobj2t</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cell</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Try to find a boundary in the hash part of table 't'. From the
** caller, we know that 'j' is zero or present and that 'j + 1' is
** present. We want to find a larger key that is absent from the
** table, so that we can do a binary search between the two keys to
** find a boundary. We keep doubling 'j' until we get an absent index.
** If the doubling would overflow, we try LUA_MAXINTEGER. If it is
** absent, we are ready for the binary search. ('j', being max integer,
** is larger or equal to 'i', but it cannot be equal because it is
** absent while 'i' is present; so 'j &gt; i'.) Otherwise, 'j' is a
** boundary. ('j + 1' cannot be a present integer key because it is
** not a valid integer in Lua.)
*/</comment>
<function><type><specifier>static</specifier> <name>lua_Unsigned</name></type> <name>hash_search</name> <parameter_list>(<parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>lua_Unsigned</name></type> <name>j</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_Unsigned</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* the caller ensures 'j + 1' is present */</comment>
  <do>do <block>{<block_content>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>  <comment type="block">/* 'i' is a present index */</comment>
    <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;=</operator> <call><name>l_castS2U</name><argument_list>(<argument><expr><name>LUA_MAXINTEGER</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>j</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else <block>{<block_content>
      <expr_stmt><expr><name>j</name> <operator>=</operator> <name>LUA_MAXINTEGER</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>isempty</name><argument_list>(<argument><expr><call><name>luaH_getint</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* t[j] not present? */</comment>
        <break>break;</break></block_content></block></if>  <comment type="block">/* 'j' now is an absent index */</comment>
      <else>else<block type="pseudo"><block_content>  <comment type="block">/* weird case */</comment>
        <return>return <expr><name>j</name></expr>;</return></block_content></block></else></if_stmt>  <comment type="block">/* well, max integer is a boundary... */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>isempty</name><argument_list>(<argument><expr><call><name>luaH_getint</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>  <comment type="block">/* repeat until an absent t[j] */</comment>
  <comment type="block">/* i &lt; j  &amp;&amp;  t[i] present  &amp;&amp;  t[j] absent */</comment>
  <while>while <condition>(<expr><name>j</name> <operator>-</operator> <name>i</name> <operator>&gt;</operator> <literal type="number">1u</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* do a binary search between them */</comment>
    <decl_stmt><decl><type><name>lua_Unsigned</name></type> <name>m</name> <init>= <expr><operator>(</operator><name>i</name> <operator>+</operator> <name>j</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>isempty</name><argument_list>(<argument><expr><call><name>luaH_getint</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>j</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>i</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>binsearch</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl></parameter>,
                                                    <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>j</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <while>while <condition>(<expr><name>j</name> <operator>-</operator> <name>i</name> <operator>&gt;</operator> <literal type="number">1u</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* binary search */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>m</name> <init>= <expr><operator>(</operator><name>i</name> <operator>+</operator> <name>j</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>isempty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>array</name><index>[<expr><name>m</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>j</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>i</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Try to find a boundary in table 't'. (A 'boundary' is an integer index
** such that t[i] is present and t[i+1] is absent, or 0 if t[1] is absent
** and 'maxinteger' if t[maxinteger] is present.)
** (In the next explanation, we use Lua indices, that is, with base 1.
** The code itself uses base 0 when indexing the array part of the table.)
** The code starts with 'limit = t-&gt;alimit', a position in the array
** part that may be a boundary.
**
** (1) If 't[limit]' is empty, there must be a boundary before it.
** As a common case (e.g., after 't[#t]=nil'), check whether 'limit-1'
** is present. If so, it is a boundary. Otherwise, do a binary search
** between 0 and limit to find a boundary. In both cases, try to
** use this boundary as the new 'alimit', as a hint for the next call.
**
** (2) If 't[limit]' is not empty and the array has more elements
** after 'limit', try to find a boundary there. Again, try first
** the special case (which should be quite frequent) where 'limit+1'
** is empty, so that 'limit' is a boundary. Otherwise, check the
** last element of the array part. If it is empty, there must be a
** boundary between the old limit (present) and the last element
** (absent), which is found with a binary search. (This boundary always
** can be a new limit.)
**
** (3) The last case is when there are no elements in the array part
** (limit == 0) or its last element (the new limit) is present.
** In this case, must check the hash part. If there is no hash part
** or 'limit+1' is absent, 'limit' is a boundary.  Otherwise, call
** 'hash_search' to find a boundary in the hash part of the table.
** (In those cases, the boundary is not inside the array part, and
** therefore cannot be used as a new limit.)
*/</comment>
<function><type><name>lua_Unsigned</name></type> <name>luaH_getn</name> <parameter_list>(<parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>limit</name> <init>= <expr><name><name>t</name><operator>-&gt;</operator><name>alimit</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>isempty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>limit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* (1)? */</comment>
    <comment type="block">/* there must be a boundary before 'limit' */</comment>
    <if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isempty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>limit</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <comment type="block">/* 'limit - 1' is a boundary; can it be a new limit? */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>ispow2realasize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ispow2</name><argument_list>(<argument><expr><name>limit</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>alimit</name></name> <operator>=</operator> <name>limit</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setnorealasize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* now 'alimit' is not the real size */</comment>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>limit</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if>
    <else>else <block>{<block_content>  <comment type="block">/* must search for a boundary in [0, limit] */</comment>
      <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>boundary</name> <init>= <expr><call><name>binsearch</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <comment type="block">/* can this boundary represent the real size of the array? */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>ispow2realasize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>boundary</name> <operator>&gt;</operator> <call><name>luaH_realasize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>alimit</name></name> <operator>=</operator> <name>boundary</name></expr>;</expr_stmt>  <comment type="block">/* use it as the new limit */</comment>
        <expr_stmt><expr><call><name>setnorealasize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name>boundary</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* 'limit' is zero or present in table */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>limitequalsasize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* (2)? */</comment>
    <comment type="block">/* 'limit' &gt; 0 and array has more elements after 'limit' */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>isempty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>limit</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* 'limit + 1' is empty? */</comment>
      <return>return <expr><name>limit</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* this is the boundary */</comment>
    <comment type="block">/* else, try last element in the array */</comment>
    <expr_stmt><expr><name>limit</name> <operator>=</operator> <call><name>luaH_realasize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>isempty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>limit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* empty? */</comment>
      <comment type="block">/* there must be a boundary in the array after old limit,
         and it must be a valid new limit */</comment>
      <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>boundary</name> <init>= <expr><call><name>binsearch</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>array</name></name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>alimit</name></name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>alimit</name></name> <operator>=</operator> <name>boundary</name></expr>;</expr_stmt>
      <return>return <expr><name>boundary</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* else, new limit is present in the table; check the hash part */</comment>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* (3) 'limit' is the last element and either is zero or present in table */</comment>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>limit</name> <operator>==</operator> <call><name>luaH_realasize</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
             <operator>(</operator><name>limit</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>isempty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>limit</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>isdummy</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isempty</name><argument_list>(<argument><expr><call><name>luaH_getint</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><call><name>cast</name><argument_list>(<argument><expr><name>lua_Integer</name></expr></argument>, <argument><expr><name>limit</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>limit</name></expr>;</return></block_content></block></if>  <comment type="block">/* 'limit + 1' is absent */</comment>
  <else>else<block type="pseudo"><block_content>  <comment type="block">/* 'limit + 1' is also present */</comment>
    <return>return <expr><call><name>hash_search</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LUA_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/* export these functions for the test library */</comment>

<function><type><name>Node</name> <modifier>*</modifier></type><name>luaH_mainposition</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>mainpositionTV</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>luaH_isdummy</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>isdummy</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
