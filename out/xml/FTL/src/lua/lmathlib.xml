<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/lua/lmathlib.c"><comment type="block">/*
** $Id: lmathlib.c $
** Standard mathematical library
** See Copyright Notice in lua.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lmathlib_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_LIB</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lprefix.h"</cpp:file></cpp:include>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lua.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lauxlib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lualib.h"</cpp:file></cpp:include>


<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PI</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PI</name></cpp:macro>	<cpp:value>(l_mathop(3.141592653589793238462643383279502884))</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>int</name></type> <name>math_abs</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>lua_isinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Integer</name></type> <name>n</name> <init>= <expr><call><name>lua_tointeger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>lua_Integer</name><operator>)</operator><operator>(</operator><literal type="number">0u</literal> <operator>-</operator> <operator>(</operator><name>lua_Unsigned</name><operator>)</operator><name>n</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>fabs</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>math_sin</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>sin</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>math_cos</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>cos</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>math_tan</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>tan</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>math_asin</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>asin</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>math_acos</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>acos</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>math_atan</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>y</name> <init>= <expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>x</name> <init>= <expr><call><name>luaL_optnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>atan2</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>math_toint</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>valid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Integer</name></type> <name>n</name> <init>= <expr><call><name>lua_tointegerx</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>valid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>valid</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>luaL_checkany</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaL_pushfail</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* value is not convertible to integer */</comment>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>pushnumint</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>lua_Number</name></type> <name>d</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_Integer</name></type> <name>n</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>lua_numbertointeger</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* does 'd' fit in an integer? */</comment>
    <expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* result is integer */</comment>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* result is float */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>math_floor</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>lua_isinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_settop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* integer is its own floor */</comment>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Number</name></type> <name>d</name> <init>= <expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>floor</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>pushnumint</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>math_ceil</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>lua_isinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_settop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* integer is its own ceil */</comment>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Number</name></type> <name>d</name> <init>= <expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>ceil</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>pushnumint</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>math_fmod</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>lua_isinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>lua_isinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Integer</name></type> <name>d</name> <init>= <expr><call><name>lua_tointeger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>lua_Unsigned</name><operator>)</operator><name>d</name> <operator>+</operator> <literal type="number">1u</literal> <operator>&lt;=</operator> <literal type="number">1u</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* special cases: -1 or 0 */</comment>
      <expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>d</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* avoid overflow with 0x80000... / -1 */</comment>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>lua_tointeger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>%</operator> <name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>fmod</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** next function does not use 'modf', avoiding problems with 'double*'
** (which is not compatible with 'float*') when lua_Number is not
** 'double'.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>math_modf</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>lua_isinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument> ,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_settop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* number is its own integer part */</comment>
    <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* no fractional part */</comment>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Number</name></type> <name>n</name> <init>= <expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* integer part (rounds toward zero) */</comment>
    <decl_stmt><decl><type><name>lua_Number</name></type> <name>ip</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>ceil</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>floor</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>pushnumint</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* fractional part (test needed for inf/-inf) */</comment>
    <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>n</name> <operator>==</operator> <name>ip</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>l_mathop</name><argument_list>(<argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>(</operator><name>n</name> <operator>-</operator> <name>ip</name><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>math_sqrt</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>sqrt</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>math_ult</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_Integer</name></type> <name>a</name> <init>= <expr><call><name>luaL_checkinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Integer</name></type> <name>b</name> <init>= <expr><call><name>luaL_checkinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_pushboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>(</operator><name>lua_Unsigned</name><operator>)</operator><name>a</name> <operator>&lt;</operator> <operator>(</operator><name>lua_Unsigned</name><operator>)</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>math_log</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>x</name> <init>= <expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>res</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>lua_isnoneornil</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><call><name>l_mathop</name><argument_list>(<argument><expr><name>log</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Number</name></type> <name>base</name> <init>= <expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LUA_USE_C89</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>base</name> <operator>==</operator> <call><name>l_mathop</name><argument_list>(<argument><expr><literal type="number">2.0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><call><name>l_mathop</name><argument_list>(<argument><expr><name>log2</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    if <condition>(<expr><name>base</name> <operator>==</operator> <call><name>l_mathop</name><argument_list>(<argument><expr><literal type="number">10.0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><call><name>l_mathop</name><argument_list>(<argument><expr><name>log10</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>res</name> <operator>=</operator> <call><call><name>l_mathop</name><argument_list>(<argument><expr><name>log</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>/</operator><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>log</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>math_exp</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>exp</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>math_deg</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>*</operator> <operator>(</operator><call><name>l_mathop</name><argument_list>(<argument><expr><literal type="number">180.0</literal></expr></argument>)</argument_list></call> <operator>/</operator> <name>PI</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>math_rad</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>*</operator> <operator>(</operator><name>PI</name> <operator>/</operator> <call><name>l_mathop</name><argument_list>(<argument><expr><literal type="number">180.0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>math_min</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* number of arguments */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>imin</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* index of current minimum value */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"value expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>lua_compare</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>imin</name></expr></argument>, <argument><expr><name>LUA_OPLT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>imin</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>imin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>math_max</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* number of arguments */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>imax</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* index of current maximum value */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"value expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>lua_compare</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>imax</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>LUA_OPLT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>imax</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>imax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>math_type</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>lua_type</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>LUA_TNUMBER</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><call><name>lua_isinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"integer"</literal></expr> </then><else>: <expr><literal type="string">"float"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>luaL_checkany</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaL_pushfail</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
** {==================================================================
** Pseudo-Random Number Generator based on 'xoshiro256**'.
** ===================================================================
*/</comment>

<comment type="block">/* number of binary digits in the mantissa of a float */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIGS</name></cpp:macro>	<cpp:value>l_floatatt(MANT_DIG)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FIGS</name> <operator>&gt;</operator> <literal type="number">64</literal></expr></cpp:if>
<comment type="block">/* there are only 64 random bits; use them all */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FIGS</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIGS</name></cpp:macro>	<cpp:value>64</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** LUA_RAND32 forces the use of 32-bit integers in the implementation
** of the PRN generator (mainly for testing).
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LUA_RAND32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>Rand64</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/* try to find an integer type with at least 64 bits */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>ULONG_MAX</name> <operator>&gt;</operator><name>&gt;</name> <literal type="number">31</literal> <operator>&gt;</operator><name>&gt;</name> <literal type="number">31</literal><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal></expr></cpp:if>

<comment type="block">/* 'long' has at least 64 bits */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Rand64</name></cpp:macro>		<cpp:value>unsigned long</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LUA_USE_C89</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>LLONG_MAX</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<comment type="block">/* there is a 'long long' type (which must have at least 64 bits) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Rand64</name></cpp:macro>		<cpp:value>unsigned long long</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><name>LUA_MAXUNSIGNED</name> <operator>&gt;</operator><name>&gt;</name> <literal type="number">31</literal> <operator>&gt;</operator><name>&gt;</name> <literal type="number">31</literal><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal></expr></cpp:elif>

<comment type="block">/* 'lua_Integer' has at least 64 bits */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Rand64</name></cpp:macro>		<cpp:value>lua_Unsigned</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Rand64</name></expr></argument>)</argument_list></call></expr></cpp:if>  <comment type="block">/* { */</comment>

<comment type="block">/*
** Standard implementation, using 64-bit integers.
** If 'Rand64' has more than 64 bits, the extra bits do not interfere
** with the 64 initial bits, except in a right shift. Moreover, the
** final result has to discard the extra bits.
*/</comment>

<comment type="block">/* avoid using extra bits when needed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>trim64</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((x) &amp; 0xffffffffffffffffu)</cpp:value></cpp:define>


<comment type="block">/* rotate left 'x' by 'n' bits */</comment>
<function><type><specifier>static</specifier> <name>Rand64</name></type> <name>rotl</name> <parameter_list>(<parameter><decl><type><name>Rand64</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><name>x</name> <operator>&lt;&lt;</operator> <name>n</name><operator>)</operator> <operator>|</operator> <operator>(</operator><call><name>trim64</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">64</literal> <operator>-</operator> <name>n</name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Rand64</name></type> <name>nextrand</name> <parameter_list>(<parameter><decl><type><name>Rand64</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Rand64</name></type> <name>state0</name> <init>= <expr><name><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Rand64</name></type> <name>state1</name> <init>= <expr><name><name>state</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Rand64</name></type> <name>state2</name> <init>= <expr><name><name>state</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>^</operator> <name>state0</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Rand64</name></type> <name>state3</name> <init>= <expr><name><name>state</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>^</operator> <name>state1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Rand64</name></type> <name>res</name> <init>= <expr><call><name>rotl</name><argument_list>(<argument><expr><name>state1</name> <operator>*</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">9</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>state0</name> <operator>^</operator> <name>state3</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>state</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>state1</name> <operator>^</operator> <name>state2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>state</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>state2</name> <operator>^</operator> <operator>(</operator><name>state1</name> <operator>&lt;&lt;</operator> <literal type="number">17</literal><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>state</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>rotl</name><argument_list>(<argument><expr><name>state3</name></expr></argument>, <argument><expr><literal type="number">45</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* must take care to not shift stuff by more than 63 slots */</comment>


<comment type="block">/*
** Convert bits from a random integer into a float in the
** interval [0,1), getting the higher FIG bits from the
** random unsigned integer and converting that to a float.
*/</comment>

<comment type="block">/* must throw out the extra (64 - FIGS) bits */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>shift64_FIG</name></cpp:macro>	<cpp:value>(64 - FIGS)</cpp:value></cpp:define>

<comment type="block">/* to scale to [0, 1), multiply by scaleFIG = 2^(-FIGS) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scaleFIG</name></cpp:macro>	<cpp:value>(l_mathop(0.5) / ((Rand64)1 &lt;&lt; (FIGS - 1)))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>lua_Number</name></type> <name>I2d</name> <parameter_list>(<parameter><decl><type><name>Rand64</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><name>lua_Number</name><operator>)</operator><operator>(</operator><call><name>trim64</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <name>shift64_FIG</name><operator>)</operator> <operator>*</operator> <name>scaleFIG</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* convert a 'Rand64' to a 'lua_Unsigned' */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>I2UInt</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((lua_Unsigned)trim64(x))</cpp:value></cpp:define>

<comment type="block">/* convert a 'lua_Unsigned' to a 'Rand64' */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Int2I</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((Rand64)(x))</cpp:value></cpp:define>


<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>	<comment type="block">/* no 'Rand64'   }{ */</comment>

<comment type="block">/* get an integer with at least 32 bits */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LUAI_IS32INT</name></expr></cpp:if>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>lu_int32</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <type><name>unsigned</name> <name>long</name></type> <name>lu_int32</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Use two 32-bit integers to represent a 64-bit quantity.
*/</comment>
<typedef>typedef <type><struct>struct <name>Rand64</name> <block>{
  <decl_stmt><decl><type><name>lu_int32</name></type> <name>h</name></decl>;</decl_stmt>  <comment type="block">/* higher half */</comment>
  <decl_stmt><decl><type><name>lu_int32</name></type> <name>l</name></decl>;</decl_stmt>  <comment type="block">/* lower half */</comment>
}</block></struct></type> <name>Rand64</name>;</typedef>


<comment type="block">/*
** If 'lu_int32' has more than 32 bits, the extra bits do not interfere
** with the 32 initial bits, except in a right shift and comparisons.
** Moreover, the final result has to discard the extra bits.
*/</comment>

<comment type="block">/* avoid using extra bits when needed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>trim32</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((x) &amp; 0xffffffffu)</cpp:value></cpp:define>


<comment type="block">/*
** basic operations on 'Rand64' values
*/</comment>

<comment type="block">/* build a new Rand64 value */</comment>
<function><type><specifier>static</specifier> <name>Rand64</name></type> <name>packI</name> <parameter_list>(<parameter><decl><type><name>lu_int32</name></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>lu_int32</name></type> <name>l</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Rand64</name></type> <name>result</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>result</name><operator>.</operator><name>h</name></name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>result</name><operator>.</operator><name>l</name></name> <operator>=</operator> <name>l</name></expr>;</expr_stmt>
  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* return i &lt;&lt; n */</comment>
<function><type><specifier>static</specifier> <name>Rand64</name></type> <name>Ishl</name> <parameter_list>(<parameter><decl><type><name>Rand64</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>packI</name><argument_list>(<argument><expr><operator>(</operator><name><name>i</name><operator>.</operator><name>h</name></name> <operator>&lt;&lt;</operator> <name>n</name><operator>)</operator> <operator>|</operator> <operator>(</operator><call><name>trim32</name><argument_list>(<argument><expr><name><name>i</name><operator>.</operator><name>l</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">32</literal> <operator>-</operator> <name>n</name><operator>)</operator><operator>)</operator></expr></argument>, <argument><expr><name><name>i</name><operator>.</operator><name>l</name></name> <operator>&lt;&lt;</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* i1 ^= i2 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>Ixor</name> <parameter_list>(<parameter><decl><type><name>Rand64</name> <modifier>*</modifier></type><name>i1</name></decl></parameter>, <parameter><decl><type><name>Rand64</name></type> <name>i2</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>i1</name><operator>-&gt;</operator><name>h</name></name> <operator>^=</operator> <name><name>i2</name><operator>.</operator><name>h</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>i1</name><operator>-&gt;</operator><name>l</name></name> <operator>^=</operator> <name><name>i2</name><operator>.</operator><name>l</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* return i1 + i2 */</comment>
<function><type><specifier>static</specifier> <name>Rand64</name></type> <name>Iadd</name> <parameter_list>(<parameter><decl><type><name>Rand64</name></type> <name>i1</name></decl></parameter>, <parameter><decl><type><name>Rand64</name></type> <name>i2</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Rand64</name></type> <name>result</name> <init>= <expr><call><name>packI</name><argument_list>(<argument><expr><name><name>i1</name><operator>.</operator><name>h</name></name> <operator>+</operator> <name><name>i2</name><operator>.</operator><name>h</name></name></expr></argument>, <argument><expr><name><name>i1</name><operator>.</operator><name>l</name></name> <operator>+</operator> <name><name>i2</name><operator>.</operator><name>l</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>trim32</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>l</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>trim32</name><argument_list>(<argument><expr><name><name>i1</name><operator>.</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* carry? */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>h</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* return i * 5 */</comment>
<function><type><specifier>static</specifier> <name>Rand64</name></type> <name>times5</name> <parameter_list>(<parameter><decl><type><name>Rand64</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>Iadd</name><argument_list>(<argument><expr><call><name>Ishl</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* i * 5 == (i &lt;&lt; 2) + i */</comment>
</block_content>}</block></function>

<comment type="block">/* return i * 9 */</comment>
<function><type><specifier>static</specifier> <name>Rand64</name></type> <name>times9</name> <parameter_list>(<parameter><decl><type><name>Rand64</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>Iadd</name><argument_list>(<argument><expr><call><name>Ishl</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* i * 9 == (i &lt;&lt; 3) + i */</comment>
</block_content>}</block></function>

<comment type="block">/* return 'i' rotated left 'n' bits */</comment>
<function><type><specifier>static</specifier> <name>Rand64</name></type> <name>rotl</name> <parameter_list>(<parameter><decl><type><name>Rand64</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>packI</name><argument_list>(<argument><expr><operator>(</operator><name><name>i</name><operator>.</operator><name>h</name></name> <operator>&lt;&lt;</operator> <name>n</name><operator>)</operator> <operator>|</operator> <operator>(</operator><call><name>trim32</name><argument_list>(<argument><expr><name><name>i</name><operator>.</operator><name>l</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">32</literal> <operator>-</operator> <name>n</name><operator>)</operator><operator>)</operator></expr></argument>,
               <argument><expr><operator>(</operator><call><name>trim32</name><argument_list>(<argument><expr><name><name>i</name><operator>.</operator><name>h</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">32</literal> <operator>-</operator> <name>n</name><operator>)</operator><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>i</name><operator>.</operator><name>l</name></name> <operator>&lt;&lt;</operator> <name>n</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* for offsets larger than 32, rotate right by 64 - offset */</comment>
<function><type><specifier>static</specifier> <name>Rand64</name></type> <name>rotl1</name> <parameter_list>(<parameter><decl><type><name>Rand64</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>n</name> <operator>&gt;</operator> <literal type="number">32</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;</operator> <literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">64</literal> <operator>-</operator> <name>n</name></expr>;</expr_stmt>
  <return>return <expr><call><name>packI</name><argument_list>(<argument><expr><operator>(</operator><call><name>trim32</name><argument_list>(<argument><expr><name><name>i</name><operator>.</operator><name>h</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <name>n</name><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>i</name><operator>.</operator><name>l</name></name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">32</literal> <operator>-</operator> <name>n</name><operator>)</operator><operator>)</operator></expr></argument>,
               <argument><expr><operator>(</operator><name><name>i</name><operator>.</operator><name>h</name></name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">32</literal> <operator>-</operator> <name>n</name><operator>)</operator><operator>)</operator> <operator>|</operator> <operator>(</operator><call><name>trim32</name><argument_list>(<argument><expr><name><name>i</name><operator>.</operator><name>l</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <name>n</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** implementation of 'xoshiro256**' algorithm on 'Rand64' values
*/</comment>
<function><type><specifier>static</specifier> <name>Rand64</name></type> <name>nextrand</name> <parameter_list>(<parameter><decl><type><name>Rand64</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Rand64</name></type> <name>res</name> <init>= <expr><call><name>times9</name><argument_list>(<argument><expr><call><name>rotl</name><argument_list>(<argument><expr><call><name>times5</name><argument_list>(<argument><expr><name><name>state</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Rand64</name></type> <name>t</name> <init>= <expr><call><name>Ishl</name><argument_list>(<argument><expr><name><name>state</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>Ixor</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Ixor</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>state</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Ixor</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>state</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Ixor</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>state</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>Ixor</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>state</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>rotl1</name><argument_list>(<argument><expr><name><name>state</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">45</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Converts a 'Rand64' into a float.
*/</comment>

<comment type="block">/* an unsigned 1 with proper type */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UONE</name></cpp:macro>		<cpp:value>((lu_int32)1)</cpp:value></cpp:define>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FIGS</name> <operator>&lt;=</operator> <literal type="number">32</literal></expr></cpp:if>

<comment type="block">/* 2^(-FIGS) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scaleFIG</name></cpp:macro>       <cpp:value>(l_mathop(0.5) / (UONE &lt;&lt; (FIGS - 1)))</cpp:value></cpp:define>

<comment type="block">/*
** get up to 32 bits from higher half, shifting right to
** throw out the extra bits.
*/</comment>
<function><type><specifier>static</specifier> <name>lua_Number</name></type> <name>I2d</name> <parameter_list>(<parameter><decl><type><name>Rand64</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>h</name> <init>= <expr><operator>(</operator><name>lua_Number</name><operator>)</operator><operator>(</operator><call><name>trim32</name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>h</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">32</literal> <operator>-</operator> <name>FIGS</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
  <return>return <expr><name>h</name> <operator>*</operator> <name>scaleFIG</name></expr>;</return>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>	<comment type="block">/* 32 &lt; FIGS &lt;= 64 */</comment>

<comment type="block">/* must take care to not shift stuff by more than 31 slots */</comment>

<comment type="block">/* 2^(-FIGS) = 1.0 / 2^30 / 2^3 / 2^(FIGS-33) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scaleFIG</name></cpp:macro>  \
	<cpp:value>((lua_Number)1.0 / (UONE &lt;&lt; 30) / 8.0 / (UONE &lt;&lt; (FIGS - 33)))</cpp:value></cpp:define>

<comment type="block">/*
** use FIGS - 32 bits from lower half, throwing out the other
** (32 - (FIGS - 32)) = (64 - FIGS) bits
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>shiftLOW</name></cpp:macro>	<cpp:value>(64 - FIGS)</cpp:value></cpp:define>

<comment type="block">/*
** higher 32 bits go after those (FIGS - 32) bits: shiftHI = 2^(FIGS - 32)
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>shiftHI</name></cpp:macro>		<cpp:value>((lua_Number)(UONE &lt;&lt; (FIGS - 33)) * 2.0)</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>lua_Number</name></type> <name>I2d</name> <parameter_list>(<parameter><decl><type><name>Rand64</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>h</name> <init>= <expr><operator>(</operator><name>lua_Number</name><operator>)</operator><call><name>trim32</name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>h</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <name>shiftHI</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>l</name> <init>= <expr><operator>(</operator><name>lua_Number</name><operator>)</operator><operator>(</operator><call><name>trim32</name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>l</name></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <name>shiftLOW</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <return>return <expr><operator>(</operator><name>h</name> <operator>+</operator> <name>l</name><operator>)</operator> <operator>*</operator> <name>scaleFIG</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* convert a 'Rand64' to a 'lua_Unsigned' */</comment>
<function><type><specifier>static</specifier> <name>lua_Unsigned</name></type> <name>I2UInt</name> <parameter_list>(<parameter><decl><type><name>Rand64</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><operator>(</operator><name>lua_Unsigned</name><operator>)</operator><call><name>trim32</name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>h</name></name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">31</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>lua_Unsigned</name><operator>)</operator><call><name>trim32</name><argument_list>(<argument><expr><name><name>x</name><operator>.</operator><name>l</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* convert a 'lua_Unsigned' to a 'Rand64' */</comment>
<function><type><specifier>static</specifier> <name>Rand64</name></type> <name>Int2I</name> <parameter_list>(<parameter><decl><type><name>lua_Unsigned</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>packI</name><argument_list>(<argument><expr><operator>(</operator><name>lu_int32</name><operator>)</operator><operator>(</operator><name>n</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>lu_int32</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* } */</comment>


<comment type="block">/*
** A state uses four 'Rand64' values.
*/</comment>
<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>Rand64</name></type> <name><name>s</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>RanState</name>;</typedef>


<comment type="block">/*
** Project the random integer 'ran' into the interval [0, n].
** Because 'ran' has 2^B possible values, the projection can only be
** uniform when the size of the interval is a power of 2 (exact
** division). Otherwise, to get a uniform projection into [0, n], we
** first compute 'lim', the smallest Mersenne number not smaller than
** 'n'. We then project 'ran' into the interval [0, lim].  If the result
** is inside [0, n], we are done. Otherwise, we try with another 'ran',
** until we have a result inside the interval.
*/</comment>
<function><type><specifier>static</specifier> <name>lua_Unsigned</name></type> <name>project</name> <parameter_list>(<parameter><decl><type><name>lua_Unsigned</name></type> <name>ran</name></decl></parameter>, <parameter><decl><type><name>lua_Unsigned</name></type> <name>n</name></decl></parameter>,
                             <parameter><decl><type><name>RanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>n</name> <operator>&amp;</operator> <operator>(</operator><name>n</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* is 'n + 1' a power of 2? */</comment>
    <return>return <expr><name>ran</name> <operator>&amp;</operator> <name>n</name></expr>;</return></block_content></block></if>  <comment type="block">/* no bias */</comment>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Unsigned</name></type> <name>lim</name> <init>= <expr><name>n</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* compute the smallest (2^b - 1) not smaller than 'n' */</comment>
    <expr_stmt><expr><name>lim</name> <operator>|=</operator> <operator>(</operator><name>lim</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>lim</name> <operator>|=</operator> <operator>(</operator><name>lim</name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>lim</name> <operator>|=</operator> <operator>(</operator><name>lim</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>lim</name> <operator>|=</operator> <operator>(</operator><name>lim</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>lim</name> <operator>|=</operator> <operator>(</operator><name>lim</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>LUA_MAXUNSIGNED</name> <operator>&gt;</operator><name>&gt;</name> <literal type="number">31</literal><operator>)</operator> <operator>&gt;=</operator> <literal type="number">3</literal></expr></cpp:if>
    <expr_stmt><expr><name>lim</name> <operator>|=</operator> <operator>(</operator><name>lim</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* integer type has more than 32 bits */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><name>lim</name> <operator>&amp;</operator> <operator>(</operator><name>lim</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>  <comment type="block">/* 'lim + 1' is a power of 2, */</comment>
      <operator>&amp;&amp;</operator> <name>lim</name> <operator>&gt;=</operator> <name>n</name>  <comment type="block">/* not smaller than 'n', */</comment>
      <operator>&amp;&amp;</operator> <operator>(</operator><name>lim</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* and it is the smallest one */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>ran</name> <operator>&amp;=</operator> <name>lim</name><operator>)</operator> <operator>&gt;</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* project 'ran' into [0..lim] */</comment>
      <expr_stmt><expr><name>ran</name> <operator>=</operator> <call><name>I2UInt</name><argument_list>(<argument><expr><call><name>nextrand</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>  <comment type="block">/* not inside [0..n]? try again */</comment>
    <return>return <expr><name>ran</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>math_random</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_Integer</name></type> <name>low</name></decl>, <decl><type ref="prev"/><name>up</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Unsigned</name></type> <name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>RanState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>RanState</name> <operator>*</operator><operator>)</operator><call><name>lua_touserdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Rand64</name></type> <name>rv</name> <init>= <expr><call><name>nextrand</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* next pseudo-random value */</comment>
  <switch>switch <condition>(<expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* check number of arguments */</comment>
    <case>case <expr><literal type="number">0</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* no arguments */</comment>
      <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>I2d</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* float between 0 and 1 */</comment>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><literal type="number">1</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* only upper limit */</comment>
      <expr_stmt><expr><name>low</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>up</name> <operator>=</operator> <call><name>luaL_checkinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>up</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* single 0 as argument? */</comment>
        <expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>I2UInt</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* full random integer */</comment>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="number">2</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* lower and upper limits */</comment>
      <expr_stmt><expr><name>low</name> <operator>=</operator> <call><name>luaL_checkinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>up</name> <operator>=</operator> <call><name>luaL_checkinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <return>return <expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"wrong number of arguments"</literal></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></switch>
  <comment type="block">/* random integer in the interval [low, up] */</comment>
  <expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>low</name> <operator>&lt;=</operator> <name>up</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"interval is empty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* project random integer into the interval [0, up - low] */</comment>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>project</name><argument_list>(<argument><expr><call><name>I2UInt</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>lua_Unsigned</name><operator>)</operator><name>up</name> <operator>-</operator> <operator>(</operator><name>lua_Unsigned</name><operator>)</operator><name>low</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <operator>(</operator><name>lua_Unsigned</name><operator>)</operator><name>low</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>setseed</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Rand64</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
                     <parameter><decl><type><name>lua_Unsigned</name></type> <name>n1</name></decl></parameter>, <parameter><decl><type><name>lua_Unsigned</name></type> <name>n2</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>state</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int2I</name><argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>state</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int2I</name><argument_list>(<argument><expr><literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* avoid a zero state */</comment>
  <expr_stmt><expr><name><name>state</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int2I</name><argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>state</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>Int2I</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>nextrand</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>  <comment type="block">/* discard initial values to "spread" seed */</comment>
  <expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Set a "random" seed. To get some randomness, use the current time
** and the address of 'L' (in case the machine does address space layout
** randomization).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>randseed</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>RanState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_Unsigned</name></type> <name>seed1</name> <init>= <expr><operator>(</operator><name>lua_Unsigned</name><operator>)</operator><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Unsigned</name></type> <name>seed2</name> <init>= <expr><operator>(</operator><name>lua_Unsigned</name><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><name>L</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setseed</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name>seed1</name></expr></argument>, <argument><expr><name>seed2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>math_randomseed</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>RanState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>RanState</name> <operator>*</operator><operator>)</operator><call><name>lua_touserdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>lua_isnone</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>randseed</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Integer</name></type> <name>n1</name> <init>= <expr><call><name>luaL_checkinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>lua_Integer</name></type> <name>n2</name> <init>= <expr><call><name>luaL_optinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>setseed</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">2</literal></expr>;</return>  <comment type="block">/* return seeds */</comment>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>luaL_Reg</name></type> <name><name>randfuncs</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{<expr><literal type="string">"random"</literal></expr>, <expr><name>math_random</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"randomseed"</literal></expr>, <expr><name>math_randomseed</name></expr>}</block></expr>,
  <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/*
** Register the random functions and initialize their state.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setrandfunc</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>RanState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>RanState</name> <operator>*</operator><operator>)</operator><call><name>lua_newuserdatauv</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RanState</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>randseed</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* initialize with a "random" seed */</comment>
  <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remove pushed seeds */</comment>
  <expr_stmt><expr><call><name>luaL_setfuncs</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>randfuncs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* }================================================================== */</comment>


<comment type="block">/*
** {==================================================================
** Deprecated functions (for compatibility only)
** ===================================================================
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LUA_COMPAT_MATHLIB</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type> <name>math_cosh</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>cosh</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>math_sinh</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>sinh</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>math_tanh</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>tanh</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>math_pow</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>x</name> <init>= <expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>y</name> <init>= <expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>pow</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>math_frexp</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>e</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>frexp</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>math_ldexp</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>x</name> <init>= <expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ep</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>luaL_checkinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>ldexp</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>math_log10</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>log10</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><call><name>luaL_checknumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* }================================================================== */</comment>



<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>luaL_Reg</name></type> <name><name>mathlib</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{<expr><literal type="string">"abs"</literal></expr>,   <expr><name>math_abs</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"acos"</literal></expr>,  <expr><name>math_acos</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"asin"</literal></expr>,  <expr><name>math_asin</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"atan"</literal></expr>,  <expr><name>math_atan</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"ceil"</literal></expr>,  <expr><name>math_ceil</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"cos"</literal></expr>,   <expr><name>math_cos</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"deg"</literal></expr>,   <expr><name>math_deg</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"exp"</literal></expr>,   <expr><name>math_exp</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"tointeger"</literal></expr>, <expr><name>math_toint</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"floor"</literal></expr>, <expr><name>math_floor</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"fmod"</literal></expr>,   <expr><name>math_fmod</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"ult"</literal></expr>,   <expr><name>math_ult</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"log"</literal></expr>,   <expr><name>math_log</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"max"</literal></expr>,   <expr><name>math_max</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"min"</literal></expr>,   <expr><name>math_min</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"modf"</literal></expr>,   <expr><name>math_modf</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"rad"</literal></expr>,   <expr><name>math_rad</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"sin"</literal></expr>,   <expr><name>math_sin</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"sqrt"</literal></expr>,  <expr><name>math_sqrt</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"tan"</literal></expr>,   <expr><name>math_tan</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"type"</literal></expr>, <expr><name>math_type</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LUA_COMPAT_MATHLIB</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr><block>{<expr><literal type="string">"atan2"</literal></expr>, <expr><name>math_atan</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"cosh"</literal></expr>,   <expr><name>math_cosh</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"sinh"</literal></expr>,   <expr><name>math_sinh</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"tanh"</literal></expr>,   <expr><name>math_tanh</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"pow"</literal></expr>,   <expr><name>math_pow</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"frexp"</literal></expr>, <expr><name>math_frexp</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"ldexp"</literal></expr>, <expr><name>math_ldexp</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"log10"</literal></expr>, <expr><name>math_log10</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <comment type="block">/* placeholders */</comment>
  <expr><block>{<expr><literal type="string">"random"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"randomseed"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"pi"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"huge"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"maxinteger"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"mininteger"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,
  <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/*
** Open math library
*/</comment>
<function><type><name>LUAMOD_API</name> <name>int</name></type> <name>luaopen_math</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>luaL_newlib</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>mathlib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>PI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"pi"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_pushnumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>(</operator><name>lua_Number</name><operator>)</operator><name>HUGE_VAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"huge"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_MAXINTEGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"maxinteger"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_MININTEGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"mininteger"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setrandfunc</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

</unit>
