<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/lua/ldo.c"><comment type="block">/*
** $Id: ldo.c $
** Stack and Call structure of Lua
** See Copyright Notice in lua.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ldo_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lprefix.h"</cpp:file></cpp:include>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;setjmp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lua.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ldebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ldo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lfunc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lgc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lopcodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lparser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lstate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lstring.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ltable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ltm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lundump.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lvm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lzio.h"</cpp:file></cpp:include>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>errorstatus</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((s) &gt; LUA_YIELD)</cpp:value></cpp:define>


<comment type="block">/*
** {======================================================
** Error-recovery functions
** =======================================================
*/</comment>

<comment type="block">/*
** LUAI_THROW/LUAI_TRY define how Lua does exception handling. By
** default, Lua handles errors with exceptions when compiling as
** C++ code, with _longjmp/_setjmp when asked to use them, and with
** longjmp/setjmp otherwise.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LUAI_THROW</name></expr></argument>)</argument_list></call></expr></cpp:if>				<comment type="block">/* { */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LUA_USE_LONGJMP</name></expr></argument>)</argument_list></call></expr></cpp:if>	<comment type="block">/* { */</comment>

<comment type="block">/* C++ exceptions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUAI_THROW</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>throw(c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUAI_TRY</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>try { a } catch(...) { if ((c)-&gt;status == 0) (c)-&gt;status = -1; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luai_jmpbuf</name></cpp:macro>		<cpp:value>int</cpp:value></cpp:define>  <comment type="block">/* dummy variable */</comment>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LUA_USE_POSIX</name></expr></argument>)</argument_list></call></expr></cpp:elif>				<comment type="block">/* }{ */</comment>

<comment type="block">/* in POSIX, try _longjmp/_setjmp (more efficient) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUAI_THROW</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>_longjmp((c)-&gt;b, 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUAI_TRY</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>if (_setjmp((c)-&gt;b) == 0) { a }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luai_jmpbuf</name></cpp:macro>		<cpp:value>jmp_buf</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* }{ */</comment>

<comment type="block">/* ISO C handling with long jumps */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUAI_THROW</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>longjmp((c)-&gt;b, 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUAI_TRY</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>if (setjmp((c)-&gt;b) == 0) { a }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luai_jmpbuf</name></cpp:macro>		<cpp:value>jmp_buf</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* } */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* } */</comment>



<comment type="block">/* chain list of long jump buffers */</comment>
<struct>struct <name>lua_longjmp</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>lua_longjmp</name></name> <modifier>*</modifier></type><name>previous</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>luai_jmpbuf</name></type> <name>b</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>status</name></decl>;</decl_stmt>  <comment type="block">/* error code */</comment>
}</block>;</struct>


<function><type><name>void</name></type> <name>luaD_seterrorobj</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>oldtop</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>errcode</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LUA_ERRMEM</name></expr>:</case> <block>{<block_content>  <comment type="block">/* memory error? */</comment>
      <expr_stmt><expr><call><name>setsvalue2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>oldtop</name></expr></argument>, <argument><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>memerrmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* reuse preregistered msg. */</comment>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>LUA_ERRERR</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>setsvalue2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>oldtop</name></expr></argument>, <argument><expr><call><name>luaS_newliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"error in error handling"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>CLOSEPROTECT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>oldtop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* no error message */</comment>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>setobjs2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>oldtop</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* error message on current top */</comment>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>oldtop</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>l_noret</name></type> <name>luaD_throw</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>errorJmp</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* thread has an error handler? */</comment>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errorJmp</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>errcode</name></expr>;</expr_stmt>  <comment type="block">/* set status */</comment>
    <expr_stmt><expr><call><name>LUAI_THROW</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>errorJmp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* jump to it */</comment>
  </block_content>}</block></if>
  <else>else <block>{<block_content>  <comment type="block">/* thread has no error handler */</comment>
    <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>luaF_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>, <argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* close all upvalues */</comment>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <call><name>cast_byte</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* mark it as dead */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>mainthread</name><operator>-&gt;</operator><name>errorJmp</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* main thread has a handler? */</comment>
      <expr_stmt><expr><call><name>setobjs2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>mainthread</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* copy error obj. */</comment>
      <expr_stmt><expr><call><name>luaD_throw</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>mainthread</name></name></expr></argument>, <argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* re-throw in main thread */</comment>
    </block_content>}</block></if>
    <else>else <block>{<block_content>  <comment type="block">/* no handler at all; abort */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>panic</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* panic function? */</comment>
        <expr_stmt><expr><call><name>luaD_seterrorobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>errcode</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* assume EXTRA_STACK */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* pushing msg. can break this invariant */</comment>
        <expr_stmt><expr><call><name>lua_unlock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>g</name><operator>-&gt;</operator><name>panic</name></name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* call panic function (last chance to jump out) */</comment>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>luaD_rawrunprotected</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Pfunc</name></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ud</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>l_uint32</name></type> <name>oldnCcalls</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>Cstacklimit</name></name> <operator>-</operator> <operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name> <operator>+</operator> <name><name>L</name><operator>-&gt;</operator><name>nci</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>lua_longjmp</name></name></type> <name>lj</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>lj</name><operator>.</operator><name>status</name></name> <operator>=</operator> <name>LUA_OK</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lj</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>errorJmp</name></name></expr>;</expr_stmt>  <comment type="block">/* chain new error handler */</comment>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errorJmp</name></name> <operator>=</operator> <operator>&amp;</operator><name>lj</name></expr>;</expr_stmt>
  <macro><name>LUAI_TRY</name><argument_list>(<argument>L</argument>, <argument>&amp;lj</argument>,
    <argument>(*f)(L, ud);</argument>
  )</argument_list></macro><empty_stmt>;</empty_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errorJmp</name></name> <operator>=</operator> <name><name>lj</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>  <comment type="block">/* restore old error handler */</comment>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>Cstacklimit</name></name> <operator>-</operator> <name>oldnCcalls</name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>nci</name></name></expr>;</expr_stmt>
  <return>return <expr><name><name>lj</name><operator>.</operator><name>status</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }====================================================== */</comment>


<comment type="block">/*
** {==================================================================
** Stack reallocation
** ===================================================================
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>correctstack</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>oldstack</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>newstack</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UpVal</name> <modifier>*</modifier></type><name>up</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>oldstack</name> <operator>==</operator> <name>newstack</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* stack address did not change */</comment>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name>oldstack</name><operator>)</operator> <operator>+</operator> <name>newstack</name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>up</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>openupval</name></name></expr>;</init> <condition><expr><name>up</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>up</name> <operator>=</operator> <name><name>up</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>open</name><operator>.</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>up</name><operator>-&gt;</operator><name>v</name></name> <operator>=</operator> <call><name>s2v</name><argument_list>(<argument><expr><operator>(</operator><call><name>uplevel</name><argument_list>(<argument><expr><name>up</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>oldstack</name><operator>)</operator> <operator>+</operator> <name>newstack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <for>for <control>(<init><expr><name>ci</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr>;</init> <condition><expr><name>ci</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ci</name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>previous</name></name></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <operator>(</operator><name><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name>oldstack</name><operator>)</operator> <operator>+</operator> <name>newstack</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <operator>(</operator><name><name>ci</name><operator>-&gt;</operator><name>func</name></name> <operator>-</operator> <name>oldstack</name><operator>)</operator> <operator>+</operator> <name>newstack</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>isLua</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>trap</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* signal to update 'trap' in 'luaV_execute' */</comment>
  </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/* some space for error handling */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRORSTACKSIZE</name></cpp:macro>	<cpp:value>(LUAI_MAXSTACK + 200)</cpp:value></cpp:define>


<function><type><name>int</name></type> <name>luaD_reallocstack</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newsize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>raiseerror</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>lim</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StkId</name></type> <name>newstack</name> <init>= <expr><call><name>luaM_reallocvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>, <argument><expr><name>lim</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>, <argument><expr><name>StackValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>newsize</name> <operator>&lt;=</operator> <name>LUAI_MAXSTACK</name> <operator>||</operator> <name>newsize</name> <operator>==</operator> <name>ERRORSTACKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>stack_last</name></name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>stack</name></name> <operator>==</operator> <name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name> <operator>-</operator> <name>EXTRA_STACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>newstack</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* reallocation failed? */</comment>
    <if_stmt><if>if <condition>(<expr><name>raiseerror</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaM_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>  <comment type="block">/* do not raise an error */</comment>
  </block_content>}</block></if></if_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>lim</name> <operator>&lt;</operator> <name>newsize</name></expr>;</condition> <incr><expr><name>lim</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>newstack</name> <operator>+</operator> <name>lim</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for> <comment type="block">/* erase new segment */</comment>
  <expr_stmt><expr><call><name>correctstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>, <argument><expr><name>newstack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name>newstack</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>stack_last</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>stack</name></name> <operator>+</operator> <name>newsize</name> <operator>-</operator> <name>EXTRA_STACK</name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Try to grow the stack by at least 'n' elements. when 'raiseerror'
** is true, raises any error; otherwise, return 0 in case of errors.
*/</comment>
<function><type><name>int</name></type> <name>luaD_growstack</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>raiseerror</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>newsize</name> <init>= <expr><literal type="number">2</literal> <operator>*</operator> <name>size</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* tentative new size */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>size</name> <operator>&gt;</operator> <name>LUAI_MAXSTACK</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* need more space after extra size? */</comment>
    <if_stmt><if>if <condition>(<expr><name>raiseerror</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaD_throw</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_ERRERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* error inside message handler */</comment>
    <else>else<block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>needed</name> <init>= <expr><call><name>cast_int</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>n</name> <operator>+</operator> <name>EXTRA_STACK</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>newsize</name> <operator>&gt;</operator> <name>LUAI_MAXSTACK</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* cannot cross the limit */</comment>
      <expr_stmt><expr><name>newsize</name> <operator>=</operator> <name>LUAI_MAXSTACK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>newsize</name> <operator>&lt;</operator> <name>needed</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* but must respect what was asked for */</comment>
      <expr_stmt><expr><name>newsize</name> <operator>=</operator> <name>needed</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>newsize</name> <operator>&gt;</operator> <name>LUAI_MAXSTACK</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* stack overflow? */</comment>
      <comment type="block">/* add extra size to be able to handle the error message */</comment>
      <expr_stmt><expr><call><name>luaD_reallocstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ERRORSTACKSIZE</name></expr></argument>, <argument><expr><name>raiseerror</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>raiseerror</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"stack overflow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>  <comment type="block">/* else no errors */</comment>
  <return>return <expr><call><name>luaD_reallocstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>, <argument><expr><name>raiseerror</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>stackinuse</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StkId</name></type> <name>lim</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>ci</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr>;</init> <condition><expr><name>ci</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ci</name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>previous</name></name></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>lim</name> <operator>&lt;</operator> <name><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lim</name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>lim</name> <operator>&lt;=</operator> <name><name>L</name><operator>-&gt;</operator><name>stack_last</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>cast_int</name><argument_list>(<argument><expr><name>lim</name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</return>  <comment type="block">/* part of stack in use */</comment>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>luaD_shrinkstack</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>inuse</name> <init>= <expr><call><name>stackinuse</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>goodsize</name> <init>= <expr><name>inuse</name> <operator>+</operator> <name>BASIC_STACK_SIZE</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>goodsize</name> <operator>&gt;</operator> <name>LUAI_MAXSTACK</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>goodsize</name> <operator>=</operator> <name>LUAI_MAXSTACK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* respect stack limit */</comment>
  <comment type="block">/* if thread is currently not handling a stack overflow and its
     good size is smaller than current size, shrink its stack */</comment>
  <if_stmt><if>if <condition>(<expr><name>inuse</name> <operator>&lt;=</operator> <operator>(</operator><name>LUAI_MAXSTACK</name> <operator>-</operator> <name>EXTRA_STACK</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>goodsize</name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaD_reallocstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>goodsize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* ok if that fails */</comment>
  <else>else<block type="pseudo"><block_content>  <comment type="block">/* don't change stack */</comment>
    <macro><name>condmovestack</name><argument_list>(<argument>L</argument>,<argument>{}</argument>,<argument>{}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt></block_content></block></else></if_stmt>  <comment type="block">/* (change only for debugging) */</comment>
  <expr_stmt><expr><call><name>luaE_shrinkCI</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* shrink CI list */</comment>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>luaD_inctop</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>luaD_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* }================================================================== */</comment>


<comment type="block">/*
** Call a hook for the given event. Make sure there is a hook to be
** called. (Both 'L-&gt;hook' and 'L-&gt;hookmask', which trigger this
** function, can be changed asynchronously by signals.)
*/</comment>
<function><type><name>void</name></type> <name>luaD_hook</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
                              <parameter><decl><type><name>int</name></type> <name>ftransfer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ntransfer</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_Hook</name></type> <name>hook</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>hook</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>hook</name> <operator>&amp;&amp;</operator> <name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* make sure there is a hook */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>mask</name> <init>= <expr><name>CIST_HOOKED</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>top</name> <init>= <expr><call><name>savestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>ci_top</name> <init>= <expr><call><name>savestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>lua_Debug</name></type> <name>ar</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>ar</name><operator>.</operator><name>event</name></name> <operator>=</operator> <name>event</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ar</name><operator>.</operator><name>currentline</name></name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ar</name><operator>.</operator><name>i_ci</name></name> <operator>=</operator> <name>ci</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ntransfer</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>mask</name> <operator>|=</operator> <name>CIST_TRAN</name></expr>;</expr_stmt>  <comment type="block">/* 'ci' has transfer information */</comment>
      <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>u2</name><operator>.</operator><name>transferinfo</name><operator>.</operator><name>ftransfer</name></name> <operator>=</operator> <name>ftransfer</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>u2</name><operator>.</operator><name>transferinfo</name><operator>.</operator><name>ntransfer</name></name> <operator>=</operator> <name>ntransfer</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>luaD_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_MINSTACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* ensure minimum stack size */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>+</operator> <name>LUA_MINSTACK</name> <operator>&gt;</operator> <name><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>+</operator> <name>LUA_MINSTACK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* cannot call hooks inside a hook */</comment>
    <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>callstatus</name></name> <operator>|=</operator> <name>mask</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_unlock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call>(<modifier>*</modifier><name>hook</name>)<argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_lock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ci_top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>callstatus</name></name> <operator>&amp;=</operator> <operator>~</operator><name>mask</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Executes a call hook for Lua functions. This function is called
** whenever 'hookmask' is not zero, so it checks whether call hooks are
** active.
*/</comment>
<function><type><name>void</name></type> <name>luaD_hookcall</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>hook</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>ci</name><operator>-&gt;</operator><name>callstatus</name></name> <operator>&amp;</operator> <name>CIST_TAIL</name><operator>)</operator></expr> ?</condition><then> <expr><name>LUA_HOOKTAILCALL</name></expr> </then><else>: <expr><name>LUA_HOOKCALL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>hookmask</name></name> <operator>&amp;</operator> <name>LUA_MASKCALL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* some other hook? */</comment>
    <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* don't call hook */</comment>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>clLvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt>  <comment type="block">/* prepare top */</comment>
  <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>savedpc</name></name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* hooks assume 'pc' is already incremented */</comment>
  <expr_stmt><expr><call><name>luaD_hook</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>hook</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>numparams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>savedpc</name></name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* correct 'pc' */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>StkId</name></type> <name>rethook</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>firstres</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nres</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>oldtop</name> <init>= <expr><call><name>savestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* hook may change top */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>isLuacode</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>ci_func</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>p</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>is_vararg</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>delta</name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>nextraargs</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>numparams</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>&lt;</operator> <name><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* correct top to run hook */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>hookmask</name></name> <operator>&amp;</operator> <name>LUA_MASKRET</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* is return hook on? */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ftransfer</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>func</name></name> <operator>+=</operator> <name>delta</name></expr>;</expr_stmt>  <comment type="block">/* if vararg, back to virtual 'func' */</comment>
    <expr_stmt><expr><name>ftransfer</name> <operator>=</operator> <macro><name>cast</name><argument_list>(<argument>unsigned short</argument>, <argument>firstres - ci-&gt;func</argument>)</argument_list></macro></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaD_hook</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_HOOKRET</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>ftransfer</name></expr></argument>, <argument><expr><name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* call it */</comment>
    <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>func</name></name> <operator>-=</operator> <name>delta</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>isLua</name><argument_list>(<argument><expr><name>ci</name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>previous</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>oldpc</name></name> <operator>=</operator> <call><name>pcRel</name><argument_list>(<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>savedpc</name></name></expr></argument>, <argument><expr><call><name>ci_func</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* update 'oldpc' */</comment>
  <return>return <expr><call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>oldtop</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Check whether 'func' has a '__call' metafield. If so, put it in the
** stack, below original 'func', so that 'luaD_call' can call it. Raise
** an error if there is no '__call' metafield.
*/</comment>
<function><type><name>void</name></type> <name>luaD_tryfuncTM</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>func</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>tm</name> <init>= <expr><call><name>luaT_gettmbyobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TM_CALL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StkId</name></type> <name>p</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>ttisnil</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaG_typeerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"call"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* nothing to call */</comment>
  <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>;</init> <condition><expr><name>p</name> <operator>&gt;</operator> <name>func</name></expr>;</condition> <incr><expr><name>p</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* open space for metamethod */</comment>
    <expr_stmt><expr><call><name>setobjs2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* stack space pre-allocated by the caller */</comment>
  <expr_stmt><expr><call><name>setobj2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* metamethod is the new function to be called */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Given 'nres' results at 'firstResult', move 'wanted' of them to 'res'.
** Handle most typical cases (zero results for commands, one result for
** expressions, multiple results for tail calls/single parameters)
** separated.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>moveresults</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nres</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wanted</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>StkId</name></type> <name>firstresult</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name>wanted</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* handle typical cases separately */</comment>
    <case>case <expr><literal type="number">0</literal></expr>:</case>  <comment type="block">/* no values needed */</comment>
      <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>
      <return>return;</return>
    <case>case <expr><literal type="number">1</literal></expr>:</case>  <comment type="block">/* one value needed */</comment>
      <if_stmt><if>if <condition>(<expr><name>nres</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>   <comment type="block">/* no results? */</comment>
        <expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* adjust with nil */</comment>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>setobjs2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* move it to proper place */</comment>
      <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>res</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <return>return;</return>
    <case>case <expr><name>LUA_MULTRET</name></expr>:</case>
      <expr_stmt><expr><name>wanted</name> <operator>=</operator> <name>nres</name></expr>;</expr_stmt>  <comment type="block">/* we want all results */</comment>
      <break>break;</break>
    <default>default:</default>  <comment type="block">/* multiple results (or to-be-closed variables) */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>hastocloseCfunc</name><argument_list>(<argument><expr><name>wanted</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* to-be-closed variables? */</comment>
        <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>savedres</name> <init>= <expr><call><name>savestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>luaF_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>LUA_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* may change the stack */</comment>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>savedres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>wanted</name> <operator>=</operator> <call><name>codeNresults</name><argument_list>(<argument><expr><name>wanted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* correct value */</comment>
        <if_stmt><if>if <condition>(<expr><name>wanted</name> <operator>==</operator> <name>LUA_MULTRET</name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>wanted</name> <operator>=</operator> <name>nres</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
  <expr_stmt><expr><name>firstresult</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name>nres</name></expr>;</expr_stmt>  <comment type="block">/* index of first result */</comment>
  <comment type="block">/* move all results to correct place */</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nres</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>wanted</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>setobjs2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>res</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>firstresult</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>wanted</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* complete wanted number of results */</comment>
    <expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>res</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>res</name> <operator>+</operator> <name>wanted</name></expr>;</expr_stmt>  <comment type="block">/* top points after the last result */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Finishes a function call: calls hook if necessary, removes CallInfo,
** moves current number of results to proper place.
*/</comment>
<function><type><name>void</name></type> <name>luaD_poscall</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nres</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>hookmask</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <call><name>rethook</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name>nres</name></expr></argument>, <argument><expr><name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>previous</name></name></expr>;</expr_stmt>  <comment type="block">/* back to caller */</comment>
  <comment type="block">/* move results to proper place */</comment>
  <expr_stmt><expr><call><name>moveresults</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>ci</name><operator>-&gt;</operator><name>func</name></name></expr></argument>, <argument><expr><name>nres</name></expr></argument>, <argument><expr><name><name>ci</name><operator>-&gt;</operator><name>nresults</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>next_ci</name><parameter_list>(<parameter><type><name>L</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(L-&gt;ci-&gt;next ? L-&gt;ci-&gt;next : luaE_extendCI(L))</cpp:value></cpp:define>


<comment type="block">/*
** Prepare a function for a tail call, building its call info on top
** of the current call info. 'narg1' is the number of arguments plus 1
** (so that it includes the function itself).
*/</comment>
<function><type><name>void</name></type> <name>luaD_pretailcall</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>narg1</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>clLvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>p</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>fsize</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>maxstacksize</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* frame size */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nfixparams</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>numparams</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>narg1</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* move down function and arguments */</comment>
    <expr_stmt><expr><call><name>setobjs2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>ci</name><operator>-&gt;</operator><name>func</name></name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>func</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>checkstackGC</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>fsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>func</name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>func</name></name></expr>;</expr_stmt>  <comment type="block">/* moved-down function */</comment>
  <for>for <control>(<init>;</init> <condition><expr><name>narg1</name> <operator>&lt;=</operator> <name>nfixparams</name></expr>;</condition> <incr><expr><name>narg1</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>func</name> <operator>+</operator> <name>narg1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>  <comment type="block">/* complete missing arguments */</comment>
  <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>func</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>fsize</name></expr>;</expr_stmt>  <comment type="block">/* top for new function */</comment>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>&lt;=</operator> <name><name>L</name><operator>-&gt;</operator><name>stack_last</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>savedpc</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>code</name></name></expr>;</expr_stmt>  <comment type="block">/* starting point */</comment>
  <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>callstatus</name></name> <operator>|=</operator> <name>CIST_TAIL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>func</name> <operator>+</operator> <name>narg1</name></expr>;</expr_stmt>  <comment type="block">/* set top */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Call a function (C or Lua). The function to be called is at *func.
** The arguments are on the stack, right after the function.
** When returns, all the results are on the stack, starting at the original
** function position.
*/</comment>
<function><type><name>void</name></type> <name>luaD_call</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nresults</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_CFunction</name></type> <name>f</name></decl>;</decl_stmt>
 <label><name>retry</name>:</label>
  <switch>switch <condition>(<expr><call><name>ttypetag</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LUA_VCCL</name></expr>:</case>  <comment type="block">/* C closure */</comment>
      <expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>clCvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>f</name></expr>;</expr_stmt>
      <goto>goto <name>Cfunc</name>;</goto>
    <case>case <expr><name>LUA_VLCF</name></expr>:</case>  <comment type="block">/* light C function */</comment>
      <expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>fvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <label><name>Cfunc</name>:</label> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>  <comment type="block">/* number of returns */</comment>
      <decl_stmt><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>checkstackGCp</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_MINSTACK</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* ensure minimum stack size */</comment>
      <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name> <operator>=</operator> <name>ci</name> <operator>=</operator> <call><name>next_ci</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>nresults</name></name> <operator>=</operator> <name>nresults</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>callstatus</name></name> <operator>=</operator> <name>CIST_C</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>+</operator> <name>LUA_MINSTACK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>&lt;=</operator> <name><name>L</name><operator>-&gt;</operator><name>stack_last</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>hookmask</name></name> <operator>&amp;</operator> <name>LUA_MASKCALL</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>narg</name> <init>= <expr><call><name>cast_int</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name>func</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>luaD_hook</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_HOOKCALL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>narg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>lua_unlock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <call>(<modifier>*</modifier><name>f</name>)<argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* do the actual call */</comment>
      <expr_stmt><expr><call><name>lua_lock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>api_checknelems</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>luaD_poscall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>LUA_VLCL</name></expr>:</case> <block>{<block_content>  <comment type="block">/* Lua function */</comment>
      <decl_stmt><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>clLvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>p</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>narg</name> <init>= <expr><call><name>cast_int</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name>func</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* number of real arguments */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>nfixparams</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>numparams</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>fsize</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>maxstacksize</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* frame size */</comment>
      <expr_stmt><expr><call><name>checkstackGCp</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>fsize</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name> <operator>=</operator> <name>ci</name> <operator>=</operator> <call><name>next_ci</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>nresults</name></name> <operator>=</operator> <name>nresults</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>savedpc</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>code</name></name></expr>;</expr_stmt>  <comment type="block">/* starting point */</comment>
      <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>callstatus</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>func</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>fsize</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>func</name></name> <operator>=</operator> <name>func</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name> <operator>=</operator> <name>ci</name></expr>;</expr_stmt>
      <for>for <control>(<init>;</init> <condition><expr><name>narg</name> <operator>&lt;</operator> <name>nfixparams</name></expr>;</condition> <incr><expr><name>narg</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>  <comment type="block">/* complete missing arguments */</comment>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>&lt;=</operator> <name><name>L</name><operator>-&gt;</operator><name>stack_last</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>luaV_execute</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* run the function */</comment>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>  <comment type="block">/* not a function */</comment>
      <expr_stmt><expr><call><name>checkstackGCp</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* space for metamethod */</comment>
      <expr_stmt><expr><call><name>luaD_tryfuncTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* try to get '__call' metamethod */</comment>
      <goto>goto <name>retry</name>;</goto>  <comment type="block">/* try again with metamethod */</comment>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
** Similar to 'luaD_call', but does not allow yields during the call.
*/</comment>
<function><type><name>void</name></type> <name>luaD_callnoyield</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nResults</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>incXCcalls</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>getCcalls</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>CSTACKERR</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* possible C stack overflow? */</comment>
    <expr_stmt><expr><call><name>luaE_exitCcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* to compensate decrement in next call */</comment>
    <expr_stmt><expr><call><name>luaE_enterCcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* check properly */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>luaD_call</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>nResults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decXCcalls</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Completes the execution of an interrupted C function, calling its
** continuation function.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>finishCcall</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <comment type="block">/* must have a continuation and must be able to call it */</comment>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name><operator>.</operator><name>k</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>yieldable</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* error status can only happen in a protected call */</comment>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>ci</name><operator>-&gt;</operator><name>callstatus</name></name> <operator>&amp;</operator> <name>CIST_YPCALL</name><operator>)</operator> <operator>||</operator> <name>status</name> <operator>==</operator> <name>LUA_YIELD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ci</name><operator>-&gt;</operator><name>callstatus</name></name> <operator>&amp;</operator> <name>CIST_YPCALL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* was inside a pcall? */</comment>
    <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>callstatus</name></name> <operator>&amp;=</operator> <operator>~</operator><name>CIST_YPCALL</name></expr>;</expr_stmt>  <comment type="block">/* continuation is also inside it */</comment>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errfunc</name></name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name><operator>.</operator><name>old_errfunc</name></name></expr>;</expr_stmt>  <comment type="block">/* with the same error function */</comment>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* finish 'lua_callk'/'lua_pcall'; CIST_YPCALL and 'errfunc' already
     handled */</comment>
  <expr_stmt><expr><call><name>adjustresults</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>ci</name><operator>-&gt;</operator><name>nresults</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_unlock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name><operator>.</operator><name>k</name></name>)<argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name><operator>.</operator><name>ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* call continuation function */</comment>
  <expr_stmt><expr><call><name>lua_lock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>api_checknelems</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaD_poscall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* finish 'luaD_call' */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Executes "full continuation" (everything in the stack) of a
** previously interrupted coroutine until the stack is empty (or another
** interruption long-jumps out of the loop). If the coroutine is
** recovering from an error, 'ud' points to the error status, which must
** be passed to the first continuation function (otherwise the default
** status is LUA_YIELD).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>unroll</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ud</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>ud</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* error status? */</comment>
    <expr_stmt><expr><call><name>finishCcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>ud</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* finish 'lua_pcallk' callee */</comment>
  <while>while <condition>(<expr><operator>(</operator><name>ci</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>ci</name></name><operator>)</operator> <operator>!=</operator> <operator>&amp;</operator><name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* something in the stack */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isLua</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* C function? */</comment>
      <expr_stmt><expr><call><name>finishCcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_YIELD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* complete its execution */</comment>
    <else>else <block>{<block_content>  <comment type="block">/* Lua function */</comment>
      <expr_stmt><expr><call><name>luaV_finishOp</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* finish interrupted instruction */</comment>
      <expr_stmt><expr><call><name>luaV_execute</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* execute down to higher C 'boundary' */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
** Try to find a suspended protected call (a "recover point") for the
** given thread.
*/</comment>
<function><type><specifier>static</specifier> <name>CallInfo</name> <modifier>*</modifier></type><name>findpcall</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>ci</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr>;</init> <condition><expr><name>ci</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ci</name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>previous</name></name></expr></incr>)</control> <block>{<block_content>  <comment type="block">/* search for a pcall */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>ci</name><operator>-&gt;</operator><name>callstatus</name></name> <operator>&amp;</operator> <name>CIST_YPCALL</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>ci</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>NULL</name></expr>;</return>  <comment type="block">/* no pending pcall */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Recovers from an error in a coroutine. Finds a recover point (if
** there is one) and completes the execution of the interrupted
** 'luaD_pcall'. If there is no recover point, returns zero.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>recover</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>StkId</name></type> <name>oldtop</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><call><name>findpcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>ci</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* no recovery point */</comment>
  <comment type="block">/* "finish" luaD_pcall */</comment>
  <expr_stmt><expr><name>oldtop</name> <operator>=</operator> <call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>ci</name><operator>-&gt;</operator><name>u2</name><operator>.</operator><name>funcidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaF_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>oldtop</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* may change the stack */</comment>
  <expr_stmt><expr><name>oldtop</name> <operator>=</operator> <call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>ci</name><operator>-&gt;</operator><name>u2</name><operator>.</operator><name>funcidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaD_seterrorobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>oldtop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name> <operator>=</operator> <name>ci</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name> <operator>=</operator> <call><name>getoah</name><argument_list>(<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>callstatus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* restore original 'allowhook' */</comment>
  <expr_stmt><expr><call><name>luaD_shrinkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errfunc</name></name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name><operator>.</operator><name>old_errfunc</name></name></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* continue running the coroutine */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Signal an error in the call to 'lua_resume', not in the execution
** of the coroutine itself. (Such errors should not be handled by any
** coroutine error handler and should not kill the coroutine.)
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>resume_error</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-=</operator> <name>narg</name></expr>;</expr_stmt>  <comment type="block">/* remove args from the stack */</comment>
  <expr_stmt><expr><call><name>setsvalue2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>, <argument><expr><call><name>luaS_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* push error message */</comment>
  <expr_stmt><expr><call><name>api_incr_top</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_unlock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>LUA_ERRRUN</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Do the work for 'lua_resume' in protected mode. Most of the work
** depends on the status of the coroutine: initial state, suspended
** inside a hook, or regularly suspended (optionally with a continuation
** function), plus erroneous cases: non-suspended coroutine or dead
** coroutine.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>resume</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ud</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>*</operator><operator>(</operator><call><name>cast</name><argument_list>(<argument><expr><name>int</name><operator>*</operator></expr></argument>, <argument><expr><name>ud</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>  <comment type="block">/* number of arguments */</comment>
  <decl_stmt><decl><type><name>StkId</name></type> <name>firstArg</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name>n</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* first argument */</comment>
  <decl_stmt><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>LUA_OK</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* starting a coroutine? */</comment>
    <expr_stmt><expr><call><name>luaD_call</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>firstArg</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>LUA_MULTRET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>  <comment type="block">/* resuming from previous yield */</comment>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>LUA_YIELD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>LUA_OK</name></expr>;</expr_stmt>  <comment type="block">/* mark that it is running (again) */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>isLua</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* yielded inside a hook? */</comment>
      <expr_stmt><expr><call><name>luaV_execute</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* just continue running Lua code */</comment>
    <else>else <block>{<block_content>  <comment type="block">/* 'common' yield */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name><operator>.</operator><name>k</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* does it have a continuation function? */</comment>
        <expr_stmt><expr><call><name>lua_unlock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name><operator>.</operator><name>k</name></name>)<argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_YIELD</name></expr></argument>, <argument><expr><name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name><operator>.</operator><name>ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* call continuation */</comment>
        <expr_stmt><expr><call><name>lua_lock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>api_checknelems</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>luaD_poscall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* finish 'luaD_call' */</comment>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>unroll</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* run continuation */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>LUA_API</name> <name>int</name></type> <name>lua_resume</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>,
                                      <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nresults</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_lock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>LUA_OK</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* may be starting a coroutine */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name> <operator>!=</operator> <operator>&amp;</operator><name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* not in base level? */</comment>
      <return>return <expr><call><name>resume_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"cannot resume non-suspended coroutine"</literal></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>func</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>nargs</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* no function? */</comment>
      <return>return <expr><call><name>resume_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"cannot resume dead coroutine"</literal></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>LUA_YIELD</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* ended with errors? */</comment>
    <return>return <expr><call><name>resume_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"cannot resume dead coroutine"</literal></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>from</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name> <operator>=</operator> <name>CSTACKTHREAD</name></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>  <comment type="block">/* correct 'nCcalls' for this thread */</comment>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name> <operator>=</operator> <call><name>getCcalls</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>nci</name></name> <operator>-</operator> <name>CSTACKCF</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>nCcalls</name></name> <operator>&lt;=</operator> <name>CSTACKERR</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>resume_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"C stack overflow"</literal></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>luai_userstateresume</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>api_checknelems</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>LUA_OK</name><operator>)</operator></expr> ?</condition><then> <expr><name>nargs</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>nargs</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>luaD_rawrunprotected</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>resume</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <comment type="block">/* continue running after recoverable errors */</comment>
  <while>while <condition>(<expr><call><name>errorstatus</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>recover</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* unroll continuation */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>luaD_rawrunprotected</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>unroll</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><operator>!</operator><call><name>errorstatus</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>status</name> <operator>==</operator> <name><name>L</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* normal end or yield */</comment>
  <else>else <block>{<block_content>  <comment type="block">/* unrecoverable error */</comment>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <call><name>cast_byte</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* mark thread as 'dead' */</comment>
    <expr_stmt><expr><call><name>luaD_seterrorobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* push error message */</comment>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><operator>*</operator><name>nresults</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>status</name> <operator>==</operator> <name>LUA_YIELD</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>u2</name><operator>.</operator><name>nyield</name></name></expr>
                                    </then><else>: <expr><call><name>cast_int</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <operator>(</operator><name><name>L</name><operator>-&gt;</operator><name>ci</name><operator>-&gt;</operator><name>func</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_unlock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>LUA_API</name> <name>int</name></type> <name>lua_isyieldable</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>yieldable</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>LUA_API</name> <name>int</name></type> <name>lua_yieldk</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nresults</name></decl></parameter>, <parameter><decl><type><name>lua_KContext</name></type> <name>ctx</name></decl></parameter>,
                        <parameter><decl><type><name>lua_KFunction</name></type> <name>k</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luai_userstateyield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>nresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_lock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ci</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>api_checknelems</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>nresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><call><name>yieldable</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>L</name> <operator>!=</operator> <call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>mainthread</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"attempt to yield across a C-call boundary"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"attempt to yield from outside a coroutine"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>LUA_YIELD</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>isLua</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* inside a hook? */</comment>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isLuacode</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>api_check</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>k</name> <operator>==</operator> <name>NULL</name></expr></argument>, <argument><expr><literal type="string">"hooks cannot continue after yielding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>u2</name><operator>.</operator><name>nyield</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* no results */</comment>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>k</name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* is there a continuation? */</comment>
      <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>c</name><operator>.</operator><name>ctx</name></name> <operator>=</operator> <name>ctx</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* save context */</comment>
    <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>u2</name><operator>.</operator><name>nyield</name></name> <operator>=</operator> <name>nresults</name></expr>;</expr_stmt>  <comment type="block">/* save number of results */</comment>
    <expr_stmt><expr><call><name>luaD_throw</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_YIELD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>callstatus</name></name> <operator>&amp;</operator> <name>CIST_HOOKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* must be inside a hook */</comment>
  <expr_stmt><expr><call><name>lua_unlock</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* return to 'luaD_hook' */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Call the C function 'func' in protected mode, restoring basic
** thread information ('allowhook', etc.) and in particular
** its stack level in case of errors.
*/</comment>
<function><type><name>int</name></type> <name>luaD_pcall</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Pfunc</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>u</name></decl></parameter>,
                <parameter><decl><type><name>ptrdiff_t</name></type> <name>old_top</name></decl></parameter>, <parameter><decl><type><name>ptrdiff_t</name></type> <name>ef</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>old_ci</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lu_byte</name></type> <name>old_allowhooks</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>old_errfunc</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>errfunc</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errfunc</name></name> <operator>=</operator> <name>ef</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>luaD_rawrunprotected</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>status</name> <operator>!=</operator> <name>LUA_OK</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* an error occurred? */</comment>
    <decl_stmt><decl><type><name>StkId</name></type> <name>oldtop</name> <init>= <expr><call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>old_top</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name> <operator>=</operator> <name>old_ci</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name> <operator>=</operator> <name>old_allowhooks</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>luaF_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>oldtop</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldtop</name> <operator>=</operator> <call><name>restorestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>old_top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* previous call may change stack */</comment>
    <expr_stmt><expr><call><name>luaD_seterrorobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>oldtop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaD_shrinkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>errfunc</name></name> <operator>=</operator> <name>old_errfunc</name></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
** Execute a protected parser.
*/</comment>
<struct>struct <name>SParser</name> <block>{  <comment type="block">/* data to 'f_parser' */</comment>
  <decl_stmt><decl><type><name>ZIO</name> <modifier>*</modifier></type><name>z</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Mbuffer</name></type> <name>buff</name></decl>;</decl_stmt>  <comment type="block">/* dynamic structure used by the scanner */</comment>
  <decl_stmt><decl><type><name>Dyndata</name></type> <name>dyd</name></decl>;</decl_stmt>  <comment type="block">/* dynamic structures used by the parser */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>void</name></type> <name>checkmode</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>mode</name> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>,
       <argument><expr><literal type="string">"attempt to load a %s chunk (mode is '%s')"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaD_throw</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_ERRSYNTAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>f_parser</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ud</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>LClosure</name> <modifier>*</modifier></type><name>cl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>SParser</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>cast</name><argument_list>(<argument><expr>struct <name>SParser</name> <operator>*</operator></expr></argument>, <argument><expr><name>ud</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>zgetc</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* read first character */</comment>
  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name><name>LUA_SIGNATURE</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>checkmode</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>, <argument><expr><literal type="string">"binary"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cl</name> <operator>=</operator> <call><name>luaU_undump</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>checkmode</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>, <argument><expr><literal type="string">"text"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cl</name> <operator>=</operator> <call><name>luaY_parser</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>dyd</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>nupvalues</name></name> <operator>==</operator> <name><name>cl</name><operator>-&gt;</operator><name>p</name><operator>-&gt;</operator><name>sizeupvalues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaF_initupvals</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>luaD_protectedparser</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>ZIO</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
                                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>SParser</name></name></type> <name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>incnny</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* cannot yield during parsing */</comment>
  <expr_stmt><expr><name><name>p</name><operator>.</operator><name>z</name></name> <operator>=</operator> <name>z</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>mode</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>.</operator><name>dyd</name><operator>.</operator><name>actvar</name><operator>.</operator><name>arr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>.</operator><name>dyd</name><operator>.</operator><name>actvar</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>.</operator><name>dyd</name><operator>.</operator><name>gt</name><operator>.</operator><name>arr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>.</operator><name>dyd</name><operator>.</operator><name>gt</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>.</operator><name>dyd</name><operator>.</operator><name>label</name><operator>.</operator><name>arr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>p</name><operator>.</operator><name>dyd</name><operator>.</operator><name>label</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaZ_initbuffer</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>.</operator><name>buff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>luaD_pcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>f_parser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><call><name>savestack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>errfunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaZ_freebuffer</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>.</operator><name>buff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_freearray</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>p</name><operator>.</operator><name>dyd</name><operator>.</operator><name>actvar</name><operator>.</operator><name>arr</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>.</operator><name>dyd</name><operator>.</operator><name>actvar</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_freearray</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>p</name><operator>.</operator><name>dyd</name><operator>.</operator><name>gt</name><operator>.</operator><name>arr</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>.</operator><name>dyd</name><operator>.</operator><name>gt</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_freearray</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>p</name><operator>.</operator><name>dyd</name><operator>.</operator><name>label</name><operator>.</operator><name>arr</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>.</operator><name>dyd</name><operator>.</operator><name>label</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decnny</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>


</unit>
