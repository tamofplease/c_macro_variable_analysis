<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/lua/lua.c"><comment type="block">/*
** $Id: lua.c $
** Lua stand-alone interpreter
** See Copyright Notice in lua.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_c</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lprefix.h"</cpp:file></cpp:include>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lua.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lauxlib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lualib.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/************** Pi-hole modification ***************/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ftl_lua.h"</cpp:file></cpp:include>
<comment type="block" format="doxygen">/***************************************************/</comment>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LUA_PROGNAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_PROGNAME</name></cpp:macro>		<cpp:value>"lua"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LUA_INIT_VAR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_INIT_VAR</name></cpp:macro>		<cpp:value>"LUA_INIT"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_INITVARVERSION</name></cpp:macro>	<cpp:value>LUA_INIT_VAR LUA_VERSUFFIX</cpp:value></cpp:define>


<decl_stmt><decl><type><specifier>static</specifier> <name>lua_State</name> <modifier>*</modifier></type><name>globalL</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name> <init>= <expr><name>LUA_PROGNAME</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*
** Hook set by signal function to stop the interpreter.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>lstop</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>lua_Debug</name> <modifier>*</modifier></type><name>ar</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>ar</name></expr>;</expr_stmt>  <comment type="block">/* unused arg. */</comment>
  <expr_stmt><expr><call><name>lua_sethook</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* reset hook */</comment>
  <expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"interrupted!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Function to be called at a C signal. Because a C signal cannot
** just change a Lua state (as there is no proper synchronization),
** this function only sets a hook that, when called, will stop the
** interpreter.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>laction</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>flag</name> <init>= <expr><name>LUA_MASKCALL</name> <operator>|</operator> <name>LUA_MASKRET</name> <operator>|</operator> <name>LUA_MASKLINE</name> <operator>|</operator> <name>LUA_MASKCOUNT</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* if another SIGINT happens, terminate process */</comment>
  <expr_stmt><expr><call><name>lua_sethook</name><argument_list>(<argument><expr><name>globalL</name></expr></argument>, <argument><expr><name>lstop</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>print_usage</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>badoption</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_writestringerror</name><argument_list>(<argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>badoption</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal> <operator>||</operator> <name><name>badoption</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'l'</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_writestringerror</name><argument_list>(<argument><expr><literal type="string">"'%s' needs argument\n"</literal></expr></argument>, <argument><expr><name>badoption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_writestringerror</name><argument_list>(<argument><expr><literal type="string">"unrecognized option '%s'\n"</literal></expr></argument>, <argument><expr><name>badoption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><call><name>lua_writestringerror</name><argument_list>(
  <argument><expr><literal type="string">"usage: %s [options] [script [args]]\n"</literal>
  <literal type="string">"Available options are:\n"</literal>
  <literal type="string">"  -e stat  execute string 'stat'\n"</literal>
  <literal type="string">"  -i       enter interactive mode after executing 'script'\n"</literal>
  <literal type="string">"  -l name  require library 'name' into global 'name'\n"</literal>
  <literal type="string">"  -v       show version information\n"</literal>
  <literal type="string">"  -E       ignore environment variables\n"</literal>
  <literal type="string">"  -W       turn warnings on\n"</literal>
  <literal type="string">"  --       stop handling options\n"</literal>
  <literal type="string">"  -        stop handling options and execute stdin\n"</literal></expr></argument>
  ,
  <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Prints an error message, adding the program name in front of it
** (if present)
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>l_message</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>pname</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lua_writestringerror</name><argument_list>(<argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lua_writestringerror</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>report</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>LUA_OK</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>l_message</name><argument_list>(<argument><expr><name>progname</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remove message */</comment>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Message handler used to run all chunks
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>msghandler</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>msg</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* is error object not a string? */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>luaL_callmeta</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"__tostring"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>  <comment type="block">/* does it have a metamethod */</comment>
        <call><name>lua_type</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>LUA_TSTRING</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* that produces a string? */</comment>
      <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>  <comment type="block">/* that is the message */</comment>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>lua_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"(error object is a %s value)"</literal></expr></argument>,
                               <argument><expr><call><name>luaL_typename</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>luaL_traceback</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>L</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* append a standard traceback */</comment>
  <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* return the traceback */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Interface to 'lua_pcall', which sets appropriate message function
** and C-signal handler. Used to run all chunks.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>docall</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>narg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nres</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>base</name> <init>= <expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>narg</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* function index */</comment>
  <expr_stmt><expr><call><name>lua_pushcfunction</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>msghandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* push message handler */</comment>
  <expr_stmt><expr><call><name>lua_insert</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* put it under function and args */</comment>
  <expr_stmt><expr><name>globalL</name> <operator>=</operator> <name>L</name></expr>;</expr_stmt>  <comment type="block">/* to be available to 'laction' */</comment>
  <expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>laction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* set C-signal handler */</comment>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>lua_pcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>narg</name></expr></argument>, <argument><expr><name>nres</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>signal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* reset C-signal handler */</comment>
  <expr_stmt><expr><call><name>lua_remove</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remove message handler from the stack */</comment>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>print_version</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_writestring</name><argument_list>(<argument><expr><name>LUA_COPYRIGHT</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>LUA_COPYRIGHT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_writeline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Create the 'arg' table, which stores all arguments from the
** command line ('argv'). It should be aligned so that, at index 0,
** it has 'argv[script]', which is the script name. The arguments
** to the script (everything after 'script') go to positive indices;
** other arguments (before the script name) go to negative indices.
** If there is no script name, assume interpreter's name as base.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>createargtable</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>script</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>narg</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>script</name> <operator>==</operator> <name>argc</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>script</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* no script name? */</comment>
  <expr_stmt><expr><name>narg</name> <operator>=</operator> <name>argc</name> <operator>-</operator> <operator>(</operator><name>script</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* number of positive indices */</comment>
  <expr_stmt><expr><call><name>lua_createtable</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>narg</name></expr></argument>, <argument><expr><name>script</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_rawseti</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>i</name> <operator>-</operator> <name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>lua_setglobal</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"arg"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>dochunk</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>LUA_OK</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>docall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><call><name>report</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>dofile</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>dochunk</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>luaL_loadfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>dostring</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>dochunk</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>luaL_loadbuffer</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Calls 'require(name)' and stores the result in a global variable
** with the given name.
*/</comment>
<comment type="block" format="doxygen">/************** Pi-hole modification ***************/</comment>
<function><type><name>int</name></type> <name>dolibrary</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<comment type="block" format="doxygen">/***************************************************/</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_getglobal</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"require"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_pushstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>docall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* call 'require(name)' */</comment>
  <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>LUA_OK</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_setglobal</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* global[name] = require return */</comment>
  <return>return <expr><call><name>report</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Push on the stack the contents of table 'arg' from 1 to #arg
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pushargs</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>lua_getglobal</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"arg"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>LUA_TTABLE</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"'arg' is not a table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>luaL_len</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaL_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"too many arguments to script"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_rawgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><name>i</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>lua_remove</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remove table from the stack */</comment>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>handle_script</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>fname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* stdin */</comment>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>luaL_loadfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>LUA_OK</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>pushargs</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* push arguments to script */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>docall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>LUA_MULTRET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>report</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* bits of various argument indicators in 'args' */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>has_error</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>	<comment type="block">/* bad option */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>has_i</name></cpp:macro>		<cpp:value>2</cpp:value></cpp:define>	<comment type="block">/* -i */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>has_v</name></cpp:macro>		<cpp:value>4</cpp:value></cpp:define>	<comment type="block">/* -v */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>has_e</name></cpp:macro>		<cpp:value>8</cpp:value></cpp:define>	<comment type="block">/* -e */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>has_E</name></cpp:macro>		<cpp:value>16</cpp:value></cpp:define>	<comment type="block">/* -E */</comment>


<comment type="block">/*
** Traverses all arguments from 'argv', returning a mask with those
** needed before running any Lua code (or an error code if it finds
** any invalid argument). 'first' returns the first not-handled argument
** (either the script name or a bad argument in case of error).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>collectargs</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>first</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>args</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>first</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* not an option? */</comment>
        <return>return <expr><name>args</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* stop handling options */</comment>
    <switch>switch <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* else check option */</comment>
      <case>case <expr><literal type="char">'-'</literal></expr>:</case>  <comment type="block">/* '--' */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* extra characters after '--'? */</comment>
          <return>return <expr><name>has_error</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* invalid option */</comment>
        <expr_stmt><expr><operator>*</operator><name>first</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>args</name></expr>;</return>
      <case>case <expr><literal type="char">'\0'</literal></expr>:</case>  <comment type="block">/* '-' */</comment>
        <return>return <expr><name>args</name></expr>;</return>  <comment type="block">/* script "name" is '-' */</comment>
      <case>case <expr><literal type="char">'E'</literal></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* extra characters? */</comment>
          <return>return <expr><name>has_error</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* invalid option */</comment>
        <expr_stmt><expr><name>args</name> <operator>|=</operator> <name>has_E</name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><literal type="char">'W'</literal></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* extra characters? */</comment>
          <return>return <expr><name>has_error</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* invalid option */</comment>
        <break>break;</break>
      <case>case <expr><literal type="char">'i'</literal></expr>:</case>
        <expr_stmt><expr><name>args</name> <operator>|=</operator> <name>has_i</name></expr>;</expr_stmt>  <comment type="block">/* (-i implies -v) */</comment><comment type="block">/* FALLTHROUGH */</comment>
      <case>case <expr><literal type="char">'v'</literal></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* extra characters? */</comment>
          <return>return <expr><name>has_error</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* invalid option */</comment>
        <expr_stmt><expr><name>args</name> <operator>|=</operator> <name>has_v</name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><literal type="char">'e'</literal></expr>:</case>
        <expr_stmt><expr><name>args</name> <operator>|=</operator> <name>has_e</name></expr>;</expr_stmt>  <comment type="block">/* FALLTHROUGH */</comment>
      <case>case <expr><literal type="char">'l'</literal></expr>:</case>  <comment type="block">/* both options need an argument */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* no concatenated argument? */</comment>
          <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* try next 'argv' */</comment>
          <if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>has_error</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* no next argument or it is another option */</comment>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
      <default>default:</default>  <comment type="block">/* invalid option */</comment>
        <return>return <expr><name>has_error</name></expr>;</return>
    </block_content>}</block></switch>
  </block_content>}</block></for>
  <expr_stmt><expr><operator>*</operator><name>first</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>  <comment type="block">/* no script name */</comment>
  <return>return <expr><name>args</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Processes options 'e' and 'l', which involve running Lua code, and
** 'W', which also affects the state.
** Returns 0 if some code raises an error.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>runargs</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>option</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* already checked */</comment>
    <switch>switch <condition>(<expr><name>option</name></expr>)</condition> <block>{<block_content>
      <case>case <expr><literal type="char">'e'</literal></expr>:</case>  <case>case <expr><literal type="char">'l'</literal></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extra</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* both options need an argument */</comment>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>extra</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>extra</name> <operator>=</operator> <name><name>argv</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>extra</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>status</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>option</name> <operator>==</operator> <literal type="char">'e'</literal><operator>)</operator></expr>
                 ?</condition><then> <expr><call><name>dostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><literal type="string">"=(command line)"</literal></expr></argument>)</argument_list></call></expr>
                 </then><else>: <expr><call><name>dolibrary</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>LUA_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'W'</literal></expr>:</case>
        <expr_stmt><expr><call><name>lua_warning</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"@on"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* warnings on */</comment>
        <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>handle_luainit</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><literal type="string">"="</literal> <name>LUA_INITVARVERSION</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>init</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><name>name</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>init</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>name</name> <operator>=</operator> <literal type="string">"="</literal> <name>LUA_INIT_VAR</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>init</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><name>name</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* try alternative name */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>init</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>LUA_OK</name></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name><name>init</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'@'</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>dofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>init</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><call><name>dostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>init</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** {==================================================================
** Read-Eval-Print Loop (REPL)
** ===================================================================
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LUA_PROMPT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_PROMPT</name></cpp:macro>		<cpp:value>"&gt; "</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_PROMPT2</name></cpp:macro>		<cpp:value>"&gt;&gt; "</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LUA_MAXINPUT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_MAXINPUT</name></cpp:macro>		<cpp:value>512</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** lua_stdin_is_tty detects whether the standard input is a 'tty' (that
** is, whether we're running lua interactively).
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>lua_stdin_is_tty</name></expr></argument>)</argument_list></call></expr></cpp:if>	<comment type="block">/* { */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LUA_USE_POSIX</name></expr></argument>)</argument_list></call></expr></cpp:if>	<comment type="block">/* { */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_stdin_is_tty</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>isatty(0)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LUA_USE_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:elif>	<comment type="block">/* }{ */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_stdin_is_tty</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>_isatty(_fileno(stdin))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>				<comment type="block">/* }{ */</comment>

<comment type="block">/* ISO C definition */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_stdin_is_tty</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>  <comment type="block">/* assume stdin is a tty */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>				<comment type="block">/* } */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>				<comment type="block">/* } */</comment>


<comment type="block">/*
** lua_readline defines how to show a prompt and then read a line from
** the standard input.
** lua_saveline defines how to "save" a read line in a "history".
** lua_freeline defines how to free a line read by lua_readline.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>lua_readline</name></expr></argument>)</argument_list></call></expr></cpp:if>	<comment type="block">/* { */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LUA_USE_READLINE</name></expr></argument>)</argument_list></call></expr></cpp:if>	<comment type="block">/* { */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;readline/readline.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;readline/history.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_initreadline</name><parameter_list>(<parameter><type><name>L</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((void)L, rl_readline_name="lua")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_readline</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((void)L, ((b)=readline(p)) != NULL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_saveline</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>line</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((void)L, add_history(line))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_freeline</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((void)L, free(b))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>				<comment type="block">/* }{ */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_initreadline</name><parameter_list>(<parameter><type><name>L</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((void)L)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_readline</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> \
        <cpp:value>((void)L, fputs(p, stdout), fflush(stdout),  <comment type="block">/* show prompt */</comment> \
        fgets(b, LUA_MAXINPUT, stdin) != NULL)</cpp:value></cpp:define>  <comment type="block">/* get line */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_saveline</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>line</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>{ (void)L; (void)line; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lua_freeline</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>{ (void)L; (void)b; }</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>				<comment type="block">/* } */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>				<comment type="block">/* } */</comment>


<comment type="block">/*
** Returns the string to be used as a prompt by the interpreter.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_prompt</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>firstline</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_getglobal</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><ternary><condition><expr><name>firstline</name></expr> ?</condition><then> <expr><literal type="string">"_PROMPT"</literal></expr> </then><else>: <expr><literal type="string">"_PROMPT2"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>firstline</name></expr> ?</condition><then> <expr><name>LUA_PROMPT</name></expr> </then><else>: <expr><name>LUA_PROMPT2</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* mark in error messages for incomplete statements */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EOFMARK</name></cpp:macro>		<cpp:value>"&lt;eof&gt;"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>marklen</name></cpp:macro>		<cpp:value>(sizeof(EOFMARK)/sizeof(char) - 1)</cpp:value></cpp:define>


<comment type="block">/*
** Check whether 'status' signals a syntax error and the error
** message at the top of the stack ends with the above mark for
** incomplete statements.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>incomplete</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>LUA_ERRSYNTAX</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>lmsg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>lua_tolstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>lmsg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>lmsg</name> <operator>&gt;=</operator> <name>marklen</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>msg</name> <operator>+</operator> <name>lmsg</name> <operator>-</operator> <name>marklen</name></expr></argument>, <argument><expr><name>EOFMARK</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* else... */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Prompt the user, read a line, and push it into the Lua stack.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pushline</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>firstline</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>LUA_MAXINPUT</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prmt</name> <init>= <expr><call><name>get_prompt</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>firstline</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>readstatus</name> <init>= <expr><call><name>lua_readline</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>prmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>readstatus</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* no input (prompt will be popped by caller) */</comment>
  <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remove prompt */</comment>
  <expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>b</name><index>[<expr><name>l</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* line ends with newline? */</comment>
    <expr_stmt><expr><name><name>b</name><index>[<expr><operator>--</operator><name>l</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* remove it */</comment>
  <if_stmt><if>if <condition>(<expr><name>firstline</name> <operator>&amp;&amp;</operator> <name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* for compatibility with 5.2, ... */</comment>
    <expr_stmt><expr><call><name>lua_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"return %s"</literal></expr></argument>, <argument><expr><name>b</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* change '=' to 'return' */</comment>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_pushlstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><call><name>lua_freeline</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Try to compile line on the stack as 'return &lt;line&gt;;'; on return, stack
** has either compiled chunk or original line (if compilation failed).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>addreturn</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* original line */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>retline</name> <init>= <expr><call><name>lua_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"return %s;"</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><call><name>luaL_loadbuffer</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>retline</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>retline</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"=stdin"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>LUA_OK</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_remove</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remove modified line */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* non empty? */</comment>
      <expr_stmt><expr><call><name>lua_saveline</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* keep history */</comment>
  </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* pop result from 'luaL_loadbuffer' and modified line */</comment>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Read multiple lines until a complete Lua statement
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>multiline</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>  <comment type="block">/* repeat until gets a complete statement */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name> <init>= <expr><call><name>lua_tolstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* get what it has */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><call><name>luaL_loadbuffer</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"=stdin"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* try it */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>incomplete</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>pushline</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>lua_saveline</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* keep history */</comment>
      <return>return <expr><name>status</name></expr>;</return>  <comment type="block">/* cannot or should not try to add continuation line */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* add newline... */</comment>
    <expr_stmt><expr><call><name>lua_insert</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* ...between the two lines */</comment>
    <expr_stmt><expr><call><name>lua_concat</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* join them */</comment>
  </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
** Read a line and try to load (compile) it first as an expression (by
** adding "return " in front of it) and second as a statement. Return
** the final status of load/call with the resulting function (if any)
** in the top of the stack.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>loadline</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_settop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pushline</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* no input */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>=</operator> <call><name>addreturn</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>LUA_OK</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* 'return ...' did not work? */</comment>
    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>multiline</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* try as command, maybe with continuation lines */</comment>
  <expr_stmt><expr><call><name>lua_remove</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remove line from the stack */</comment>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Prints (calling the Lua 'print' function) any values on the stack
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>l_print</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* any result to be printed? */</comment>
    <expr_stmt><expr><call><name>luaL_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_MINSTACK</name></expr></argument>, <argument><expr><literal type="string">"too many results to print"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_getglobal</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"print"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_insert</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>lua_pcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>LUA_OK</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>l_message</name><argument_list>(<argument><expr><name>progname</name></expr></argument>, <argument><expr><call><name>lua_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"error calling 'print' (%s)"</literal></expr></argument>,
                                             <argument><expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Do the REPL: repeatedly read (load) a line, evaluate (call) it, and
** print any results.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>doREPL</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldprogname</name> <init>= <expr><name>progname</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>progname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>  <comment type="block">/* no 'progname' on errors in interactive mode */</comment>
  <expr_stmt><expr><call><name>lua_initreadline</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><operator>(</operator><name>status</name> <operator>=</operator> <call><name>loadline</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>LUA_OK</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>docall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LUA_MULTRET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>LUA_OK</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>l_print</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>report</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>lua_settop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* clear stack */</comment>
  <expr_stmt><expr><call><name>lua_writeline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>progname</name> <operator>=</operator> <name>oldprogname</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* }================================================================== */</comment>


<comment type="block">/*
** Main body of stand-alone interpreter (to be called in protected mode).
** Reads the options and handles them all.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pmain</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>lua_tointeger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>lua_touserdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>script</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>args</name> <init>= <expr><call><name>collectargs</name><argument_list>(<argument><expr><name>argv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>script</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaL_checkversion</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* check that interpreter has correct version */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>progname</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>args</name> <operator>==</operator> <name>has_error</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* bad arg? */</comment>
    <expr_stmt><expr><call><name>print_usage</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>script</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* 'script' has index of bad arg. */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>args</name> <operator>&amp;</operator> <name>has_v</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* option '-v'? */</comment>
    <expr_stmt><expr><call><name>print_version</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>args</name> <operator>&amp;</operator> <name>has_E</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* option '-E'? */</comment>
    <expr_stmt><expr><call><name>lua_pushboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* signal for libraries to ignore env. vars. */</comment>
    <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_REGISTRYINDEX</name></expr></argument>, <argument><expr><literal type="string">"LUA_NOENV"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>luaL_openlibs</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* open standard libraries */</comment>
  <expr_stmt><expr><call><name>createargtable</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* create table 'arg' */</comment>
  <expr_stmt><expr><call><name>lua_gc</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_GCGEN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* GC in generational mode */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>args</name> <operator>&amp;</operator> <name>has_E</name><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* no option '-E'? */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>handle_luainit</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>LUA_OK</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* run LUA_INIT */</comment>
      <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* error running LUA_INIT */</comment>
  </block_content>}</block></if></if_stmt>


  <comment type="block" format="doxygen">/************** Pi-hole modification ***************/</comment>
  <comment type="line">// Load and enable libraries bundled with Pi-hole</comment>
  <expr_stmt><expr><call><name>ftl_lua_init</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block" format="doxygen">/***************************************************/</comment>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>runargs</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* execute arguments -e and -l */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* something failed */</comment>
  <if_stmt><if>if <condition>(<expr><name>script</name> <operator>&lt;</operator> <name>argc</name> <operator>&amp;&amp;</operator>  <comment type="block">/* execute main script (if there is one) */</comment>
      <call><name>handle_script</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>argv</name> <operator>+</operator> <name>script</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>LUA_OK</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>args</name> <operator>&amp;</operator> <name>has_i</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* -i option? */</comment>
    <expr_stmt><expr><call><name>doREPL</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* do read-eval-print loop */</comment>
  <if type="elseif">else if <condition>(<expr><name>script</name> <operator>==</operator> <name>argc</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>args</name> <operator>&amp;</operator> <operator>(</operator><name>has_e</name> <operator>|</operator> <name>has_v</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* no arguments? */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>lua_stdin_is_tty</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* running in interactive mode? */</comment>
      <expr_stmt><expr><call><name>print_version</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>doREPL</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* do read-eval-print loop */</comment>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>dofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* executes stdin as a file */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lua_pushboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* signal no errors */</comment>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>lua_main</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>, <decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><call><name>luaL_newstate</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* create state */</comment>
  <if_stmt><if>if <condition>(<expr><name>L</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>l_message</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"cannot create state: not enough memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lua_pushcfunction</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pmain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* to call 'pmain' in protected mode */</comment>
  <expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* 1st argument */</comment>
  <expr_stmt><expr><call><name>lua_pushlightuserdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 2nd argument */</comment>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>lua_pcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* do the call */</comment>
  <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lua_toboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* get result */</comment>
  <expr_stmt><expr><call><name>report</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name>result</name> <operator>&amp;&amp;</operator> <name>status</name> <operator>==</operator> <name>LUA_OK</name><operator>)</operator></expr> ?</condition><then> <expr><name>EXIT_SUCCESS</name></expr> </then><else>: <expr><name>EXIT_FAILURE</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

</unit>
