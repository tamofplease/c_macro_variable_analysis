<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/lua/lvm.c"><comment type="block">/*
** $Id: lvm.c $
** Lua virtual machine
** See Copyright Notice in lua.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lvm_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lprefix.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lua.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ldebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ldo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lfunc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lgc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lopcodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lstate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lstring.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ltable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ltm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lvm.h"</cpp:file></cpp:include>


<comment type="block">/*
** By default, use jump tables in the main interpreter loop on gcc
** and compatible compilers.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LUA_USE_JUMPTABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_USE_JUMPTABLE</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_USE_JUMPTABLE</name></cpp:macro>	<cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<comment type="block">/* limit for table tag-method chains (to avoid infinite loops) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXTAGLOOP</name></cpp:macro>	<cpp:value>2000</cpp:value></cpp:define>


<comment type="block">/*
** 'l_intfitsf' checks whether a given integer is in the range that
** can be converted to a float without rounding. Used in comparisons.
*/</comment>

<comment type="block">/* number of bits in the mantissa of a float */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBM</name></cpp:macro>		<cpp:value>(l_floatatt(MANT_DIG))</cpp:value></cpp:define>

<comment type="block">/*
** Check whether some integers may not fit in a float, testing whether
** (maxinteger &gt;&gt; NBM) &gt; 0. (That implies (1 &lt;&lt; NBM) &lt;= maxinteger.)
** (The shifts are done in parts, to avoid shifting by more than the size
** of an integer. In a worst case, NBM == 113 for long double and
** sizeof(long) == 32.)
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>LUA_MAXINTEGER</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>NBM</name> <operator>/</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <operator>(</operator><name>NBM</name> <operator>/</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <operator>(</operator><name>NBM</name> <operator>/</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator> \
	<operator>&gt;&gt;</operator> <operator>(</operator><name>NBM</name> <operator>-</operator> <operator>(</operator><literal type="number">3</literal> <operator>*</operator> <operator>(</operator><name>NBM</name> <operator>/</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator><operator>)</operator><operator>)</operator>  <operator>&gt;</operator>  <literal type="number">0</literal></expr></cpp:if>

<comment type="block">/* limit for integers that fit in a float */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXINTFITSF</name></cpp:macro>	<cpp:value>((lua_Unsigned)1 &lt;&lt; NBM)</cpp:value></cpp:define>

<comment type="block">/* check whether 'i' is in the interval [-MAXINTFITSF, MAXINTFITSF] */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_intfitsf</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((MAXINTFITSF + l_castS2U(i)) &lt;= (2 * MAXINTFITSF))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* all integers fit in a float precisely */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_intfitsf</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
** Try to convert a value from string to a number value.
** If the value is not a string or is a string not representing
** a valid numeral (or if coercions from strings to numbers
** are disabled via macro 'cvt2num'), do not modify 'result'
** and return 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>l_strton</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>obj</name> <operator>!=</operator> <name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cvt2num</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* is object not a string? */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><operator>(</operator><call><name>luaO_str2num</name><argument_list>(<argument><expr><call><name>svalue</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>vslen</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Try to convert a value to a float. The float case is already handled
** by the macro 'tonumber'.
*/</comment>
<function><type><name>int</name></type> <name>luaV_tonumber_</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>lua_Number</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name></type> <name>v</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ttisinteger</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <call><name>cast_num</name><argument_list>(<argument><expr><call><name>ivalue</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><call><name>l_strton</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* string coercible to number? */</comment>
    <expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <call><name>nvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* convert result of 'luaO_str2num' to a float */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>  <comment type="block">/* conversion failed */</comment>
</block_content>}</block></function>


<comment type="block">/*
** try to convert a float to an integer, rounding according to 'mode'.
*/</comment>
<function><type><name>int</name></type> <name>luaV_flttointeger</name> <parameter_list>(<parameter><decl><type><name>lua_Number</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>lua_Integer</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>F2Imod</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>f</name> <init>= <expr><call><name>l_floor</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <name>f</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* not an integral value? */</comment>
    <if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>F2Ieq</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>  <comment type="block">/* fails if mode demands integral value */</comment>
    <if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>F2Iceil</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* needs ceil? */</comment>
      <expr_stmt><expr><name>f</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* convert floor to ceil (remember: n != f) */</comment>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>lua_numbertointeger</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** try to convert a value to an integer, rounding according to 'mode',
** without string coercion.
** ("Fast track" handled by macro 'tointegerns'.)
*/</comment>
<function><type><name>int</name></type> <name>luaV_tointegerns</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>lua_Integer</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>F2Imod</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>ttisfloat</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>luaV_flttointeger</name><argument_list>(<argument><expr><call><name>fltvalue</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><call><name>ttisinteger</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>ivalue</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** try to convert a value to an integer.
*/</comment>
<function><type><name>int</name></type> <name>luaV_tointeger</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>lua_Integer</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>F2Imod</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name></type> <name>v</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>l_strton</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* does 'obj' point to a numerical string? */</comment>
    <expr_stmt><expr><name>obj</name> <operator>=</operator> <operator>&amp;</operator><name>v</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* change it to point to its corresponding number */</comment>
  <return>return <expr><call><name>luaV_tointegerns</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Try to convert a 'for' limit to an integer, preserving the semantics
** of the loop. Return true if the loop must not run; otherwise, '*p'
** gets the integer limit.
** (The following explanation assumes a positive step; it is valid for
** negative steps mutatis mutandis.)
** If the limit is an integer or can be converted to an integer,
** rounding down, that is the limit.
** Otherwise, check whether the limit can be converted to a float. If
** the float is too large, clip it to LUA_MAXINTEGER.  If the float
** is too negative, the loop should not run, because any initial
** integer value is greater than such limit; so, the function returns
** true to signal that. (For this latter case, no integer limit would be
** correct; even a limit of LUA_MININTEGER would run the loop once for
** an initial value equal to LUA_MININTEGER.)
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>forlimit</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>lua_Integer</name></type> <name>init</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>lim</name></decl></parameter>,
                                   <parameter><decl><type><name>lua_Integer</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>lua_Integer</name></type> <name>step</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>luaV_tointeger</name><argument_list>(<argument><expr><name>lim</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>step</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>F2Iceil</name></expr> </then><else>: <expr><name>F2Ifloor</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* not coercible to in integer */</comment>
    <decl_stmt><decl><type><name>lua_Number</name></type> <name>flim</name></decl>;</decl_stmt>  <comment type="block">/* try to convert to float */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tonumber</name><argument_list>(<argument><expr><name>lim</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flim</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* cannot convert to float? */</comment>
      <expr_stmt><expr><call><name>luaG_forerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>lim</name></expr></argument>, <argument><expr><literal type="string">"limit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* else 'flim' is a float out of integer bounds */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>luai_numlt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>flim</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* if it is positive, it is too large */</comment>
      <if_stmt><if>if <condition>(<expr><name>step</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* initial value must be less than it */</comment>
      <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>LUA_MAXINTEGER</name></expr>;</expr_stmt>  <comment type="block">/* truncate */</comment>
    </block_content>}</block></if>
    <else>else <block>{<block_content>  <comment type="block">/* it is less than min integer */</comment>
      <if_stmt><if>if <condition>(<expr><name>step</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* initial value must be greater than it */</comment>
      <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>LUA_MININTEGER</name></expr>;</expr_stmt>  <comment type="block">/* truncate */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator><ternary><condition><expr><name>step</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>init</name> <operator>&gt;</operator> <operator>*</operator><name>p</name></expr> </then><else>: <expr><name>init</name> <operator>&lt;</operator> <operator>*</operator><name>p</name></expr></else></ternary><operator>)</operator></expr>;</return>  <comment type="block">/* not to run? */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Prepare a numerical for loop (opcode OP_FORPREP).
** Return true to skip the loop. Otherwise,
** after preparation, stack will be as follows:
**   ra : internal index (safe copy of the control variable)
**   ra + 1 : loop counter (integer loops) or limit (float loops)
**   ra + 2 : step
**   ra + 3 : control variable
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>forprep</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>ra</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>pinit</name> <init>= <expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>plimit</name> <init>= <expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>pstep</name> <init>= <expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ttisinteger</name><argument_list>(<argument><expr><name>pinit</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ttisinteger</name><argument_list>(<argument><expr><name>pstep</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <comment type="block">/* integer loop? */</comment>
    <decl_stmt><decl><type><name>lua_Integer</name></type> <name>init</name> <init>= <expr><call><name>ivalue</name><argument_list>(<argument><expr><name>pinit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>lua_Integer</name></type> <name>step</name> <init>= <expr><call><name>ivalue</name><argument_list>(<argument><expr><name>pstep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>lua_Integer</name></type> <name>limit</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>step</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"'for' step is zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* control variable */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>forlimit</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>init</name></expr></argument>, <argument><expr><name>plimit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>limit</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>  <comment type="block">/* skip the loop */</comment>
    <else>else <block>{<block_content>  <comment type="block">/* prepare loop counter */</comment>
      <decl_stmt><decl><type><name>lua_Unsigned</name></type> <name>count</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>step</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* ascending loop? */</comment>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>l_castS2U</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>l_castS2U</name><argument_list>(<argument><expr><name>init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>step</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* avoid division in the too common case */</comment>
          <expr_stmt><expr><name>count</name> <operator>/=</operator> <call><name>l_castS2U</name><argument_list>(<argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if>
      <else>else <block>{<block_content>  <comment type="block">/* step &lt; 0; descending loop */</comment>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>l_castS2U</name><argument_list>(<argument><expr><name>init</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>l_castS2U</name><argument_list>(<argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* 'step+1' avoids negating 'mininteger' */</comment>
        <expr_stmt><expr><name>count</name> <operator>/=</operator> <call><name>l_castS2U</name><argument_list>(<argument><expr><operator>-</operator><operator>(</operator><name>step</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1u</literal></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <comment type="block">/* store the counter in place of the limit (which won't be
         needed anymore */</comment>
      <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><name>plimit</name></expr></argument>, <argument><expr><call><name>l_castU2S</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>  <comment type="block">/* try making all values floats */</comment>
    <decl_stmt><decl><type><name>lua_Number</name></type> <name>init</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>lua_Number</name></type> <name>limit</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>lua_Number</name></type> <name>step</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><call><name>tonumber</name><argument_list>(<argument><expr><name>plimit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>limit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaG_forerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>plimit</name></expr></argument>, <argument><expr><literal type="string">"limit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><call><name>tonumber</name><argument_list>(<argument><expr><name>pstep</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>step</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaG_forerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>pstep</name></expr></argument>, <argument><expr><literal type="string">"step"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><call><name>tonumber</name><argument_list>(<argument><expr><name>pinit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>init</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaG_forerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>pinit</name></expr></argument>, <argument><expr><literal type="string">"initial value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>step</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"'for' step is zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><ternary><condition><expr><call><name>luai_numlt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>luai_numlt</name><argument_list>(<argument><expr><name>limit</name></expr></argument>, <argument><expr><name>init</name></expr></argument>)</argument_list></call></expr>
                            </then><else>: <expr><call><name>luai_numlt</name><argument_list>(<argument><expr><name>init</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>  <comment type="block">/* skip the loop */</comment>
    <else>else <block>{<block_content>
      <comment type="block">/* make sure internal values are all floats */</comment>
      <expr_stmt><expr><call><name>setfltvalue</name><argument_list>(<argument><expr><name>plimit</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setfltvalue</name><argument_list>(<argument><expr><name>pstep</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>setfltvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* internal index */</comment>
      <expr_stmt><expr><call><name>setfltvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* control variable */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Execute a step of a float numerical for loop, returning
** true iff the loop must continue. (The integer case is
** written online with opcode OP_FORLOOP, for performance.)
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>floatforloop</name> <parameter_list>(<parameter><decl><type><name>StkId</name></type> <name>ra</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>step</name> <init>= <expr><call><name>fltvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>limit</name> <init>= <expr><call><name>fltvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>idx</name> <init>= <expr><call><name>fltvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* internal index */</comment>
  <expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>luai_numadd</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* increment index */</comment>
  <if_stmt><if>if <condition>(<expr><ternary><condition><expr><call><name>luai_numlt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>luai_numle</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>
                          </then><else>: <expr><call><name>luai_numle</name><argument_list>(<argument><expr><name>limit</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>chgfltvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* update internal index */</comment>
    <expr_stmt><expr><call><name>setfltvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* and control variable */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* jump back */</comment>
  </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>  <comment type="block">/* finish the loop */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Finish the table access 'val = t[key]'.
** if 'slot' is NULL, 't' is not a table; otherwise, 'slot' points to
** t[k] entry (which must be empty).
*/</comment>
<function><type><name>void</name></type> <name>luaV_finishget</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>val</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>loop</name></decl>;</decl_stmt>  <comment type="block">/* counter to avoid infinite loops */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>tm</name></decl>;</decl_stmt>  <comment type="block">/* metamethod */</comment>
  <for>for <control>(<init><expr><name>loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>loop</name> <operator>&lt;</operator> <name>MAXTAGLOOP</name></expr>;</condition> <incr><expr><name>loop</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* 't' is not a table? */</comment>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ttistable</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>luaT_gettmbyobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>TM_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>notm</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>luaG_typeerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="string">"index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* no metamethod */</comment>
      <comment type="block">/* else will try the metamethod */</comment>
    </block_content>}</block></if>
    <else>else <block>{<block_content>  <comment type="block">/* 't' is a table */</comment>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>isempty</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>fasttm</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>hvalue</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>, <argument><expr><name>TM_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* table's metamethod */</comment>
      <if_stmt><if>if <condition>(<expr><name>tm</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* no metamethod? */</comment>
        <expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* result is nil */</comment>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* else will try the metamethod */</comment>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ttisfunction</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* is metamethod a function? */</comment>
      <expr_stmt><expr><call><name>luaT_callTMres</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* call it */</comment>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <name>tm</name></expr>;</expr_stmt>  <comment type="block">/* else try to access 'tm[key]' */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>luaV_fastget</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>luaH_get</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* fast track? */</comment>
      <expr_stmt><expr><call><name>setobj2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* done */</comment>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* else repeat (tail call 'luaV_finishget') */</comment>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"'__index' chain too long; possible loop"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Finish a table assignment 't[key] = val'.
** If 'slot' is NULL, 't' is not a table.  Otherwise, 'slot' points
** to the entry 't[key]', or to a value with an absent key if there
** is no such entry.  (The value at 'slot' must be empty, otherwise
** 'luaV_fastget' would have done the job.)
*/</comment>
<function><type><name>void</name></type> <name>luaV_finishset</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
                     <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>loop</name></decl>;</decl_stmt>  <comment type="block">/* counter to avoid infinite loops */</comment>
  <for>for <control>(<init><expr><name>loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>loop</name> <operator>&lt;</operator> <name>MAXTAGLOOP</name></expr>;</condition> <incr><expr><name>loop</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>tm</name></decl>;</decl_stmt>  <comment type="block">/* '__newindex' metamethod */</comment>
    <if_stmt><if>if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* is 't' a table? */</comment>
      <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><call><name>hvalue</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* save 't' table */</comment>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>isempty</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* slot must be empty */</comment>
      <expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>fasttm</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>metatable</name></name></expr></argument>, <argument><expr><name>TM_NEWINDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* get metamethod */</comment>
      <if_stmt><if>if <condition>(<expr><name>tm</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* no metamethod? */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>isabstkey</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* no previous entry? */</comment>
          <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>luaH_newkey</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* create one */</comment>
        <comment type="block">/* no metamethod and (now) there is an entry with given key */</comment>
        <expr_stmt><expr><call><name>setobj2t</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>cast</name><argument_list>(<argument><expr><name>TValue</name> <operator>*</operator></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* set its new value */</comment>
        <expr_stmt><expr><call><name>invalidateTMcache</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>luaC_barrierback</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="block">/* else will try the metamethod */</comment>
    </block_content>}</block></if>
    <else>else <block>{<block_content>  <comment type="block">/* not a table; check metamethod */</comment>
      <expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>luaT_gettmbyobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>TM_NEWINDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>notm</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>luaG_typeerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><literal type="string">"index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* try the metamethod */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ttisfunction</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>luaT_callTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>t</name> <operator>=</operator> <name>tm</name></expr>;</expr_stmt>  <comment type="block">/* else repeat assignment over 'tm' */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>luaV_fastget</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>luaH_get</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>luaV_finishfastset</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>  <comment type="block">/* done */</comment>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* else 'return luaV_finishset(L, t, key, val, slot)' (loop) */</comment>
  </block_content>}</block></for>
  <expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"'__newindex' chain too long; possible loop"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Compare two strings 'ls' x 'rs', returning an integer less-equal-
** -greater than zero if 'ls' is less-equal-greater than 'rs'.
** The code is a little tricky because it allows '\0' in the strings
** and it uses 'strcoll' (to respect locales) for each segments
** of the strings.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>l_strcmp</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TString</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TString</name> <modifier>*</modifier></type><name>rs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>getstr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>ll</name> <init>= <expr><call><name>tsslen</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>getstr</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>lr</name> <init>= <expr><call><name>tsslen</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>  <comment type="block">/* for each segment */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>temp</name> <init>= <expr><call><name>strcoll</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>temp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* not equal? */</comment>
      <return>return <expr><name>temp</name></expr>;</return></block_content></block></if>  <comment type="block">/* done */</comment>
    <else>else <block>{<block_content>  <comment type="block">/* strings are equal up to a '\0' */</comment>
      <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* index of first '\0' in both strings */</comment>
      <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name>lr</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* 'rs' is finished? */</comment>
        <return>return <expr><ternary><condition><expr><operator>(</operator><name>len</name> <operator>==</operator> <name>ll</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if>  <comment type="block">/* check 'ls' */</comment>
      <if type="elseif">else if <condition>(<expr><name>len</name> <operator>==</operator> <name>ll</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* 'ls' is finished? */</comment>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* 'ls' is less than 'rs' ('rs' is not finished) */</comment>
      <comment type="block">/* both strings longer than 'len'; go on comparing after the '\0' */</comment>
      <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>l</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt> <expr_stmt><expr><name>ll</name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt> <expr_stmt><expr><name>r</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt> <expr_stmt><expr><name>lr</name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
** Check whether integer 'i' is less than float 'f'. If 'i' has an
** exact representation as a float ('l_intfitsf'), compare numbers as
** floats. Otherwise, use the equivalence 'i &lt; f &lt;=&gt; i &lt; ceil(f)'.
** If 'ceil(f)' is out of integer range, either 'f' is greater than
** all integers or less than all integers.
** (The test with 'l_intfitsf' is only for performance; the else
** case is correct for all values, but it is slow due to the conversion
** from float to int.)
** When 'f' is NaN, comparisons must result in false.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>LTintfloat</name> <parameter_list>(<parameter><decl><type><name>lua_Integer</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>lua_Number</name></type> <name>f</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>l_intfitsf</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>luai_numlt</name><argument_list>(<argument><expr><call><name>cast_num</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>  <comment type="block">/* compare them as floats */</comment>
  <else>else <block>{<block_content>  <comment type="block">/* i &lt; f &lt;=&gt; i &lt; ceil(f) */</comment>
    <decl_stmt><decl><type><name>lua_Integer</name></type> <name>fi</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>luaV_flttointeger</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fi</name></expr></argument>, <argument><expr><name>F2Iceil</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* fi = ceil(f) */</comment>
      <return>return <expr><name>i</name> <operator>&lt;</operator> <name>fi</name></expr>;</return></block_content></block></if>   <comment type="block">/* compare them as integers */</comment>
    <else>else<block type="pseudo"><block_content>  <comment type="block">/* 'f' is either greater or less than all integers */</comment>
      <return>return <expr><name>f</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>  <comment type="block">/* greater? */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Check whether integer 'i' is less than or equal to float 'f'.
** See comments on previous function.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>LEintfloat</name> <parameter_list>(<parameter><decl><type><name>lua_Integer</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>lua_Number</name></type> <name>f</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>l_intfitsf</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>luai_numle</name><argument_list>(<argument><expr><call><name>cast_num</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>  <comment type="block">/* compare them as floats */</comment>
  <else>else <block>{<block_content>  <comment type="block">/* i &lt;= f &lt;=&gt; i &lt;= floor(f) */</comment>
    <decl_stmt><decl><type><name>lua_Integer</name></type> <name>fi</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>luaV_flttointeger</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fi</name></expr></argument>, <argument><expr><name>F2Ifloor</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* fi = floor(f) */</comment>
      <return>return <expr><name>i</name> <operator>&lt;=</operator> <name>fi</name></expr>;</return></block_content></block></if>   <comment type="block">/* compare them as integers */</comment>
    <else>else<block type="pseudo"><block_content>  <comment type="block">/* 'f' is either greater or less than all integers */</comment>
      <return>return <expr><name>f</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>  <comment type="block">/* greater? */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Check whether float 'f' is less than integer 'i'.
** See comments on previous function.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>LTfloatint</name> <parameter_list>(<parameter><decl><type><name>lua_Number</name></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>lua_Integer</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>l_intfitsf</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>luai_numlt</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><call><name>cast_num</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>  <comment type="block">/* compare them as floats */</comment>
  <else>else <block>{<block_content>  <comment type="block">/* f &lt; i &lt;=&gt; floor(f) &lt; i */</comment>
    <decl_stmt><decl><type><name>lua_Integer</name></type> <name>fi</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>luaV_flttointeger</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fi</name></expr></argument>, <argument><expr><name>F2Ifloor</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* fi = floor(f) */</comment>
      <return>return <expr><name>fi</name> <operator>&lt;</operator> <name>i</name></expr>;</return></block_content></block></if>   <comment type="block">/* compare them as integers */</comment>
    <else>else<block type="pseudo"><block_content>  <comment type="block">/* 'f' is either greater or less than all integers */</comment>
      <return>return <expr><name>f</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>  <comment type="block">/* less? */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Check whether float 'f' is less than or equal to integer 'i'.
** See comments on previous function.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>LEfloatint</name> <parameter_list>(<parameter><decl><type><name>lua_Number</name></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>lua_Integer</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>l_intfitsf</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>luai_numle</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><call><name>cast_num</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>  <comment type="block">/* compare them as floats */</comment>
  <else>else <block>{<block_content>  <comment type="block">/* f &lt;= i &lt;=&gt; ceil(f) &lt;= i */</comment>
    <decl_stmt><decl><type><name>lua_Integer</name></type> <name>fi</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>luaV_flttointeger</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fi</name></expr></argument>, <argument><expr><name>F2Iceil</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* fi = ceil(f) */</comment>
      <return>return <expr><name>fi</name> <operator>&lt;=</operator> <name>i</name></expr>;</return></block_content></block></if>   <comment type="block">/* compare them as integers */</comment>
    <else>else<block type="pseudo"><block_content>  <comment type="block">/* 'f' is either greater or less than all integers */</comment>
      <return>return <expr><name>f</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>  <comment type="block">/* less? */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Return 'l &lt; r', for numbers.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>LTnum</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ttisnumber</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ttisnumber</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ttisinteger</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Integer</name></type> <name>li</name> <init>= <expr><call><name>ivalue</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ttisinteger</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>li</name> <operator>&lt;</operator> <call><name>ivalue</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>  <comment type="block">/* both are integers */</comment>
    <else>else<block type="pseudo"><block_content>  <comment type="block">/* 'l' is int and 'r' is float */</comment>
      <return>return <expr><call><name>LTintfloat</name><argument_list>(<argument><expr><name>li</name></expr></argument>, <argument><expr><call><name>fltvalue</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>  <comment type="block">/* l &lt; r ? */</comment>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Number</name></type> <name>lf</name> <init>= <expr><call><name>fltvalue</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* 'l' must be float */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ttisfloat</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><call><name>luai_numlt</name><argument_list>(<argument><expr><name>lf</name></expr></argument>, <argument><expr><call><name>fltvalue</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>  <comment type="block">/* both are float */</comment>
    <else>else<block type="pseudo"><block_content>  <comment type="block">/* 'l' is float and 'r' is int */</comment>
      <return>return <expr><call><name>LTfloatint</name><argument_list>(<argument><expr><name>lf</name></expr></argument>, <argument><expr><call><name>ivalue</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Return 'l &lt;= r', for numbers.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>LEnum</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ttisnumber</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ttisnumber</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ttisinteger</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Integer</name></type> <name>li</name> <init>= <expr><call><name>ivalue</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ttisinteger</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>li</name> <operator>&lt;=</operator> <call><name>ivalue</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>  <comment type="block">/* both are integers */</comment>
    <else>else<block type="pseudo"><block_content>  <comment type="block">/* 'l' is int and 'r' is float */</comment>
      <return>return <expr><call><name>LEintfloat</name><argument_list>(<argument><expr><name>li</name></expr></argument>, <argument><expr><call><name>fltvalue</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>  <comment type="block">/* l &lt;= r ? */</comment>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Number</name></type> <name>lf</name> <init>= <expr><call><name>fltvalue</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* 'l' must be float */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ttisfloat</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><call><name>luai_numle</name><argument_list>(<argument><expr><name>lf</name></expr></argument>, <argument><expr><call><name>fltvalue</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>  <comment type="block">/* both are float */</comment>
    <else>else<block type="pseudo"><block_content>  <comment type="block">/* 'l' is float and 'r' is int */</comment>
      <return>return <expr><call><name>LEfloatint</name><argument_list>(<argument><expr><name>lf</name></expr></argument>, <argument><expr><call><name>ivalue</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** return 'l &lt; r' for non-numbers.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lessthanothers</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ttisnumber</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>ttisnumber</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ttisstring</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ttisstring</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* both are strings? */</comment>
    <return>return <expr><call><name>l_strcmp</name><argument_list>(<argument><expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><call><name>luaT_callorderTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>TM_LT</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Main operation less than; return 'l &lt; r'.
*/</comment>
<function><type><name>int</name></type> <name>luaV_lessthan</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>ttisnumber</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ttisnumber</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* both operands are numbers? */</comment>
    <return>return <expr><call><name>LTnum</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content> <return>return <expr><call><name>lessthanothers</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** return 'l &lt;= r' for non-numbers.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>lessequalothers</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ttisnumber</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>ttisnumber</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ttisstring</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ttisstring</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* both are strings? */</comment>
    <return>return <expr><call><name>l_strcmp</name><argument_list>(<argument><expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><call><name>luaT_callorderTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>TM_LE</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Main operation less than or equal to; return 'l &lt;= r'.
*/</comment>
<function><type><name>int</name></type> <name>luaV_lessequal</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>ttisnumber</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ttisnumber</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* both operands are numbers? */</comment>
    <return>return <expr><call><name>LEnum</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content> <return>return <expr><call><name>lessequalothers</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Main operation for equality of Lua values; return 't1 == t2'.
** L == NULL means raw equality (no metamethods)
*/</comment>
<function><type><name>int</name></type> <name>luaV_equalobj</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>t1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>t2</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>tm</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ttypetag</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>ttypetag</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* not the same variant? */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ttype</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>ttype</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>ttype</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>LUA_TNUMBER</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>  <comment type="block">/* only numbers can be equal with different variants */</comment>
    <else>else <block>{<block_content>  <comment type="block">/* two numbers with different variants */</comment>
      <decl_stmt><decl><type><name>lua_Integer</name></type> <name>i1</name></decl>, <decl><type ref="prev"/><name>i2</name></decl>;</decl_stmt>  <comment type="block">/* compare them as integers */</comment>
      <return>return <expr><operator>(</operator><call><name>tointegerns</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tointegerns</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>i1</name> <operator>==</operator> <name>i2</name><operator>)</operator></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* values have same type and same variant */</comment>
  <switch>switch <condition>(<expr><call><name>ttypetag</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LUA_VNIL</name></expr>:</case> <case>case <expr><name>LUA_VFALSE</name></expr>:</case> <case>case <expr><name>LUA_VTRUE</name></expr>:</case> <return>return <expr><literal type="number">1</literal></expr>;</return>
    <case>case <expr><name>LUA_VNUMINT</name></expr>:</case> <return>return <expr><operator>(</operator><call><name>ivalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>ivalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
    <case>case <expr><name>LUA_VNUMFLT</name></expr>:</case> <return>return <expr><call><name>luai_numeq</name><argument_list>(<argument><expr><call><name>fltvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>fltvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_VLIGHTUSERDATA</name></expr>:</case> <return>return <expr><call><name>pvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>pvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_VLCF</name></expr>:</case> <return>return <expr><call><name>fvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>fvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_VSHRSTR</name></expr>:</case> <return>return <expr><call><name>eqshrstr</name><argument_list>(<argument><expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_VLNGSTR</name></expr>:</case> <return>return <expr><call><name>luaS_eqlngstr</name><argument_list>(<argument><expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_VUSERDATA</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>uvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>uvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name>L</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>fasttm</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>uvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>, <argument><expr><name>TM_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>tm</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>fasttm</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>uvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>, <argument><expr><name>TM_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>  <comment type="block">/* will try TM */</comment>
    </block_content>}</block>
    <case>case <expr><name>LUA_VTABLE</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>hvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>hvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name>L</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>fasttm</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>hvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>, <argument><expr><name>TM_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>tm</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>fasttm</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>hvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>, <argument><expr><name>TM_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>  <comment type="block">/* will try TM */</comment>
    </block_content>}</block>
    <default>default:</default>
      <return>return <expr><call><name>gcvalue</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>gcvalue</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></switch>
  <if_stmt><if>if <condition>(<expr><name>tm</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* no TM? */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>  <comment type="block">/* objects are different */</comment>
  <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>luaT_callTMres</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* call TM */</comment>
    <return>return <expr><operator>!</operator><call><name>l_isfalse</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/* macro used by 'luaV_concat' to ensure that element at 'o' is a string */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tostring</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro>  \
	<cpp:value>(ttisstring(o) || (cvt2str(o) &amp;&amp; (luaO_tostring(L, o), 1)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isemptystr</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(ttisshrstring(o) &amp;&amp; tsvalue(o)-&gt;shrlen == 0)</cpp:value></cpp:define>

<comment type="block">/* copy strings in stack from top - n up to top - 1 to buffer */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>copy2buff</name> <parameter_list>(<parameter><decl><type><name>StkId</name></type> <name>top</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>tl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* size already copied */</comment>
  <do>do <block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>l</name> <init>= <expr><call><name>vslen</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>top</name> <operator>-</operator> <name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* length of string being copied */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buff</name> <operator>+</operator> <name>tl</name></expr></argument>, <argument><expr><call><name>svalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>top</name> <operator>-</operator> <name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>l</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tl</name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>
  </block_content>}</block> while <condition>(<expr><operator>--</operator><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
</block_content>}</block></function>


<comment type="block">/*
** Main operation for concatenation: concat 'total' values in the stack,
** from 'L-&gt;top - total' up to 'L-&gt;top - 1'.
*/</comment>
<function><type><name>void</name></type> <name>luaV_concat</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>total</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>total</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* "all" values already concatenated */</comment>
  <do>do <block>{<block_content>
    <decl_stmt><decl><type><name>StkId</name></type> <name>top</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* number of elements handled in this pass (at least 2) */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>ttisstring</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>top</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>cvt2str</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>top</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
        <operator>!</operator><call><name>tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>top</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaT_tryconcatTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>isemptystr</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>top</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* second operand is empty? */</comment>
      <expr_stmt><expr><call><name>cast_void</name><argument_list>(<argument><expr><call><name>tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>top</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* result is first operand */</comment>
    <if type="elseif">else if <condition>(<expr><call><name>isemptystr</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>top</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* first operand is empty string? */</comment>
      <expr_stmt><expr><call><name>setobjs2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>top</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>top</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* result is second op. */</comment>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
      <comment type="block">/* at least two non-empty string values; get as many as possible */</comment>
      <decl_stmt><decl><type><name>size_t</name></type> <name>tl</name> <init>= <expr><call><name>vslen</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>top</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>TString</name> <modifier>*</modifier></type><name>ts</name></decl>;</decl_stmt>
      <comment type="block">/* collect total length and number of strings */</comment>
      <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>total</name> <operator>&amp;&amp;</operator> <call><name>tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>top</name> <operator>-</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>l</name> <init>= <expr><call><name>vslen</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>top</name> <operator>-</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>l</name> <operator>&gt;=</operator> <operator>(</operator><name>MAX_SIZE</name><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>-</operator> <name>tl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"string length overflow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>tl</name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if <condition>(<expr><name>tl</name> <operator>&lt;=</operator> <name>LUAI_MAXSHORTLEN</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* is result a short string? */</comment>
        <decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><name>LUAI_MAXSHORTLEN</name></expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>copy2buff</name><argument_list>(<argument><expr><name>top</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* copy strings to buffer */</comment>
        <expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>luaS_newlstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else <block>{<block_content>  <comment type="block">/* long string; copy strings directly to final result */</comment>
        <expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>luaS_createlngstrobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>copy2buff</name><argument_list>(<argument><expr><name>top</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>setsvalue2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>top</name> <operator>-</operator> <name>n</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* create result */</comment>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>total</name> <operator>-=</operator> <name>n</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* got 'n' strings to create 1 new */</comment>
    <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-=</operator> <name>n</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* popped 'n' strings and pushed one */</comment>
  </block_content>}</block> while <condition>(<expr><name>total</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>;</do>  <comment type="block">/* repeat until only 1 result left */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Main operation 'ra = #rb'.
*/</comment>
<function><type><name>void</name></type> <name>luaV_objlen</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>ra</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>rb</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>tm</name></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><call><name>ttypetag</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LUA_VTABLE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><call><name>hvalue</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>fasttm</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>metatable</name></name></expr></argument>, <argument><expr><name>TM_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>tm</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* metamethod? break switch to call it */</comment>
      <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>luaH_getn</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* else primitive len */</comment>
      <return>return;</return>
    </block_content>}</block>
    <case>case <expr><name>LUA_VSHRSTR</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>shrlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
    <case>case <expr><name>LUA_VLNGSTR</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>lnglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>  <comment type="block">/* try metamethod */</comment>
      <expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>luaT_gettmbyobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>TM_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>notm</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* no metamethod? */</comment>
        <expr_stmt><expr><call><name>luaG_typeerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><literal type="string">"get length of"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>luaT_callTMres</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Integer division; return 'm // n', that is, floor(m/n).
** C division truncates its result (rounds towards zero).
** 'floor(q) == trunc(q)' when 'q &gt;= 0' or when 'q' is integer,
** otherwise 'floor(q) == trunc(q) - 1'.
*/</comment>
<function><type><name>lua_Integer</name></type> <name>luaV_idiv</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>lua_Integer</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>lua_Integer</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>l_castS2U</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1u</literal> <operator>&lt;=</operator> <literal type="number">1u</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* special cases: -1 or 0 */</comment>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"attempt to divide by zero"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><call><name>intop</name><argument_list>(<argument><expr><operator>-</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</return>   <comment type="block">/* n==-1; avoid overflow with 0x80000...//-1 */</comment>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Integer</name></type> <name>q</name> <init>= <expr><name>m</name> <operator>/</operator> <name>n</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* perform C division */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>m</name> <operator>^</operator> <name>n</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>m</name> <operator>%</operator> <name>n</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* 'm/n' would be negative non-integer? */</comment>
      <expr_stmt><expr><name>q</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* correct result for different rounding */</comment>
    <return>return <expr><name>q</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Integer modulus; return 'm % n'. (Assume that C '%' with
** negative operands follows C99 behavior. See previous comment
** about luaV_idiv.)
*/</comment>
<function><type><name>lua_Integer</name></type> <name>luaV_mod</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>lua_Integer</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>lua_Integer</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>l_castS2U</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1u</literal> <operator>&lt;=</operator> <literal type="number">1u</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* special cases: -1 or 0 */</comment>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"attempt to perform 'n%%0'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>   <comment type="block">/* m % -1 == 0; avoid overflow with 0x80000...%-1 */</comment>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Integer</name></type> <name>r</name> <init>= <expr><name>m</name> <operator>%</operator> <name>n</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>r</name> <operator>^</operator> <name>n</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* 'm/n' would be non-integer negative? */</comment>
      <expr_stmt><expr><name>r</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* correct result for different rounding */</comment>
    <return>return <expr><name>r</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Float modulus
*/</comment>
<function><type><name>lua_Number</name></type> <name>luaV_modf</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>lua_Number</name></type> <name>m</name></decl></parameter>, <parameter><decl><type><name>lua_Number</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>r</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luai_nummod</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* number of bits in an integer */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBITS</name></cpp:macro>	<cpp:value>cast_int(sizeof(lua_Integer) * CHAR_BIT)</cpp:value></cpp:define>

<comment type="block">/*
** Shift left operation. (Shift right just negates 'y'.)
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>luaV_shiftr</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>luaV_shiftl(x,-(y))</cpp:value></cpp:define>

<function><type><name>lua_Integer</name></type> <name>luaV_shiftl</name> <parameter_list>(<parameter><decl><type><name>lua_Integer</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>lua_Integer</name></type> <name>y</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>y</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* shift right? */</comment>
    <if_stmt><if>if <condition>(<expr><name>y</name> <operator>&lt;=</operator> <operator>-</operator><name>NBITS</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content> <return>return <expr><call><name>intop</name><argument_list>(<argument><expr><operator>&gt;&gt;</operator></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><operator>-</operator><name>y</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>  <comment type="block">/* shift left */</comment>
    <if_stmt><if>if <condition>(<expr><name>y</name> <operator>&gt;=</operator> <name>NBITS</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content> <return>return <expr><call><name>intop</name><argument_list>(<argument><expr><operator>&lt;&lt;</operator></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** create a new Lua closure, push it in the stack, and initialize
** its upvalues.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pushclosure</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Proto</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>UpVal</name> <modifier>*</modifier><modifier>*</modifier></type><name>encup</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>base</name></decl></parameter>,
                         <parameter><decl><type><name>StkId</name></type> <name>ra</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nup</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>sizeupvalues</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Upvaldesc</name> <modifier>*</modifier></type><name>uv</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>upvalues</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LClosure</name> <modifier>*</modifier></type><name>ncl</name> <init>= <expr><call><name>luaF_newLclosure</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>nup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>ncl</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setclLvalue2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>ncl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* anchor new closure in stack */</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nup</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>  <comment type="block">/* fill in its upvalues */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>uv</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>instack</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* upvalue refers to local variable? */</comment>
      <expr_stmt><expr><name><name>ncl</name><operator>-&gt;</operator><name>upvals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>luaF_findupval</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>base</name> <operator>+</operator> <name><name>uv</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>  <comment type="block">/* get upvalue from enclosing function */</comment>
      <expr_stmt><expr><name><name>ncl</name><operator>-&gt;</operator><name>upvals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>encup</name><index>[<expr><name><name>uv</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>idx</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>luaC_objbarrier</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ncl</name></expr></argument>, <argument><expr><name><name>ncl</name><operator>-&gt;</operator><name>upvals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
** finish execution of an opcode interrupted by a yield
*/</comment>
<function><type><name>void</name></type> <name>luaV_finishOp</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StkId</name></type> <name>base</name> <init>= <expr><name><name>ci</name><operator>-&gt;</operator><name>func</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Instruction</name></type> <name>inst</name> <init>= <expr><operator>*</operator><operator>(</operator><name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>savedpc</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>  <comment type="block">/* interrupted instruction */</comment>
  <decl_stmt><decl><type><name>OpCode</name></type> <name>op</name> <init>= <expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* finish its execution */</comment>
    <case>case <expr><name>OP_MMBIN</name></expr>:</case> <case>case <expr><name>OP_MMBINI</name></expr>:</case> <case>case <expr><name>OP_MMBINK</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>setobjs2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>base</name> <operator>+</operator> <call><name>GETARG_A</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>savedpc</name></name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>--</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OP_UNM</name></expr>:</case> <case>case <expr><name>OP_BNOT</name></expr>:</case> <case>case <expr><name>OP_LEN</name></expr>:</case>
    <case>case <expr><name>OP_GETTABUP</name></expr>:</case> <case>case <expr><name>OP_GETTABLE</name></expr>:</case> <case>case <expr><name>OP_GETI</name></expr>:</case>
    <case>case <expr><name>OP_GETFIELD</name></expr>:</case> <case>case <expr><name>OP_SELF</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>setobjs2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>base</name> <operator>+</operator> <call><name>GETARG_A</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>--</operator><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OP_LT</name></expr>:</case> <case>case <expr><name>OP_LE</name></expr>:</case>
    <case>case <expr><name>OP_LTI</name></expr>:</case> <case>case <expr><name>OP_LEI</name></expr>:</case>
    <case>case <expr><name>OP_GTI</name></expr>:</case> <case>case <expr><name>OP_GEI</name></expr>:</case>
    <case>case <expr><name>OP_EQ</name></expr>:</case> <block>{<block_content>  <comment type="block">/* note that 'OP_EQI'/'OP_EQK' cannot yield */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><operator>!</operator><call><name>l_isfalse</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>--</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LUA_COMPAT_LT_LE</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><name><name>ci</name><operator>-&gt;</operator><name>callstatus</name></name> <operator>&amp;</operator> <name>CIST_LEQ</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* "&lt;=" using "&lt;" instead? */</comment>
        <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>callstatus</name></name> <operator>^=</operator> <name>CIST_LEQ</name></expr>;</expr_stmt>  <comment type="block">/* clear mark */</comment>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>!</operator><name>res</name></expr>;</expr_stmt>  <comment type="block">/* negate result */</comment>
      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><operator>*</operator><name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>savedpc</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP_JMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <call><name>GETARG_k</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* condition failed? */</comment>
        <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>savedpc</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* skip jump instruction */</comment>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OP_CONCAT</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>StkId</name></type> <name>top</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* top when 'luaT_tryconcatTM' was called */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>a</name> <init>= <expr><call><name>GETARG_A</name><argument_list>(<argument><expr><name>inst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>      <comment type="block">/* first element to concatenate */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>total</name> <init>= <expr><call><name>cast_int</name><argument_list>(<argument><expr><name>top</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <operator>(</operator><name>base</name> <operator>+</operator> <name>a</name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* yet to concatenate */</comment>
      <expr_stmt><expr><call><name>setobjs2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>top</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>top</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* put TM result in proper position */</comment>
      <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>top</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* top is one after last element (at top-2) */</comment>
      <expr_stmt><expr><call><name>luaV_concat</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* concat them (may yield again) */</comment>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <comment type="block">/* only these other opcodes can yield */</comment>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>op</name> <operator>==</operator> <name>OP_TFORCALL</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>OP_CALL</name> <operator>||</operator>
           <name>op</name> <operator>==</operator> <name>OP_TAILCALL</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>OP_SETTABUP</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>OP_SETTABLE</name> <operator>||</operator>
           <name>op</name> <operator>==</operator> <name>OP_SETI</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>OP_SETFIELD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>




<comment type="block">/*
** {==================================================================
** Macros for arithmetic/bitwise/comparison opcodes in 'luaV_execute'
** ===================================================================
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_addi</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>intop(+, a, b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_subi</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>intop(-, a, b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_muli</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>intop(*, a, b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_band</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>intop(&amp;, a, b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_bor</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>intop(|, a, b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_bxor</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>intop(^, a, b)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_lti</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(a &lt; b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_lei</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(a &lt;= b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_gti</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(a &gt; b)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_gei</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(a &gt;= b)</cpp:value></cpp:define>


<comment type="block">/*
** Arithmetic operations with immediate operands. 'iop' is the integer
** operation, 'fop' is the float operation.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>op_arithI</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>iop</name></type></parameter>,<parameter><type><name>fop</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{  \
  TValue *v1 = vRB(i);  \
  int imm = GETARG_sC(i);  \
  if (ttisinteger(v1)) {  \
    lua_Integer iv1 = ivalue(v1);  \
    pc++; setivalue(s2v(ra), iop(L, iv1, imm));  \
  }  \
  else if (ttisfloat(v1)) {  \
    lua_Number nb = fltvalue(v1);  \
    lua_Number fimm = cast_num(imm);  \
    pc++; setfltvalue(s2v(ra), fop(L, nb, fimm)); \
  }}</cpp:value></cpp:define>


<comment type="block">/*
** Auxiliary function for arithmetic operations over floats and others
** with two register operands.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>op_arithf_aux</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>v1</name></type></parameter>,<parameter><type><name>v2</name></type></parameter>,<parameter><type><name>fop</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{  \
  lua_Number n1; lua_Number n2;  \
  if (tonumberns(v1, n1) &amp;&amp; tonumberns(v2, n2)) {  \
    pc++; setfltvalue(s2v(ra), fop(L, n1, n2));  \
  }}</cpp:value></cpp:define>


<comment type="block">/*
** Arithmetic operations over floats and others with register operands.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>op_arithf</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>fop</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{  \
  TValue *v1 = vRB(i);  \
  TValue *v2 = vRC(i);  \
  op_arithf_aux(L, v1, v2, fop); }</cpp:value></cpp:define>


<comment type="block">/*
** Arithmetic operations with K operands for floats.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>op_arithfK</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>fop</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{  \
  TValue *v1 = vRB(i);  \
  TValue *v2 = KC(i);  \
  op_arithf_aux(L, v1, v2, fop); }</cpp:value></cpp:define>


<comment type="block">/*
** Arithmetic operations over integers and floats.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>op_arith_aux</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>v1</name></type></parameter>,<parameter><type><name>v2</name></type></parameter>,<parameter><type><name>iop</name></type></parameter>,<parameter><type><name>fop</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{  \
  if (ttisinteger(v1) &amp;&amp; ttisinteger(v2)) {  \
    lua_Integer i1 = ivalue(v1); lua_Integer i2 = ivalue(v2);  \
    pc++; setivalue(s2v(ra), iop(L, i1, i2));  \
  }  \
  else op_arithf_aux(L, v1, v2, fop); }</cpp:value></cpp:define>


<comment type="block">/*
** Arithmetic operations with register operands.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>op_arith</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>iop</name></type></parameter>,<parameter><type><name>fop</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{  \
  TValue *v1 = vRB(i);  \
  TValue *v2 = vRC(i);  \
  op_arith_aux(L, v1, v2, iop, fop); }</cpp:value></cpp:define>


<comment type="block">/*
** Arithmetic operations with K operands.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>op_arithK</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>iop</name></type></parameter>,<parameter><type><name>fop</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{  \
  TValue *v1 = vRB(i);  \
  TValue *v2 = KC(i);  \
  op_arith_aux(L, v1, v2, iop, fop); }</cpp:value></cpp:define>


<comment type="block">/*
** Bitwise operations with constant operand.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>op_bitwiseK</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>op</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{  \
  TValue *v1 = vRB(i);  \
  TValue *v2 = KC(i);  \
  lua_Integer i1;  \
  lua_Integer i2 = ivalue(v2);  \
  if (tointegerns(v1, &amp;i1)) {  \
    pc++; setivalue(s2v(ra), op(i1, i2));  \
  }}</cpp:value></cpp:define>


<comment type="block">/*
** Bitwise operations with register operands.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>op_bitwise</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>op</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{  \
  TValue *v1 = vRB(i);  \
  TValue *v2 = vRC(i);  \
  lua_Integer i1; lua_Integer i2;  \
  if (tointegerns(v1, &amp;i1) &amp;&amp; tointegerns(v2, &amp;i2)) {  \
    pc++; setivalue(s2v(ra), op(i1, i2));  \
  }}</cpp:value></cpp:define>


<comment type="block">/*
** Order operations with register operands. 'opn' actually works
** for all numbers, but the fast track improves performance for
** integers.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>op_order</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>opi</name></type></parameter>,<parameter><type><name>opn</name></type></parameter>,<parameter><type><name>other</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{  \
        int cond;  \
        TValue *rb = vRB(i);  \
        if (ttisinteger(s2v(ra)) &amp;&amp; ttisinteger(rb)) {  \
          lua_Integer ia = ivalue(s2v(ra));  \
          lua_Integer ib = ivalue(rb);  \
          cond = opi(ia, ib);  \
        }  \
        else if (ttisnumber(s2v(ra)) &amp;&amp; ttisnumber(rb))  \
          cond = opn(s2v(ra), rb);  \
        else  \
          Protect(cond = other(L, s2v(ra), rb));  \
        docondjump(); }</cpp:value></cpp:define>


<comment type="block">/*
** Order operations with immediate operand. (Immediate operand is
** always small enough to have an exact representation as a float.)
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>op_orderI</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>opi</name></type></parameter>,<parameter><type><name>opf</name></type></parameter>,<parameter><type><name>inv</name></type></parameter>,<parameter><type><name>tm</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{  \
        int cond;  \
        int im = GETARG_sB(i);  \
        if (ttisinteger(s2v(ra)))  \
          cond = opi(ivalue(s2v(ra)), im);  \
        else if (ttisfloat(s2v(ra))) {  \
          lua_Number fa = fltvalue(s2v(ra));  \
          lua_Number fim = cast_num(im);  \
          cond = opf(fa, fim);  \
        }  \
        else {  \
          int isf = GETARG_C(i);  \
          Protect(cond = luaT_callorderiTM(L, s2v(ra), im, inv, isf, tm));  \
        }  \
        docondjump(); }</cpp:value></cpp:define>

<comment type="block">/* }================================================================== */</comment>


<comment type="block">/*
** {==================================================================
** Function 'luaV_execute': main interpreter loop
** ===================================================================
*/</comment>

<comment type="block">/*
** some macros for common tasks in 'luaV_execute'
*/</comment>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RA</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(base+GETARG_A(i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RB</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(base+GETARG_B(i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vRB</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>s2v(RB(i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KB</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(k+GETARG_B(i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RC</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(base+GETARG_C(i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vRC</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>s2v(RC(i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KC</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(k+GETARG_C(i))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RKC</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((TESTARG_k(i)) ? k + GETARG_C(i) : s2v(base + GETARG_C(i)))</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>updatetrap</name><parameter_list>(<parameter><type><name>ci</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(trap = ci-&gt;u.l.trap)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>updatebase</name><parameter_list>(<parameter><type><name>ci</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(base = ci-&gt;func + 1)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>updatestack</name><parameter_list>(<parameter><type><name>ci</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ if (trap) { updatebase(ci); ra = RA(i); } }</cpp:value></cpp:define>


<comment type="block">/*
** Execute a jump instruction. The 'updatetrap' allows signals to stop
** tight loops. (Without it, the local copy of 'trap' could never change.)
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dojump</name><parameter_list>(<parameter><type><name>ci</name></type></parameter>,<parameter><type><name>i</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>{ pc += GETARG_sJ(i) + e; updatetrap(ci); }</cpp:value></cpp:define>


<comment type="block">/* for test instructions, execute the jump instruction that follows it */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>donextjump</name><parameter_list>(<parameter><type><name>ci</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>{ Instruction ni = *pc; dojump(ci, ni, 1); }</cpp:value></cpp:define>

<comment type="block">/*
** do a conditional jump: skip next instruction if 'cond' is not what
** was expected (parameter 'k'), else do next instruction, which must
** be a jump.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>docondjump</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>if (cond != GETARG_k(i)) pc++; else donextjump(ci);</cpp:value></cpp:define>


<comment type="block">/*
** Correct global 'pc'.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>savepc</name><parameter_list>(<parameter><type><name>L</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(ci-&gt;u.l.savedpc = pc)</cpp:value></cpp:define>


<comment type="block">/*
** Whenever code can raise errors, the global 'pc' and the global
** 'top' must be correct to report occasional errors.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>savestate</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>ci</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(savepc(L), L-&gt;top = ci-&gt;top)</cpp:value></cpp:define>


<comment type="block">/*
** Protect code that, in general, can raise errors, reallocate the
** stack, and change the hooks.
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Protect</name><parameter_list>(<parameter><type><name>exp</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(savestate(L,ci), (exp), updatetrap(ci))</cpp:value></cpp:define>

<comment type="block">/* special version that does not change the top */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ProtectNT</name><parameter_list>(<parameter><type><name>exp</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(savepc(L), (exp), updatetrap(ci))</cpp:value></cpp:define>

<comment type="block">/*
** Protect code that will finish the loop (returns) or can only raise
** errors. (That is, it will not return to the interpreter main loop
** after changing the stack or hooks.)
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>halfProtect</name><parameter_list>(<parameter><type><name>exp</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(savestate(L,ci), (exp))</cpp:value></cpp:define>

<comment type="block">/* idem, but without changing the stack */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>halfProtectNT</name><parameter_list>(<parameter><type><name>exp</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(savepc(L), (exp))</cpp:value></cpp:define>

<comment type="block">/* 'c' is the limit of live values in the stack */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>checkGC</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>  \
	<cpp:value>{ luaC_condGC(L, (savepc(L), L-&gt;top = (c)), \
                         updatetrap(ci)); \
           luai_threadyield(L); }</cpp:value></cpp:define>


<comment type="block">/* fetch an instruction and prepare its execution */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vmfetch</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>{ \
  if (trap) {  <comment type="block">/* stack reallocation or hooks? */</comment> \
    trap = luaG_traceexec(L, pc);  <comment type="block">/* handle hooks */</comment> \
    updatebase(ci);  <comment type="block">/* correct stack */</comment> \
  } \
  i = *(pc++); \
  ra = RA(i); <comment type="block">/* WARNING: any stack reallocation invalidates 'ra' */</comment> \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vmdispatch</name><parameter_list>(<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>switch(o)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vmcase</name><parameter_list>(<parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>case l:</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vmbreak</name></cpp:macro>		<cpp:value>break</cpp:value></cpp:define>


<function><type><name>void</name></type> <name>luaV_execute</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>LClosure</name> <modifier>*</modifier></type><name>cl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>k</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>StkId</name></type> <name>base</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>Instruction</name> <modifier>*</modifier></type><name>pc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>trap</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LUA_USE_JUMPTABLE</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ljumptab.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
 <label><name>tailcall</name>:</label>
  <expr_stmt><expr><name>trap</name> <operator>=</operator> <name><name>L</name><operator>-&gt;</operator><name>hookmask</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>cl</name> <operator>=</operator> <call><name>clLvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>func</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>cl</name><operator>-&gt;</operator><name>p</name><operator>-&gt;</operator><name>k</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pc</name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>savedpc</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>trap</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>cl</name><operator>-&gt;</operator><name>p</name><operator>-&gt;</operator><name>is_vararg</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>trap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* hooks will start after VARARGPREP instruction */</comment>
    <if type="elseif">else if <condition>(<expr><name>pc</name> <operator>==</operator> <name><name>cl</name><operator>-&gt;</operator><name>p</name><operator>-&gt;</operator><name>code</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* first instruction (not resuming)? */</comment>
      <expr_stmt><expr><call><name>luaD_hookcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>trap</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* there may be other hooks */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>base</name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>func</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <comment type="block">/* main loop of interpreter */</comment>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>Instruction</name></type> <name>i</name></decl>;</decl_stmt>  <comment type="block">/* instruction being executed */</comment>
    <decl_stmt><decl><type><name>StkId</name></type> <name>ra</name></decl>;</decl_stmt>  <comment type="block">/* instruction's A register */</comment>
    <expr_stmt><expr><call><name>vmfetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>base</name> <operator>==</operator> <name><name>ci</name><operator>-&gt;</operator><name>func</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>base</name> <operator>&lt;=</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>&amp;&amp;</operator> <name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>stack</name></name> <operator>+</operator> <name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* invalidate top for instructions not expecting it */</comment>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>isIT</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>cast_void</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>base</name></expr></argument>)</argument_list></call><operator>,</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>vmdispatch</name> <argument_list>(<argument>GET_OPCODE(i)</argument>)</argument_list></macro> <block>{<block_content>
      <macro><name>vmcase</name><argument_list>(<argument>OP_MOVE</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>setobjs2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><call><name>RB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_LOADI</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>lua_Integer</name></type> <name>b</name> <init>= <expr><call><name>GETARG_sBx</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_LOADF</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>b</name> <init>= <expr><call><name>GETARG_sBx</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>setfltvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cast_num</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_LOADK</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rb</name> <init>= <expr><name>k</name> <operator>+</operator> <call><name>GETARG_Bx</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>setobj2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_LOADKX</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rb</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>rb</name> <operator>=</operator> <name>k</name> <operator>+</operator> <call><name>GETARG_Ax</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>pc</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setobj2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_LOADFALSE</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>setbfvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_LFALSESKIP</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>setbfvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc</name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* skip next instruction */</comment>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_LOADTRUE</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>setbtvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_LOADNIL</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>b</name> <init>= <expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <do>do <block>{<block_content>
          <expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block> while <condition>(<expr><name>b</name><operator>--</operator></expr>)</condition>;</do>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_GETUPVAL</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>b</name> <init>= <expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>setobj2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name><name>cl</name><operator>-&gt;</operator><name>upvals</name><index>[<expr><name>b</name></expr>]</index></name><operator>-&gt;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_SETUPVAL</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>UpVal</name> <modifier>*</modifier></type><name>uv</name> <init>= <expr><name><name>cl</name><operator>-&gt;</operator><name>upvals</name><index>[<expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>uv</name><operator>-&gt;</operator><name>v</name></name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>luaC_barrier</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>uv</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_GETTABUP</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>upval</name> <init>= <expr><name><name>cl</name><operator>-&gt;</operator><name>upvals</name><index>[<expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>-&gt;</operator><name>v</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><call><name>KC</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TString</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* key must be a string */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>luaV_fastget</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>upval</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>luaH_getshortstr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>setobj2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaV_finishget</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>upval</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_GETTABLE</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rb</name> <init>= <expr><call><name>vRB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><call><name>vRC</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>lua_Unsigned</name></type> <name>n</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><ternary><condition><expr><call><name>ttisinteger</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>  <comment type="block">/* fast track for integers? */</comment>
            ?</condition><then> <expr><operator>(</operator><call><name>cast_void</name><argument_list>(<argument><expr><name>n</name> <operator>=</operator> <call><name>ivalue</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator> <call><name>luaV_fastgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
            </then><else>: <expr><call><name>luaV_fastget</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>luaH_get</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>setobj2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaV_finishget</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_GETI</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rb</name> <init>= <expr><call><name>vRB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>GETARG_C</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>luaV_fastgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>setobj2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else <block>{<block_content>
          <decl_stmt><decl><type><name>TValue</name></type> <name>key</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaV_finishget</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_GETFIELD</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rb</name> <init>= <expr><call><name>vRB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><call><name>KC</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TString</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* key must be a string */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>luaV_fastget</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>luaH_getshortstr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>setobj2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaV_finishget</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_SETTABUP</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>upval</name> <init>= <expr><name><name>cl</name><operator>-&gt;</operator><name>upvals</name><index>[<expr><call><name>GETARG_A</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>-&gt;</operator><name>v</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rb</name> <init>= <expr><call><name>KB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><call><name>RKC</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TString</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* key must be a string */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>luaV_fastget</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>upval</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>luaH_getshortstr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>luaV_finishfastset</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>upval</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaV_finishset</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>upval</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_SETTABLE</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rb</name> <init>= <expr><call><name>vRB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* key (table is in 'ra') */</comment>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><call><name>RKC</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* value */</comment>
        <decl_stmt><decl><type><name>lua_Unsigned</name></type> <name>n</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><ternary><condition><expr><call><name>ttisinteger</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>  <comment type="block">/* fast track for integers? */</comment>
            ?</condition><then> <expr><operator>(</operator><call><name>cast_void</name><argument_list>(<argument><expr><name>n</name> <operator>=</operator> <call><name>ivalue</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator> <call><name>luaV_fastgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call><operator>)</operator></expr>
            </then><else>: <expr><call><name>luaV_fastget</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>luaH_get</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>luaV_finishfastset</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaV_finishset</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_SETI</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><call><name>RKC</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>luaV_fastgeti</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>luaV_finishfastset</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else <block>{<block_content>
          <decl_stmt><decl><type><name>TValue</name></type> <name>key</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaV_finishset</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_SETFIELD</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rb</name> <init>= <expr><call><name>KB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><call><name>RKC</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TString</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* key must be a string */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>luaV_fastget</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>luaH_getshortstr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>luaV_finishfastset</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaV_finishset</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_NEWTABLE</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>b</name> <init>= <expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* log2(hash size) + 1 */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>GETARG_C</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* array size */</comment>
        <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>b</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>b</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>b</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* size is 2^(b - 1) */</comment>
        <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>(</operator><operator>!</operator><call><name>TESTARG_k</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>(</operator><call><name>GETARG_Ax</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>TESTARG_k</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* non-zero extra argument? */</comment>
          <expr_stmt><expr><name>c</name> <operator>+=</operator> <call><name>GETARG_Ax</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call> <operator>*</operator> <operator>(</operator><name>MAXARG_C</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* add it to size */</comment>
        <expr_stmt><expr><name>pc</name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* skip extra argument */</comment>
        <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>ra</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* correct top in case of emergency GC */</comment>
        <expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>luaH_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* memory allocation */</comment>
        <expr_stmt><expr><call><name>sethvalue2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>b</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>c</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>luaH_resize</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* idem */</comment>
        <expr_stmt><expr><call><name>checkGC</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_SELF</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rb</name> <init>= <expr><call><name>vRB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><call><name>RKC</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TString</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>tsvalue</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* key must be a string */</comment>
        <expr_stmt><expr><call><name>setobj2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>luaV_fastget</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>luaH_getstr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>setobj2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaV_finishget</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_ADDI</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_arithI</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l_addi</name></expr></argument>, <argument><expr><name>luai_numadd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_ADDK</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_arithK</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l_addi</name></expr></argument>, <argument><expr><name>luai_numadd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_SUBK</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_arithK</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l_subi</name></expr></argument>, <argument><expr><name>luai_numsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_MULK</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_arithK</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l_muli</name></expr></argument>, <argument><expr><name>luai_nummul</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_MODK</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_arithK</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>luaV_mod</name></expr></argument>, <argument><expr><name>luaV_modf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_POWK</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_arithfK</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>luai_numpow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_DIVK</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_arithfK</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>luai_numdiv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_IDIVK</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_arithK</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>luaV_idiv</name></expr></argument>, <argument><expr><name>luai_numidiv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_BANDK</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_bitwiseK</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l_band</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_BORK</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_bitwiseK</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l_bor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_BXORK</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_bitwiseK</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l_bxor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_SHRI</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rb</name> <init>= <expr><call><name>vRB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>ic</name> <init>= <expr><call><name>GETARG_sC</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>lua_Integer</name></type> <name>ib</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>tointegerns</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ib</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>pc</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>luaV_shiftl</name><argument_list>(<argument><expr><name>ib</name></expr></argument>, <argument><expr><operator>-</operator><name>ic</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_SHLI</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rb</name> <init>= <expr><call><name>vRB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>ic</name> <init>= <expr><call><name>GETARG_sC</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>lua_Integer</name></type> <name>ib</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>tointegerns</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ib</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>pc</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>luaV_shiftl</name><argument_list>(<argument><expr><name>ic</name></expr></argument>, <argument><expr><name>ib</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_ADD</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_arith</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l_addi</name></expr></argument>, <argument><expr><name>luai_numadd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_SUB</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_arith</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l_subi</name></expr></argument>, <argument><expr><name>luai_numsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_MUL</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_arith</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l_muli</name></expr></argument>, <argument><expr><name>luai_nummul</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_MOD</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_arith</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>luaV_mod</name></expr></argument>, <argument><expr><name>luaV_modf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_POW</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_arithf</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>luai_numpow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_DIV</argument>)</argument_list></macro> <block>{<block_content>  <comment type="block">/* float division (always with floats) */</comment>
        <expr_stmt><expr><call><name>op_arithf</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>luai_numdiv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_IDIV</argument>)</argument_list></macro> <block>{<block_content>  <comment type="block">/* floor division */</comment>
        <expr_stmt><expr><call><name>op_arith</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>luaV_idiv</name></expr></argument>, <argument><expr><name>luai_numidiv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_BAND</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_bitwise</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l_band</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_BOR</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_bitwise</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l_bor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_BXOR</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_bitwise</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l_bxor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_SHR</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_bitwise</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>luaV_shiftr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_SHL</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_bitwise</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>luaV_shiftl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_MMBIN</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>Instruction</name></type> <name>pi</name> <init>= <expr><operator>*</operator><operator>(</operator><name>pc</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>  <comment type="block">/* original arith. expression */</comment>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rb</name> <init>= <expr><call><name>vRB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TMS</name></type> <name>tm</name> <init>= <expr><operator>(</operator><name>TMS</name><operator>)</operator><call><name>GETARG_C</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>StkId</name></type> <name>result</name> <init>= <expr><call><name>RA</name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>OP_ADD</name> <operator>&lt;=</operator> <call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>OP_SHR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaT_trybinTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_MMBINI</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>Instruction</name></type> <name>pi</name> <init>= <expr><operator>*</operator><operator>(</operator><name>pc</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>  <comment type="block">/* original arith. expression */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>imm</name> <init>= <expr><call><name>GETARG_sB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TMS</name></type> <name>tm</name> <init>= <expr><operator>(</operator><name>TMS</name><operator>)</operator><call><name>GETARG_C</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>flip</name> <init>= <expr><call><name>GETARG_k</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>StkId</name></type> <name>result</name> <init>= <expr><call><name>RA</name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaT_trybiniTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>imm</name></expr></argument>, <argument><expr><name>flip</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_MMBINK</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>Instruction</name></type> <name>pi</name> <init>= <expr><operator>*</operator><operator>(</operator><name>pc</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>  <comment type="block">/* original arith. expression */</comment>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>imm</name> <init>= <expr><call><name>KB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TMS</name></type> <name>tm</name> <init>= <expr><operator>(</operator><name>TMS</name><operator>)</operator><call><name>GETARG_C</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>flip</name> <init>= <expr><call><name>GETARG_k</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>StkId</name></type> <name>result</name> <init>= <expr><call><name>RA</name><argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaT_trybinassocTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>imm</name></expr></argument>, <argument><expr><name>flip</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_UNM</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rb</name> <init>= <expr><call><name>vRB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>lua_Number</name></type> <name>nb</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ttisinteger</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <decl_stmt><decl><type><name>lua_Integer</name></type> <name>ib</name> <init>= <expr><call><name>ivalue</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>intop</name><argument_list>(<argument><expr><operator>-</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ib</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>tonumberns</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>setfltvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>luai_numunm</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaT_trybinTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>TM_UNM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_BNOT</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rb</name> <init>= <expr><call><name>vRB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>lua_Integer</name></type> <name>ib</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>tointegerns</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ib</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>intop</name><argument_list>(<argument><expr><operator>^</operator></expr></argument>, <argument><expr><operator>~</operator><call><name>l_castS2U</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ib</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaT_trybinTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>TM_BNOT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_NOT</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rb</name> <init>= <expr><call><name>vRB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>l_isfalse</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>setbtvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>setbfvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_LEN</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaV_objlen</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><call><name>vRB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_CONCAT</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* number of elements to concatenate */</comment>
        <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>ra</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>  <comment type="block">/* mark the end of concat operands */</comment>
        <expr_stmt><expr><call><name>ProtectNT</name><argument_list>(<argument><expr><call><name>luaV_concat</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>checkGC</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 'luaV_concat' ensures correct top */</comment>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_CLOSE</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaF_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>LUA_OK</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_TBC</argument>)</argument_list></macro> <block>{<block_content>
        <comment type="block">/* create new to-be-closed upvalue */</comment>
        <expr_stmt><expr><call><name>halfProtect</name><argument_list>(<argument><expr><call><name>luaF_newtbcupval</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_JMP</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>dojump</name><argument_list>(<argument><expr><name>ci</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_EQ</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>cond</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rb</name> <init>= <expr><call><name>vRB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><name>cond</name> <operator>=</operator> <call><name>luaV_equalobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>docondjump</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_LT</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_order</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l_lti</name></expr></argument>, <argument><expr><name>LTnum</name></expr></argument>, <argument><expr><name>lessthanothers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_LE</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_order</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l_lei</name></expr></argument>, <argument><expr><name>LEnum</name></expr></argument>, <argument><expr><name>lessequalothers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_EQK</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rb</name> <init>= <expr><call><name>KB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="block">/* basic types do not use '__eq'; we can use raw equality */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>cond</name> <init>= <expr><call><name>luaV_rawequalobj</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>docondjump</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_EQI</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>cond</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>im</name> <init>= <expr><call><name>GETARG_sB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ttisinteger</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>cond</name> <operator>=</operator> <operator>(</operator><call><name>ivalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>im</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>ttisfloat</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>cond</name> <operator>=</operator> <call><name>luai_numeq</name><argument_list>(<argument><expr><call><name>fltvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>cast_num</name><argument_list>(<argument><expr><name>im</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><name>cond</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* other types cannot be equal to a number */</comment>
        <expr_stmt><expr><call><name>docondjump</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_LTI</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_orderI</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l_lti</name></expr></argument>, <argument><expr><name>luai_numlt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TM_LT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_LEI</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_orderI</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l_lei</name></expr></argument>, <argument><expr><name>luai_numle</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TM_LE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_GTI</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_orderI</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l_gti</name></expr></argument>, <argument><expr><name>luai_numgt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>TM_LT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_GEI</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>op_orderI</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>l_gei</name></expr></argument>, <argument><expr><name>luai_numge</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>TM_LE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_TEST</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>cond</name> <init>= <expr><operator>!</operator><call><name>l_isfalse</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>docondjump</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_TESTSET</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>rb</name> <init>= <expr><call><name>vRB</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>l_isfalse</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>GETARG_k</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>pc</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
        <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>setobj2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>donextjump</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_CALL</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>b</name> <init>= <expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nresults</name> <init>= <expr><call><name>GETARG_C</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>b</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* fixed number of arguments? */</comment>
          <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>ra</name> <operator>+</operator> <name>b</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* top signals number of arguments */</comment>
        <comment type="block">/* else previous instruction set top */</comment>
        <expr_stmt><expr><call><name>ProtectNT</name><argument_list>(<argument><expr><call><name>luaD_call</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>nresults</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_TAILCALL</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>b</name> <init>= <expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* number of arguments + 1 (function) */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>nparams1</name> <init>= <expr><call><name>GETARG_C</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="block">/* delat is virtual 'func' - real 'func' (vararg functions) */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>nparams1</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>nextraargs</name></name> <operator>+</operator> <name>nparams1</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>b</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>ra</name> <operator>+</operator> <name>b</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>  <comment type="block">/* previous instruction set top */</comment>
          <expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>cast_int</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name>ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><call><name>savepc</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* some calls here can raise errors */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>TESTARG_k</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <comment type="block">/* close upvalues from current call; the compiler ensures
             that there are no to-be-closed variables here, so this
             call cannot change the stack */</comment>
          <expr_stmt><expr><call><name>luaF_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>NOCLOSINGMETH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>base</name> <operator>==</operator> <name><name>ci</name><operator>-&gt;</operator><name>func</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <while>while <condition>(<expr><operator>!</operator><call><name>ttisfunction</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* not a function? */</comment>
          <expr_stmt><expr><call><name>luaD_tryfuncTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* try '__call' metamethod */</comment>
          <expr_stmt><expr><name>b</name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* there is now one extra argument */</comment>
          <expr_stmt><expr><call><name>checkstackGCp</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ttisLclosure</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* C function? */</comment>
          <expr_stmt><expr><call><name>luaD_call</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>LUA_MULTRET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* call it */</comment>
          <expr_stmt><expr><call><name>updatetrap</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>updatestack</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* stack may have been relocated */</comment>
          <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>func</name></name> <operator>-=</operator> <name>delta</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>luaD_poscall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><call><name>cast_int</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>func</name></name> <operator>-=</operator> <name>delta</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>luaD_pretailcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* prepare call frame */</comment>
        <goto>goto <name>tailcall</name>;</goto>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_RETURN</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* number of results */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>nparams1</name> <init>= <expr><call><name>GETARG_C</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* not fixed? */</comment>
          <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>cast_int</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name>ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* get what is available */</comment>
        <expr_stmt><expr><call><name>savepc</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>TESTARG_k</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* may there be open upvalues? */</comment>
          <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>&lt;</operator> <name><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
          <expr_stmt><expr><call><name>luaF_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>LUA_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>updatetrap</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>updatestack</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>nparams1</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* vararg function? */</comment>
          <expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>func</name></name> <operator>-=</operator> <name><name>ci</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>nextraargs</name></name> <operator>+</operator> <name>nparams1</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>ra</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>  <comment type="block">/* set call for 'luaD_poscall' */</comment>
        <expr_stmt><expr><call><name>luaD_poscall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_RETURN0</argument>)</argument_list></macro> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>hookmask</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>ra</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>halfProtectNT</name><argument_list>(<argument><expr><call><name>luaD_poscall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* no hurry... */</comment>
        </block_content>}</block></if>
        <else>else <block>{<block_content>  <comment type="block">/* do the 'poscall' here */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>nres</name> <init>= <expr><name><name>ci</name><operator>-&gt;</operator><name>nresults</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>previous</name></name></expr>;</expr_stmt>  <comment type="block">/* back to caller */</comment>
          <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>base</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <while>while <condition>(<expr><name>nres</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>  <comment type="block">/* all results are nil */</comment>
        </block_content>}</block></else></if_stmt>
        <return>return;</return>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_RETURN1</argument>)</argument_list></macro> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>hookmask</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>ra</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>halfProtectNT</name><argument_list>(<argument><expr><call><name>luaD_poscall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* no hurry... */</comment>
        </block_content>}</block></if>
        <else>else <block>{<block_content>  <comment type="block">/* do the 'poscall' here */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>nres</name> <init>= <expr><name><name>ci</name><operator>-&gt;</operator><name>nresults</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>previous</name></name></expr>;</expr_stmt>  <comment type="block">/* back to caller */</comment>
          <if_stmt><if>if <condition>(<expr><name>nres</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>base</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* asked for no results */</comment>
          <else>else <block>{<block_content>
            <expr_stmt><expr><call><name>setobjs2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>base</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* at least this result */</comment>
            <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
            <while>while <condition>(<expr><operator>--</operator><name>nres</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* complete missing results */</comment>
              <expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return;</return>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_FORLOOP</argument>)</argument_list></macro> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>ttisinteger</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* integer loop? */</comment>
          <decl_stmt><decl><type><name>lua_Unsigned</name></type> <name>count</name> <init>= <expr><call><name>l_castS2U</name><argument_list>(<argument><expr><call><name>ivalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* still more iterations? */</comment>
            <decl_stmt><decl><type><name>lua_Integer</name></type> <name>step</name> <init>= <expr><call><name>ivalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>lua_Integer</name></type> <name>idx</name> <init>= <expr><call><name>ivalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* internal index */</comment>
            <expr_stmt><expr><call><name>chgivalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>count</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* update counter */</comment>
            <expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>intop</name><argument_list>(<argument><expr><operator>+</operator></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* add step to index */</comment>
            <expr_stmt><expr><call><name>chgivalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* update internal index */</comment>
            <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* and control variable */</comment>
            <expr_stmt><expr><name>pc</name> <operator>-=</operator> <call><name>GETARG_Bx</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* jump back */</comment>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>floatforloop</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* float loop */</comment>
          <expr_stmt><expr><name>pc</name> <operator>-=</operator> <call><name>GETARG_Bx</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* jump back */</comment>
        <expr_stmt><expr><call><name>updatetrap</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* allows a signal to break the loop */</comment>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_FORPREP</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>savestate</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* in case of errors */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>forprep</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>pc</name> <operator>+=</operator> <call><name>GETARG_Bx</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* skip the loop */</comment>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_TFORPREP</argument>)</argument_list></macro> <block>{<block_content>
        <comment type="block">/* create to-be-closed upvalue (if needed) */</comment>
        <expr_stmt><expr><call><name>halfProtect</name><argument_list>(<argument><expr><call><name>luaF_newtbcupval</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pc</name> <operator>+=</operator> <call><name>GETARG_Bx</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>pc</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* go to next instruction */</comment>
        <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP_TFORCALL</name> <operator>&amp;&amp;</operator> <name>ra</name> <operator>==</operator> <call><name>RA</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>l_tforcall</name>;</goto>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_TFORCALL</argument>)</argument_list></macro> <block>{<block_content>
       <label><name>l_tforcall</name>:</label>
        <comment type="block">/* 'ra' has the iterator function, 'ra + 1' has the state,
           'ra + 2' has the control variable, and 'ra + 3' has the
           to-be-closed variable. The call will use the stack after
           these values (starting at 'ra + 4')
        */</comment>
        <comment type="block">/* push function, state, and control variable */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ra</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><literal type="number">3</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ra</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name>ra</name> <operator>+</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ProtectNT</name><argument_list>(<argument><expr><call><name>luaD_call</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><call><name>GETARG_C</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* do the call */</comment>
        <expr_stmt><expr><call><name>updatestack</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* stack may have changed */</comment>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>pc</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt>  <comment type="block">/* go to next instruction */</comment>
        <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP_TFORLOOP</name> <operator>&amp;&amp;</operator> <name>ra</name> <operator>==</operator> <call><name>RA</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>l_tforloop</name>;</goto>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_TFORLOOP</argument>)</argument_list></macro> <block>{<block_content>
        <label><name>l_tforloop</name>:</label>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ttisnil</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* continue loop? */</comment>
          <expr_stmt><expr><call><name>setobjs2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>ra</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* save control variable */</comment>
          <expr_stmt><expr><name>pc</name> <operator>-=</operator> <call><name>GETARG_Bx</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* jump back */</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_SETLIST</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>last</name> <init>= <expr><call><name>GETARG_C</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><call><name>hvalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>cast_int</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <name>ra</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* get up to the top */</comment>
        <else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* correct top in case of emergency GC */</comment>
        <expr_stmt><expr><name>last</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>TESTARG_k</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>last</name> <operator>+=</operator> <call><name>GETARG_Ax</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call> <operator>*</operator> <operator>(</operator><name>MAXARG_C</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
          <expr_stmt><expr><name>pc</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>last</name> <operator>&gt;</operator> <call><name>luaH_realasize</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* needs more space? */</comment>
          <expr_stmt><expr><call><name>luaH_resizearray</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* preallocate it at once */</comment>
        <for>for <control>(<init>;</init> <condition><expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>n</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
          <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>s2v</name><argument_list>(<argument><expr><name>ra</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>setobj2t</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>last</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>last</name><operator>--</operator></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>luaC_barrierback</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_CLOSURE</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>cl</name><operator>-&gt;</operator><name>p</name><operator>-&gt;</operator><name>p</name><index>[<expr><call><name>GETARG_Bx</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>halfProtect</name><argument_list>(<argument><expr><call><name>pushclosure</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>cl</name><operator>-&gt;</operator><name>upvals</name></name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>checkGC</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ra</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_VARARG</argument>)</argument_list></macro> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>GETARG_C</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* required results */</comment>
        <expr_stmt><expr><call><name>Protect</name><argument_list>(<argument><expr><call><name>luaT_getvarargs</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_VARARGPREP</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>ProtectNT</name><argument_list>(<argument><expr><call><name>luaT_adjustvarargs</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>GETARG_A</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ci</name></expr></argument>, <argument><expr><name><name>cl</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>trap</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>luaD_hookcall</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>oldpc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* next opcode will be seen as a "new" line */</comment>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>updatebase</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* function has new base after adjustment */</comment>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
      <macro><name>vmcase</name><argument_list>(<argument>OP_EXTRAARG</argument>)</argument_list></macro> <block>{<block_content>
        <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vmbreak</name></expr>;</expr_stmt>
      </block_content>}</block>
    </block_content>}</block>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* }================================================================== */</comment>
</unit>
