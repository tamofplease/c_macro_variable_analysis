<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/lua/lcode.c"><comment type="block">/*
** $Id: lcode.c $
** Code generator for Lua
** See Copyright Notice in lua.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lcode_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lprefix.h"</cpp:file></cpp:include>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lua.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lcode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ldebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ldo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lgc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lopcodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lparser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lstring.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ltable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lvm.h"</cpp:file></cpp:include>


<comment type="block">/* Maximum number of registers in a Lua function (must fit in 8 bits) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXREGS</name></cpp:macro>		<cpp:value>255</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hasjumps</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((e)-&gt;t != (e)-&gt;f)</cpp:value></cpp:define>


<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>codesJ</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>OpCode</name></type> <name>o</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>;</function_decl>



<comment type="block">/* semantic error */</comment>
<function><type><name>l_noret</name></type> <name>luaK_semerror</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* remove "near &lt;token&gt;" from final message */</comment>
  <expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** If expression is a numeric constant, fills 'v' with its value
** and returns 1. Otherwise, returns 0.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>tonumeral</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>hasjumps</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* not a numeral */</comment>
  <switch>switch <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>VKINT</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>v</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    <case>case <expr><name>VKFLT</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>v</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>setfltvalue</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    <default>default:</default> <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
** Get the constant value from a constant expression
*/</comment>
<function><type><specifier>static</specifier> <name>TValue</name> <modifier>*</modifier></type><name>const2val</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VCONST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>dyd</name><operator>-&gt;</operator><name>actvar</name><operator>.</operator><name>arr</name><index>[<expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr>]</index></name><operator>.</operator><name>k</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** If expression is a constant, fills 'v' with its value
** and returns 1. Otherwise, returns 0.
*/</comment>
<function><type><name>int</name></type> <name>luaK_exp2const</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>hasjumps</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* not a constant */</comment>
  <switch>switch <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>VFALSE</name></expr>:</case>
      <expr_stmt><expr><call><name>setbfvalue</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    <case>case <expr><name>VTRUE</name></expr>:</case>
      <expr_stmt><expr><call><name>setbtvalue</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    <case>case <expr><name>VNIL</name></expr>:</case>
      <expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    <case>case <expr><name>VKSTR</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>setsvalue</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>strval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>VCONST</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><call><name>const2val</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block>
    <default>default:</default> <return>return <expr><call><name>tonumeral</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
** Return the previous instruction of the current code. If there
** may be a jump target between the current instruction and the
** previous one, return an invalid instruction (to avoid wrong
** optimizations).
*/</comment>
<function><type><specifier>static</specifier> <name>Instruction</name> <modifier>*</modifier></type><name>previousinstruction</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>Instruction</name></type> <name>invalidinstruction</name> <init>= <expr><operator>~</operator><operator>(</operator><name>Instruction</name><operator>)</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name> <operator>&gt;</operator> <name><name>fs</name><operator>-&gt;</operator><name>lasttarget</name></name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>code</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return></block_content></block></if>  <comment type="block">/* previous instruction */</comment>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><call><name>cast</name><argument_list>(<argument><expr><name>Instruction</name><operator>*</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>invalidinstruction</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Create a OP_LOADNIL instruction, but try to optimize: if the previous
** instruction is also OP_LOADNIL and ranges are compatible, adjust
** range of previous instruction instead of emitting a new one. (For
** instance, 'local a; local b' will generate a single opcode.)
*/</comment>
<function><type><name>void</name></type> <name>luaK_nil</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><name>from</name> <operator>+</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* last register to set nil */</comment>
  <decl_stmt><decl><type><name>Instruction</name> <modifier>*</modifier></type><name>previous</name> <init>= <expr><call><name>previousinstruction</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><operator>*</operator><name>previous</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP_LOADNIL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* previous is LOADNIL? */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>pfrom</name> <init>= <expr><call><name>GETARG_A</name><argument_list>(<argument><expr><operator>*</operator><name>previous</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* get previous range */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>pl</name> <init>= <expr><name>pfrom</name> <operator>+</operator> <call><name>GETARG_B</name><argument_list>(<argument><expr><operator>*</operator><name>previous</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pfrom</name> <operator>&lt;=</operator> <name>from</name> <operator>&amp;&amp;</operator> <name>from</name> <operator>&lt;=</operator> <name>pl</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>from</name> <operator>&lt;=</operator> <name>pfrom</name> <operator>&amp;&amp;</operator> <name>pfrom</name> <operator>&lt;=</operator> <name>l</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* can connect both? */</comment>
      <if_stmt><if>if <condition>(<expr><name>pfrom</name> <operator>&lt;</operator> <name>from</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>from</name> <operator>=</operator> <name>pfrom</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* from = min(from, pfrom) */</comment>
      <if_stmt><if>if <condition>(<expr><name>pl</name> <operator>&gt;</operator> <name>l</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>l</name> <operator>=</operator> <name>pl</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* l = max(l, pl) */</comment>
      <expr_stmt><expr><call><name>SETARG_A</name><argument_list>(<argument><expr><operator>*</operator><name>previous</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SETARG_B</name><argument_list>(<argument><expr><operator>*</operator><name>previous</name></expr></argument>, <argument><expr><name>l</name> <operator>-</operator> <name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>  <comment type="block">/* else go through */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_LOADNIL</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* else no optimization */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Gets the destination address of a jump instruction. Used to traverse
** a list of jumps.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getjump</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><call><name>GETARG_sJ</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>code</name><index>[<expr><name>pc</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <name>NO_JUMP</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* point to itself represents end of list */</comment>
    <return>return <expr><name>NO_JUMP</name></expr>;</return></block_content></block></if>  <comment type="block">/* end of list */</comment>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><operator>(</operator><name>pc</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>+</operator><name>offset</name></expr>;</return></block_content></block></else></if_stmt>  <comment type="block">/* turn offset into absolute position */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Fix jump instruction at position 'pc' to jump to 'dest'.
** (Jump addresses are relative in Lua)
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fixjump</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dest</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Instruction</name> <modifier>*</modifier></type><name>jmp</name> <init>= <expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>code</name><index>[<expr><name>pc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><name>dest</name> <operator>-</operator> <operator>(</operator><name>pc</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>dest</name> <operator>!=</operator> <name>NO_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>-</operator><name>OFFSET_sJ</name> <operator>&lt;=</operator> <name>offset</name> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&lt;=</operator> <name>MAXARG_sJ</name> <operator>-</operator> <name>OFFSET_sJ</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name></expr></argument>, <argument><expr><literal type="string">"control structure too long"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><operator>*</operator><name>jmp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP_JMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SETARG_sJ</name><argument_list>(<argument><expr><operator>*</operator><name>jmp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Concatenate jump-list 'l2' into jump-list 'l1'
*/</comment>
<function><type><name>void</name></type> <name>luaK_concat</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>l1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>l2</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>l2</name> <operator>==</operator> <name>NO_JUMP</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if>  <comment type="block">/* nothing to concatenate? */</comment>
  <if type="elseif">else if <condition>(<expr><operator>*</operator><name>l1</name> <operator>==</operator> <name>NO_JUMP</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* no original list? */</comment>
    <expr_stmt><expr><operator>*</operator><name>l1</name> <operator>=</operator> <name>l2</name></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* 'l1' points to 'l2' */</comment>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>list</name> <init>= <expr><operator>*</operator><name>l1</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>next</name></decl>;</decl_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>next</name> <operator>=</operator> <call><name>getjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NO_JUMP</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* find last element */</comment>
      <expr_stmt><expr><name>list</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><call><name>fixjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* last element links to 'l2' */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Create a jump instruction and return its position, so its destination
** can be fixed later (with 'fixjump').
*/</comment>
<function><type><name>int</name></type> <name>luaK_jump</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>codesJ</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_JMP</name></expr></argument>, <argument><expr><name>NO_JUMP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Code a 'return' instruction
*/</comment>
<function><type><name>void</name></type> <name>luaK_ret</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>first</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nret</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>OpCode</name></type> <name>op</name></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name>nret</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_RETURN0</name></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_RETURN1</name></expr>;</expr_stmt> <break>break;</break>
    <default>default:</default> <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_RETURN</name></expr>;</expr_stmt> <break>break;</break>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>nret</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Code a "conditional jump", that is, a test or comparison opcode
** followed by a jump. Return jump position.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>condjump</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>OpCode</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>A</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>B</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>C</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>luaK_codeABCk</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>C</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** returns current 'pc' and marks it as a jump target (to avoid wrong
** optimizations with consecutive instructions not in the same basic block).
*/</comment>
<function><type><name>int</name></type> <name>luaK_getlabel</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>lasttarget</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
  <return>return <expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Returns the position of the instruction "controlling" a given
** jump (that is, its condition), or the jump itself if it is
** unconditional.
*/</comment>
<function><type><specifier>static</specifier> <name>Instruction</name> <modifier>*</modifier></type><name>getjumpcontrol</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Instruction</name> <modifier>*</modifier></type><name>pi</name> <init>= <expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>code</name><index>[<expr><name>pc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>pc</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>testTMode</name><argument_list>(<argument><expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>pi</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>pi</name><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><name>pi</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Patch destination register for a TESTSET instruction.
** If instruction in position 'node' is not a TESTSET, return 0 ("fails").
** Otherwise, if 'reg' is not 'NO_REG', set it as the destination
** register. Otherwise, change instruction to a simple 'TEST' (produces
** no register value)
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>patchtestreg</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Instruction</name> <modifier>*</modifier></type><name>i</name> <init>= <expr><call><name>getjumpcontrol</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><operator>*</operator><name>i</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OP_TESTSET</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* cannot patch other instructions */</comment>
  <if_stmt><if>if <condition>(<expr><name>reg</name> <operator>!=</operator> <name>NO_REG</name> <operator>&amp;&amp;</operator> <name>reg</name> <operator>!=</operator> <call><name>GETARG_B</name><argument_list>(<argument><expr><operator>*</operator><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>SETARG_A</name><argument_list>(<argument><expr><operator>*</operator><name>i</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else <block>{<block_content>
     <comment type="block">/* no register to put value or register already has the value;
        change instruction to simple test */</comment>
    <expr_stmt><expr><operator>*</operator><name>i</name> <operator>=</operator> <call><name>CREATE_ABCk</name><argument_list>(<argument><expr><name>OP_TEST</name></expr></argument>, <argument><expr><call><name>GETARG_B</name><argument_list>(<argument><expr><operator>*</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>GETARG_k</name><argument_list>(<argument><expr><operator>*</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Traverse a list of tests ensuring no one produces a value
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>removevalues</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>list</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <for>for <control>(<init>;</init> <condition><expr><name>list</name> <operator>!=</operator> <name>NO_JUMP</name></expr>;</condition> <incr><expr><name>list</name> <operator>=</operator> <call><name>getjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>patchtestreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>NO_REG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>


<comment type="block">/*
** Traverse a list of tests, patching their destination address and
** registers: tests producing values jump to 'vtarget' (and put their
** values in 'reg'), other tests jump to 'dtarget'.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>patchlistaux</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>vtarget</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reg</name></decl></parameter>,
                          <parameter><decl><type><name>int</name></type> <name>dtarget</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <while>while <condition>(<expr><name>list</name> <operator>!=</operator> <name>NO_JUMP</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>next</name> <init>= <expr><call><name>getjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>patchtestreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fixjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>vtarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fixjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>dtarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* jump to default target */</comment>
    <expr_stmt><expr><name>list</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
** Path all jumps in 'list' to jump to 'target'.
** (The assert means that we cannot fix a jump to a forward address
** because we only know addresses once code is generated.)
*/</comment>
<function><type><name>void</name></type> <name>luaK_patchlist</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>target</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>target</name> <operator>&lt;=</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>patchlistaux</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>NO_REG</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>luaK_patchtohere</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>list</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>hr</name> <init>= <expr><call><name>luaK_getlabel</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* mark "here" as a jump target */</comment>
  <expr_stmt><expr><call><name>luaK_patchlist</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>hr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** MAXimum number of successive Instructions WiTHout ABSolute line
** information.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MAXIWTHABS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXIWTHABS</name></cpp:macro>	<cpp:value>120</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* limit for difference between lines in relative line info. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIMLINEDIFF</name></cpp:macro>	<cpp:value>0x80</cpp:value></cpp:define>


<comment type="block">/*
** Save line info for a new instruction. If difference from last line
** does not fit in a byte, of after that many instructions, save a new
** absolute line info; (in that case, the special value 'ABSLINEINFO'
** in 'lineinfo' signals the existence of this absolute information.)
** Otherwise, store the difference from last line in 'lineinfo'.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>savelineinfo</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>Proto</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>linedif</name> <init>= <expr><name>line</name> <operator>-</operator> <name><name>fs</name><operator>-&gt;</operator><name>previousline</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pc</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* last instruction coded */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>abs</name><argument_list>(<argument><expr><name>linedif</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>LIMLINEDIFF</name> <operator>||</operator> <name><name>fs</name><operator>-&gt;</operator><name>iwthabs</name></name><operator>++</operator> <operator>&gt;</operator> <name>MAXIWTHABS</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>luaM_growvector</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>abslineinfo</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nabslineinfo</name></name></expr></argument>,
                    <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizeabslineinfo</name></name></expr></argument>, <argument><expr><name>AbsLineInfo</name></expr></argument>, <argument><expr><name>MAX_INT</name></expr></argument>, <argument><expr><literal type="string">"lines"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>abslineinfo</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>nabslineinfo</name></name></expr>]</index></name><operator>.</operator><name>pc</name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>abslineinfo</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>nabslineinfo</name></name><operator>++</operator></expr>]</index></name><operator>.</operator><name>line</name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>linedif</name> <operator>=</operator> <name>ABSLINEINFO</name></expr>;</expr_stmt>  <comment type="block">/* signal that there is absolute information */</comment>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>iwthabs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* restart counter */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>luaM_growvector</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>lineinfo</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizelineinfo</name></name></expr></argument>, <argument><expr><name>ls_byte</name></expr></argument>,
                  <argument><expr><name>MAX_INT</name></expr></argument>, <argument><expr><literal type="string">"opcodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>lineinfo</name><index>[<expr><name>pc</name></expr>]</index></name> <operator>=</operator> <name>linedif</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>previousline</name></name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>  <comment type="block">/* last line saved */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Remove line information from the last instruction.
** If line information for that instruction is absolute, set 'iwthabs'
** above its max to force the new (replacing) instruction to have
** absolute line info, too.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>removelastlineinfo</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pc</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* last instruction coded */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>lineinfo</name><index>[<expr><name>pc</name></expr>]</index></name> <operator>!=</operator> <name>ABSLINEINFO</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* relative line info? */</comment>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>previousline</name></name> <operator>-=</operator> <name><name>f</name><operator>-&gt;</operator><name>lineinfo</name><index>[<expr><name>pc</name></expr>]</index></name></expr>;</expr_stmt>  <comment type="block">/* correct last line saved */</comment>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>iwthabs</name></name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* undo previous increment */</comment>
  </block_content>}</block></if>
  <else>else <block>{<block_content>  <comment type="block">/* absolute line information */</comment>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>abslineinfo</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>nabslineinfo</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>pc</name> <operator>==</operator> <name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>nabslineinfo</name></name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* remove it */</comment>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>iwthabs</name></name> <operator>=</operator> <name>MAXIWTHABS</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* force next line info to be absolute */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Remove the last instruction created, correcting line information
** accordingly.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>removelastinstruction</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>removelastlineinfo</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Emit instruction 'i', checking for array sizes and saving also its
** line information. Return 'i' position.
*/</comment>
<function><type><name>int</name></type> <name>luaK_code</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>Instruction</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* put new instruction in code array */</comment>
  <expr_stmt><expr><call><name>luaM_growvector</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizecode</name></name></expr></argument>, <argument><expr><name>Instruction</name></expr></argument>,
                  <argument><expr><name>MAX_INT</name></expr></argument>, <argument><expr><literal type="string">"opcodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>code</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>savelineinfo</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>lastline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>  <comment type="block">/* index of new instruction */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Format and emit an 'iABC' instruction. (Assertions check consistency
** of parameters versus opcode.)
*/</comment>
<function><type><name>int</name></type> <name>luaK_codeABCk</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>OpCode</name></type> <name>o</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>getOpMode</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>iABC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>a</name> <operator>&lt;=</operator> <name>MAXARG_A</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>&lt;=</operator> <name>MAXARG_B</name> <operator>&amp;&amp;</operator>
             <name>c</name> <operator>&lt;=</operator> <name>MAXARG_C</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>k</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>luaK_code</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>CREATE_ABCk</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Format and emit an 'iABx' instruction.
*/</comment>
<function><type><name>int</name></type> <name>luaK_codeABx</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>OpCode</name></type> <name>o</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>bc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>getOpMode</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>iABx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>a</name> <operator>&lt;=</operator> <name>MAXARG_A</name> <operator>&amp;&amp;</operator> <name>bc</name> <operator>&lt;=</operator> <name>MAXARG_Bx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>luaK_code</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>CREATE_ABx</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>bc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Format and emit an 'iAsBx' instruction.
*/</comment>
<function><type><name>int</name></type> <name>luaK_codeAsBx</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>OpCode</name></type> <name>o</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>b</name> <init>= <expr><name>bc</name> <operator>+</operator> <name>OFFSET_sBx</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>getOpMode</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>iAsBx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>a</name> <operator>&lt;=</operator> <name>MAXARG_A</name> <operator>&amp;&amp;</operator> <name>b</name> <operator>&lt;=</operator> <name>MAXARG_Bx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>luaK_code</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>CREATE_ABx</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Format and emit an 'isJ' instruction.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>codesJ</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>OpCode</name></type> <name>o</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>j</name> <init>= <expr><name>sj</name> <operator>+</operator> <name>OFFSET_sJ</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>getOpMode</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>isJ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>j</name> <operator>&lt;=</operator> <name>MAXARG_sJ</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>k</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>luaK_code</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>CREATE_sJ</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Emit an "extra argument" instruction (format 'iAx')
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>codeextraarg</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>a</name> <operator>&lt;=</operator> <name>MAXARG_Ax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>luaK_code</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>CREATE_Ax</name><argument_list>(<argument><expr><name>OP_EXTRAARG</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Emit a "load constant" instruction, using either 'OP_LOADK'
** (if constant index 'k' fits in 18 bits) or an 'OP_LOADKX'
** instruction with "extra argument".
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaK_codek</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&lt;=</operator> <name>MAXARG_Bx</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>luaK_codeABx</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_LOADK</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><call><name>luaK_codeABx</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_LOADKX</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>codeextraarg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>p</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Check register-stack level, keeping track of its maximum size
** in field 'maxstacksize'
*/</comment>
<function><type><name>void</name></type> <name>luaK_checkstack</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>newstack</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>+</operator> <name>n</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>newstack</name> <operator>&gt;</operator> <name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>maxstacksize</name></name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>newstack</name> <operator>&gt;=</operator> <name>MAXREGS</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name></expr></argument>,
        <argument><expr><literal type="string">"function or expression needs too many registers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>maxstacksize</name></name> <operator>=</operator> <call><name>cast_byte</name><argument_list>(<argument><expr><name>newstack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Reserve 'n' registers in register stack
*/</comment>
<function><type><name>void</name></type> <name>luaK_reserveregs</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>luaK_checkstack</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Free register 'reg', if it is neither a constant index nor
** a local variable.
)
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freereg</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>reg</name> <operator>&gt;=</operator> <call><name>luaY_nvarstack</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>reg</name> <operator>==</operator> <name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Free two registers in proper order
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freeregs</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r2</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>r1</name> <operator>&gt;</operator> <name>r2</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>freereg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freereg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>freereg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freereg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Free register used by expression 'e' (if any)
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freeexp</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VNONRELOC</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>freereg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Free registers used by expressions 'e1' and 'e2' (if any) in proper
** order.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freeexps</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>e1</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VNONRELOC</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>r2</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>e2</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VNONRELOC</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>e2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>freeregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Add constant 'v' to prototype's list of constants (field 'k').
** Use scanner's table to cache position of constants in constant list
** and try to reuse constants. Because some values should not be used
** as keys (nil cannot be a key, integer keys can collapse with float
** keys), the caller must provide a useful 'key' for indexing the cache.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>addk</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>idx</name> <init>= <expr><call><name>luaH_set</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* index scanner table */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>, <decl><type ref="prev"/><name>oldsize</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ttisinteger</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* is there an index there? */</comment>
    <expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>cast_int</name><argument_list>(<argument><expr><call><name>ivalue</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* correct value? (warning: must distinguish floats from integers!) */</comment>
    <if_stmt><if>if <condition>(<expr><name>k</name> <operator>&lt;</operator> <name><name>fs</name><operator>-&gt;</operator><name>nk</name></name> <operator>&amp;&amp;</operator> <call><name>ttypetag</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>k</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>ttypetag</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                      <call><name>luaV_rawequalobj</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>k</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>k</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* reuse index */</comment>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* constant not found; create a new entry */</comment>
  <expr_stmt><expr><name>oldsize</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>sizek</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nk</name></name></expr>;</expr_stmt>
  <comment type="block">/* numerical value does not need GC barrier;
     table has no metatable, so it does not need to invalidate cache */</comment>
  <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_growvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>k</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizek</name></name></expr></argument>, <argument><expr><name>TValue</name></expr></argument>, <argument><expr><name>MAXARG_Ax</name></expr></argument>, <argument><expr><literal type="string">"constants"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>oldsize</name> <operator>&lt;</operator> <name><name>f</name><operator>-&gt;</operator><name>sizek</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>k</name><index>[<expr><name>oldsize</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><call><name>setobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>k</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>nk</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaC_barrier</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>k</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Add a string to list of constants and return its index.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>stringK</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name></type> <name>o</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setsvalue</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>o</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>addk</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>o</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>o</name></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* use string itself as key */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Add an integer to list of constants and return its index.
** Integers use userdata as keys to avoid collision with floats with
** same value; conversion to 'void*' is used only for hashing, so there
** are no "precision" problems.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaK_intK</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>lua_Integer</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name></type> <name>k</name></decl>, <decl><type ref="prev"/><name>o</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setpvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>k</name></expr></argument>, <argument><expr><call><name>cast_voidp</name><argument_list>(<argument><expr><call><name>cast_sizet</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>o</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>addk</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>o</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Add a float to list of constants and return its index.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaK_numberK</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>lua_Number</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name></type> <name>o</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setfltvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>o</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>addk</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>o</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>o</name></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* use number itself as key */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Add a false to list of constants and return its index.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>boolF</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name></type> <name>o</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setbfvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>addk</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>o</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>o</name></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* use boolean itself as key */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Add a true to list of constants and return its index.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>boolT</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name></type> <name>o</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setbtvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>addk</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>o</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>o</name></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* use boolean itself as key */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Add nil to list of constants and return its index.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nilK</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name></type> <name>k</name></decl>, <decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* cannot use nil as key; instead use table itself to represent nil */</comment>
  <expr_stmt><expr><call><name>sethvalue</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>h</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>addk</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>k</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Check whether 'i' can be stored in an 'sC' operand. Equivalent to
** (0 &lt;= int2sC(i) &amp;&amp; int2sC(i) &lt;= MAXARG_C) but without risk of
** overflows in the hidden addition inside 'int2sC'.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fitsC</name> <parameter_list>(<parameter><decl><type><name>lua_Integer</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><call><name>l_castS2U</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>OFFSET_sC</name> <operator>&lt;=</operator> <call><name>cast_uint</name><argument_list>(<argument><expr><name>MAXARG_C</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Check whether 'i' can be stored in an 'sBx' operand.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fitsBx</name> <parameter_list>(<parameter><decl><type><name>lua_Integer</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><operator>-</operator><name>OFFSET_sBx</name> <operator>&lt;=</operator> <name>i</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;=</operator> <name>MAXARG_Bx</name> <operator>-</operator> <name>OFFSET_sBx</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>luaK_int</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>lua_Integer</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>fitsBx</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaK_codeAsBx</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_LOADI</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><call><name>cast_int</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaK_codek</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><call><name>luaK_intK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>luaK_float</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reg</name></decl></parameter>, <parameter><decl><type><name>lua_Number</name></type> <name>f</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_Integer</name></type> <name>fi</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>luaV_flttointeger</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fi</name></expr></argument>, <argument><expr><name>F2Ieq</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>fitsBx</name><argument_list>(<argument><expr><name>fi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaK_codeAsBx</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_LOADF</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><call><name>cast_int</name><argument_list>(<argument><expr><name>fi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaK_codek</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><call><name>luaK_numberK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Convert a constant in 'v' into an expression description 'e'
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>const2exp</name> <parameter_list>(<parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><call><name>ttypetag</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LUA_VNUMINT</name></expr>:</case>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VKINT</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name> <operator>=</operator> <call><name>ivalue</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>LUA_VNUMFLT</name></expr>:</case>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VKFLT</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nval</name></name> <operator>=</operator> <call><name>fltvalue</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>LUA_VFALSE</name></expr>:</case>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VFALSE</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>LUA_VTRUE</name></expr>:</case>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VTRUE</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>LUA_VNIL</name></expr>:</case>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VNIL</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>LUA_VSHRSTR</name></expr>:</case>  <case>case <expr><name>LUA_VLNGSTR</name></expr>:</case>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VKSTR</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>strval</name></name> <operator>=</operator> <call><name>tsvalue</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
** Fix an expression to return the number of results 'nresults'.
** 'e' must be a multi-ret expression (function call or vararg).
*/</comment>
<function><type><name>void</name></type> <name>luaK_setreturns</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nresults</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Instruction</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><operator>&amp;</operator><call><name>getinstruction</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VCALL</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* expression is an open function call? */</comment>
    <expr_stmt><expr><call><name>SETARG_C</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>, <argument><expr><name>nresults</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VVARARG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SETARG_C</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>, <argument><expr><name>nresults</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SETARG_A</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Convert a VKSTR to a VK
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>str2K</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKSTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name> <operator>=</operator> <call><name>stringK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>strval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VK</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Fix an expression to return one result.
** If expression is not a multi-ret expression (function call or
** vararg), it already returns one result, so nothing needs to be done.
** Function calls become VNONRELOC expressions (as its result comes
** fixed in the base register of the call), while vararg expressions
** become VRELOC (as OP_VARARG puts its results where it wants).
** (Calls are created returning one result, so that does not need
** to be fixed.)
*/</comment>
<function><type><name>void</name></type> <name>luaK_setoneret</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VCALL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* expression is an open function call? */</comment>
    <comment type="block">/* already returns 1 value */</comment>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>GETARG_C</name><argument_list>(<argument><expr><call><name>getinstruction</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VNONRELOC</name></expr>;</expr_stmt>  <comment type="block">/* result has fixed position */</comment>
    <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name> <operator>=</operator> <call><name>GETARG_A</name><argument_list>(<argument><expr><call><name>getinstruction</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VVARARG</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>SETARG_C</name><argument_list>(<argument><expr><call><name>getinstruction</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VRELOC</name></expr>;</expr_stmt>  <comment type="block">/* can relocate its simple result */</comment>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Ensure that expression 'e' is not a variable (nor a constant).
** (Expression still may have jump lists.)
*/</comment>
<function><type><name>void</name></type> <name>luaK_dischargevars</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>VCONST</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>const2exp</name><argument_list>(<argument><expr><call><name>const2val</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VLOCAL</name></expr>:</case> <block>{<block_content>  <comment type="block">/* already in a register */</comment>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>var</name><operator>.</operator><name>sidx</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VNONRELOC</name></expr>;</expr_stmt>  <comment type="block">/* becomes a non-relocatable value */</comment>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VUPVAL</name></expr>:</case> <block>{<block_content>  <comment type="block">/* move value to some (pending) register */</comment>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name> <operator>=</operator> <call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_GETUPVAL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VRELOC</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VINDEXUP</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name> <operator>=</operator> <call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_GETTABUP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>t</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VRELOC</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VINDEXI</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>freereg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name> <operator>=</operator> <call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_GETI</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>t</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VRELOC</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VINDEXSTR</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>freereg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name> <operator>=</operator> <call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_GETFIELD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>t</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VRELOC</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VINDEXED</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>freeregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>t</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name> <operator>=</operator> <call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_GETTABLE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>t</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VRELOC</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VVARARG</name></expr>:</case> <case>case <expr><name>VCALL</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>luaK_setoneret</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <break>break;</break>  <comment type="block">/* there is one value available (somewhere) */</comment>
  </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
** Ensures expression value is in register 'reg' (and therefore
** 'e' will become a non-relocatable expression).
** (Expression still may have jump lists.)
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>discharge2reg</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>luaK_dischargevars</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>VNIL</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>luaK_nil</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VFALSE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_LOADFALSE</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VTRUE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_LOADTRUE</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VKSTR</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>str2K</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>  <comment type="block">/* FALLTHROUGH */</comment>
    <case>case <expr><name>VK</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>luaK_codek</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VKFLT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>luaK_float</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VKINT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>luaK_int</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VRELOC</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Instruction</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><operator>&amp;</operator><call><name>getinstruction</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SETARG_A</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* instruction will put result in 'reg' */</comment>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VNONRELOC</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>reg</name> <operator>!=</operator> <name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_MOVE</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VJMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>  <comment type="block">/* nothing to do... */</comment>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name>reg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VNONRELOC</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Ensures expression value is in any register.
** (Expression still may have jump lists.)
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>discharge2anyreg</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>!=</operator> <name>VNONRELOC</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* no fixed register yet? */</comment>
    <expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* get a register */</comment>
    <expr_stmt><expr><call><name>discharge2reg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* put value there */</comment>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>code_loadbool</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>A</name></decl></parameter>, <parameter><decl><type><name>OpCode</name></type> <name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>luaK_getlabel</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* those instructions may be jump targets */</comment>
  <return>return <expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** check whether list has any jump that do not produce a value
** or produce an inverted value
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>need_value</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>list</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <for>for <control>(<init>;</init> <condition><expr><name>list</name> <operator>!=</operator> <name>NO_JUMP</name></expr>;</condition> <incr><expr><name>list</name> <operator>=</operator> <call><name>getjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>Instruction</name></type> <name>i</name> <init>= <expr><operator>*</operator><call><name>getjumpcontrol</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OP_TESTSET</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* not found */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Ensures final expression result (which includes results from its
** jump lists) is in register 'reg'.
** If expression has jumps, need to patch these jumps either to
** its final position or to "load" instructions (for those tests
** that do not produce values).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>exp2reg</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>discharge2reg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VJMP</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* expression itself is a test? */</comment>
    <expr_stmt><expr><call><name>luaK_concat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>t</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* put this jump in 't' list */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>hasjumps</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>final</name></decl>;</decl_stmt>  <comment type="block">/* position after whole expression */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>p_f</name> <init>= <expr><name>NO_JUMP</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* position of an eventual LOAD false */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>p_t</name> <init>= <expr><name>NO_JUMP</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* position of an eventual LOAD true */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>need_value</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>need_value</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>fj</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VJMP</name><operator>)</operator></expr> ?</condition><then> <expr><name>NO_JUMP</name></expr> </then><else>: <expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>p_f</name> <operator>=</operator> <call><name>code_loadbool</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_LFALSESKIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip next inst. */</comment>
      <expr_stmt><expr><name>p_t</name> <operator>=</operator> <call><name>code_loadbool</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>OP_LOADTRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* jump around these booleans if 'e' is not a test */</comment>
      <expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>fj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>final</name> <operator>=</operator> <call><name>luaK_getlabel</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>patchlistaux</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name></expr></argument>, <argument><expr><name>final</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>p_f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>patchlistaux</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>t</name></name></expr></argument>, <argument><expr><name>final</name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>p_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name>NO_JUMP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name>reg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VNONRELOC</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Ensures final expression result is in next available register.
*/</comment>
<function><type><name>void</name></type> <name>luaK_exp2nextreg</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>luaK_dischargevars</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>exp2reg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Ensures final expression result is in some (any) register
** and return that register.
*/</comment>
<function><type><name>int</name></type> <name>luaK_exp2anyreg</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>luaK_dischargevars</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VNONRELOC</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* expression already has a register? */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasjumps</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* no jumps? */</comment>
      <return>return <expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* result is already in a register */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name> <operator>&gt;=</operator> <call><name>luaY_nvarstack</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* reg. is not a local? */</comment>
      <expr_stmt><expr><call><name>exp2reg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* put final result in it */</comment>
      <return>return <expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* otherwise, use next available register */</comment>
  <return>return <expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Ensures final expression result is either in a register
** or in an upvalue.
*/</comment>
<function><type><name>void</name></type> <name>luaK_exp2anyregup</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>!=</operator> <name>VUPVAL</name> <operator>||</operator> <call><name>hasjumps</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Ensures final expression result is either in a register
** or it is a constant.
*/</comment>
<function><type><name>void</name></type> <name>luaK_exp2val</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>hasjumps</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaK_dischargevars</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Try to make 'e' a K expression with an index in the range of R/K
** indices. Return true iff succeeded.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>luaK_exp2K</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasjumps</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>info</name></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* move constants to 'k' */</comment>
      <case>case <expr><name>VTRUE</name></expr>:</case> <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>boolT</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>VFALSE</name></expr>:</case> <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>boolF</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>VNIL</name></expr>:</case> <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>nilK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>VKINT</name></expr>:</case> <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>luaK_intK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>VKFLT</name></expr>:</case> <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>luaK_numberK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>VKSTR</name></expr>:</case> <expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>stringK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>strval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
      <case>case <expr><name>VK</name></expr>:</case> <expr_stmt><expr><name>info</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr>;</expr_stmt> <break>break;</break>
      <default>default:</default> <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* not a constant */</comment>
    </block_content>}</block></switch>
    <if_stmt><if>if <condition>(<expr><name>info</name> <operator>&lt;=</operator> <name>MAXINDEXRK</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* does constant fit in 'argC'? */</comment>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VK</name></expr>;</expr_stmt>  <comment type="block">/* make expression a 'K' expression */</comment>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name>info</name></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* else, expression doesn't fit; leave it unchanged */</comment>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Ensures final expression result is in a valid R/K index
** (that is, it is either in a register or in 'k' with an index
** in the range of R/K indices).
** Returns 1 iff expression is K.
*/</comment>
<function><type><name>int</name></type> <name>luaK_exp2RK</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>luaK_exp2K</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
  <else>else <block>{<block_content>  <comment type="block">/* not a constant in the right range: put it in a register */</comment>
    <expr_stmt><expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>codeABRK</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>OpCode</name></type> <name>o</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>,
                      <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>k</name> <init>= <expr><call><name>luaK_exp2RK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>ec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaK_codeABCk</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>ec</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Generate code to store result of expression 'ex' into variable 'var'.
*/</comment>
<function><type><name>void</name></type> <name>luaK_storevar</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>ex</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>k</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>VLOCAL</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>exp2reg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>var</name><operator>.</operator><name>sidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* compute 'ex' into proper place */</comment>
      <return>return;</return>
    </block_content>}</block>
    <case>case <expr><name>VUPVAL</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_SETUPVAL</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VINDEXUP</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>codeABRK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_SETTABUP</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>t</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>idx</name></name></expr></argument>, <argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VINDEXI</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>codeABRK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_SETI</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>t</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>idx</name></name></expr></argument>, <argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VINDEXSTR</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>codeABRK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_SETFIELD</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>t</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>idx</name></name></expr></argument>, <argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VINDEXED</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>codeABRK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_SETTABLE</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>t</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>idx</name></name></expr></argument>, <argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* invalid var kind to store */</comment>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Emit SELF instruction (convert expression 'e' into 'e:key(e,').
*/</comment>
<function><type><name>void</name></type> <name>luaK_self</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ereg</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ereg</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr>;</expr_stmt>  <comment type="block">/* register where 'e' was placed */</comment>
  <expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr>;</expr_stmt>  <comment type="block">/* base register for op_self */</comment>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VNONRELOC</name></expr>;</expr_stmt>  <comment type="block">/* self expression has a fixed register */</comment>
  <expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* function and 'self' produced by op_self */</comment>
  <expr_stmt><expr><call><name>codeABRK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_SELF</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><name>ereg</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Negate condition 'e' (where 'e' is a comparison).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>negatecondition</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Instruction</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>getjumpcontrol</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>testTMode</name><argument_list>(<argument><expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>GET_OPCODE</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OP_TESTSET</name> <operator>&amp;&amp;</operator>
                                           <call><name>GET_OPCODE</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OP_TEST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SETARG_k</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>, <argument><expr><operator>(</operator><call><name>GETARG_k</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call> <operator>^</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Emit instruction to jump if 'e' is 'cond' (that is, if 'cond'
** is true, code will jump if 'e' is true.) Return jump position.
** Optimize when 'e' is 'not' something, inverting the condition
** and removing the 'not'.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>jumponcond</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cond</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VRELOC</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>Instruction</name></type> <name>ie</name> <init>= <expr><call><name>getinstruction</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>ie</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP_NOT</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>removelastinstruction</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remove previous OP_NOT */</comment>
      <return>return <expr><call><name>condjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_TEST</name></expr></argument>, <argument><expr><call><name>GETARG_B</name><argument_list>(<argument><expr><name>ie</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>!</operator><name>cond</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* else go through */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>discharge2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>condjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_TESTSET</name></expr></argument>, <argument><expr><name>NO_REG</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Emit code to go through if 'e' is true, jump otherwise.
*/</comment>
<function><type><name>void</name></type> <name>luaK_goiftrue</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>pc</name></decl>;</decl_stmt>  <comment type="block">/* pc of new jump */</comment>
  <expr_stmt><expr><call><name>luaK_dischargevars</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>VJMP</name></expr>:</case> <block>{<block_content>  <comment type="block">/* condition? */</comment>
      <expr_stmt><expr><call><name>negatecondition</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* jump when it is false */</comment>
      <expr_stmt><expr><name>pc</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr>;</expr_stmt>  <comment type="block">/* save jump position */</comment>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VK</name></expr>:</case> <case>case <expr><name>VKFLT</name></expr>:</case> <case>case <expr><name>VKINT</name></expr>:</case> <case>case <expr><name>VKSTR</name></expr>:</case> <case>case <expr><name>VTRUE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>pc</name> <operator>=</operator> <name>NO_JUMP</name></expr>;</expr_stmt>  <comment type="block">/* always true; do nothing */</comment>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>jumponcond</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* jump when false */</comment>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>luaK_concat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>f</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* insert new jump in false list */</comment>
  <expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* true list jumps to here (to go through) */</comment>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name>NO_JUMP</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Emit code to go through if 'e' is false, jump otherwise.
*/</comment>
<function><type><name>void</name></type> <name>luaK_goiffalse</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>pc</name></decl>;</decl_stmt>  <comment type="block">/* pc of new jump */</comment>
  <expr_stmt><expr><call><name>luaK_dischargevars</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>VJMP</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>pc</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr>;</expr_stmt>  <comment type="block">/* already jump if true */</comment>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VNIL</name></expr>:</case> <case>case <expr><name>VFALSE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>pc</name> <operator>=</operator> <name>NO_JUMP</name></expr>;</expr_stmt>  <comment type="block">/* always false; do nothing */</comment>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>jumponcond</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* jump if true */</comment>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>luaK_concat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e</name><operator>-&gt;</operator><name>t</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* insert new jump in 't' list */</comment>
  <expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* false list jumps to here (to go through) */</comment>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <name>NO_JUMP</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Code 'not e', doing constant folding.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codenot</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>VNIL</name></expr>:</case> <case>case <expr><name>VFALSE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VTRUE</name></expr>;</expr_stmt>  <comment type="block">/* true == not nil == not false */</comment>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VK</name></expr>:</case> <case>case <expr><name>VKFLT</name></expr>:</case> <case>case <expr><name>VKINT</name></expr>:</case> <case>case <expr><name>VKSTR</name></expr>:</case> <case>case <expr><name>VTRUE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VFALSE</name></expr>;</expr_stmt>  <comment type="block">/* false == not "x" == not 0.5 == not 1 == not true */</comment>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VJMP</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>negatecondition</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VRELOC</name></expr>:</case>
    <case>case <expr><name>VNONRELOC</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>discharge2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name> <operator>=</operator> <call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_NOT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VRELOC</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* cannot happen */</comment>
  </block_content>}</block></switch>
  <comment type="block">/* interchange true and false lists */</comment>
  <block>{<block_content> <decl_stmt><decl><type><name>int</name></type> <name>temp</name> <init>= <expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>t</name></name></expr>;</expr_stmt> <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt> </block_content>}</block>
  <expr_stmt><expr><call><name>removevalues</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* values are useless when negated */</comment>
  <expr_stmt><expr><call><name>removevalues</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Check whether expression 'e' is a small literal string
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isKstr</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VK</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>hasjumps</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name> <operator>&lt;=</operator> <name>MAXARG_B</name> <operator>&amp;&amp;</operator>
          <call><name>ttisshrstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>k</name><index>[<expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
** Check whether expression 'e' is a literal integer.
*/</comment>
<function><type><name>int</name></type> <name>luaK_isKint</name> <parameter_list>(<parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKINT</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>hasjumps</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Check whether expression 'e' is a literal integer in
** proper range to fit in register C
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isCint</name> <parameter_list>(<parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>luaK_isKint</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>l_castS2U</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>l_castS2U</name><argument_list>(<argument><expr><name>MAXARG_C</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Check whether expression 'e' is a literal integer in
** proper range to fit in register sC
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isSCint</name> <parameter_list>(<parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>luaK_isKint</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>fitsC</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Check whether expression 'e' is a literal integer or float in
** proper range to fit in a register (sB or sC).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>isSCnumber</name> <parameter_list>(<parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pi</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>isfloat</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_Integer</name></type> <name>i</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKINT</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKFLT</name> <operator>&amp;&amp;</operator> <call><name>luaV_flttointeger</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nval</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><name>F2Ieq</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>isfloat</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>  <comment type="block">/* not a number */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasjumps</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>fitsC</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pi</name> <operator>=</operator> <call><name>int2sC</name><argument_list>(<argument><expr><call><name>cast_int</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Create expression 't[k]'. 't' must have its final result already in a
** register or upvalue. Upvalues can only be indexed by literal strings.
** Keys can be literal strings in the constant table or arbitrary
** values in registers.
*/</comment>
<function><type><name>void</name></type> <name>luaK_indexed</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>k</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>k</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKSTR</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>str2K</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>hasjumps</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
             <operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VLOCAL</name> <operator>||</operator> <name><name>t</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VNONRELOC</name> <operator>||</operator> <name><name>t</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VUPVAL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VUPVAL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isKstr</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* upvalue indexed by non 'Kstr'? */</comment>
    <expr_stmt><expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* put it in a register */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VUPVAL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr>;</expr_stmt>  <comment type="block">/* upvalue index */</comment>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>idx</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr>;</expr_stmt>  <comment type="block">/* literal string */</comment>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VINDEXUP</name></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <comment type="block">/* register index of the table */</comment>
    <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>t</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>t</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VLOCAL</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>var</name><operator>.</operator><name>sidx</name></name></expr></then><else>: <expr><name><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>isKstr</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>idx</name></name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr>;</expr_stmt>  <comment type="block">/* literal string */</comment>
      <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VINDEXSTR</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>isCint</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>idx</name></name> <operator>=</operator> <call><name>cast_int</name><argument_list>(<argument><expr><name><name>k</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* int. constant in proper range */</comment>
      <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VINDEXI</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>idx</name></name> <operator>=</operator> <call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* register */</comment>
      <expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VINDEXED</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Return false if folding can raise an error.
** Bitwise operations need operands convertible to integers; division
** operations cannot have 0 as divisor.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>validop</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>v1</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>v2</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LUA_OPBAND</name></expr>:</case> <case>case <expr><name>LUA_OPBOR</name></expr>:</case> <case>case <expr><name>LUA_OPBXOR</name></expr>:</case>
    <case>case <expr><name>LUA_OPSHL</name></expr>:</case> <case>case <expr><name>LUA_OPSHR</name></expr>:</case> <case>case <expr><name>LUA_OPBNOT</name></expr>:</case> <block>{<block_content>  <comment type="block">/* conversion errors */</comment>
      <decl_stmt><decl><type><name>lua_Integer</name></type> <name>i</name></decl>;</decl_stmt>
      <return>return <expr><operator>(</operator><call><name>tointegerns</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tointegerns</name><argument_list>(<argument><expr><name>v2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>LUA_OPDIV</name></expr>:</case> <case>case <expr><name>LUA_OPIDIV</name></expr>:</case> <case>case <expr><name>LUA_OPMOD</name></expr>:</case>  <comment type="block">/* division by 0 */</comment>
      <return>return <expr><operator>(</operator><call><name>nvalue</name><argument_list>(<argument><expr><name>v2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
    <default>default:</default> <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* everything else is valid */</comment>
  </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
** Try to "constant-fold" an operation; return 1 iff successful.
** (In this case, 'e1' has the final result.)
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>constfolding</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>,
                                        <parameter><decl><type><specifier>const</specifier> <name>expdesc</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>TValue</name></type> <name>v1</name></decl>, <decl><type ref="prev"/><name>v2</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tonumeral</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v1</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>tonumeral</name><argument_list>(<argument><expr><name>e2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v2</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>validop</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* non-numeric operands or not safe to fold */</comment>
  <expr_stmt><expr><call><name>luaO_rawarith</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* does operation */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>ttisinteger</name><argument_list>(<argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VKINT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name> <operator>=</operator> <call><name>ivalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>  <comment type="block">/* folds neither NaN nor 0.0 (to avoid problems with -0.0) */</comment>
    <decl_stmt><decl><type><name>lua_Number</name></type> <name>n</name> <init>= <expr><call><name>fltvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>luai_numisnan</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VKFLT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nval</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Emit code for unary expressions that "produce values"
** (everything but 'not').
** Expression to produce final result will be encoded in 'e'.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codeunexpval</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>OpCode</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* opcodes operate only on registers */</comment>
  <expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name> <operator>=</operator> <call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* generate opcode */</comment>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VRELOC</name></expr>;</expr_stmt>  <comment type="block">/* all those operations are relocatable */</comment>
  <expr_stmt><expr><call><name>luaK_fixline</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Emit code for binary expressions that "produce values"
** (everything but logical operators 'and'/'or' and comparison
** operators).
** Expression to produce final result will be encoded in 'e1'.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>finishbinexpval</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>,
                             <parameter><decl><type><name>OpCode</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
                             <parameter><decl><type><name>OpCode</name></type> <name>mmop</name></decl></parameter>, <parameter><decl><type><name>TMS</name></type> <name>event</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>v1</name> <init>= <expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pc</name> <init>= <expr><call><name>luaK_codeABCk</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>freeexps</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VRELOC</name></expr>;</expr_stmt>  <comment type="block">/* all those operations are relocatable */</comment>
  <expr_stmt><expr><call><name>luaK_fixline</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_codeABCk</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>mmop</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>event</name></expr></argument>, <argument><expr><name>flip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* to call metamethod */</comment>
  <expr_stmt><expr><call><name>luaK_fixline</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Emit code for binary expressions that "produce values" over
** two registers.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codebinexpval</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>OpCode</name></type> <name>op</name></decl></parameter>,
                           <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>v2</name> <init>= <expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* both operands are in registers */</comment>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>OP_ADD</name> <operator>&lt;=</operator> <name>op</name> <operator>&amp;&amp;</operator> <name>op</name> <operator>&lt;=</operator> <name>OP_SHR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>finishbinexpval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>OP_MMBIN</name></expr></argument>,
                  <argument><expr><call><name>cast</name><argument_list>(<argument><expr><name>TMS</name></expr></argument>, <argument><expr><operator>(</operator><name>op</name> <operator>-</operator> <name>OP_ADD</name><operator>)</operator> <operator>+</operator> <name>TM_ADD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Code binary operators with immediate operands.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codebini</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>OpCode</name></type> <name>op</name></decl></parameter>,
                       <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
                       <parameter><decl><type><name>TMS</name></type> <name>event</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>v2</name> <init>= <expr><call><name>int2sC</name><argument_list>(<argument><expr><call><name>cast_int</name><argument_list>(<argument><expr><name><name>e2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* immediate operand */</comment>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>e2</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>finishbinexpval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>flip</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>OP_MMBINI</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Try to code a binary operator negating its second operand.
** For the metamethod, 2nd operand must keep its original value.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>finishbinexpneg</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>,
                             <parameter><decl><type><name>OpCode</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>TMS</name></type> <name>event</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>luaK_isKint</name><argument_list>(<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>  <comment type="block">/* not an integer constant */</comment>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>lua_Integer</name></type> <name>i2</name> <init>= <expr><name><name>e2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>fitsC</name><argument_list>(<argument><expr><name>i2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>fitsC</name><argument_list>(<argument><expr><operator>-</operator><name>i2</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>  <comment type="block">/* not in the proper range */</comment>
    <else>else <block>{<block_content>  <comment type="block">/* operating a small integer constant */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>v2</name> <init>= <expr><call><name>cast_int</name><argument_list>(<argument><expr><name>i2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>finishbinexpval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><call><name>int2sC</name><argument_list>(<argument><expr><operator>-</operator><name>v2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>OP_MMBINI</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* correct metamethod argument */</comment>
      <expr_stmt><expr><call><name>SETARG_B</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>code</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>int2sC</name><argument_list>(<argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>  <comment type="block">/* successfully coded */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>swapexps</name> <parameter_list>(<parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>temp</name> <init>= <expr><operator>*</operator><name>e1</name></expr></init></decl>;</decl_stmt> <expr_stmt><expr><operator>*</operator><name>e1</name> <operator>=</operator> <operator>*</operator><name>e2</name></expr>;</expr_stmt> <expr_stmt><expr><operator>*</operator><name>e2</name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>  <comment type="block">/* swap 'e1' and 'e2' */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Code arithmetic operators ('+', '-', ...). If second operand is a
** constant in the proper range, use variant opcodes with K operands.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codearith</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BinOpr</name></type> <name>opr</name></decl></parameter>,
                       <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>TMS</name></type> <name>event</name> <init>= <expr><call><name>cast</name><argument_list>(<argument><expr><name>TMS</name></expr></argument>, <argument><expr><name>opr</name> <operator>+</operator> <name>TM_ADD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tonumeral</name><argument_list>(<argument><expr><name>e2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>luaK_exp2K</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* K operand? */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>v2</name> <init>= <expr><name><name>e2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* K index */</comment>
    <decl_stmt><decl><type><name>OpCode</name></type> <name>op</name> <init>= <expr><call><name>cast</name><argument_list>(<argument><expr><name>OpCode</name></expr></argument>, <argument><expr><name>opr</name> <operator>+</operator> <name>OP_ADDK</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>finishbinexpval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>flip</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>OP_MMBINK</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>  <comment type="block">/* 'e2' is neither an immediate nor a K operand */</comment>
    <decl_stmt><decl><type><name>OpCode</name></type> <name>op</name> <init>= <expr><call><name>cast</name><argument_list>(<argument><expr><name>OpCode</name></expr></argument>, <argument><expr><name>opr</name> <operator>+</operator> <name>OP_ADD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>flip</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>swapexps</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* back to original order */</comment>
    <expr_stmt><expr><call><name>codebinexpval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* use standard operators */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Code commutative operators ('+', '*'). If first operand is a
** numeric constant, change order of operands to try to use an
** immediate or K operator.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codecommutative</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BinOpr</name></type> <name>op</name></decl></parameter>,
                             <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>flip</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>tonumeral</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* is first operand a numeric constant? */</comment>
    <expr_stmt><expr><call><name>swapexps</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* change order */</comment>
    <expr_stmt><expr><name>flip</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>OPR_ADD</name> <operator>&amp;&amp;</operator> <call><name>isSCint</name><argument_list>(<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* immediate operand? */</comment>
    <expr_stmt><expr><call><name>codebini</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>cast</name><argument_list>(<argument><expr><name>OpCode</name></expr></argument>, <argument><expr><name>OP_ADDI</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>flip</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>TM_ADD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>codearith</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>flip</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Code bitwise operations; they are all associative, so the function
** tries to put an integer constant as the 2nd operand (a K operand).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codebitwise</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BinOpr</name></type> <name>opr</name></decl></parameter>,
                         <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>flip</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>v2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>OpCode</name></type> <name>op</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>e1</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKINT</name> <operator>&amp;&amp;</operator> <call><name>luaK_exp2RK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>swapexps</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* 'e2' will be the constant operand */</comment>
    <expr_stmt><expr><name>flip</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>e2</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKINT</name> <operator>&amp;&amp;</operator> <call><name>luaK_exp2RK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* no constants? */</comment>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>cast</name><argument_list>(<argument><expr><name>OpCode</name></expr></argument>, <argument><expr><name>opr</name> <operator>+</operator> <name>OP_ADD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>codebinexpval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* all-register opcodes */</comment>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>v2</name> <operator>=</operator> <name><name>e2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr>;</expr_stmt>  <comment type="block">/* index in K array */</comment>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>cast</name><argument_list>(<argument><expr><name>OpCode</name></expr></argument>, <argument><expr><name>opr</name> <operator>+</operator> <name>OP_ADDK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ttisinteger</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>k</name><index>[<expr><name>v2</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>finishbinexpval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>, <argument><expr><name>flip</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>OP_MMBINK</name></expr></argument>,
                  <argument><expr><call><name>cast</name><argument_list>(<argument><expr><name>TMS</name></expr></argument>, <argument><expr><name>opr</name> <operator>+</operator> <name>TM_ADD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Emit code for order comparisons. When using an immediate operand,
** 'isfloat' tells whether the original value was a float.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codeorder</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>OpCode</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>, <decl><type ref="prev"/><name>r2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>im</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isfloat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>isSCnumber</name><argument_list>(<argument><expr><name>e2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>im</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isfloat</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* use immediate operand */</comment>
    <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r2</name> <operator>=</operator> <name>im</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>cast</name><argument_list>(<argument><expr><name>OpCode</name></expr></argument>, <argument><expr><operator>(</operator><name>op</name> <operator>-</operator> <name>OP_LT</name><operator>)</operator> <operator>+</operator> <name>OP_LTI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><call><name>isSCnumber</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>im</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isfloat</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* transform (A &lt; B) to (B &gt; A) and (A &lt;= B) to (B &gt;= A) */</comment>
    <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r2</name> <operator>=</operator> <name>im</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>op</name> <operator>==</operator> <name>OP_LT</name><operator>)</operator></expr> ?</condition><then> <expr><name>OP_GTI</name></expr> </then><else>: <expr><name>OP_GEI</name></expr></else></ternary></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>  <comment type="block">/* regular case, compare two registers */</comment>
    <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>freeexps</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name> <operator>=</operator> <call><name>condjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>isfloat</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VJMP</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Emit code for equality comparisons ('==', '~=').
** 'e1' was already put as RK by 'luaK_infix'.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codeeq</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BinOpr</name></type> <name>opr</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>r1</name></decl>, <decl><type ref="prev"/><name>r2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>im</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isfloat</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* not needed here, but kept for symmetry */</comment>
  <decl_stmt><decl><type><name>OpCode</name></type> <name>op</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>e1</name><operator>-&gt;</operator><name>k</name></name> <operator>!=</operator> <name>VNONRELOC</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>e1</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VK</name> <operator>||</operator> <name><name>e1</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKINT</name> <operator>||</operator> <name><name>e1</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VKFLT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>swapexps</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>r1</name> <operator>=</operator> <call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* 1st expression must be in register */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>isSCnumber</name><argument_list>(<argument><expr><name>e2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>im</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isfloat</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_EQI</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>r2</name> <operator>=</operator> <name>im</name></expr>;</expr_stmt>  <comment type="block">/* immediate operand */</comment>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><call><name>luaK_exp2RK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* 1st expression is constant? */</comment>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_EQK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>r2</name> <operator>=</operator> <name><name>e2</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr>;</expr_stmt>  <comment type="block">/* constant index */</comment>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>OP_EQ</name></expr>;</expr_stmt>  <comment type="block">/* will compare two registers */</comment>
    <expr_stmt><expr><name>r2</name> <operator>=</operator> <call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>freeexps</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name> <operator>=</operator> <call><name>condjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>r1</name></expr></argument>, <argument><expr><name>r2</name></expr></argument>, <argument><expr><name>isfloat</name></expr></argument>, <argument><expr><operator>(</operator><name>opr</name> <operator>==</operator> <name>OPR_EQ</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e1</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VJMP</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Apply prefix operation 'op' to expression 'e'.
*/</comment>
<function><type><name>void</name></type> <name>luaK_prefix</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>UnOpr</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>expdesc</name></type> <name>ef</name> <init>= <expr><block>{<expr><name>VKINT</name></expr>, <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>, <expr><name>NO_JUMP</name></expr>, <expr><name>NO_JUMP</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaK_dischargevars</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OPR_MINUS</name></expr>:</case> <case>case <expr><name>OPR_BNOT</name></expr>:</case>  <comment type="block">/* use 'ef' as fake 2nd operand */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>constfolding</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>op</name> <operator>+</operator> <name>LUA_OPUNM</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ef</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt>
      <comment type="block">/* else */</comment> <comment type="block">/* FALLTHROUGH */</comment>
    <case>case <expr><name>OPR_LEN</name></expr>:</case>
      <expr_stmt><expr><call><name>codeunexpval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>cast</name><argument_list>(<argument><expr><name>OpCode</name></expr></argument>, <argument><expr><name>op</name> <operator>+</operator> <name>OP_UNM</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>OPR_NOT</name></expr>:</case> <expr_stmt><expr><call><name>codenot</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
** Process 1st operand 'v' of binary operation 'op' before reading
** 2nd operand.
*/</comment>
<function><type><name>void</name></type> <name>luaK_infix</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BinOpr</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>luaK_dischargevars</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OPR_AND</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>luaK_goiftrue</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* go ahead only if 'v' is true */</comment>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OPR_OR</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>luaK_goiffalse</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* go ahead only if 'v' is false */</comment>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OPR_CONCAT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* operand must be on the stack */</comment>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OPR_ADD</name></expr>:</case> <case>case <expr><name>OPR_SUB</name></expr>:</case>
    <case>case <expr><name>OPR_MUL</name></expr>:</case> <case>case <expr><name>OPR_DIV</name></expr>:</case> <case>case <expr><name>OPR_IDIV</name></expr>:</case>
    <case>case <expr><name>OPR_MOD</name></expr>:</case> <case>case <expr><name>OPR_POW</name></expr>:</case>
    <case>case <expr><name>OPR_BAND</name></expr>:</case> <case>case <expr><name>OPR_BOR</name></expr>:</case> <case>case <expr><name>OPR_BXOR</name></expr>:</case>
    <case>case <expr><name>OPR_SHL</name></expr>:</case> <case>case <expr><name>OPR_SHR</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tonumeral</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <comment type="block">/* else keep numeral, which may be folded with 2nd operand */</comment>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OPR_EQ</name></expr>:</case> <case>case <expr><name>OPR_NE</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tonumeral</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>luaK_exp2RK</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <comment type="block">/* else keep numeral, which may be an immediate operand */</comment>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OPR_LT</name></expr>:</case> <case>case <expr><name>OPR_LE</name></expr>:</case>
    <case>case <expr><name>OPR_GT</name></expr>:</case> <case>case <expr><name>OPR_GE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>dummy</name></decl>, <decl><type ref="prev"/><name>dummy2</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isSCnumber</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <comment type="block">/* else keep numeral, which may be an immediate operand */</comment>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
** Create code for '(e1 .. e2)'.
** For '(e1 .. e2.1 .. e2.2)' (which is '(e1 .. (e2.1 .. e2.2))',
** because concatenation is right associative), merge both CONCATs.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codeconcat</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Instruction</name> <modifier>*</modifier></type><name>ie2</name> <init>= <expr><call><name>previousinstruction</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><operator>*</operator><name>ie2</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OP_CONCAT</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* is 'e2' a concatenation? */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>GETARG_B</name><argument_list>(<argument><expr><operator>*</operator><name>ie2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* # of elements concatenated in 'e2' */</comment>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <call><name>GETARG_A</name><argument_list>(<argument><expr><operator>*</operator><name>ie2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SETARG_A</name><argument_list>(<argument><expr><operator>*</operator><name>ie2</name></expr></argument>, <argument><expr><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* correct first element ('e1') */</comment>
    <expr_stmt><expr><call><name>SETARG_B</name><argument_list>(<argument><expr><operator>*</operator><name>ie2</name></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* will concatenate one more element */</comment>
  </block_content>}</block></if>
  <else>else <block>{<block_content>  <comment type="block">/* 'e2' is not a concatenation */</comment>
    <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_CONCAT</name></expr></argument>, <argument><expr><name><name>e1</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* new concat opcode */</comment>
    <expr_stmt><expr><call><name>freeexp</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaK_fixline</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Finalize code for binary operation, after reading 2nd operand.
*/</comment>
<function><type><name>void</name></type> <name>luaK_posfix</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BinOpr</name></type> <name>opr</name></decl></parameter>,
                  <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e1</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>luaK_dischargevars</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>foldbinop</name><argument_list>(<argument><expr><name>opr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>constfolding</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>opr</name> <operator>+</operator> <name>LUA_OPADD</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* done by folding */</comment>
  <switch>switch <condition>(<expr><name>opr</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>OPR_AND</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>e1</name><operator>-&gt;</operator><name>t</name></name> <operator>==</operator> <name>NO_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* list closed by 'luaK_infix' */</comment>
      <expr_stmt><expr><call><name>luaK_concat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e2</name><operator>-&gt;</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>e1</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>e1</name> <operator>=</operator> <operator>*</operator><name>e2</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OPR_OR</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>e1</name><operator>-&gt;</operator><name>f</name></name> <operator>==</operator> <name>NO_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* list closed by 'luaK_infix' */</comment>
      <expr_stmt><expr><call><name>luaK_concat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e2</name><operator>-&gt;</operator><name>t</name></name></expr></argument>, <argument><expr><name><name>e1</name><operator>-&gt;</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>e1</name> <operator>=</operator> <operator>*</operator><name>e2</name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OPR_CONCAT</name></expr>:</case> <block>{<block_content>  <comment type="block">/* e1 .. e2 */</comment>
      <expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeconcat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OPR_ADD</name></expr>:</case> <case>case <expr><name>OPR_MUL</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>codecommutative</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>opr</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OPR_SUB</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>finishbinexpneg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>OP_ADDI</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>TM_SUB</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* coded as (r1 + -I) */</comment>
      <comment type="block">/* ELSE */</comment>
    </block_content>}</block>  <comment type="block">/* FALLTHROUGH */</comment>
    <case>case <expr><name>OPR_DIV</name></expr>:</case> <case>case <expr><name>OPR_IDIV</name></expr>:</case> <case>case <expr><name>OPR_MOD</name></expr>:</case> <case>case <expr><name>OPR_POW</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>codearith</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>opr</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OPR_BAND</name></expr>:</case> <case>case <expr><name>OPR_BOR</name></expr>:</case> <case>case <expr><name>OPR_BXOR</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>codebitwise</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>opr</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OPR_SHL</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>isSCint</name><argument_list>(<argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>swapexps</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>codebini</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_SHLI</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>TM_SHL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* I &lt;&lt; r2 */</comment>
      </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><call><name>finishbinexpneg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>OP_SHRI</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>TM_SHL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <comment type="block">/* coded as (r1 &gt;&gt; -I) */</comment><empty_stmt>;</empty_stmt>
      </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content>  <comment type="block">/* regular case (two registers) */</comment>
       <expr_stmt><expr><call><name>codebinexpval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_SHL</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OPR_SHR</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>isSCint</name><argument_list>(<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>codebini</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_SHRI</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>TM_SHR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* r1 &gt;&gt; I */</comment>
      <else>else<block type="pseudo"><block_content>  <comment type="block">/* regular case (two registers) */</comment>
        <expr_stmt><expr><call><name>codebinexpval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_SHR</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OPR_EQ</name></expr>:</case> <case>case <expr><name>OPR_NE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>codeeq</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>opr</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OPR_LT</name></expr>:</case> <case>case <expr><name>OPR_LE</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>OpCode</name></type> <name>op</name> <init>= <expr><call><name>cast</name><argument_list>(<argument><expr><name>OpCode</name></expr></argument>, <argument><expr><operator>(</operator><name>opr</name> <operator>-</operator> <name>OPR_EQ</name><operator>)</operator> <operator>+</operator> <name>OP_EQ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>codeorder</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>OPR_GT</name></expr>:</case> <case>case <expr><name>OPR_GE</name></expr>:</case> <block>{<block_content>
      <comment type="block">/* '(a &gt; b)' &lt;=&gt; '(b &lt; a)';  '(a &gt;= b)' &lt;=&gt; '(b &lt;= a)' */</comment>
      <decl_stmt><decl><type><name>OpCode</name></type> <name>op</name> <init>= <expr><call><name>cast</name><argument_list>(<argument><expr><name>OpCode</name></expr></argument>, <argument><expr><operator>(</operator><name>opr</name> <operator>-</operator> <name>OPR_NE</name><operator>)</operator> <operator>+</operator> <name>OP_EQ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>swapexps</name><argument_list>(<argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>codeorder</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>e1</name></expr></argument>, <argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
** Change line information associated with current position, by removing
** previous info and adding it again with new line.
*/</comment>
<function><type><name>void</name></type> <name>luaK_fixline</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>removelastlineinfo</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>savelineinfo</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>luaK_settablesize</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ra</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>asize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hsize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Instruction</name> <modifier>*</modifier></type><name>inst</name> <init>= <expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>code</name><index>[<expr><name>pc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rb</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>hsize</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>luaO_ceillog2</name><argument_list>(<argument><expr><name>hsize</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>  <comment type="block">/* hash size */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>extra</name> <init>= <expr><name>asize</name> <operator>/</operator> <operator>(</operator><name>MAXARG_C</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>  <comment type="block">/* higher bits of array size */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>asize</name> <operator>%</operator> <operator>(</operator><name>MAXARG_C</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>  <comment type="block">/* lower bits of array size */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>k</name> <init>= <expr><operator>(</operator><name>extra</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>  <comment type="block">/* true iff needs extra argument */</comment>
  <expr_stmt><expr><operator>*</operator><name>inst</name> <operator>=</operator> <call><name>CREATE_ABCk</name><argument_list>(<argument><expr><name>OP_NEWTABLE</name></expr></argument>, <argument><expr><name>ra</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><operator>(</operator><name>inst</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <call><name>CREATE_Ax</name><argument_list>(<argument><expr><name>OP_EXTRAARG</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Emit a SETLIST instruction.
** 'base' is register that keeps table;
** 'nelems' is #table plus those to be stored now;
** 'tostore' is number of values (in registers 'base + 1',...) to add to
** table (or LUA_MULTRET to add up to stack top).
*/</comment>
<function><type><name>void</name></type> <name>luaK_setlist</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nelems</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tostore</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>tostore</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tostore</name> <operator>&lt;=</operator> <name>LFIELDS_PER_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>tostore</name> <operator>==</operator> <name>LUA_MULTRET</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>tostore</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>nelems</name> <operator>&lt;=</operator> <name>MAXARG_C</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_SETLIST</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>tostore</name></expr></argument>, <argument><expr><name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>extra</name> <init>= <expr><name>nelems</name> <operator>/</operator> <operator>(</operator><name>MAXARG_C</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>nelems</name> <operator>%=</operator> <operator>(</operator><name>MAXARG_C</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaK_codeABCk</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_SETLIST</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>tostore</name></expr></argument>, <argument><expr><name>nelems</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>codeextraarg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>=</operator> <name>base</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* free registers with list values */</comment>
</block_content>}</block></function>


<comment type="block">/*
** return the final target of a jump (skipping jumps to jumps)
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>finaltarget</name> <parameter_list>(<parameter><decl><type><name>Instruction</name> <modifier>*</modifier></type><name>code</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>count</name> <operator>&lt;</operator> <literal type="number">100</literal></expr>;</condition> <incr><expr><name>count</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>  <comment type="block">/* avoid infinite loops */</comment>
    <decl_stmt><decl><type><name>Instruction</name></type> <name>pc</name> <init>= <expr><name><name>code</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OP_JMP</name></expr>)</condition><block type="pseudo"><block_content>
      <break>break;</break></block_content></block></if>
     <else>else<block type="pseudo"><block_content>
       <expr_stmt><expr><name>i</name> <operator>+=</operator> <call><name>GETARG_sJ</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Do a final pass over the code of a function, doing small peephole
** optimizations and adjustments.
*/</comment>
<function><type><name>void</name></type> <name>luaK_finish</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>Instruction</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>code</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>isOT</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>pc</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>isIT</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><call><name>GET_OPCODE</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>OP_RETURN0</name></expr>:</case> <case>case <expr><name>OP_RETURN1</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>fs</name><operator>-&gt;</operator><name>needclose</name></name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>is_vararg</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
          <break>break;</break></block_content></block></if></if_stmt>  <comment type="block">/* no extra work */</comment>
        <comment type="block">/* else use OP_RETURN to do the extra work */</comment>
        <expr_stmt><expr><call><name>SET_OPCODE</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>, <argument><expr><name>OP_RETURN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block>  <comment type="block">/* FALLTHROUGH */</comment>
      <case>case <expr><name>OP_RETURN</name></expr>:</case> <case>case <expr><name>OP_TAILCALL</name></expr>:</case> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>needclose</name></name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>SETARG_k</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* signal that it needs to close */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>is_vararg</name></name></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>SETARG_C</name><argument_list>(<argument><expr><operator>*</operator><name>pc</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>numparams</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* signal that it is vararg */</comment>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><name>OP_JMP</name></expr>:</case> <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>target</name> <init>= <expr><call><name>finaltarget</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>fixjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default> <break>break;</break>
    </block_content>}</block></switch>
  </block_content>}</block></for>
</block_content>}</block></function>
</unit>
