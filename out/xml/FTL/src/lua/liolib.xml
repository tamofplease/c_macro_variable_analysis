<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/lua/liolib.c"><comment type="block">/*
** $Id: liolib.c $
** Standard I/O (and system) library
** See Copyright Notice in lua.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>liolib_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_LIB</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lprefix.h"</cpp:file></cpp:include>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;locale.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lua.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lauxlib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lualib.h"</cpp:file></cpp:include>




<comment type="block">/*
** Change this macro to accept other modes for 'fopen' besides
** the standard ones.
*/</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>l_checkmode</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/* accepted extensions to 'mode' in 'fopen' */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>L_MODEEXT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_MODEEXT</name></cpp:macro>	<cpp:value>"b"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Check whether 'mode' matches '[rwa]%+?[L_MODEEXT]*' */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>l_checkmode</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><operator>*</operator><name>mode</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"rwa"</literal></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>mode</name><operator>++</operator><operator>)</operator></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
         <operator>(</operator><operator>*</operator><name>mode</name> <operator>!=</operator> <literal type="char">'+'</literal> <operator>||</operator> <operator>(</operator><operator>(</operator><name>void</name><operator>)</operator><operator>(</operator><operator>++</operator><name>mode</name><operator>)</operator><operator>,</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>  <comment type="block">/* skip if char is '+' */</comment>
         <operator>(</operator><call><name>strspn</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>L_MODEEXT</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</return>  <comment type="block">/* check extensions */</comment>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** {======================================================
** l_popen spawns a new process connected to the current
** one through the file streams.
** =======================================================
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>l_checkmodep</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* By default, Lua accepts only "r" or "w" as mode */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_checkmodep</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((m[0] == 'r' || m[0] == 'w') &amp;&amp; m[1] == '\0')</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>l_popen</name></expr></argument>)</argument_list></call></expr></cpp:if>		<comment type="block">/* { */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LUA_USE_POSIX</name></expr></argument>)</argument_list></call></expr></cpp:if>	<comment type="block">/* { */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_popen</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(fflush(NULL), popen(c,m))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_pclose</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>file</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(pclose(file))</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LUA_USE_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:elif>	<comment type="block">/* }{ */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_popen</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>(_popen(c,m))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_pclose</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>file</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(_pclose(file))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>				<comment type="block">/* }{ */</comment>

<comment type="block">/* ISO C definitions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_popen</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro>  \
	  <cpp:value>((void)c, (void)m, \
	  luaL_error(L, "'popen' not supported"), \
	  (FILE*)0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_pclose</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>file</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((void)L, (void)file, -1)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>				<comment type="block">/* } */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>				<comment type="block">/* } */</comment>

<comment type="block">/* }====================================================== */</comment>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>l_getc</name></expr></argument>)</argument_list></call></expr></cpp:if>		<comment type="block">/* { */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LUA_USE_POSIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_getc</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>getc_unlocked(f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_lockfile</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>flockfile(f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_unlockfile</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>funlockfile(f)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_getc</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>getc(f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_lockfile</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_unlockfile</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>				<comment type="block">/* } */</comment>


<comment type="block">/*
** {======================================================
** l_fseek: configuration for longer offsets
** =======================================================
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>l_fseek</name></expr></argument>)</argument_list></call></expr></cpp:if>		<comment type="block">/* { */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LUA_USE_POSIX</name></expr></argument>)</argument_list></call></expr></cpp:if>	<comment type="block">/* { */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_fseek</name><parameter_list>(<parameter><type><name>f</name></type></parameter>,<parameter><type><name>o</name></type></parameter>,<parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>fseeko(f,o,w)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_ftell</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>ftello(f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_seeknum</name></cpp:macro>		<cpp:value>off_t</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LUA_USE_WINDOWS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_CRTIMP_TYPEINFO</name></expr></argument>)</argument_list></call> \
   <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1400</literal><operator>)</operator></expr></cpp:elif>	<comment type="block">/* }{ */</comment>

<comment type="block">/* Windows (but not DDK) and Visual C++ 2005 or higher */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_fseek</name><parameter_list>(<parameter><type><name>f</name></type></parameter>,<parameter><type><name>o</name></type></parameter>,<parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>_fseeki64(f,o,w)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_ftell</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>_ftelli64(f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_seeknum</name></cpp:macro>		<cpp:value>__int64</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>				<comment type="block">/* }{ */</comment>

<comment type="block">/* ISO C definitions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_fseek</name><parameter_list>(<parameter><type><name>f</name></type></parameter>,<parameter><type><name>o</name></type></parameter>,<parameter><type><name>w</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>fseek(f,o,w)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_ftell</name><parameter_list>(<parameter><type><name>f</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>ftell(f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>l_seeknum</name></cpp:macro>		<cpp:value>long</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>				<comment type="block">/* } */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>				<comment type="block">/* } */</comment>

<comment type="block">/* }====================================================== */</comment>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IO_PREFIX</name></cpp:macro>	<cpp:value>"_IO_"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IOPREF_LEN</name></cpp:macro>	<cpp:value>(sizeof(IO_PREFIX)/sizeof(char) - 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IO_INPUT</name></cpp:macro>	<cpp:value>(IO_PREFIX "input")</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IO_OUTPUT</name></cpp:macro>	<cpp:value>(IO_PREFIX "output")</cpp:value></cpp:define>


<typedef>typedef <type><name>luaL_Stream</name></type> <name>LStream</name>;</typedef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tolstream</name><parameter_list>(<parameter><type><name>L</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((LStream *)luaL_checkudata(L, 1, LUA_FILEHANDLE))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isclosed</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((p)-&gt;closef == NULL)</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>int</name></type> <name>io_type</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>LStream</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaL_checkany</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>LStream</name> <operator>*</operator><operator>)</operator><call><name>luaL_testudata</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LUA_FILEHANDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaL_pushfail</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* not a file */</comment>
  <if type="elseif">else if <condition>(<expr><call><name>isclosed</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"closed file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>f_tostring</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>LStream</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>tolstream</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>isclosed</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"file (closed)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>lua_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"file (%p)"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>tofile</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>LStream</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>tolstream</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>isclosed</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"attempt to use a closed file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** When creating file handles, always creates a 'closed' file handle
** before opening the actual file; so, if there is a memory error, the
** handle is in a consistent state.
*/</comment>
<function><type><specifier>static</specifier> <name>LStream</name> <modifier>*</modifier></type><name>newprefile</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>LStream</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LStream</name> <operator>*</operator><operator>)</operator><call><name>lua_newuserdatauv</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LStream</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>closef</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>  <comment type="block">/* mark file handle as 'closed' */</comment>
  <expr_stmt><expr><call><name>luaL_setmetatable</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_FILEHANDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Calls the 'close' function from a file handle. The 'volatile' avoids
** a bug in some versions of the Clang compiler (e.g., clang 3.0 for
** 32 bits).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>aux_close</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>LStream</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>tolstream</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>lua_CFunction</name></type> <name>cf</name> <init>= <expr><name><name>p</name><operator>-&gt;</operator><name>closef</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>closef</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>  <comment type="block">/* mark stream as closed */</comment>
  <return>return <expr><call>(<modifier>*</modifier><name>cf</name>)<argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>  <comment type="block">/* close it */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>f_close</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* make sure argument is an open stream */</comment>
  <return>return <expr><call><name>aux_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>io_close</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>lua_isnone</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* no argument? */</comment>
    <expr_stmt><expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_REGISTRYINDEX</name></expr></argument>, <argument><expr><name>IO_OUTPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* use default output */</comment>
  <return>return <expr><call><name>f_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>f_gc</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>LStream</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>tolstream</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isclosed</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>f</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>aux_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* ignore closed and incompletely open files */</comment>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** function to close regular files
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>io_fclose</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>LStream</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>tolstream</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>luaL_fileresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>(</operator><name>res</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>LStream</name> <modifier>*</modifier></type><name>newfile</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>LStream</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>newprefile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>closef</name></name> <operator>=</operator> <operator>&amp;</operator><name>io_fclose</name></expr>;</expr_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>opencheck</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>LStream</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>newfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"cannot open file '%s' (%s)"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>io_open</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><call><name>luaL_checkstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name> <init>= <expr><call><name>luaL_optstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LStream</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>newfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>md</name> <init>= <expr><name>mode</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* to traverse/check mode */</comment>
  <expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>l_checkmode</name><argument_list>(<argument><expr><name>md</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"invalid mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>f</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>luaL_fileresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** function to close 'popen' files
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>io_pclose</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>LStream</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>tolstream</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <return>return <expr><call><name>luaL_execresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>l_pclose</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>io_popen</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><call><name>luaL_checkstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name> <init>= <expr><call><name>luaL_optstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LStream</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>newprefile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>l_checkmodep</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"invalid mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <call><name>l_popen</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>closef</name></name> <operator>=</operator> <operator>&amp;</operator><name>io_pclose</name></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>f</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>luaL_fileresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>io_tmpfile</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>LStream</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>newfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <call><name>tmpfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>f</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>luaL_fileresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>getiofile</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>findex</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>LStream</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_REGISTRYINDEX</name></expr></argument>, <argument><expr><name>findex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>LStream</name> <operator>*</operator><operator>)</operator><call><name>lua_touserdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>isclosed</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"default %s file is closed"</literal></expr></argument>, <argument><expr><name>findex</name> <operator>+</operator> <name>IOPREF_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>g_iofile</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lua_isnoneornil</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>filename</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>opencheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* check that it's a valid file handle */</comment>
      <expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_REGISTRYINDEX</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="block">/* return current value */</comment>
  <expr_stmt><expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_REGISTRYINDEX</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>io_input</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>g_iofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>IO_INPUT</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>io_output</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>g_iofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>IO_OUTPUT</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>io_readline</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
** maximum number of arguments to 'f:lines'/'io.lines' (it + 3 must fit
** in the limit for upvalues of a closure)
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXARGLINE</name></cpp:macro>	<cpp:value>250</cpp:value></cpp:define>

<comment type="block">/*
** Auxiliary function to create the iteration function for 'lines'.
** The iteration function is a closure over 'io_readline', with
** the following upvalues:
** 1) The file being read (first value in the stack)
** 2) the number of arguments to read
** 3) a boolean, true iff file has to be closed when finished ('toclose')
** *) a variable number of format arguments (rest of the stack)
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>aux_lines</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>toclose</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* number of arguments to read */</comment>
  <expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name> <operator>&lt;=</operator> <name>MAXARGLINE</name></expr></argument>, <argument><expr><name>MAXARGLINE</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"too many arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* file */</comment>
  <expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* number of arguments to read */</comment>
  <expr_stmt><expr><call><name>lua_pushboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>toclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* close/not close file when finished */</comment>
  <expr_stmt><expr><call><name>lua_rotate</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* move the three values to their positions */</comment>
  <expr_stmt><expr><call><name>lua_pushcclosure</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>io_readline</name></expr></argument>, <argument><expr><literal type="number">3</literal> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>f_lines</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* check that it's a valid file handle */</comment>
  <expr_stmt><expr><call><name>aux_lines</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Return an iteration function for 'io.lines'. If file has to be
** closed, also returns the file itself as a second result (to be
** closed as the state at the exit of a generic for).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>io_lines</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>toclose</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>lua_isnone</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* at least one argument */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>lua_isnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* no file name? */</comment>
    <expr_stmt><expr><call><name>lua_getfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_REGISTRYINDEX</name></expr></argument>, <argument><expr><name>IO_INPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* get default input */</comment>
    <expr_stmt><expr><call><name>lua_replace</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* put it at index 1 */</comment>
    <expr_stmt><expr><call><name>tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* check that it's a valid file handle */</comment>
    <expr_stmt><expr><name>toclose</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* do not close it after iteration */</comment>
  </block_content>}</block></if>
  <else>else <block>{<block_content>  <comment type="block">/* open a new file */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><call><name>luaL_checkstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>opencheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_replace</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* put file at index 1 */</comment>
    <expr_stmt><expr><name>toclose</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* close it after iteration */</comment>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>aux_lines</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>toclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* push iteration function */</comment>
  <if_stmt><if>if <condition>(<expr><name>toclose</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* state */</comment>
    <expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* control */</comment>
    <expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* file is the to-be-closed variable (4th result) */</comment>
    <return>return <expr><literal type="number">4</literal></expr>;</return>
  </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** {======================================================
** READ
** =======================================================
*/</comment>


<comment type="block">/* maximum length of a numeral */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>L_MAXLENNUM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_MAXLENNUM</name></cpp:macro>     <cpp:value>200</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* auxiliary structure used by 'read_number' */</comment>
<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>  <comment type="block">/* file being read */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>  <comment type="block">/* current character (look ahead) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>  <comment type="block">/* number of elements in buffer 'buff' */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><name>L_MAXLENNUM</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* +1 for ending '\0' */</comment>
}</block></struct></type> <name>RN</name>;</typedef>


<comment type="block">/*
** Add current char to buffer (if not out of space) and read next one
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nextc</name> <parameter_list>(<parameter><decl><type><name>RN</name> <modifier>*</modifier></type><name>rn</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>rn</name><operator>-&gt;</operator><name>n</name></name> <operator>&gt;=</operator> <name>L_MAXLENNUM</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* buffer overflow? */</comment>
    <expr_stmt><expr><name><name>rn</name><operator>-&gt;</operator><name>buff</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>  <comment type="block">/* invalidate result */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* fail */</comment>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>rn</name><operator>-&gt;</operator><name>buff</name><index>[<expr><name><name>rn</name><operator>-&gt;</operator><name>n</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>rn</name><operator>-&gt;</operator><name>c</name></name></expr>;</expr_stmt>  <comment type="block">/* save current char */</comment>
    <expr_stmt><expr><name><name>rn</name><operator>-&gt;</operator><name>c</name></name> <operator>=</operator> <call><name>l_getc</name><argument_list>(<argument><expr><name><name>rn</name><operator>-&gt;</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* read next one */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Accept current char if it is in 'set' (of size 2)
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>test2</name> <parameter_list>(<parameter><decl><type><name>RN</name> <modifier>*</modifier></type><name>rn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>set</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>rn</name><operator>-&gt;</operator><name>c</name></name> <operator>==</operator> <name><name>set</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>rn</name><operator>-&gt;</operator><name>c</name></name> <operator>==</operator> <name><name>set</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>nextc</name><argument_list>(<argument><expr><name>rn</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Read a sequence of (hex)digits
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>readdigits</name> <parameter_list>(<parameter><decl><type><name>RN</name> <modifier>*</modifier></type><name>rn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hex</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><operator>(</operator><ternary><condition><expr><name>hex</name></expr> ?</condition><then> <expr><call><name>isxdigit</name><argument_list>(<argument><expr><name><name>rn</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>isdigit</name><argument_list>(<argument><expr><name><name>rn</name><operator>-&gt;</operator><name>c</name></name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>nextc</name><argument_list>(<argument><expr><name>rn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
  <return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Read a number: first reads a valid prefix of a numeral into a buffer.
** Then it calls 'lua_stringtonumber' to check whether the format is
** correct and to convert it to a Lua number.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>read_number</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>RN</name></type> <name>rn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>hex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>decp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>rn</name><operator>.</operator><name>f</name></name> <operator>=</operator> <name>f</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>rn</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>decp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>lua_getlocaledecpoint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* get decimal point from locale */</comment>
  <expr_stmt><expr><name><name>decp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>  <comment type="block">/* always accept a dot */</comment>
  <expr_stmt><expr><call><name>l_lockfile</name><argument_list>(<argument><expr><name><name>rn</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <do>do <block>{<block_content> <expr_stmt><expr><name><name>rn</name><operator>.</operator><name>c</name></name> <operator>=</operator> <call><name>l_getc</name><argument_list>(<argument><expr><name><name>rn</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block> while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><name><name>rn</name><operator>.</operator><name>c</name></name></expr></argument>)</argument_list></call></expr>)</condition>;</do>  <comment type="block">/* skip spaces */</comment>
  <expr_stmt><expr><call><name>test2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rn</name></expr></argument>, <argument><expr><literal type="string">"-+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* optional sign */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>test2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rn</name></expr></argument>, <argument><expr><literal type="string">"00"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>test2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rn</name></expr></argument>, <argument><expr><literal type="string">"xX"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>hex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* numeral is hexadecimal */</comment>
    <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* count initial '0' as a valid digit */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>count</name> <operator>+=</operator> <call><name>readdigits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rn</name></expr></argument>, <argument><expr><name>hex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* integral part */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>test2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rn</name></expr></argument>, <argument><expr><name>decp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* decimal point? */</comment>
    <expr_stmt><expr><name>count</name> <operator>+=</operator> <call><name>readdigits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rn</name></expr></argument>, <argument><expr><name>hex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* fractional part */</comment>
  <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>test2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rn</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>hex</name></expr> ?</condition><then> <expr><literal type="string">"pP"</literal></expr> </then><else>: <expr><literal type="string">"eE"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* exponent mark? */</comment>
    <expr_stmt><expr><call><name>test2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rn</name></expr></argument>, <argument><expr><literal type="string">"-+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* exponent sign */</comment>
    <expr_stmt><expr><call><name>readdigits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* exponent digits */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>ungetc</name><argument_list>(<argument><expr><name><name>rn</name><operator>.</operator><name>c</name></name></expr></argument>, <argument><expr><name><name>rn</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* unread look-ahead char */</comment>
  <expr_stmt><expr><call><name>l_unlockfile</name><argument_list>(<argument><expr><name><name>rn</name><operator>.</operator><name>f</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rn</name><operator>.</operator><name>buff</name><index>[<expr><name><name>rn</name><operator>.</operator><name>n</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>  <comment type="block">/* finish string */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>lua_stringtonumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>rn</name><operator>.</operator><name>buff</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* is this a valid number? */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>  <comment type="block">/* ok */</comment>
  <else>else <block>{<block_content>  <comment type="block">/* invalid format */</comment>
   <expr_stmt><expr><call><name>lua_pushnil</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* "result" to be removed */</comment>
   <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* read fails */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>test_eof</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>getc</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>ungetc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* no-op when c == EOF */</comment>
  <expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>c</name> <operator>!=</operator> <name>EOF</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>read_line</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>chop</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>luaL_Buffer</name></type> <name>b</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaL_buffinit</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <do>do <block>{<block_content>  <comment type="block">/* may need to read several chunks to get whole line */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buff</name> <init>= <expr><call><name>luaL_prepbuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* preallocate buffer space */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>l_lockfile</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* no memory errors can happen inside the lock */</comment>
    <while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>LUAL_BUFFERSIZE</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>=</operator> <call><name>l_getc</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>EOF</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>buff</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></while>  <comment type="block">/* read up to end of line or buffer limit */</comment>
    <expr_stmt><expr><call><name>l_unlockfile</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaL_addsize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block> while <condition>(<expr><name>c</name> <operator>!=</operator> <name>EOF</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition>;</do>  <comment type="block">/* repeat until end of line */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>chop</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* want a newline and have one? */</comment>
    <expr_stmt><expr><call><name>luaL_addchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* add ending newline to result */</comment>
  <expr_stmt><expr><call><name>luaL_pushresult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* close buffer */</comment>
  <comment type="block">/* return ok if read something (either a newline or something else) */</comment>
  <return>return <expr><operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <call><name>lua_rawlen</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>read_all</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>nr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>luaL_Buffer</name></type> <name>b</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaL_buffinit</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <do>do <block>{<block_content>  <comment type="block">/* read file in chunks of LUAL_BUFFERSIZE bytes */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>luaL_prepbuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>nr</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>LUAL_BUFFERSIZE</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaL_addsize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block> while <condition>(<expr><name>nr</name> <operator>==</operator> <name>LUAL_BUFFERSIZE</name></expr>)</condition>;</do>
  <expr_stmt><expr><call><name>luaL_pushresult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* close buffer */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>read_chars</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>nr</name></decl>;</decl_stmt>  <comment type="block">/* number of chars actually read */</comment>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>luaL_Buffer</name></type> <name>b</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaL_buffinit</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>luaL_prepbuffsize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* prepare buffer to read whole block */</comment>
  <expr_stmt><expr><name>nr</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* try to read 'n' chars */</comment>
  <expr_stmt><expr><call><name>luaL_addsize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaL_pushresult</name><argument_list>(<argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* close buffer */</comment>
  <return>return <expr><operator>(</operator><name>nr</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>  <comment type="block">/* true iff read something */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>g_read</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>first</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nargs</name> <init>= <expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>success</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* no arguments? */</comment>
    <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>read_line</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <name>first</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* to return 1 result */</comment>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <comment type="block">/* ensure stack space for all results and for auxlib's buffer */</comment>
    <expr_stmt><expr><call><name>luaL_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>nargs</name><operator>+</operator><name>LUA_MINSTACK</name></expr></argument>, <argument><expr><literal type="string">"too many arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <name>first</name></expr>;</init> <condition><expr><name>nargs</name><operator>--</operator> <operator>&amp;&amp;</operator> <name>success</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>lua_type</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LUA_TNUMBER</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>l</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><call><name>luaL_checkinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>success</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>l</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>test_eof</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>read_chars</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
      </block_content>}</block></if>
      <else>else <block>{<block_content>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>luaL_checkstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* skip optional '*' (for compatibility) */</comment>
        <switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>
          <case>case <expr><literal type="char">'n'</literal></expr>:</case>  <comment type="block">/* number */</comment>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>read_number</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          <case>case <expr><literal type="char">'l'</literal></expr>:</case>  <comment type="block">/* line */</comment>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>read_line</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          <case>case <expr><literal type="char">'L'</literal></expr>:</case>  <comment type="block">/* line with end-of-line */</comment>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <call><name>read_line</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          <case>case <expr><literal type="char">'a'</literal></expr>:</case>  <comment type="block">/* file */</comment>
            <expr_stmt><expr><call><name>read_all</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* read entire file */</comment>
            <expr_stmt><expr><name>success</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* always success */</comment>
            <break>break;</break>
          <default>default:</default>
            <return>return <expr><call><name>luaL_argerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"invalid format"</literal></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></switch>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>luaL_fileresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* remove last result */</comment>
    <expr_stmt><expr><call><name>luaL_pushfail</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* push nil instead */</comment>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>n</name> <operator>-</operator> <name>first</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>io_read</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>g_read</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>getiofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>IO_INPUT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>f_read</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>g_read</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Iteration function for 'lines'.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>io_readline</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>LStream</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>LStream</name> <operator>*</operator><operator>)</operator><call><name>lua_touserdata</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>lua_tointeger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>isclosed</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* file is already closed? */</comment>
    <return>return <expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"file is already closed"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>lua_settop</name><argument_list>(<argument><expr><name>L</name></expr></argument> , <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaL_checkstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"too many arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* push arguments to 'g_read' */</comment>
    <expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">3</literal> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>g_read</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* 'n' is number of results */</comment>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* should return at least a nil */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>lua_toboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* read at least one value? */</comment>
    <return>return <expr><name>n</name></expr>;</return></block_content></block></if>  <comment type="block">/* return them */</comment>
  <else>else <block>{<block_content>  <comment type="block">/* first result is false: EOF or error */</comment>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* is there error information? */</comment>
      <comment type="block">/* 2nd result is error message */</comment>
      <return>return <expr><call><name>luaL_error</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>lua_tostring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>lua_toboolean</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* generator created file? */</comment>
      <expr_stmt><expr><call><name>lua_settop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* clear stack */</comment>
      <expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>lua_upvalueindex</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* push file at index 1 */</comment>
      <expr_stmt><expr><call><name>aux_close</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* close it */</comment>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* }====================================================== */</comment>


<function><type><specifier>static</specifier> <name>int</name></type> <name>g_write</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nargs</name> <init>= <expr><call><name>lua_gettop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>nargs</name><operator>--</operator></expr>;</condition> <incr><expr><name>arg</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>lua_type</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LUA_TNUMBER</name></expr>)</condition> <block>{<block_content>
      <comment type="block">/* optimization: could be done exactly as for strings */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><ternary><condition><expr><call><name>lua_isinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>
                ?</condition><then> <expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>LUA_INTEGER_FMT</name></expr></argument>,
                             <argument><expr><operator>(</operator><name>LUAI_UACINT</name><operator>)</operator><call><name>lua_tointeger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>
                </then><else>: <expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>LUA_NUMBER_FMT</name></expr></argument>,
                             <argument><expr><operator>(</operator><name>LUAI_UACNUMBER</name><operator>)</operator><call><name>lua_tonumber</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <name>status</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
      <decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>luaL_checklstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>status</name> <operator>=</operator> <name>status</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>fwrite</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>l</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><name>status</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>  <comment type="block">/* file handle already on stack top */</comment>
  <else>else<block type="pseudo"><block_content> <return>return <expr><call><name>luaL_fileresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>io_write</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>g_write</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>getiofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>IO_OUTPUT</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>f_write</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* push file at the stack top (to be returned) */</comment>
  <return>return <expr><call><name>g_write</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>f_seek</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>mode</name><index>[]</index></name> <init>= <expr><block>{<expr><name>SEEK_SET</name></expr>, <expr><name>SEEK_CUR</name></expr>, <expr><name>SEEK_END</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>modenames</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"set"</literal></expr>, <expr><literal type="string">"cur"</literal></expr>, <expr><literal type="string">"end"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><call><name>luaL_checkoption</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"cur"</literal></expr></argument>, <argument><expr><name>modenames</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Integer</name></type> <name>p3</name> <init>= <expr><call><name>luaL_optinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>l_seeknum</name></type> <name>offset</name> <init>= <expr><operator>(</operator><name>l_seeknum</name><operator>)</operator><name>p3</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaL_argcheck</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>(</operator><name>lua_Integer</name><operator>)</operator><name>offset</name> <operator>==</operator> <name>p3</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>,
                  <argument><expr><literal type="string">"not an integer in proper range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>l_fseek</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name><name>mode</name><index>[<expr><name>op</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>op</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>luaL_fileresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>  <comment type="block">/* error */</comment>
  <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>lua_pushinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>(</operator><name>lua_Integer</name><operator>)</operator><call><name>l_ftell</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>f_setvbuf</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>mode</name><index>[]</index></name> <init>= <expr><block>{<expr><name>_IONBF</name></expr>, <expr><name>_IOFBF</name></expr>, <expr><name>_IOLBF</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>modenames</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"no"</literal></expr>, <expr><literal type="string">"full"</literal></expr>, <expr><literal type="string">"line"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><call><name>luaL_checkoption</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>modenames</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Integer</name></type> <name>sz</name> <init>= <expr><call><name>luaL_optinteger</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>LUAL_BUFFERSIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>mode</name><index>[<expr><name>op</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>luaL_fileresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name></type> <name>io_flush</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>luaL_fileresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>fflush</name><argument_list>(<argument><expr><call><name>getiofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>IO_OUTPUT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>f_flush</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>luaL_fileresult</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>fflush</name><argument_list>(<argument><expr><call><name>tofile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** functions for 'io' library
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>luaL_Reg</name></type> <name><name>iolib</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{<expr><literal type="string">"close"</literal></expr>, <expr><name>io_close</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"flush"</literal></expr>, <expr><name>io_flush</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"input"</literal></expr>, <expr><name>io_input</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"lines"</literal></expr>, <expr><name>io_lines</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"open"</literal></expr>, <expr><name>io_open</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"output"</literal></expr>, <expr><name>io_output</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"popen"</literal></expr>, <expr><name>io_popen</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"read"</literal></expr>, <expr><name>io_read</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"tmpfile"</literal></expr>, <expr><name>io_tmpfile</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"type"</literal></expr>, <expr><name>io_type</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"write"</literal></expr>, <expr><name>io_write</name></expr>}</block></expr>,
  <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/*
** methods for file handles
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>luaL_Reg</name></type> <name><name>meth</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{<expr><literal type="string">"read"</literal></expr>, <expr><name>f_read</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"write"</literal></expr>, <expr><name>f_write</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"lines"</literal></expr>, <expr><name>f_lines</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"flush"</literal></expr>, <expr><name>f_flush</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"seek"</literal></expr>, <expr><name>f_seek</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"close"</literal></expr>, <expr><name>f_close</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"setvbuf"</literal></expr>, <expr><name>f_setvbuf</name></expr>}</block></expr>,
  <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/*
** metamethods for file handles
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>luaL_Reg</name></type> <name><name>metameth</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{<expr><literal type="string">"__index"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>,  <comment type="block">/* place holder */</comment>
  <expr><block>{<expr><literal type="string">"__gc"</literal></expr>, <expr><name>f_gc</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"__close"</literal></expr>, <expr><name>f_gc</name></expr>}</block></expr>,
  <expr><block>{<expr><literal type="string">"__tostring"</literal></expr>, <expr><name>f_tostring</name></expr>}</block></expr>,
  <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>void</name></type> <name>createmeta</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>luaL_newmetatable</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_FILEHANDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* metatable for file handles */</comment>
  <expr_stmt><expr><call><name>luaL_setfuncs</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>metameth</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* add metamethods to new metatable */</comment>
  <expr_stmt><expr><call><name>luaL_newlibtable</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>meth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* create method table */</comment>
  <expr_stmt><expr><call><name>luaL_setfuncs</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>meth</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* add file methods to method table */</comment>
  <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"__index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* metatable.__index = method table */</comment>
  <expr_stmt><expr><call><name>lua_pop</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* pop metatable */</comment>
</block_content>}</block></function>


<comment type="block">/*
** function to (not) close the standard files stdin, stdout, and stderr
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>io_noclose</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>LStream</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>tolstream</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>closef</name></name> <operator>=</operator> <operator>&amp;</operator><name>io_noclose</name></expr>;</expr_stmt>  <comment type="block">/* keep file opened */</comment>
  <expr_stmt><expr><call><name>luaL_pushfail</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_pushliteral</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"cannot close standard file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>createstdfile</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>LStream</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>newprefile</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>closef</name></name> <operator>=</operator> <operator>&amp;</operator><name>io_noclose</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>k</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>lua_pushvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>LUA_REGISTRYINDEX</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* add file to registry */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>lua_setfield</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* add file to module */</comment>
</block_content>}</block></function>


<function><type><name>LUAMOD_API</name> <name>int</name></type> <name>luaopen_io</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>luaL_newlib</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>iolib</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* new module */</comment>
  <expr_stmt><expr><call><name>createmeta</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* create (and set) default files */</comment>
  <expr_stmt><expr><call><name>createstdfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>stdin</name></expr></argument>, <argument><expr><name>IO_INPUT</name></expr></argument>, <argument><expr><literal type="string">"stdin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>createstdfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>IO_OUTPUT</name></expr></argument>, <argument><expr><literal type="string">"stdout"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>createstdfile</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"stderr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

</unit>
