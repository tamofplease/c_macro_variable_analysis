<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/lua/lobject.c"><comment type="block">/*
** $Id: lobject.c $
** Some generic functions over Lua objects
** See Copyright Notice in lua.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lobject_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lprefix.h"</cpp:file></cpp:include>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;locale.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lua.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lctype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ldebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ldo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lstate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lstring.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lvm.h"</cpp:file></cpp:include>


<comment type="block">/*
** Computes ceil(log2(x))
*/</comment>
<function><type><name>int</name></type> <name>luaO_ceillog2</name> <parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>lu_byte</name></type> <name><name>log_2</name><index>[<expr><literal type="number">256</literal></expr>]</index></name> <init>= <expr><block>{  <comment type="block">/* log_2[i] = ceil(log2(i - 1)) */</comment>
    <expr><literal type="number">0</literal></expr>,<expr><literal type="number">1</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">2</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">3</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">4</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,<expr><literal type="number">5</literal></expr>,
    <expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,<expr><literal type="number">6</literal></expr>,
    <expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,
    <expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,<expr><literal type="number">7</literal></expr>,
    <expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,
    <expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,
    <expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,
    <expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>,<expr><literal type="number">8</literal></expr>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>x</name><operator>--</operator></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>x</name> <operator>&gt;=</operator> <literal type="number">256</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>l</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt> <expr_stmt><expr><name>x</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt> </block_content>}</block></while>
  <return>return <expr><name>l</name> <operator>+</operator> <name><name>log_2</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>lua_Integer</name></type> <name>intarith</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>lua_Integer</name></type> <name>v1</name></decl></parameter>,
                                                   <parameter><decl><type><name>lua_Integer</name></type> <name>v2</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LUA_OPADD</name></expr>:</case> <return>return <expr><call><name>intop</name><argument_list>(<argument><expr><operator>+</operator></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_OPSUB</name></expr>:</case><return>return <expr><call><name>intop</name><argument_list>(<argument><expr><operator>-</operator></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_OPMUL</name></expr>:</case><return>return <expr><call><name>intop</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_OPMOD</name></expr>:</case> <return>return <expr><call><name>luaV_mod</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_OPIDIV</name></expr>:</case> <return>return <expr><call><name>luaV_idiv</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_OPBAND</name></expr>:</case> <return>return <expr><call><name>intop</name><argument_list>(<argument><expr><operator>&amp;</operator></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_OPBOR</name></expr>:</case> <return>return <expr><call><name>intop</name><argument_list>(<argument><expr><operator>|</operator></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_OPBXOR</name></expr>:</case> <return>return <expr><call><name>intop</name><argument_list>(<argument><expr><operator>^</operator></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_OPSHL</name></expr>:</case> <return>return <expr><call><name>luaV_shiftl</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_OPSHR</name></expr>:</case> <return>return <expr><call><name>luaV_shiftl</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><operator>-</operator><name>v2</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_OPUNM</name></expr>:</case> <return>return <expr><call><name>intop</name><argument_list>(<argument><expr><operator>-</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_OPBNOT</name></expr>:</case> <return>return <expr><call><name>intop</name><argument_list>(<argument><expr><operator>^</operator></expr></argument>, <argument><expr><operator>~</operator><call><name>l_castS2U</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</return>
    <default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>lua_Number</name></type> <name>numarith</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>lua_Number</name></type> <name>v1</name></decl></parameter>,
                                                  <parameter><decl><type><name>lua_Number</name></type> <name>v2</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LUA_OPADD</name></expr>:</case> <return>return <expr><call><name>luai_numadd</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_OPSUB</name></expr>:</case> <return>return <expr><call><name>luai_numsub</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_OPMUL</name></expr>:</case> <return>return <expr><call><name>luai_nummul</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_OPDIV</name></expr>:</case> <return>return <expr><call><name>luai_numdiv</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_OPPOW</name></expr>:</case> <return>return <expr><call><name>luai_numpow</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_OPIDIV</name></expr>:</case> <return>return <expr><call><name>luai_numidiv</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_OPUNM</name></expr>:</case> <return>return <expr><call><name>luai_numunm</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>LUA_OPMOD</name></expr>:</case> <return>return <expr><call><name>luaV_modf</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>v1</name></expr></argument>, <argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr>;</return>
    <default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>luaO_rawarith</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>,
                   <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>LUA_OPBAND</name></expr>:</case> <case>case <expr><name>LUA_OPBOR</name></expr>:</case> <case>case <expr><name>LUA_OPBXOR</name></expr>:</case>
    <case>case <expr><name>LUA_OPSHL</name></expr>:</case> <case>case <expr><name>LUA_OPSHR</name></expr>:</case>
    <case>case <expr><name>LUA_OPBNOT</name></expr>:</case> <block>{<block_content>  <comment type="block">/* operate only on integers */</comment>
      <decl_stmt><decl><type><name>lua_Integer</name></type> <name>i1</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>lua_Integer</name></type> <name>i2</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>tointegerns</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tointegerns</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><call><name>intarith</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>i1</name></expr></argument>, <argument><expr><name>i2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>  <comment type="block">/* fail */</comment>
    </block_content>}</block>
    <case>case <expr><name>LUA_OPDIV</name></expr>:</case> <case>case <expr><name>LUA_OPPOW</name></expr>:</case> <block>{<block_content>  <comment type="block">/* operate only on floats */</comment>
      <decl_stmt><decl><type><name>lua_Number</name></type> <name>n1</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>lua_Number</name></type> <name>n2</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>tonumberns</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tonumberns</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>setfltvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><call><name>numarith</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>  <comment type="block">/* fail */</comment>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>  <comment type="block">/* other operations */</comment>
      <decl_stmt><decl><type><name>lua_Number</name></type> <name>n1</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>lua_Number</name></type> <name>n2</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>ttisinteger</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ttisinteger</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><call><name>intarith</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><call><name>ivalue</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ivalue</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><call><name>tonumberns</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tonumberns</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>setfltvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><call><name>numarith</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
      </block_content>}</block></if>
      <else>else<block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>  <comment type="block">/* fail */</comment>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>luaO_arith</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>,
                 <parameter><decl><type><name>StkId</name></type> <name>res</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>luaO_rawarith</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <comment type="block">/* could not perform raw operation; try metamethod */</comment>
    <expr_stmt><expr><call><name>luaT_trybinTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><call><name>cast</name><argument_list>(<argument><expr><name>TMS</name></expr></argument>, <argument><expr><operator>(</operator><name>op</name> <operator>-</operator> <name>LUA_OPADD</name><operator>)</operator> <operator>+</operator> <name>TM_ADD</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>luaO_hexavalue</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>lisdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content> <return>return <expr><operator>(</operator><call><name>ltolower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="char">'a'</literal><operator>)</operator> <operator>+</operator> <literal type="number">10</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>isneg</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content> <expr_stmt><expr><operator>(</operator><operator>*</operator><name>s</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt> <return>return <expr><literal type="number">1</literal></expr>;</return> </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>*</operator><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>(</operator><operator>*</operator><name>s</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
** {==================================================================
** Lua's implementation for 'lua_strx2number'
** ===================================================================
*/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>lua_strx2number</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/* maximum number of significant digits to read (to avoid overflows
   even with single floats) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXSIGDIG</name></cpp:macro>	<cpp:value>30</cpp:value></cpp:define>

<comment type="block">/*
** convert a hexadecimal numeric string to a number, following
** C99 specification for 'strtod'
*/</comment>
<function><type><specifier>static</specifier> <name>lua_Number</name></type> <name>lua_strx2number</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>dot</name> <init>= <expr><call><name>lua_getlocaledecpoint</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_Number</name></type> <name>r</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* result (accumulator) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>sigdig</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* number of significant digits */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nosigdig</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* number of non-significant digits */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* exponent correction */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>neg</name></decl>;</decl_stmt>  <comment type="block">/* 1 if number is negative */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>hasdot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* true after seen a dot */</comment>
  <expr_stmt><expr><operator>*</operator><name>endptr</name> <operator>=</operator> <call><name>cast_charp</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* nothing is valid yet */</comment>
  <while>while <condition>(<expr><call><name>lisspace</name><argument_list>(<argument><expr><call><name>cast_uchar</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>  <comment type="block">/* skip initial spaces */</comment>
  <expr_stmt><expr><name>neg</name> <operator>=</operator> <call><name>isneg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* check sign */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'x'</literal> <operator>||</operator> <operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'X'</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* check '0x' */</comment>
    <return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* invalid format (no '0x') */</comment>
  <for>for <control>(<init><expr><name>s</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</init> <condition>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>  <comment type="block">/* skip '0x' and read numeral */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>dot</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>hasdot</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if>  <comment type="block">/* second dot? stop loop */</comment>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>hasdot</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>lisxdigit</name><argument_list>(<argument><expr><call><name>cast_uchar</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>sigdig</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* non-significant digit (zero)? */</comment>
        <expr_stmt><expr><name>nosigdig</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><operator>++</operator><name>sigdig</name> <operator>&lt;=</operator> <name>MAXSIGDIG</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* can read it without overflow? */</comment>
          <expr_stmt><expr><name>r</name> <operator>=</operator> <operator>(</operator><name>r</name> <operator>*</operator> <call><name>cast_num</name><argument_list>(<argument><expr><literal type="number">16.0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator> <call><name>luaO_hexavalue</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>e</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* too many digits; ignore, but still count for exponent */</comment>
      <if_stmt><if>if <condition>(<expr><name>hasdot</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>e</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* decimal digit? correct exponent */</comment>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content> <break>break;</break></block_content></block></else></if_stmt>  <comment type="block">/* neither a dot nor a digit */</comment>
  </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><name>nosigdig</name> <operator>+</operator> <name>sigdig</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* no digits? */</comment>
    <return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* invalid format */</comment>
  <expr_stmt><expr><operator>*</operator><name>endptr</name> <operator>=</operator> <call><name>cast_charp</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* valid up to here */</comment>
  <expr_stmt><expr><name>e</name> <operator>*=</operator> <literal type="number">4</literal></expr>;</expr_stmt>  <comment type="block">/* each digit multiplies/divides value by 2^4 */</comment>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'p'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'P'</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* exponent part? */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>exp1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* exponent value */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>neg1</name></decl>;</decl_stmt>  <comment type="block">/* exponent sign */</comment>
    <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* skip 'p' */</comment>
    <expr_stmt><expr><name>neg1</name> <operator>=</operator> <call><name>isneg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* sign */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lisdigit</name><argument_list>(<argument><expr><call><name>cast_uchar</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* invalid; must have at least one digit */</comment>
    <while>while <condition>(<expr><call><name>lisdigit</name><argument_list>(<argument><expr><call><name>cast_uchar</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* read exponent */</comment>
      <expr_stmt><expr><name>exp1</name> <operator>=</operator> <name>exp1</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>*</operator><operator>(</operator><name>s</name><operator>++</operator><operator>)</operator> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></while>
    <if_stmt><if>if <condition>(<expr><name>neg1</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>exp1</name> <operator>=</operator> <operator>-</operator><name>exp1</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>e</name> <operator>+=</operator> <name>exp1</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>endptr</name> <operator>=</operator> <call><name>cast_charp</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* valid up to here */</comment>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>neg</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>r</name> <operator>=</operator> <operator>-</operator><name>r</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><call><call><name>l_mathop</name><argument_list>(<argument><expr><name>ldexp</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* }====================================================== */</comment>


<comment type="block">/* maximum length of a numeral to be converted to a number */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name> <argument_list>(<argument><expr><name>L_MAXLENNUM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_MAXLENNUM</name></cpp:macro>	<cpp:value>200</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
** Convert string 's' to a Lua number (put in 'result'). Return NULL on
** fail or the address of the ending '\0' on success. ('mode' == 'x')
** means a hexadecimal numeral.
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>l_str2dloc</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>lua_Number</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>mode</name> <operator>==</operator> <literal type="char">'x'</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>lua_strx2number</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>  <comment type="block">/* try to convert */</comment>
                          </then><else>: <expr><call><name>lua_str2number</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* nothing recognized? */</comment>
  <while>while <condition>(<expr><call><name>lisspace</name><argument_list>(<argument><expr><call><name>cast_uchar</name><argument_list>(<argument><expr><operator>*</operator><name>endptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>  <comment type="block">/* skip trailing spaces */</comment>
  <return>return <expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>endptr</name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator></expr> ?</condition><then> <expr><name>endptr</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>  <comment type="block">/* OK iff no trailing chars */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Convert string 's' to a Lua number (put in 'result') handling the
** current locale.
** This function accepts both the current locale or a dot as the radix
** mark. If the conversion fails, it may mean number has a dot but
** locale accepts something else. In that case, the code copies 's'
** to a buffer (because 's' is read-only), changes the dot to the
** current locale radix mark, and tries to convert again.
** The variable 'mode' checks for special characters in the string:
** - 'n' means 'inf' or 'nan' (which should be rejected)
** - 'x' means a hexadecimal numeral
** - '.' just optimizes the search for the common case (no special chars)
*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>l_str2d</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>lua_Number</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pmode</name> <init>= <expr><call><name>strpbrk</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">".xXnN"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* look for special chars */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr><ternary><condition><expr><name>pmode</name></expr> ?</condition><then> <expr><call><name>ltolower</name><argument_list>(<argument><expr><call><name>cast_uchar</name><argument_list>(<argument><expr><operator>*</operator><name>pmode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'n'</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* reject 'inf' and 'nan' */</comment>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>endptr</name> <operator>=</operator> <call><name>l_str2dloc</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* try to convert */</comment>
  <if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* failed? may be a different locale */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><name>L_MAXLENNUM</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pdot</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>L_MAXLENNUM</name> <operator>||</operator> <name>pdot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* string too long or no dot; fail */</comment>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* copy string to buffer */</comment>
    <expr_stmt><expr><name><name>buff</name><index>[<expr><name>pdot</name> <operator>-</operator> <name>s</name></expr>]</index></name> <operator>=</operator> <call><name>lua_getlocaledecpoint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* correct decimal point */</comment>
    <expr_stmt><expr><name>endptr</name> <operator>=</operator> <call><name>l_str2dloc</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* try again */</comment>
    <if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>s</name> <operator>+</operator> <operator>(</operator><name>endptr</name> <operator>-</operator> <name>buff</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* make relative to 's' */</comment>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>endptr</name></expr>;</return>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXBY10</name></cpp:macro>		<cpp:value>cast(lua_Unsigned, LUA_MAXINTEGER / 10)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXLASTD</name></cpp:macro>	<cpp:value>cast_int(LUA_MAXINTEGER % 10)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>l_str2int</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>lua_Integer</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_Unsigned</name></type> <name>a</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>empty</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>neg</name></decl>;</decl_stmt>
  <while>while <condition>(<expr><call><name>lisspace</name><argument_list>(<argument><expr><call><name>cast_uchar</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>  <comment type="block">/* skip initial spaces */</comment>
  <expr_stmt><expr><name>neg</name> <operator>=</operator> <call><name>isneg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator>
      <operator>(</operator><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'x'</literal> <operator>||</operator> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'X'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* hex? */</comment>
    <expr_stmt><expr><name>s</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>  <comment type="block">/* skip '0x' */</comment>
    <for>for <control>(<init>;</init> <condition><expr><call><name>lisxdigit</name><argument_list>(<argument><expr><call><name>cast_uchar</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <call><name>luaO_hexavalue</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>empty</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if>
  <else>else <block>{<block_content>  <comment type="block">/* decimal */</comment>
    <for>for <control>(<init>;</init> <condition><expr><call><name>lisdigit</name><argument_list>(<argument><expr><call><name>cast_uchar</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>d</name> <init>= <expr><operator>*</operator><name>s</name> <operator>-</operator> <literal type="char">'0'</literal></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>a</name> <operator>&gt;=</operator> <name>MAXBY10</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>a</name> <operator>&gt;</operator> <name>MAXBY10</name> <operator>||</operator> <name>d</name> <operator>&gt;</operator> <name>MAXLASTD</name> <operator>+</operator> <name>neg</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* overflow? */</comment>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* do not accept it (as integer) */</comment>
      <expr_stmt><expr><name>a</name> <operator>=</operator> <name>a</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <name>d</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>empty</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
  <while>while <condition>(<expr><call><name>lisspace</name><argument_list>(<argument><expr><call><name>cast_uchar</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>  <comment type="block">/* skip trailing spaces */</comment>
  <if_stmt><if>if <condition>(<expr><name>empty</name> <operator>||</operator> <operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if>  <comment type="block">/* something wrong in the numeral */</comment>
  <else>else <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>l_castU2S</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>neg</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0u</literal> <operator>-</operator> <name>a</name></expr> </then><else>: <expr><name>a</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>s</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>luaO_str2num</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_Integer</name></type> <name>i</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>lua_Number</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>e</name> <operator>=</operator> <call><name>l_str2int</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* try as an integer */</comment>
    <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name>e</name> <operator>=</operator> <call><name>l_str2d</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* else try as a float */</comment>
    <expr_stmt><expr><call><name>setfltvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>  <comment type="block">/* conversion failed */</comment>
  <return>return <expr><operator>(</operator><name>e</name> <operator>-</operator> <name>s</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</return>  <comment type="block">/* success; return string size */</comment>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>luaO_utf8esc</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* number of bytes put in buffer (backwards) */</comment>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>x</name> <operator>&lt;=</operator> <literal type="number">0x7FFFFFFFu</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* ascii? */</comment>
    <expr_stmt><expr><name><name>buff</name><index>[<expr><name>UTF8BUFFSZ</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>cast_char</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else <block>{<block_content>  <comment type="block">/* need continuation bytes */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>mfb</name> <init>= <expr><literal type="number">0x3f</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* maximum that fits in first byte */</comment>
    <do>do <block>{<block_content>  <comment type="block">/* add continuation bytes */</comment>
      <expr_stmt><expr><name><name>buff</name><index>[<expr><name>UTF8BUFFSZ</name> <operator>-</operator> <operator>(</operator><name>n</name><operator>++</operator><operator>)</operator></expr>]</index></name> <operator>=</operator> <call><name>cast_char</name><argument_list>(<argument><expr><literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>x</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>x</name> <operator>&gt;&gt;=</operator> <literal type="number">6</literal></expr>;</expr_stmt>  <comment type="block">/* remove added bits */</comment>
      <expr_stmt><expr><name>mfb</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* now there is one less bit available in first byte */</comment>
    </block_content>}</block> while <condition>(<expr><name>x</name> <operator>&gt;</operator> <name>mfb</name></expr>)</condition>;</do>  <comment type="block">/* still needs continuation byte? */</comment>
    <expr_stmt><expr><name><name>buff</name><index>[<expr><name>UTF8BUFFSZ</name> <operator>-</operator> <name>n</name></expr>]</index></name> <operator>=</operator> <call><name>cast_char</name><argument_list>(<argument><expr><operator>(</operator><operator>~</operator><name>mfb</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* add first byte */</comment>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Maximum length of the conversion of a number to a string. Must be
** enough to accommodate both LUA_INTEGER_FMT and LUA_NUMBER_FMT.
** (For a long long int, this is 19 digits plus a sign and a final '\0',
** adding to 21. For a long double, it can go to a sign, 33 digits,
** the dot, an exponent letter, an exponent sign, 5 exponent digits,
** and a final '\0', adding to 43.)
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXNUMBER2STR</name></cpp:macro>	<cpp:value>44</cpp:value></cpp:define>


<comment type="block">/*
** Convert a number object to a string, adding it to a buffer
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>tostringbuff</name> <parameter_list>(<parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ttisnumber</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>ttisinteger</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>lua_integer2str</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>MAXNUMBER2STR</name></expr></argument>, <argument><expr><call><name>ivalue</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else <block>{<block_content>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>lua_number2str</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>MAXNUMBER2STR</name></expr></argument>, <argument><expr><call><name>fltvalue</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>buff</name><index>[<expr><call><name>strspn</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="string">"-0123456789"</literal></expr></argument>)</argument_list></call></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* looks like an int? */</comment>
      <expr_stmt><expr><name><name>buff</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>lua_getlocaledecpoint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>buff</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>  <comment type="block">/* adds '.0' to result */</comment>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Convert a number object to a Lua string, replacing the value at 'obj'
*/</comment>
<function><type><name>void</name></type> <name>luaO_tostring</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buff</name><index>[<expr><name>MAXNUMBER2STR</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>tostringbuff</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setsvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>luaS_newlstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<comment type="block">/*
** {==================================================================
** 'luaO_pushvfstring'
** ===================================================================
*/</comment>

<comment type="block">/* size for buffer space used by 'luaO_pushvfstring' */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUFVFS</name></cpp:macro>		<cpp:value>200</cpp:value></cpp:define>

<comment type="block">/* buffer used by 'luaO_pushvfstring' */</comment>
<typedef>typedef <type><struct>struct <name>BuffFS</name> <block>{
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pushed</name></decl>;</decl_stmt>  <comment type="block">/* number of string pieces already on the stack */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>blen</name></decl>;</decl_stmt>  <comment type="block">/* length of partial string in 'space' */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>space</name><index>[<expr><name>BUFVFS</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* holds last part of the result */</comment>
}</block></struct></type> <name>BuffFS</name>;</typedef>


<comment type="block">/*
** Push given string to the stack, as part of the buffer, and
** join the partial strings in the stack into one.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>pushstr</name> <parameter_list>(<parameter><decl><type><name>BuffFS</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>l</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>buff</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>setsvalue2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>, <argument><expr><call><name>luaS_newlstr</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* may use one extra slot */</comment>
  <expr_stmt><expr><name><name>buff</name><operator>-&gt;</operator><name>pushed</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaV_concat</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>buff</name><operator>-&gt;</operator><name>pushed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* join partial results into one */</comment>
  <expr_stmt><expr><name><name>buff</name><operator>-&gt;</operator><name>pushed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** empty the buffer space into the stack
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>clearbuff</name> <parameter_list>(<parameter><decl><type><name>BuffFS</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>pushstr</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name><name>buff</name><operator>-&gt;</operator><name>space</name></name></expr></argument>, <argument><expr><name><name>buff</name><operator>-&gt;</operator><name>blen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* push buffer contents */</comment>
  <expr_stmt><expr><name><name>buff</name><operator>-&gt;</operator><name>blen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* space now is empty */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Get a space of size 'sz' in the buffer. If buffer has not enough
** space, empty it. 'sz' must fit in an empty buffer.
*/</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>getbuff</name> <parameter_list>(<parameter><decl><type><name>BuffFS</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>buff</name><operator>-&gt;</operator><name>blen</name></name> <operator>&lt;=</operator> <name>BUFVFS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>sz</name> <operator>&lt;=</operator> <name>BUFVFS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&gt;</operator> <name>BUFVFS</name> <operator>-</operator> <name><name>buff</name><operator>-&gt;</operator><name>blen</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* not enough space? */</comment>
    <expr_stmt><expr><call><name>clearbuff</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name><name>buff</name><operator>-&gt;</operator><name>space</name></name> <operator>+</operator> <name><name>buff</name><operator>-&gt;</operator><name>blen</name></name></expr>;</return>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>addsize</name><parameter_list>(<parameter><type><name>b</name></type></parameter>,<parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((b)-&gt;blen += (sz))</cpp:value></cpp:define>


<comment type="block">/*
** Add 'str' to the buffer. If string is larger than the buffer space,
** push the string directly to the stack.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>addstr2buff</name> <parameter_list>(<parameter><decl><type><name>BuffFS</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>slen</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&lt;=</operator> <name>BUFVFS</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* does string fit into buffer? */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>bf</name> <init>= <expr><call><name>getbuff</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><call><name>cast_int</name><argument_list>(<argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>bf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* add string to buffer */</comment>
    <expr_stmt><expr><call><name>addsize</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><call><name>cast_int</name><argument_list>(<argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>  <comment type="block">/* string larger than buffer */</comment>
    <expr_stmt><expr><call><name>clearbuff</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* string comes after buffer's content */</comment>
    <expr_stmt><expr><call><name>pushstr</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* push string */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Add a number to the buffer.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>addnum2buff</name> <parameter_list>(<parameter><decl><type><name>BuffFS</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>TValue</name> <modifier>*</modifier></type><name>num</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>numbuff</name> <init>= <expr><call><name>getbuff</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>MAXNUMBER2STR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>tostringbuff</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>numbuff</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* format number into 'numbuff' */</comment>
  <expr_stmt><expr><call><name>addsize</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** this function handles only '%d', '%c', '%f', '%p', '%s', and '%%'
   conventional formats, plus Lua-specific '%I' and '%U'
*/</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>luaO_pushvfstring</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>argp</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BuffFS</name></type> <name>buff</name></decl>;</decl_stmt>  <comment type="block">/* holds last part of the result */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>  <comment type="block">/* points to next '%' */</comment>
  <expr_stmt><expr><name><name>buff</name><operator>.</operator><name>pushed</name></name> <operator>=</operator> <name><name>buff</name><operator>.</operator><name>blen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>buff</name><operator>.</operator><name>L</name></name> <operator>=</operator> <name>L</name></expr>;</expr_stmt>
  <while>while <condition>(<expr><operator>(</operator><name>e</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>addstr2buff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>e</name> <operator>-</operator> <name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* add 'fmt' up to '%' */</comment>
    <switch>switch <condition>(<expr><operator>*</operator><operator>(</operator><name>e</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>  <comment type="block">/* conversion specifier */</comment>
      <case>case <expr><literal type="char">'s'</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* zero-terminated string */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>s</name> <operator>=</operator> <literal type="string">"(null)"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>addstr2buff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'c'</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* an 'int' as a character */</comment>
        <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><call><name>cast_uchar</name><argument_list>(<argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>addstr2buff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'d'</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* an 'int' */</comment>
        <decl_stmt><decl><type><name>TValue</name></type> <name>num</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addnum2buff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'I'</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* a 'lua_Integer' */</comment>
        <decl_stmt><decl><type><name>TValue</name></type> <name>num</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>setivalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><call><name>cast</name><argument_list>(<argument><expr><name>lua_Integer</name></expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>l_uacInt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addnum2buff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'f'</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* a 'lua_Number' */</comment>
        <decl_stmt><decl><type><name>TValue</name></type> <name>num</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>setfltvalue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>, <argument><expr><call><name>cast_num</name><argument_list>(<argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>l_uacNumber</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>addnum2buff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'p'</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* a pointer */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>sz</name> <init>= <expr><literal type="number">3</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">8</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* enough space for '%p' */</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>bf</name> <init>= <expr><call><name>getbuff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>lua_pointer2str</name><argument_list>(<argument><expr><name>bf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>addsize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'U'</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* a 'long' as a UTF-8 sequence */</comment>
        <decl_stmt><decl><type><name>char</name></type> <name><name>bf</name><index>[<expr><name>UTF8BUFFSZ</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>luaO_utf8esc</name><argument_list>(<argument><expr><name>bf</name></expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>addstr2buff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>, <argument><expr><name>bf</name> <operator>+</operator> <name>UTF8BUFFSZ</name> <operator>-</operator> <name>len</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'%'</literal></expr>:</case> <block>{<block_content>
        <expr_stmt><expr><call><name>addstr2buff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>, <argument><expr><literal type="string">"%"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default> <block>{<block_content>
        <expr_stmt><expr><call><name>luaG_runerror</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"invalid option '%%%c' to 'lua_pushfstring'"</literal></expr></argument>,
                         <argument><expr><operator>*</operator><operator>(</operator><name>e</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block>
    </block_content>}</block></switch>
    <expr_stmt><expr><name>fmt</name> <operator>=</operator> <name>e</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>  <comment type="block">/* skip '%' and the specifier */</comment>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>addstr2buff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* rest of 'fmt' */</comment>
  <expr_stmt><expr><call><name>clearbuff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* empty buffer into the stack */</comment>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>buff</name><operator>.</operator><name>pushed</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svalue</name><argument_list>(<argument><expr><call><name>s2v</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>luaO_pushfstring</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>argp</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>argp</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>luaO_pushvfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>msg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* }================================================================== */</comment>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETS</name></cpp:macro>	<cpp:value>"..."</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRE</name></cpp:macro>	<cpp:value>"[string \""</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POS</name></cpp:macro>	<cpp:value>"\"]"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>addstr</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>( memcpy(a,b,(l) * sizeof(char)), a += (l) )</cpp:value></cpp:define>

<function><type><name>void</name></type> <name>luaO_chunkid</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>srclen</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>bufflen</name> <init>= <expr><name>LUA_IDSIZE</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* free space in buffer */</comment>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>source</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* 'literal' source */</comment>
    <if_stmt><if>if <condition>(<expr><name>srclen</name> <operator>&lt;=</operator> <name>bufflen</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* small enough? */</comment>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>source</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>srclen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else <block>{<block_content>  <comment type="block">/* truncate it */</comment>
      <expr_stmt><expr><call><name>addstr</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>source</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>bufflen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>*</operator><name>source</name> <operator>==</operator> <literal type="char">'@'</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* file name */</comment>
    <if_stmt><if>if <condition>(<expr><name>srclen</name> <operator>&lt;=</operator> <name>bufflen</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* small enough? */</comment>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>source</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>srclen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else <block>{<block_content>  <comment type="block">/* add '...' before rest of name */</comment>
      <expr_stmt><expr><call><name>addstr</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>RETS</name></expr></argument>, <argument><expr><call><name>LL</name><argument_list>(<argument><expr><name>RETS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bufflen</name> <operator>-=</operator> <call><name>LL</name><argument_list>(<argument><expr><name>RETS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>source</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>srclen</name> <operator>-</operator> <name>bufflen</name></expr></argument>, <argument><expr><name>bufflen</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>  <comment type="block">/* string; format as [string "source"] */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nl</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* find first new line (if any) */</comment>
    <expr_stmt><expr><call><name>addstr</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>PRE</name></expr></argument>, <argument><expr><call><name>LL</name><argument_list>(<argument><expr><name>PRE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* add prefix */</comment>
    <expr_stmt><expr><name>bufflen</name> <operator>-=</operator> <macro><name>LL</name><argument_list>(<argument>PRE RETS POS</argument>)</argument_list></macro> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* save space for prefix+suffix+'\0' */</comment>
    <if_stmt><if>if <condition>(<expr><name>srclen</name> <operator>&lt;</operator> <name>bufflen</name> <operator>&amp;&amp;</operator> <name>nl</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* small one-line source? */</comment>
      <expr_stmt><expr><call><name>addstr</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>srclen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* keep it */</comment>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>nl</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>srclen</name> <operator>=</operator> <name>nl</name> <operator>-</operator> <name>source</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* stop at first newline */</comment>
      <if_stmt><if>if <condition>(<expr><name>srclen</name> <operator>&gt;</operator> <name>bufflen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>srclen</name> <operator>=</operator> <name>bufflen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>addstr</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>srclen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>addstr</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>RETS</name></expr></argument>, <argument><expr><call><name>LL</name><argument_list>(<argument><expr><name>RETS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>POS</name></expr></argument>, <argument><expr><operator>(</operator><call><name>LL</name><argument_list>(<argument><expr><name>POS</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

</unit>
