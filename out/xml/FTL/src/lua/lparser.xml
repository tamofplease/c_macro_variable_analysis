<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/lua/lparser.c"><comment type="block">/*
** $Id: lparser.c $
** Lua Parser
** See Copyright Notice in lua.h
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lparser_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lprefix.h"</cpp:file></cpp:include>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lua.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lcode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ldebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ldo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lfunc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lopcodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lparser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lstate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lstring.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ltable.h"</cpp:file></cpp:include>



<comment type="block">/* maximum number of local variables per function (must be smaller
   than 250, due to the bytecode format) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXVARS</name></cpp:macro>		<cpp:value>200</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hasmultret</name><parameter_list>(<parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((k) == VCALL || (k) == VVARARG)</cpp:value></cpp:define>


<comment type="block">/* because all strings are unified by the scanner, the parser
   can use pointer equality for string equality */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>eqstr</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((a) == (b))</cpp:value></cpp:define>


<comment type="block">/*
** nodes for block list (list of active blocks)
*/</comment>
<typedef>typedef <type><struct>struct <name>BlockCnt</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>BlockCnt</name></name> <modifier>*</modifier></type><name>previous</name></decl>;</decl_stmt>  <comment type="block">/* chain */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>firstlabel</name></decl>;</decl_stmt>  <comment type="block">/* index of first label in this block */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>firstgoto</name></decl>;</decl_stmt>  <comment type="block">/* index of first pending goto in this block */</comment>
  <decl_stmt><decl><type><name>lu_byte</name></type> <name>nactvar</name></decl>;</decl_stmt>  <comment type="block">/* # active locals outside the block */</comment>
  <decl_stmt><decl><type><name>lu_byte</name></type> <name>upval</name></decl>;</decl_stmt>  <comment type="block">/* true if some variable in the block is an upvalue */</comment>
  <decl_stmt><decl><type><name>lu_byte</name></type> <name>isloop</name></decl>;</decl_stmt>  <comment type="block">/* true if 'block' is a loop */</comment>
  <decl_stmt><decl><type><name>lu_byte</name></type> <name>insidetbc</name></decl>;</decl_stmt>  <comment type="block">/* true if inside the scope of a to-be-closed var. */</comment>
}</block></struct></type> <name>BlockCnt</name>;</typedef>



<comment type="block">/*
** prototypes for recursive non-terminal functions
*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>statement</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expr</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><specifier>static</specifier> <name>l_noret</name></type> <name>error_expected</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>token</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,
      <argument><expr><call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><literal type="string">"%s expected"</literal></expr></argument>, <argument><expr><call><name>luaX_token2str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>l_noret</name></type> <name>errorlimit</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>what</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>linedefined</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>where</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>line</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>
                      ?</condition><then> <expr><literal type="string">"main function"</literal></expr>
                      </then><else>: <expr><call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"function at line %d"</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="string">"too many %s (limit is %d) in %s"</literal></expr></argument>,
                             <argument><expr><name>what</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>where</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>checklimit</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>what</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;</operator> <name>l</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>errorlimit</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Test whether next token is 'c'; if so, skip it.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>testnext</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <name>c</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Check that next token is 'c'.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>check</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>!=</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>error_expected</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Check that next token is 'c' and skip it.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>checknext</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>check_condition</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>,<parameter><type><name>c</name></type></parameter>,<parameter><type><name>msg</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>{ if (!(c)) luaX_syntaxerror(ls, msg); }</cpp:value></cpp:define>


<comment type="block">/*
** Check that next token is 'what' and skip it. In case of error,
** raise an error that the expected 'what' should match a 'who'
** in line 'where' (if that is not the current line).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>check_match</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>what</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>who</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>where</name> <operator>==</operator> <name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* all in the same line? */</comment>
      <expr_stmt><expr><call><name>error_expected</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* do not need a complex message */</comment>
    <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,
             <argument><expr><literal type="string">"%s expected (to close %s at line %d)"</literal></expr></argument>,
              <argument><expr><call><name>luaX_token2str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>luaX_token2str</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>who</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>where</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>TString</name> <modifier>*</modifier></type><name>str_checkname</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>TString</name> <modifier>*</modifier></type><name>ts</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ts</name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>seminfo</name><operator>.</operator><name>ts</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>ts</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>init_exp</name> <parameter_list>(<parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>expkind</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name>NO_JUMP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>codestring</name> <parameter_list>(<parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name>NO_JUMP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VKSTR</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>strval</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>codename</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>codestring</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Register a new local variable in the active 'Proto' (for debug
** information).
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>registerlocalvar</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>varname</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>oldsize</name> <init>= <expr><name><name>f</name><operator>-&gt;</operator><name>sizelocvars</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaM_growvector</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>locvars</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ndebugvars</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizelocvars</name></name></expr></argument>,
                  <argument><expr><name>LocVar</name></expr></argument>, <argument><expr><name>SHRT_MAX</name></expr></argument>, <argument><expr><literal type="string">"local variables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>oldsize</name> <operator>&lt;</operator> <name><name>f</name><operator>-&gt;</operator><name>sizelocvars</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>locvars</name><index>[<expr><name>oldsize</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>varname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>locvars</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>ndebugvars</name></name></expr>]</index></name><operator>.</operator><name>varname</name> <operator>=</operator> <name>varname</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>locvars</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>ndebugvars</name></name></expr>]</index></name><operator>.</operator><name>startpc</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaC_objbarrier</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>fs</name><operator>-&gt;</operator><name>ndebugvars</name></name><operator>++</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Create a new local variable with the given 'name'. Return its index
** in the function.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>new_localvar</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Dyndata</name> <modifier>*</modifier></type><name>dyd</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>dyd</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Vardesc</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>checklimit</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>dyd</name><operator>-&gt;</operator><name>actvar</name><operator>.</operator><name>n</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name><name>fs</name><operator>-&gt;</operator><name>firstlocal</name></name></expr></argument>,
                 <argument><expr><name>MAXVARS</name></expr></argument>, <argument><expr><literal type="string">"local variables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_growvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>dyd</name><operator>-&gt;</operator><name>actvar</name><operator>.</operator><name>arr</name></name></expr></argument>, <argument><expr><name><name>dyd</name><operator>-&gt;</operator><name>actvar</name><operator>.</operator><name>n</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                  <argument><expr><name><name>dyd</name><operator>-&gt;</operator><name>actvar</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><name>Vardesc</name></expr></argument>, <argument><expr><name>USHRT_MAX</name></expr></argument>, <argument><expr><literal type="string">"local variables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>&amp;</operator><name><name>dyd</name><operator>-&gt;</operator><name>actvar</name><operator>.</operator><name>arr</name><index>[<expr><name><name>dyd</name><operator>-&gt;</operator><name>actvar</name><operator>.</operator><name>n</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>vd</name><operator>.</operator><name>kind</name></name> <operator>=</operator> <name>VDKREG</name></expr>;</expr_stmt>  <comment type="block">/* default */</comment>
  <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>vd</name><operator>.</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
  <return>return <expr><name><name>dyd</name><operator>-&gt;</operator><name>actvar</name><operator>.</operator><name>n</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name><name>fs</name><operator>-&gt;</operator><name>firstlocal</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>new_localvarliteral</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>,<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>new_localvar(ls,  \
      luaX_newstring(ls, "" v, (sizeof(v)/sizeof(char)) - 1));</cpp:value></cpp:define>



<comment type="block">/*
** Return the "variable description" (Vardesc) of a given variable.
** (Unless noted otherwise, all variables are referred to by their
** compiler indices.)
*/</comment>
<function><type><specifier>static</specifier> <name>Vardesc</name> <modifier>*</modifier></type><name>getlocalvardesc</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>vidx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>dyd</name><operator>-&gt;</operator><name>actvar</name><operator>.</operator><name>arr</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>firstlocal</name></name> <operator>+</operator> <name>vidx</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Convert 'nvar', a compiler index level, to it corresponding
** stack index level. For that, search for the highest variable
** below that level that is in the stack and uses its stack
** index ('sidx').
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>stacklevel</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvar</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <while>while <condition>(<expr><name>nvar</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>Vardesc</name> <modifier>*</modifier></type><name>vd</name> <init>= <expr><call><name>getlocalvardesc</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>nvar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* get variable */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>vd</name><operator>-&gt;</operator><name>vd</name><operator>.</operator><name>kind</name></name> <operator>!=</operator> <name>RDKCTC</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* is in the stack? */</comment>
      <return>return <expr><name><name>vd</name><operator>-&gt;</operator><name>vd</name><operator>.</operator><name>sidx</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><literal type="number">0</literal></expr>;</return>  <comment type="block">/* no variables in the stack */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Return the number of variables in the stack for function 'fs'
*/</comment>
<function><type><name>int</name></type> <name>luaY_nvarstack</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>stacklevel</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Get the debug-information entry for current variable 'vidx'.
*/</comment>
<function><type><specifier>static</specifier> <name>LocVar</name> <modifier>*</modifier></type><name>localdebuginfo</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>vidx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Vardesc</name> <modifier>*</modifier></type><name>vd</name> <init>= <expr><call><name>getlocalvardesc</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,  <argument><expr><name>vidx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>vd</name><operator>-&gt;</operator><name>vd</name><operator>.</operator><name>kind</name></name> <operator>==</operator> <name>RDKCTC</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if>  <comment type="block">/* no debug info. for constants */</comment>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name><name>vd</name><operator>-&gt;</operator><name>vd</name><operator>.</operator><name>pidx</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>idx</name> <operator>&lt;</operator> <name><name>fs</name><operator>-&gt;</operator><name>ndebugvars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>locvars</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Create an expression representing variable 'vidx'
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>init_var</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>vidx</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>f</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>t</name></name> <operator>=</operator> <name>NO_JUMP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>VLOCAL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>var</name><operator>.</operator><name>vidx</name></name> <operator>=</operator> <name>vidx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>var</name><operator>.</operator><name>sidx</name></name> <operator>=</operator> <call><name>getlocalvardesc</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>vidx</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>vd</name><operator>.</operator><name>sidx</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Raises an error if variable described by 'e' is read only
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>check_readonly</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TString</name> <modifier>*</modifier></type><name>varname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* to be set if variable is const */</comment>
  <switch>switch <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>VCONST</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><name>varname</name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>dyd</name><operator>-&gt;</operator><name>actvar</name><operator>.</operator><name>arr</name><index>[<expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr>]</index></name><operator>.</operator><name><name>vd</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VLOCAL</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Vardesc</name> <modifier>*</modifier></type><name>vardesc</name> <init>= <expr><call><name>getlocalvardesc</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>var</name><operator>.</operator><name>vidx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>vardesc</name><operator>-&gt;</operator><name>vd</name><operator>.</operator><name>kind</name></name> <operator>!=</operator> <name>VDKREG</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* not a regular variable? */</comment>
        <expr_stmt><expr><name>varname</name> <operator>=</operator> <name><name>vardesc</name><operator>-&gt;</operator><name>vd</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>VUPVAL</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>Upvaldesc</name> <modifier>*</modifier></type><name>up</name> <init>= <expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name><name>e</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>up</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>VDKREG</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>varname</name> <operator>=</operator> <name><name>up</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default>
      <return>return;</return>  <comment type="block">/* other cases cannot be read-only */</comment>
  </block_content>}</block></switch>
  <if_stmt><if>if <condition>(<expr><name>varname</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>,
       <argument><expr><literal type="string">"attempt to assign to const variable '%s'"</literal></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>luaK_semerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* error */</comment>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Start the scope for the last 'nvars' created variables.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>adjustlocalvars</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvars</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>stklevel</name> <init>= <expr><call><name>luaY_nvarstack</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nvars</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>vidx</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Vardesc</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>getlocalvardesc</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>vidx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>vd</name><operator>.</operator><name>sidx</name></name> <operator>=</operator> <name>stklevel</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>vd</name><operator>.</operator><name>pidx</name></name> <operator>=</operator> <call><name>registerlocalvar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>vd</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
** Close the scope for all variables up to level 'tolevel'.
** (debug info.)
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>removevars</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tolevel</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>dyd</name><operator>-&gt;</operator><name>actvar</name><operator>.</operator><name>n</name></name> <operator>-=</operator> <operator>(</operator><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>-</operator> <name>tolevel</name><operator>)</operator></expr>;</expr_stmt>
  <while>while <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>&gt;</operator> <name>tolevel</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>LocVar</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>localdebuginfo</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>--</operator><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>var</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* does it have debug information? */</comment>
      <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>endpc</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
** Search the upvalues of the function 'fs' for one
** with the given 'name'.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>searchupvalue</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Upvaldesc</name> <modifier>*</modifier></type><name>up</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>upvalues</name></name></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fs</name><operator>-&gt;</operator><name>nups</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>eqstr</name><argument_list>(<argument><expr><name><name>up</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>  <comment type="block">/* not found */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Upvaldesc</name> <modifier>*</modifier></type><name>allocupvalue</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>oldsize</name> <init>= <expr><name><name>f</name><operator>-&gt;</operator><name>sizeupvalues</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>checklimit</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nups</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>MAXUPVAL</name></expr></argument>, <argument><expr><literal type="string">"upvalues"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_growvector</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>upvalues</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nups</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizeupvalues</name></name></expr></argument>,
                  <argument><expr><name>Upvaldesc</name></expr></argument>, <argument><expr><name>MAXUPVAL</name></expr></argument>, <argument><expr><literal type="string">"upvalues"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>oldsize</name> <operator>&lt;</operator> <name><name>f</name><operator>-&gt;</operator><name>sizeupvalues</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name>oldsize</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></while>
  <return>return <expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>nups</name></name><operator>++</operator></expr>]</index></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>newupvalue</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Upvaldesc</name> <modifier>*</modifier></type><name>up</name> <init>= <expr><call><name>allocupvalue</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VLOCAL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>up</name><operator>-&gt;</operator><name>instack</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>up</name><operator>-&gt;</operator><name>idx</name></name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>var</name><operator>.</operator><name>sidx</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>up</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <call><name>getlocalvardesc</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>var</name><operator>.</operator><name>vidx</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>vd</name><operator>.</operator><name>kind</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>eqstr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>getlocalvardesc</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>var</name><operator>.</operator><name>vidx</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>vd</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>up</name><operator>-&gt;</operator><name>instack</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>up</name><operator>-&gt;</operator><name>idx</name></name> <operator>=</operator> <call><name>cast_byte</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>up</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name><name>prev</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr>]</index></name><operator>.</operator><name>kind</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>eqstr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>prev</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>up</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaC_objbarrier</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>fs</name><operator>-&gt;</operator><name>nups</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Look for an active local variable with the name 'n' in the
** function 'fs'. If found, initialize 'var' with it and return
** its expression kind; otherwise return -1.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>searchvar</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>cast_int</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>Vardesc</name> <modifier>*</modifier></type><name>vd</name> <init>= <expr><call><name>getlocalvardesc</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>eqstr</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>vd</name><operator>-&gt;</operator><name>vd</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* found? */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>vd</name><operator>-&gt;</operator><name>vd</name><operator>.</operator><name>kind</name></name> <operator>==</operator> <name>RDKCTC</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* compile-time constant? */</comment>
        <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>VCONST</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>firstlocal</name></name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>  <comment type="block">/* real variable */</comment>
        <expr_stmt><expr><call><name>init_var</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <return>return <expr><name><name>var</name><operator>-&gt;</operator><name>k</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>  <comment type="block">/* not found */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Mark block where variable at given level was defined
** (to emit close instructions later).
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>markupval</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BlockCnt</name> <modifier>*</modifier></type><name>bl</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>&gt;</operator> <name>level</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>bl</name> <operator>=</operator> <name><name>bl</name><operator>-&gt;</operator><name>previous</name></name></expr>;</expr_stmt></block_content></block></while>
  <expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>upval</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>needclose</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Find a variable with the given name 'n'. If it is an upvalue, add
** this upvalue into all intermediate functions. If it is a global, set
** 'var' as 'void' as a flag.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>singlevaraux</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>fs</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* no more levels? */</comment>
    <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>VVOID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* default is global */</comment>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>v</name> <init>= <expr><call><name>searchvar</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* look up locals at current level */</comment>
    <if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* found? */</comment>
      <if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>VLOCAL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>base</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>markupval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>var</name><operator>.</operator><name>vidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* local will be used as an upval */</comment>
    </block_content>}</block></if>
    <else>else <block>{<block_content>  <comment type="block">/* not found as local at current level; try upvalues */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>searchupvalue</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* try existing upvalues */</comment>
      <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* not found? */</comment>
        <expr_stmt><expr><call><name>singlevaraux</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* try upper levels */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VLOCAL</name> <operator>||</operator> <name><name>var</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VUPVAL</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* local or upvalue? */</comment>
          <expr_stmt><expr><name>idx</name>  <operator>=</operator> <call><name>newupvalue</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* will be a new upvalue */</comment>
        <else>else<block type="pseudo"><block_content>  <comment type="block">/* it is a global or a constant */</comment>
          <return>return;</return></block_content></block></else></if_stmt>  <comment type="block">/* don't need to do anything at this level */</comment>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>VUPVAL</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* new or old upvalue */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Find a variable with the given name 'n', handling global variables
** too.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>singlevar</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>TString</name> <modifier>*</modifier></type><name>varname</name> <init>= <expr><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>singlevaraux</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VVOID</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* global name? */</comment>
    <decl_stmt><decl><type><name>expdesc</name></type> <name>key</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>singlevaraux</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>envn</name></name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* get environment variable */</comment>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>k</name></name> <operator>!=</operator> <name>VVOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* this one must exist */</comment>
    <expr_stmt><expr><call><name>codestring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* key is variable name */</comment>
    <expr_stmt><expr><call><name>luaK_indexed</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* env[varname] */</comment>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Adjust the number of results from an expression list 'e' with 'nexps'
** expressions to 'nvars' values.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>adjust_assign</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvars</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nexps</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>needed</name> <init>= <expr><name>nvars</name> <operator>-</operator> <name>nexps</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* extra values needed */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>hasmultret</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* last expression has multiple returns? */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>extra</name> <init>= <expr><name>needed</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* discount last expression itself */</comment>
    <if_stmt><if>if <condition>(<expr><name>extra</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>extra</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>luaK_setreturns</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* last exp. provides the difference */</comment>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>k</name></name> <operator>!=</operator> <name>VVOID</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* at least one expression? */</comment>
      <expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* close last expression */</comment>
    <if_stmt><if>if <condition>(<expr><name>needed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* missing values? */</comment>
      <expr_stmt><expr><call><name>luaK_nil</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></argument>, <argument><expr><name>needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* complete with nils */</comment>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>needed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* registers for extra values */</comment>
  <else>else<block type="pseudo"><block_content>  <comment type="block">/* adding 'needed' is actually a subtraction */</comment>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>+=</operator> <name>needed</name></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* remove extra values */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Macros to limit the maximum recursion depth while parsing
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>enterlevel</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>luaE_enterCcall((ls)-&gt;L)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>leavelevel</name><parameter_list>(<parameter><type><name>ls</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>luaE_exitCcall((ls)-&gt;L)</cpp:value></cpp:define>


<comment type="block">/*
** Generates an error that a goto jumps into the scope of some
** local variable.
*/</comment>
<function><type><specifier>static</specifier> <name>l_noret</name></type> <name>jumpscopeerror</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>Labeldesc</name> <modifier>*</modifier></type><name>gt</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>varname</name> <init>= <expr><call><name>getstr</name><argument_list>(<argument><expr><call><name>getlocalvardesc</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name><name>gt</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>vd</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><literal type="string">"&lt;goto %s&gt; at line %d jumps into the scope of local '%s'"</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name><name>gt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gt</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_semerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* raise the error */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Solves the goto at index 'g' to given 'label' and removes it
** from the list of pending goto's.
** If it jumps into the scope of some variable, raises an error.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>solvegoto</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>g</name></decl></parameter>, <parameter><decl><type><name>Labeldesc</name> <modifier>*</modifier></type><name>label</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Labellist</name> <modifier>*</modifier></type><name>gl</name> <init>= <expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>dyd</name><operator>-&gt;</operator><name>gt</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* list of goto's */</comment>
  <decl_stmt><decl><type><name>Labeldesc</name> <modifier>*</modifier></type><name>gt</name> <init>= <expr><operator>&amp;</operator><name><name>gl</name><operator>-&gt;</operator><name>arr</name><index>[<expr><name>g</name></expr>]</index></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* goto to be resolved */</comment>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>eqstr</name><argument_list>(<argument><expr><name><name>gt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>label</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>gt</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>&lt;</operator> <name><name>label</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* enter some scope? */</comment>
    <expr_stmt><expr><call><name>jumpscopeerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>luaK_patchlist</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name><name>gt</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>, <argument><expr><name><name>label</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>g</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gl</name><operator>-&gt;</operator><name>n</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>  <comment type="block">/* remove goto from pending list */</comment>
    <expr_stmt><expr><name><name>gl</name><operator>-&gt;</operator><name>arr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>gl</name><operator>-&gt;</operator><name>arr</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><name><name>gl</name><operator>-&gt;</operator><name>n</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Search for an active label with the given name.
*/</comment>
<function><type><specifier>static</specifier> <name>Labeldesc</name> <modifier>*</modifier></type><name>findlabel</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Dyndata</name> <modifier>*</modifier></type><name>dyd</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>dyd</name></name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* check labels in current function for a match */</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>firstlabel</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dyd</name><operator>-&gt;</operator><name>label</name><operator>.</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <decl_stmt><decl><type><name>Labeldesc</name> <modifier>*</modifier></type><name>lb</name> <init>= <expr><operator>&amp;</operator><name><name>dyd</name><operator>-&gt;</operator><name>label</name><operator>.</operator><name>arr</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>eqstr</name><argument_list>(<argument><expr><name><name>lb</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* correct label? */</comment>
      <return>return <expr><name>lb</name></expr>;</return></block_content></block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>NULL</name></expr>;</return>  <comment type="block">/* label not found */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Adds a new label/goto in the corresponding list.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>newlabelentry</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>Labellist</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
                          <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>l</name><operator>-&gt;</operator><name>n</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaM_growvector</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>l</name><operator>-&gt;</operator><name>arr</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>l</name><operator>-&gt;</operator><name>size</name></name></expr></argument>,
                  <argument><expr><name>Labeldesc</name></expr></argument>, <argument><expr><name>SHRT_MAX</name></expr></argument>, <argument><expr><literal type="string">"labels/gotos"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>arr</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>arr</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>line</name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>arr</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>nactvar</name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>arr</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>close</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>arr</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>pc</name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>newgotoentry</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>newlabelentry</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>dyd</name><operator>-&gt;</operator><name>gt</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Solves forward jumps. Check whether new label 'lb' matches any
** pending gotos in current block and solves them. Return true
** if any of the goto's need to close upvalues.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>solvegotos</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>Labeldesc</name> <modifier>*</modifier></type><name>lb</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Labellist</name> <modifier>*</modifier></type><name>gl</name> <init>= <expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>dyd</name><operator>-&gt;</operator><name>gt</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>bl</name><operator>-&gt;</operator><name>firstgoto</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>needsclose</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>gl</name><operator>-&gt;</operator><name>n</name></name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>eqstr</name><argument_list>(<argument><expr><name><name>gl</name><operator>-&gt;</operator><name>arr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name><name>lb</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>needsclose</name> <operator>|=</operator> <name><name>gl</name><operator>-&gt;</operator><name>arr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>close</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>solvegoto</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>lb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* will remove 'i' from the list */</comment>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>needsclose</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Create a new label with the given 'name' at the given 'line'.
** 'last' tells whether label is the last non-op statement in its
** block. Solves all pending goto's to this new label and adds
** a close instruction if necessary.
** Returns true iff it added a close instruction.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>createlabel</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>,
                        <parameter><decl><type><name>int</name></type> <name>last</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Labellist</name> <modifier>*</modifier></type><name>ll</name> <init>= <expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>dyd</name><operator>-&gt;</operator><name>label</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><call><name>newlabelentry</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>ll</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><call><name>luaK_getlabel</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>last</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* label is last no-op statement in the block? */</comment>
    <comment type="block">/* assume that locals are already out of scope */</comment>
    <expr_stmt><expr><name><name>ll</name><operator>-&gt;</operator><name>arr</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name>nactvar</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>solvegotos</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ll</name><operator>-&gt;</operator><name>arr</name><index>[<expr><name>l</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* need close? */</comment>
    <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_CLOSE</name></expr></argument>, <argument><expr><call><name>luaY_nvarstack</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** Adjust pending gotos to outer level of a block.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>movegotosout</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BlockCnt</name> <modifier>*</modifier></type><name>bl</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Labellist</name> <modifier>*</modifier></type><name>gl</name> <init>= <expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>dyd</name><operator>-&gt;</operator><name>gt</name></name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* correct pending gotos to current block */</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>bl</name><operator>-&gt;</operator><name>firstgoto</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gl</name><operator>-&gt;</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>  <comment type="block">/* for each pending goto */</comment>
    <decl_stmt><decl><type><name>Labeldesc</name> <modifier>*</modifier></type><name>gt</name> <init>= <expr><operator>&amp;</operator><name><name>gl</name><operator>-&gt;</operator><name>arr</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* leaving a variable scope? */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>stacklevel</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>gt</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>stacklevel</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>gt</name><operator>-&gt;</operator><name>close</name></name> <operator>|=</operator> <name><name>bl</name><operator>-&gt;</operator><name>upval</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* jump may need a close */</comment>
    <expr_stmt><expr><name><name>gt</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>=</operator> <name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name></expr>;</expr_stmt>  <comment type="block">/* update goto level */</comment>
  </block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>enterblock</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BlockCnt</name> <modifier>*</modifier></type><name>bl</name></decl></parameter>, <parameter><decl><type><name>lu_byte</name></type> <name>isloop</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>isloop</name></name> <operator>=</operator> <name>isloop</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>firstlabel</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>dyd</name><operator>-&gt;</operator><name>label</name><operator>.</operator><name>n</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>firstgoto</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>ls</name><operator>-&gt;</operator><name>dyd</name><operator>-&gt;</operator><name>gt</name><operator>.</operator><name>n</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>upval</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>insidetbc</name></name> <operator>=</operator> <operator>(</operator><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>fs</name><operator>-&gt;</operator><name>bl</name><operator>-&gt;</operator><name>insidetbc</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>previous</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>bl</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name> <operator>=</operator> <name>bl</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>==</operator> <call><name>luaY_nvarstack</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** generates an error for an undefined 'goto'.
*/</comment>
<function><type><specifier>static</specifier> <name>l_noret</name></type> <name>undefgoto</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>Labeldesc</name> <modifier>*</modifier></type><name>gt</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>eqstr</name><argument_list>(<argument><expr><name><name>gt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>luaS_newliteral</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><literal type="string">"break"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">"break outside loop at line %d"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name><name>gt</name><operator>-&gt;</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <expr_stmt><expr><name>msg</name> <operator>=</operator> <literal type="string">"no visible label '%s' for &lt;goto&gt; at line %d"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name><name>gt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gt</name><operator>-&gt;</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>luaK_semerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>leaveblock</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BlockCnt</name> <modifier>*</modifier></type><name>bl</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>hasclose</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>stklevel</name> <init>= <expr><call><name>stacklevel</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* level outside the block */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>bl</name><operator>-&gt;</operator><name>isloop</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* fix pending breaks? */</comment>
    <expr_stmt><expr><name>hasclose</name> <operator>=</operator> <call><name>createlabel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><call><name>luaS_newliteral</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><literal type="string">"break"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>hasclose</name> <operator>&amp;&amp;</operator> <name><name>bl</name><operator>-&gt;</operator><name>previous</name></name> <operator>&amp;&amp;</operator> <name><name>bl</name><operator>-&gt;</operator><name>upval</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_CLOSE</name></expr></argument>, <argument><expr><name>stklevel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name> <operator>=</operator> <name><name>bl</name><operator>-&gt;</operator><name>previous</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>removevars</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>bl</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>==</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>=</operator> <name>stklevel</name></expr>;</expr_stmt>  <comment type="block">/* free registers */</comment>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>dyd</name><operator>-&gt;</operator><name>label</name><operator>.</operator><name>n</name></name> <operator>=</operator> <name><name>bl</name><operator>-&gt;</operator><name>firstlabel</name></name></expr>;</expr_stmt>  <comment type="block">/* remove local labels */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>bl</name><operator>-&gt;</operator><name>previous</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* inner block? */</comment>
    <expr_stmt><expr><call><name>movegotosout</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* update pending gotos to outer block */</comment>
  <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>bl</name><operator>-&gt;</operator><name>firstgoto</name></name> <operator>&lt;</operator> <name><name>ls</name><operator>-&gt;</operator><name>dyd</name><operator>-&gt;</operator><name>gt</name><operator>.</operator><name>n</name></name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* pending gotos in outer block? */</comment>
      <expr_stmt><expr><call><name>undefgoto</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ls</name><operator>-&gt;</operator><name>dyd</name><operator>-&gt;</operator><name>gt</name><operator>.</operator><name>arr</name><index>[<expr><name><name>bl</name><operator>-&gt;</operator><name>firstgoto</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* error */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** adds a new prototype into list of prototypes
*/</comment>
<function><type><specifier>static</specifier> <name>Proto</name> <modifier>*</modifier></type><name>addprototype</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>clp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* prototype of current function */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>np</name></name> <operator>&gt;=</operator> <name><name>f</name><operator>-&gt;</operator><name>sizep</name></name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>oldsize</name> <init>= <expr><name><name>f</name><operator>-&gt;</operator><name>sizep</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>luaM_growvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>np</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizep</name></name></expr></argument>, <argument><expr><name>Proto</name> <operator>*</operator></expr></argument>, <argument><expr><name>MAXARG_Bx</name></expr></argument>, <argument><expr><literal type="string">"functions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>oldsize</name> <operator>&lt;</operator> <name><name>f</name><operator>-&gt;</operator><name>sizep</name></name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>oldsize</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></while>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>p</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>np</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>clp</name> <operator>=</operator> <call><name>luaF_newproto</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaC_objbarrier</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>clp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>clp</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
** codes instruction to create new closure in parent function.
** The OP_CLOSURE instruction uses the last available register,
** so that, if it invokes the GC, the GC knows which registers
** are in use at that time.

*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>codeclosure</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>VRELOC</name></expr></argument>, <argument><expr><call><name>luaK_codeABx</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_CLOSURE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>np</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* fix it at the last register */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>open_func</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>BlockCnt</name> <modifier>*</modifier></type><name>bl</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr>;</expr_stmt>  <comment type="block">/* linked list of funcstates */</comment>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name> <operator>=</operator> <name>ls</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name> <operator>=</operator> <name>fs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>previousline</name></name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>linedefined</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>iwthabs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>lasttarget</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>nk</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>nabslineinfo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>np</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>nups</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>ndebugvars</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>needclose</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>firstlocal</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>dyd</name><operator>-&gt;</operator><name>actvar</name><operator>.</operator><name>n</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>firstlabel</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>dyd</name><operator>-&gt;</operator><name>label</name><operator>.</operator><name>n</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>source</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaC_objbarrier</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>source</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>maxstacksize</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>  <comment type="block">/* registers 0/1 are always valid */</comment>
  <expr_stmt><expr><call><name>enterblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>bl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>close_func</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaK_ret</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>luaY_nvarstack</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* final return */</comment>
  <expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_finish</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_shrinkvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizecode</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>, <argument><expr><name>Instruction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_shrinkvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>lineinfo</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizelineinfo</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>, <argument><expr><name>ls_byte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_shrinkvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>abslineinfo</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizeabslineinfo</name></name></expr></argument>,
                       <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nabslineinfo</name></name></expr></argument>, <argument><expr><name>AbsLineInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_shrinkvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>k</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizek</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nk</name></name></expr></argument>, <argument><expr><name>TValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_shrinkvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizep</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>np</name></name></expr></argument>, <argument><expr><name>Proto</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_shrinkvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>locvars</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizelocvars</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ndebugvars</name></name></expr></argument>, <argument><expr><name>LocVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaM_shrinkvector</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>upvalues</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>sizeupvalues</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nups</name></name></expr></argument>, <argument><expr><name>Upvaldesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaC_checkGC</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block">/*============================================================*/</comment>
<comment type="block">/* GRAMMAR RULES */</comment>
<comment type="block">/*============================================================*/</comment>


<comment type="block">/*
** check whether current token is in the follow set of a block.
** 'until' closes syntactical blocks, but do not close scope,
** so it is handled in separate.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>block_follow</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>withuntil</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TK_ELSE</name></expr>:</case> <case>case <expr><name>TK_ELSEIF</name></expr>:</case>
    <case>case <expr><name>TK_END</name></expr>:</case> <case>case <expr><name>TK_EOS</name></expr>:</case>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    <case>case <expr><name>TK_UNTIL</name></expr>:</case> <return>return <expr><name>withuntil</name></expr>;</return>
    <default>default:</default> <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>statlist</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* statlist -&gt; { stat [';'] } */</comment>
  <while>while <condition>(<expr><operator>!</operator><call><name>block_follow</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <name>TK_RETURN</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>statement</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>  <comment type="block">/* 'return' must be last statement */</comment>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>statement</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></while>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>fieldsel</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* fieldsel -&gt; ['.' | ':'] NAME */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>key</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaK_exp2anyregup</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip the dot or colon */</comment>
  <expr_stmt><expr><call><name>codename</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_indexed</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>yindex</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* index -&gt; '[' expr ']' */</comment>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip the '[' */</comment>
  <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_exp2val</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** {======================================================================
** Rules for Constructors
** =======================================================================
*/</comment>


<typedef>typedef <type><struct>struct <name>ConsControl</name> <block>{
  <decl_stmt><decl><type><name>expdesc</name></type> <name>v</name></decl>;</decl_stmt>  <comment type="block">/* last list item read */</comment>
  <decl_stmt><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>  <comment type="block">/* table descriptor */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nh</name></decl>;</decl_stmt>  <comment type="block">/* total number of 'record' elements */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>na</name></decl>;</decl_stmt>  <comment type="block">/* number of array elements already stored */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>tostore</name></decl>;</decl_stmt>  <comment type="block">/* number of array elements pending to be stored */</comment>
}</block></struct></type> <name>ConsControl</name>;</typedef>


<function><type><specifier>static</specifier> <name>void</name></type> <name>recfield</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>ConsControl</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* recfield -&gt; (NAME | '['exp']') = exp */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>reg</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>tab</name></decl>, <decl><type ref="prev"/><name>key</name></decl>, <decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <name>TK_NAME</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>checklimit</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>nh</name></name></expr></argument>, <argument><expr><name>MAX_INT</name></expr></argument>, <argument><expr><literal type="string">"items in a constructor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>codename</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>  <comment type="block">/* ls-&gt;t.token == '[' */</comment>
    <expr_stmt><expr><call><name>yindex</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>nh</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>tab</name> <operator>=</operator> <operator>*</operator><name><name>cc</name><operator>-&gt;</operator><name>t</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_indexed</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_storevar</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>=</operator> <name>reg</name></expr>;</expr_stmt>  <comment type="block">/* free registers */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>closelistfield</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>ConsControl</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VVOID</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>  <comment type="block">/* there is no list item */</comment>
  <expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>VVOID</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>tostore</name></name> <operator>==</operator> <name>LFIELDS_PER_FLUSH</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>luaK_setlist</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>na</name></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>tostore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* flush */</comment>
    <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>na</name></name> <operator>+=</operator> <name><name>cc</name><operator>-&gt;</operator><name>tostore</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>tostore</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>  <comment type="block">/* no more items pending */</comment>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>lastlistfield</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>ConsControl</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>tostore</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>hasmultret</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>luaK_setmultret</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaK_setlist</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>na</name></name></expr></argument>, <argument><expr><name>LUA_MULTRET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>na</name></name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* do not count last expression (unknown number of elements) */</comment>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>!=</operator> <name>VVOID</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>luaK_setlist</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>na</name></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>tostore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>na</name></name> <operator>+=</operator> <name><name>cc</name><operator>-&gt;</operator><name>tostore</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>listfield</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>ConsControl</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* listfield -&gt; exp */</comment>
  <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>tostore</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>field</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>ConsControl</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* field -&gt; listfield | recfield */</comment>
  <switch>switch<condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TK_NAME</name></expr>:</case> <block>{<block_content>  <comment type="block">/* may be 'listfield' or 'recfield' */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>luaX_lookahead</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* expression? */</comment>
        <expr_stmt><expr><call><name>listfield</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>recfield</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="char">'['</literal></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>recfield</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>listfield</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>constructor</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* constructor -&gt; '{' [ field { sep field } [sep] ] '}'
     sep -&gt; ',' | ';' */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pc</name> <init>= <expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_NEWTABLE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ConsControl</name></type> <name>cc</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaK_code</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* space for extra arg. */</comment>
  <expr_stmt><expr><name><name>cc</name><operator>.</operator><name>na</name></name> <operator>=</operator> <name><name>cc</name><operator>.</operator><name>nh</name></name> <operator>=</operator> <name><name>cc</name><operator>.</operator><name>tostore</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cc</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>VNONRELOC</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* table will be at stack top */</comment>
  <expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><name>VVOID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* no value (yet) */</comment>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <do>do <block>{<block_content>
    <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>cc</name><operator>.</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VVOID</name> <operator>||</operator> <name><name>cc</name><operator>.</operator><name>tostore</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>closelistfield</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>field</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block> while <condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>)</condition>;</do>
  <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lastlistfield</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_settablesize</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><name><name>cc</name><operator>.</operator><name>na</name></name></expr></argument>, <argument><expr><name><name>cc</name><operator>.</operator><name>nh</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* }====================================================================== */</comment>


<function><type><specifier>static</specifier> <name>void</name></type> <name>setvararg</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nparams</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>is_vararg</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_VARARGPREP</name></expr></argument>, <argument><expr><name>nparams</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>parlist</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* parlist -&gt; [ param { ',' param } ] */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nparams</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isvararg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>!=</operator> <literal type="char">')'</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* is 'parlist' not empty? */</comment>
    <do>do <block>{<block_content>
      <switch>switch <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>TK_NAME</name></expr>:</case> <block>{<block_content>  <comment type="block">/* param -&gt; NAME */</comment>
          <expr_stmt><expr><call><name>new_localvar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>nparams</name><operator>++</operator></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>TK_DOTS</name></expr>:</case> <block>{<block_content>  <comment type="block">/* param -&gt; '...' */</comment>
          <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>isvararg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block>
        <default>default:</default> <expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"&lt;name&gt; or '...' expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></switch>
    </block_content>}</block> while <condition>(<expr><operator>!</operator><name>isvararg</name> <operator>&amp;&amp;</operator> <call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition>;</do>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>adjustlocalvars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>numparams</name></name> <operator>=</operator> <call><name>cast_byte</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>isvararg</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>setvararg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>numparams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* declared vararg */</comment>
  <expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* reserve registers for parameters */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>body</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ismethod</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* body -&gt;  '(' parlist ')' block END */</comment>
  <decl_stmt><decl><type><name>FuncState</name></type> <name>new_fs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BlockCnt</name></type> <name>bl</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>new_fs</name><operator>.</operator><name>f</name></name> <operator>=</operator> <call><name>addprototype</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_fs</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>linedefined</name></name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>open_func</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>ismethod</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"self"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* create 'self' parameter */</comment>
    <expr_stmt><expr><call><name>adjustlocalvars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>parlist</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>statlist</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_fs</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>lastlinedefined</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_END</name></expr></argument>, <argument><expr><name>TK_FUNCTION</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>codeclosure</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>close_func</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>explist</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* explist -&gt; expr { ',' expr } */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* at least one expression */</comment>
  <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>funcargs</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>args</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>base</name></decl>, <decl><type ref="prev"/><name>nparams</name></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="char">'('</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* funcargs -&gt; '(' [ explist ] ')' */</comment>
      <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* arg list is empty? */</comment>
        <expr_stmt><expr><name><name>args</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>VVOID</name></expr>;</expr_stmt></block_content></block></if>
      <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>explist</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>hasmultret</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>k</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><call><name>luaK_setmultret</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="char">'{'</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* funcargs -&gt; constructor */</comment>
      <expr_stmt><expr><call><name>constructor</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_STRING</name></expr>:</case> <block>{<block_content>  <comment type="block">/* funcargs -&gt; STRING */</comment>
      <expr_stmt><expr><call><name>codestring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>seminfo</name><operator>.</operator><name>ts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* must use 'seminfo' before 'next' */</comment>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"function arguments expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VNONRELOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>base</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr>;</expr_stmt>  <comment type="block">/* base register for call */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>hasmultret</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>k</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>nparams</name> <operator>=</operator> <name>LUA_MULTRET</name></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* open call */</comment>
  <else>else <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>args</name><operator>.</operator><name>k</name></name> <operator>!=</operator> <name>VVOID</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* close last argument */</comment>
    <expr_stmt><expr><name>nparams</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>-</operator> <operator>(</operator><name>base</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>VCALL</name></expr></argument>, <argument><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_CALL</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>nparams</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_fixline</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>=</operator> <name>base</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* call remove function and arguments and leaves
                            (unless changed) one result */</comment>
</block_content>}</block></function>




<comment type="block">/*
** {======================================================================
** Expression parsing
** =======================================================================
*/</comment>


<function><type><specifier>static</specifier> <name>void</name></type> <name>primaryexp</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* primaryexp -&gt; NAME | '(' expr ')' */</comment>
  <switch>switch <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="char">'('</literal></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>luaK_dischargevars</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_NAME</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>singlevar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"unexpected symbol"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>suffixedexp</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* suffixedexp -&gt;
       primaryexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs } */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>primaryexp</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
    <switch>switch <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition> <block>{<block_content>
      <case>case <expr><literal type="char">'.'</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* fieldsel */</comment>
        <expr_stmt><expr><call><name>fieldsel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'['</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* '[' exp ']' */</comment>
        <decl_stmt><decl><type><name>expdesc</name></type> <name>key</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>luaK_exp2anyregup</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>yindex</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>luaK_indexed</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">':'</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* ':' NAME funcargs */</comment>
        <decl_stmt><decl><type><name>expdesc</name></type> <name>key</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>codename</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>luaK_self</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>funcargs</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <case>case <expr><literal type="char">'('</literal></expr>:</case> <case>case <expr><name>TK_STRING</name></expr>:</case> <case>case <expr><literal type="char">'{'</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* funcargs */</comment>
        <expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>funcargs</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </block_content>}</block>
      <default>default:</default> <return>return;</return>
    </block_content>}</block></switch>
  </block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>simpleexp</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* simpleexp -&gt; FLT | INT | STRING | NIL | TRUE | FALSE | ... |
                  constructor | FUNCTION body | suffixedexp */</comment>
  <switch>switch <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TK_FLT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>VKFLT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>nval</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>seminfo</name><operator>.</operator><name>r</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_INT</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>VKINT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>ival</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>seminfo</name><operator>.</operator><name>i</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_STRING</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>codestring</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>seminfo</name><operator>.</operator><name>ts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_NIL</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>VNIL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_TRUE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>VTRUE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_FALSE</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>VFALSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_DOTS</name></expr>:</case> <block>{<block_content>  <comment type="block">/* vararg */</comment>
      <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>check_condition</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>is_vararg</name></name></expr></argument>,
                      <argument><expr><literal type="string">"cannot use '...' outside a vararg function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>VVARARG</name></expr></argument>, <argument><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_VARARG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><literal type="char">'{'</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* constructor */</comment>
      <expr_stmt><expr><call><name>constructor</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
    <case>case <expr><name>TK_FUNCTION</name></expr>:</case> <block>{<block_content>
      <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>body</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>
      <expr_stmt><expr><call><name>suffixedexp</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>UnOpr</name></type> <name>getunopr</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TK_NOT</name></expr>:</case> <return>return <expr><name>OPR_NOT</name></expr>;</return>
    <case>case <expr><literal type="char">'-'</literal></expr>:</case> <return>return <expr><name>OPR_MINUS</name></expr>;</return>
    <case>case <expr><literal type="char">'~'</literal></expr>:</case> <return>return <expr><name>OPR_BNOT</name></expr>;</return>
    <case>case <expr><literal type="char">'#'</literal></expr>:</case> <return>return <expr><name>OPR_LEN</name></expr>;</return>
    <default>default:</default> <return>return <expr><name>OPR_NOUNOPR</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>BinOpr</name></type> <name>getbinopr</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="char">'+'</literal></expr>:</case> <return>return <expr><name>OPR_ADD</name></expr>;</return>
    <case>case <expr><literal type="char">'-'</literal></expr>:</case> <return>return <expr><name>OPR_SUB</name></expr>;</return>
    <case>case <expr><literal type="char">'*'</literal></expr>:</case> <return>return <expr><name>OPR_MUL</name></expr>;</return>
    <case>case <expr><literal type="char">'%'</literal></expr>:</case> <return>return <expr><name>OPR_MOD</name></expr>;</return>
    <case>case <expr><literal type="char">'^'</literal></expr>:</case> <return>return <expr><name>OPR_POW</name></expr>;</return>
    <case>case <expr><literal type="char">'/'</literal></expr>:</case> <return>return <expr><name>OPR_DIV</name></expr>;</return>
    <case>case <expr><name>TK_IDIV</name></expr>:</case> <return>return <expr><name>OPR_IDIV</name></expr>;</return>
    <case>case <expr><literal type="char">'&amp;'</literal></expr>:</case> <return>return <expr><name>OPR_BAND</name></expr>;</return>
    <case>case <expr><literal type="char">'|'</literal></expr>:</case> <return>return <expr><name>OPR_BOR</name></expr>;</return>
    <case>case <expr><literal type="char">'~'</literal></expr>:</case> <return>return <expr><name>OPR_BXOR</name></expr>;</return>
    <case>case <expr><name>TK_SHL</name></expr>:</case> <return>return <expr><name>OPR_SHL</name></expr>;</return>
    <case>case <expr><name>TK_SHR</name></expr>:</case> <return>return <expr><name>OPR_SHR</name></expr>;</return>
    <case>case <expr><name>TK_CONCAT</name></expr>:</case> <return>return <expr><name>OPR_CONCAT</name></expr>;</return>
    <case>case <expr><name>TK_NE</name></expr>:</case> <return>return <expr><name>OPR_NE</name></expr>;</return>
    <case>case <expr><name>TK_EQ</name></expr>:</case> <return>return <expr><name>OPR_EQ</name></expr>;</return>
    <case>case <expr><literal type="char">'&lt;'</literal></expr>:</case> <return>return <expr><name>OPR_LT</name></expr>;</return>
    <case>case <expr><name>TK_LE</name></expr>:</case> <return>return <expr><name>OPR_LE</name></expr>;</return>
    <case>case <expr><literal type="char">'&gt;'</literal></expr>:</case> <return>return <expr><name>OPR_GT</name></expr>;</return>
    <case>case <expr><name>TK_GE</name></expr>:</case> <return>return <expr><name>OPR_GE</name></expr>;</return>
    <case>case <expr><name>TK_AND</name></expr>:</case> <return>return <expr><name>OPR_AND</name></expr>;</return>
    <case>case <expr><name>TK_OR</name></expr>:</case> <return>return <expr><name>OPR_OR</name></expr>;</return>
    <default>default:</default> <return>return <expr><name>OPR_NOBINOPR</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
** Priority table for binary operators.
*/</comment>
<struct><specifier>static</specifier> <specifier>const</specifier> struct <block>{
  <decl_stmt><decl><type><name>lu_byte</name></type> <name>left</name></decl>;</decl_stmt>  <comment type="block">/* left priority for each binary operator */</comment>
  <decl_stmt><decl><type><name>lu_byte</name></type> <name>right</name></decl>;</decl_stmt> <comment type="block">/* right priority */</comment>
}</block> <decl><name><name>priority</name><index>[]</index></name> <init>= <expr><block>{  <comment type="block">/* ORDER OPR */</comment>
   <expr><block>{<expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>}</block></expr>,           <comment type="block">/* '+' '-' */</comment>
   <expr><block>{<expr><literal type="number">11</literal></expr>, <expr><literal type="number">11</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">11</literal></expr>, <expr><literal type="number">11</literal></expr>}</block></expr>,           <comment type="block">/* '*' '%' */</comment>
   <expr><block>{<expr><literal type="number">14</literal></expr>, <expr><literal type="number">13</literal></expr>}</block></expr>,                  <comment type="block">/* '^' (right associative) */</comment>
   <expr><block>{<expr><literal type="number">11</literal></expr>, <expr><literal type="number">11</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">11</literal></expr>, <expr><literal type="number">11</literal></expr>}</block></expr>,           <comment type="block">/* '/' '//' */</comment>
   <expr><block>{<expr><literal type="number">6</literal></expr>, <expr><literal type="number">6</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">4</literal></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr>}</block></expr>,   <comment type="block">/* '&amp;' '|' '~' */</comment>
   <expr><block>{<expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">7</literal></expr>, <expr><literal type="number">7</literal></expr>}</block></expr>,           <comment type="block">/* '&lt;&lt;' '&gt;&gt;' */</comment>
   <expr><block>{<expr><literal type="number">9</literal></expr>, <expr><literal type="number">8</literal></expr>}</block></expr>,                   <comment type="block">/* '..' (right associative) */</comment>
   <expr><block>{<expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,   <comment type="block">/* ==, &lt;, &lt;= */</comment>
   <expr><block>{<expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,   <comment type="block">/* ~=, &gt;, &gt;= */</comment>
   <expr><block>{<expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>            <comment type="block">/* and, or */</comment>
}</block></expr></init></decl>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNARY_PRIORITY</name></cpp:macro>	<cpp:value>12</cpp:value></cpp:define>  <comment type="block">/* priority for unary operators */</comment>


<comment type="block">/*
** subexpr -&gt; (simpleexp | unop subexpr) { binop subexpr }
** where 'binop' is any binary operator with a priority higher than 'limit'
*/</comment>
<function><type><specifier>static</specifier> <name>BinOpr</name></type> <name>subexpr</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BinOpr</name></type> <name>op</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>UnOpr</name></type> <name>uop</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>enterlevel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>uop</name> <operator>=</operator> <call><name>getunopr</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>uop</name> <operator>!=</operator> <name>OPR_NOUNOPR</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* prefix (unary) operator? */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip operator */</comment>
    <expr_stmt><expr><call><name>subexpr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>UNARY_PRIORITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaK_prefix</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>uop</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>simpleexp</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  <comment type="block">/* expand while operators have priorities higher than 'limit' */</comment>
  <expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>getbinopr</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>op</name> <operator>!=</operator> <name>OPR_NOBINOPR</name> <operator>&amp;&amp;</operator> <name><name>priority</name><index>[<expr><name>op</name></expr>]</index></name><operator>.</operator><name>left</name> <operator>&gt;</operator> <name>limit</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>expdesc</name></type> <name>v2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BinOpr</name></type> <name>nextop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip operator */</comment>
    <expr_stmt><expr><call><name>luaK_infix</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* read sub-expression with higher priority */</comment>
    <expr_stmt><expr><name>nextop</name> <operator>=</operator> <call><name>subexpr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v2</name></expr></argument>, <argument><expr><name><name>priority</name><index>[<expr><name>op</name></expr>]</index></name><operator>.</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaK_posfix</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v2</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>op</name> <operator>=</operator> <name>nextop</name></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>leavelevel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>op</name></expr>;</return>  <comment type="block">/* return first untreated operator */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>expr</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>subexpr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* }==================================================================== */</comment>



<comment type="block">/*
** {======================================================================
** Rules for Statements
** =======================================================================
*/</comment>


<function><type><specifier>static</specifier> <name>void</name></type> <name>block</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* block -&gt; statlist */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BlockCnt</name></type> <name>bl</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>enterblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>statlist</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** structure to chain all variables in the left-hand side of an
** assignment
*/</comment>
<struct>struct <name>LHS_assign</name> <block>{
  <decl_stmt><decl><type><name><name>struct</name> <name>LHS_assign</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>v</name></decl>;</decl_stmt>  <comment type="block">/* variable (global, local, upvalue, or indexed) */</comment>
}</block>;</struct>


<comment type="block">/*
** check whether, in an assignment to an upvalue/local variable, the
** upvalue/local variable is begin used in a previous assignment to a
** table. If so, save original upvalue/local value in a safe place and
** use this safe copy in the previous assignment.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>check_conflict</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>LHS_assign</name></name> <modifier>*</modifier></type><name>lh</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>extra</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* eventual position to save local variable */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>conflict</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <for>for <control>(<init>;</init> <condition><expr><name>lh</name></expr>;</condition> <incr><expr><name>lh</name> <operator>=</operator> <name><name>lh</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control> <block>{<block_content>  <comment type="block">/* check all previous assignments */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>vkisindexed</name><argument_list>(<argument><expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* assignment to table field? */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VINDEXUP</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* is table an upvalue? */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VUPVAL</name> <operator>&amp;&amp;</operator> <name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>conflict</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* table is the upvalue being assigned now */</comment>
          <expr_stmt><expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>VINDEXSTR</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>  <comment type="block">/* assignment will use safe copy */</comment>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if>
      <else>else <block>{<block_content>  <comment type="block">/* table is a register */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VLOCAL</name> <operator>&amp;&amp;</operator> <name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>t</name></name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>var</name><operator>.</operator><name>sidx</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>conflict</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* table is the local being assigned now */</comment>
          <expr_stmt><expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>  <comment type="block">/* assignment will use safe copy */</comment>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* is index the local being assigned? */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VINDEXED</name> <operator>&amp;&amp;</operator> <name><name>v</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VLOCAL</name> <operator>&amp;&amp;</operator>
            <name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>idx</name></name> <operator>==</operator> <name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>var</name><operator>.</operator><name>sidx</name></name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>conflict</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>u</name><operator>.</operator><name>ind</name><operator>.</operator><name>idx</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>  <comment type="block">/* previous assignment will use safe copy */</comment>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><name>conflict</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* copy upvalue/local value to a temporary (in position 'extra') */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>k</name></name> <operator>==</operator> <name>VLOCAL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_MOVE</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>var</name><operator>.</operator><name>sidx</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_GETUPVAL</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>info</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
** Parse and compile a multiple assignment. The first "variable"
** (a 'suffixedexp') was already read by the caller.
**
** assignment -&gt; suffixedexp restassign
** restassign -&gt; ',' suffixedexp restassign | '=' explist
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>restassign</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>LHS_assign</name></name> <modifier>*</modifier></type><name>lh</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvars</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>e</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>check_condition</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><call><name>vkisvar</name><argument_list>(<argument><expr><name><name>lh</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>k</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"syntax error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>check_readonly</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lh</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* restassign -&gt; ',' suffixedexp restassign */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>LHS_assign</name></name></type> <name>nv</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>nv</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <name>lh</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>suffixedexp</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nv</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vkisindexed</name><argument_list>(<argument><expr><name><name>nv</name><operator>.</operator><name>v</name><operator>.</operator><name>k</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>check_conflict</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>lh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nv</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>enterlevel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* control recursion depth */</comment>
    <expr_stmt><expr><call><name>restassign</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nv</name></expr></argument>, <argument><expr><name>nvars</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>leavelevel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>  <comment type="block">/* restassign -&gt; '=' explist */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>nexps</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nexps</name> <operator>=</operator> <call><name>explist</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nexps</name> <operator>!=</operator> <name>nvars</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>adjust_assign</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nvars</name></expr></argument>, <argument><expr><name>nexps</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>luaK_setoneret</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* close last expression */</comment>
      <expr_stmt><expr><call><name>luaK_storevar</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lh</name><operator>-&gt;</operator><name>v</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>  <comment type="block">/* avoid default */</comment>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>init_exp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><name>VNONRELOC</name></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>freereg</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* default assignment */</comment>
  <expr_stmt><expr><call><name>luaK_storevar</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lh</name><operator>-&gt;</operator><name>v</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>cond</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* cond -&gt; exp */</comment>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>v</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* read condition */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>v</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VNIL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>v</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>VFALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* 'falses' are all equal here */</comment>
  <expr_stmt><expr><call><name>luaK_goiftrue</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>v</name><operator>.</operator><name>f</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>gotostat</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TString</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* label's name */</comment>
  <decl_stmt><decl><type><name>Labeldesc</name> <modifier>*</modifier></type><name>lb</name> <init>= <expr><call><name>findlabel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>lb</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* no label? */</comment>
    <comment type="block">/* forward jump; will be resolved when the label is declared */</comment>
    <expr_stmt><expr><call><name>newgotoentry</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else <block>{<block_content>  <comment type="block">/* found a label */</comment>
    <comment type="block">/* backward jump; will be resolved here */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>lblevel</name> <init>= <expr><call><name>stacklevel</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>lb</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* label level */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>luaY_nvarstack</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>lblevel</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* leaving the scope of a variable? */</comment>
      <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_CLOSE</name></expr></argument>, <argument><expr><name>lblevel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* create jump and link it to the label */</comment>
    <expr_stmt><expr><call><name>luaK_patchlist</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>lb</name><operator>-&gt;</operator><name>pc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Break statement. Semantically equivalent to "goto break".
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>breakstat</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip break */</comment>
  <expr_stmt><expr><call><name>newgotoentry</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><call><name>luaS_newliteral</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><literal type="string">"break"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Check whether there is already a label with the given 'name'.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>checkrepeated</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Labeldesc</name> <modifier>*</modifier></type><name>lb</name> <init>= <expr><call><name>findlabel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>lb</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* already defined? */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><literal type="string">"label '%s' already defined on line %d"</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>lb</name><operator>-&gt;</operator><name>line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaK_semerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* error */</comment>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>labelstat</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* label -&gt; '::' NAME '::' */</comment>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_DBCOLON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip double colon */</comment>
  <while>while <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <literal type="char">';'</literal> <operator>||</operator> <name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <name>TK_DBCOLON</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>statement</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>  <comment type="block">/* skip other no-op statements */</comment>
  <expr_stmt><expr><call><name>checkrepeated</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* check for repeated labels */</comment>
  <expr_stmt><expr><call><name>createlabel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><call><name>block_follow</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>whilestat</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* whilestat -&gt; WHILE cond DO block END */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>whileinit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>condexit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BlockCnt</name></type> <name>bl</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip WHILE */</comment>
  <expr_stmt><expr><name>whileinit</name> <operator>=</operator> <call><name>luaK_getlabel</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>condexit</name> <operator>=</operator> <call><name>cond</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>enterblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_DO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_jumpto</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>whileinit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_END</name></expr></argument>, <argument><expr><name>TK_WHILE</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>condexit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* false conditions finish the loop */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>repeatstat</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* repeatstat -&gt; REPEAT block UNTIL cond */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>condexit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>repeat_init</name> <init>= <expr><call><name>luaK_getlabel</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BlockCnt</name></type> <name>bl1</name></decl>, <decl><type ref="prev"/><name>bl2</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>enterblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* loop block */</comment>
  <expr_stmt><expr><call><name>enterblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* scope block */</comment>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip REPEAT */</comment>
  <expr_stmt><expr><call><name>statlist</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_UNTIL</name></expr></argument>, <argument><expr><name>TK_REPEAT</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>condexit</name> <operator>=</operator> <call><name>cond</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* read condition (inside scope block) */</comment>
  <expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* finish scope */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>bl2</name><operator>.</operator><name>upval</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* upvalues? */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>exit</name> <init>= <expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* normal exit must jump over fix */</comment>
    <expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>condexit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* repetition must close upvalues */</comment>
    <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_CLOSE</name></expr></argument>, <argument><expr><call><name>stacklevel</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>bl2</name><operator>.</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>condexit</name> <operator>=</operator> <call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* repeat after closing upvalues */</comment>
    <expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>exit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* normal exit comes to here */</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>luaK_patchlist</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>condexit</name></expr></argument>, <argument><expr><name>repeat_init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* close the loop */</comment>
  <expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* finish loop */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Read an expression and generate code to put its results in next
** stack slot.
**
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>exp1</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>e</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>e</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VNONRELOC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Fix for instruction at position 'pc' to jump to 'dest'.
** (Jump addresses are relative in Lua). 'back' true means
** a back jump.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fixforjump</name> <parameter_list>(<parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>back</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>Instruction</name> <modifier>*</modifier></type><name>jmp</name> <init>= <expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>code</name><index>[<expr><name>pc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><name>dest</name> <operator>-</operator> <operator>(</operator><name>pc</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>back</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>-</operator><name>offset</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;</operator> <name>MAXARG_Bx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>ls</name></name></expr></argument>, <argument><expr><literal type="string">"control structure too long"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>SETARG_Bx</name><argument_list>(<argument><expr><operator>*</operator><name>jmp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
** Generate code for a 'for' loop.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>forbody</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvars</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isgen</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* forbody -&gt; DO block */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>OpCode</name></type> <name><name>forprep</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>OP_FORPREP</name></expr>, <expr><name>OP_TFORPREP</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>OpCode</name></type> <name><name>forloop</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>OP_FORLOOP</name></expr>, <expr><name>OP_TFORLOOP</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BlockCnt</name></type> <name>bl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>prep</name></decl>, <decl><type ref="prev"/><name>endfor</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_DO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>prep</name> <operator>=</operator> <call><name>luaK_codeABx</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>forprep</name><index>[<expr><name>isgen</name></expr>]</index></name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>enterblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* scope for declared variables */</comment>
  <expr_stmt><expr><call><name>adjustlocalvars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>nvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* end of scope for declared variables */</comment>
  <expr_stmt><expr><call><name>fixforjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>prep</name></expr></argument>, <argument><expr><call><name>luaK_getlabel</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>isgen</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* generic for? */</comment>
    <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_TFORCALL</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaK_fixline</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>endfor</name> <operator>=</operator> <call><name>luaK_codeABx</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>forloop</name><index>[<expr><name>isgen</name></expr>]</index></name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fixforjump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>endfor</name></expr></argument>, <argument><expr><name>prep</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_fixline</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>fornum</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>varname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* fornum -&gt; NAME = exp,exp[,exp] forbody */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>base</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"(for state)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"(for state)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"(for state)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>new_localvar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>exp1</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* initial value */</comment>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>exp1</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* limit */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>exp1</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* optional step */</comment>
  <else>else <block>{<block_content>  <comment type="block">/* default step = 1 */</comment>
    <expr_stmt><expr><call><name>luaK_int</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>luaK_reserveregs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>adjustlocalvars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* control variables */</comment>
  <expr_stmt><expr><call><name>forbody</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>forlist</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier></type><name>indexname</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* forlist -&gt; NAME {,NAME} IN explist forbody */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>e</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nvars</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* gen, state, control, toclose, 'indexname' */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>base</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* create control variables */</comment>
  <expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"(for state)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"(for state)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"(for state)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>new_localvarliteral</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"(for state)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* create declared variables */</comment>
  <expr_stmt><expr><call><name>new_localvar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>new_localvar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nvars</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></while>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_IN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>line</name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>adjust_assign</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><call><name>explist</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>adjustlocalvars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* control variables */</comment>
  <expr_stmt><expr><call><name>markupval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* last control var. must be closed */</comment>
  <expr_stmt><expr><call><name>luaK_checkstack</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* extra space to call generator */</comment>
  <expr_stmt><expr><call><name>forbody</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>nvars</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>forstat</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* forstat -&gt; FOR (fornum | forlist) END */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TString</name> <modifier>*</modifier></type><name>varname</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BlockCnt</name></type> <name>bl</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>enterblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* scope for loop and control variables */</comment>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip 'for' */</comment>
  <expr_stmt><expr><name>varname</name> <operator>=</operator> <call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* first variable name */</comment>
  <switch>switch <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="char">'='</literal></expr>:</case> <expr_stmt><expr><call><name>fornum</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <case>case <expr><literal type="char">','</literal></expr>:</case> <case>case <expr><name>TK_IN</name></expr>:</case> <expr_stmt><expr><call><name>forlist</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
    <default>default:</default> <expr_stmt><expr><call><name>luaX_syntaxerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"'=' or 'in' expected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_END</name></expr></argument>, <argument><expr><name>TK_FOR</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* loop scope ('break' jumps to this point) */</comment>
</block_content>}</block></function>


<comment type="block">/*
** Check whether next instruction is a single jump (a 'break', a 'goto'
** to a forward label, or a 'goto' to a backward label with no variable
** to close). If so, set the name of the 'label' it is jumping to
** ("break" for a 'break') or to where it is jumping to ('target') and
** return true. If not a single jump, leave input unchanged, to be
** handled as a regular statement.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>issinglejump</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>TString</name> <modifier>*</modifier><modifier>*</modifier></type><name>label</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_BREAK</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* a break? */</comment>
    <expr_stmt><expr><operator>*</operator><name>label</name> <operator>=</operator> <call><name>luaS_newliteral</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><literal type="string">"break"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>!=</operator> <name>TK_GOTO</name> <operator>||</operator> <call><name>luaX_lookahead</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TK_NAME</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>  <comment type="block">/* not a valid goto */</comment>
  <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>TString</name> <modifier>*</modifier></type><name>lname</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>lookahead</name><operator>.</operator><name>seminfo</name><operator>.</operator><name>ts</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* label's id */</comment>
    <decl_stmt><decl><type><name>Labeldesc</name> <modifier>*</modifier></type><name>lb</name> <init>= <expr><call><name>findlabel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>lname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>lb</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* a backward jump? */</comment>
      <comment type="block">/* does it need to close variables? */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>luaY_nvarstack</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>stacklevel</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name><name>lb</name><operator>-&gt;</operator><name>nactvar</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>  <comment type="block">/* not a single jump; cannot optimize */</comment>
      <expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <name><name>lb</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>  <comment type="block">/* jump forward */</comment>
      <expr_stmt><expr><operator>*</operator><name>label</name> <operator>=</operator> <name>lname</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip goto */</comment>
    <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip name */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>test_then_block</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>escapelist</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* test_then_block -&gt; [IF | ELSEIF] cond THEN block */</comment>
  <decl_stmt><decl><type><name>BlockCnt</name></type> <name>bl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TString</name> <modifier>*</modifier></type><name>jlb</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>target</name> <init>= <expr><name>NO_JUMP</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>jf</name></decl>;</decl_stmt>  <comment type="block">/* instruction to skip 'then' code (if condition is false) */</comment>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip IF or ELSEIF */</comment>
  <expr_stmt><expr><call><name>expr</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* read condition */</comment>
  <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_THEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>line</name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>issinglejump</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>jlb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* 'if x then goto' ? */</comment>
    <expr_stmt><expr><call><name>luaK_goiffalse</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* will jump to label if condition is true */</comment>
    <expr_stmt><expr><call><name>enterblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* must enter block before 'goto' */</comment>
    <if_stmt><if>if <condition>(<expr><name>jlb</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* forward jump? */</comment>
      <expr_stmt><expr><call><name>newgotoentry</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>jlb</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>t</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* will be resolved later */</comment>
    <else>else<block type="pseudo"><block_content>  <comment type="block">/* backward jump */</comment>
      <expr_stmt><expr><call><name>luaK_patchlist</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>t</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>  <comment type="block">/* jump directly to 'target' */</comment>
    <while>while <condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content/>}</block></while>  <comment type="block">/* skip semicolons */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>block_follow</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* jump is the entire block? */</comment>
      <expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>  <comment type="block">/* and that is it */</comment>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>  <comment type="block">/* must skip over 'then' part if condition is false */</comment>
      <expr_stmt><expr><name>jf</name> <operator>=</operator> <call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>  <comment type="block">/* regular case (not a jump) */</comment>
    <expr_stmt><expr><call><name>luaK_goiftrue</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip over block if condition is false */</comment>
    <expr_stmt><expr><call><name>enterblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>jf</name> <operator>=</operator> <name><name>v</name><operator>.</operator><name>f</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>statlist</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* 'then' part */</comment>
  <expr_stmt><expr><call><name>leaveblock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <name>TK_ELSE</name> <operator>||</operator>
      <name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <name>TK_ELSEIF</name></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* followed by 'else'/'elseif'? */</comment>
    <expr_stmt><expr><call><name>luaK_concat</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>escapelist</name></expr></argument>, <argument><expr><call><name>luaK_jump</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* must jump over it */</comment>
  <expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>jf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>ifstat</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* ifstat -&gt; IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>escapelist</name> <init>= <expr><name>NO_JUMP</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* exit list for finished parts */</comment>
  <expr_stmt><expr><call><name>test_then_block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>escapelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* IF cond THEN block */</comment>
  <while>while <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <name>TK_ELSEIF</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>test_then_block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>escapelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>  <comment type="block">/* ELSEIF cond THEN block */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_ELSE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>  <comment type="block">/* 'else' part */</comment>
  <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_END</name></expr></argument>, <argument><expr><name>TK_IF</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_patchtohere</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>escapelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* patch escape list to 'if' end */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>localfunc</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>b</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>fvar</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* function's variable index */</comment>
  <expr_stmt><expr><call><name>new_localvar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* new local variable */</comment>
  <expr_stmt><expr><call><name>adjustlocalvars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* enter its scope */</comment>
  <expr_stmt><expr><call><name>body</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* function created in next register */</comment>
  <comment type="block">/* debug information will only see the variable after this point! */</comment>
  <expr_stmt><expr><call><name>localdebuginfo</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>fvar</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>startpc</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>pc</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>getlocalattribute</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* ATTRIB -&gt; ['&lt;' Name '&gt;'] */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'&lt;'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attr</name> <init>= <expr><call><name>getstr</name><argument_list>(<argument><expr><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>checknext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'&gt;'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><literal type="string">"const"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>RDKCONST</name></expr>;</return></block_content></block></if>  <comment type="block">/* read-only variable */</comment>
    <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><literal type="string">"close"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>RDKTOCLOSE</name></expr>;</return></block_content></block></if>  <comment type="block">/* to-be-closed variable */</comment>
    <else>else<block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>luaK_semerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>,
        <argument><expr><call><name>luaO_pushfstring</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><literal type="string">"unknown attribute '%s'"</literal></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>VDKREG</name></expr>;</return>  <comment type="block">/* regular variable */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>checktoclose</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>level</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>  <comment type="block">/* is there a to-be-closed variable? */</comment>
    <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>markupval</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>bl</name><operator>-&gt;</operator><name>insidetbc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="block">/* in the scope of a to-be-closed variable */</comment>
    <expr_stmt><expr><call><name>luaK_codeABC</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>OP_TBC</name></expr></argument>, <argument><expr><call><name>stacklevel</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>localstat</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* stat -&gt; LOCAL ATTRIB NAME {',' ATTRIB NAME} ['=' explist] */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>toclose</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* index of to-be-closed variable (if any) */</comment>
  <decl_stmt><decl><type><name>Vardesc</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>  <comment type="block">/* last variable */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>vidx</name></decl>, <decl><type ref="prev"/><name>kind</name></decl>;</decl_stmt>  <comment type="block">/* index and kind of last variable */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>nvars</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nexps</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>e</name></decl>;</decl_stmt>
  <do>do <block>{<block_content>
    <expr_stmt><expr><name>vidx</name> <operator>=</operator> <call><name>new_localvar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>getlocalattribute</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>getlocalvardesc</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>vidx</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>vd</name><operator>.</operator><name>kind</name></name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>RDKTOCLOSE</name></expr>)</condition> <block>{<block_content>  <comment type="block">/* to-be-closed? */</comment>
      <if_stmt><if>if <condition>(<expr><name>toclose</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* one already present? */</comment>
        <expr_stmt><expr><call><name>luaK_semerror</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="string">"multiple to-be-closed variables in local list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>toclose</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name> <operator>+</operator> <name>nvars</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nvars</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block> while <condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>)</condition>;</do>
  <if_stmt><if>if <condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>nexps</name> <operator>=</operator> <call><name>explist</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>e</name><operator>.</operator><name>k</name></name> <operator>=</operator> <name>VVOID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nexps</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>getlocalvardesc</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>vidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* get last variable */</comment>
  <if_stmt><if>if <condition>(<expr><name>nvars</name> <operator>==</operator> <name>nexps</name> <operator>&amp;&amp;</operator>  <comment type="block">/* no adjustments? */</comment>
      <name><name>var</name><operator>-&gt;</operator><name>vd</name><operator>.</operator><name>kind</name></name> <operator>==</operator> <name>RDKCONST</name> <operator>&amp;&amp;</operator>  <comment type="block">/* last variable is const? */</comment>
      <call><name>luaK_exp2const</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>k</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>  <comment type="block">/* compile-time constant? */</comment>
    <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>vd</name><operator>.</operator><name>kind</name></name> <operator>=</operator> <name>RDKCTC</name></expr>;</expr_stmt>  <comment type="block">/* variable is a compile-time constant */</comment>
    <expr_stmt><expr><call><name>adjustlocalvars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nvars</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* exclude last variable */</comment>
    <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>nactvar</name></name><operator>++</operator></expr>;</expr_stmt>  <comment type="block">/* but count it */</comment>
  </block_content>}</block></if>
  <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>adjust_assign</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nvars</name></expr></argument>, <argument><expr><name>nexps</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>adjustlocalvars</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>nvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>checktoclose</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>toclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>funcname</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>expdesc</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* funcname -&gt; NAME {fieldsel} [':' NAME] */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ismethod</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>singlevar</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fieldsel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>ismethod</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fieldsel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>ismethod</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>funcstat</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* funcstat -&gt; FUNCTION funcname body */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ismethod</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>v</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip FUNCTION */</comment>
  <expr_stmt><expr><name>ismethod</name> <operator>=</operator> <call><name>funcname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>body</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><name>ismethod</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_storevar</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaK_fixline</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* definition "happens" in the first line */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>exprstat</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* stat -&gt; func | assignment */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>LHS_assign</name></name></type> <name>v</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>suffixedexp</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <literal type="char">'='</literal> <operator>||</operator> <name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition> <block>{<block_content> <comment type="block">/* stat -&gt; assignment ? */</comment>
    <expr_stmt><expr><name><name>v</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>restassign</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if>
  <else>else <block>{<block_content>  <comment type="block">/* stat -&gt; func */</comment>
    <decl_stmt><decl><type><name>Instruction</name> <modifier>*</modifier></type><name>inst</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>check_condition</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name><name>v</name><operator>.</operator><name>v</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VCALL</name></expr></argument>, <argument><expr><literal type="string">"syntax error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>inst</name> <operator>=</operator> <operator>&amp;</operator><call><name>getinstruction</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SETARG_C</name><argument_list>(<argument><expr><operator>*</operator><name>inst</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* call statement uses no results */</comment>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>retstat</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* stat -&gt; RETURN [explist] [';'] */</comment>
  <decl_stmt><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>expdesc</name></type> <name>e</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nret</name></decl>;</decl_stmt>  <comment type="block">/* number of values being returned */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>first</name> <init>= <expr><call><name>luaY_nvarstack</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* first slot to be returned */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>block_follow</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name> <operator>==</operator> <literal type="char">';'</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>nret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* return no values */</comment>
  <else>else <block>{<block_content>
    <expr_stmt><expr><name>nret</name> <operator>=</operator> <call><name>explist</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* optional return values */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>hasmultret</name><argument_list>(<argument><expr><name><name>e</name><operator>.</operator><name>k</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>luaK_setmultret</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>e</name><operator>.</operator><name>k</name></name> <operator>==</operator> <name>VCALL</name> <operator>&amp;&amp;</operator> <name>nret</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>fs</name><operator>-&gt;</operator><name>bl</name><operator>-&gt;</operator><name>insidetbc</name></name></expr>)</condition> <block>{<block_content>  <comment type="block">/* tail call? */</comment>
        <expr_stmt><expr><call><name>SET_OPCODE</name><argument_list>(<argument><expr><call><name>getinstruction</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>OP_TAILCALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>GETARG_A</name><argument_list>(<argument><expr><call><name>getinstruction</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>luaY_nvarstack</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>nret</name> <operator>=</operator> <name>LUA_MULTRET</name></expr>;</expr_stmt>  <comment type="block">/* return all values */</comment>
    </block_content>}</block></if>
    <else>else <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>nret</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* only one single value? */</comment>
        <expr_stmt><expr><name>first</name> <operator>=</operator> <call><name>luaK_exp2anyreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>  <comment type="block">/* can use original slot */</comment>
      <else>else <block>{<block_content>  <comment type="block">/* values must go to the top of the stack */</comment>
        <expr_stmt><expr><call><name>luaK_exp2nextreg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>nret</name> <operator>==</operator> <name><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>-</operator> <name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><call><name>luaK_ret</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><name>nret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip optional semicolon */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>statement</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>line</name> <init>= <expr><name><name>ls</name><operator>-&gt;</operator><name>linenumber</name></name></expr></init></decl>;</decl_stmt>  <comment type="block">/* may be needed for error messages */</comment>
  <expr_stmt><expr><call><name>enterlevel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name><name>ls</name><operator>-&gt;</operator><name>t</name><operator>.</operator><name>token</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><literal type="char">';'</literal></expr>:</case> <block>{<block_content>  <comment type="block">/* stat -&gt; ';' (empty statement) */</comment>
      <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip ';' */</comment>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_IF</name></expr>:</case> <block>{<block_content>  <comment type="block">/* stat -&gt; ifstat */</comment>
      <expr_stmt><expr><call><name>ifstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_WHILE</name></expr>:</case> <block>{<block_content>  <comment type="block">/* stat -&gt; whilestat */</comment>
      <expr_stmt><expr><call><name>whilestat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_DO</name></expr>:</case> <block>{<block_content>  <comment type="block">/* stat -&gt; DO block END */</comment>
      <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip DO */</comment>
      <expr_stmt><expr><call><name>block</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>check_match</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_END</name></expr></argument>, <argument><expr><name>TK_DO</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_FOR</name></expr>:</case> <block>{<block_content>  <comment type="block">/* stat -&gt; forstat */</comment>
      <expr_stmt><expr><call><name>forstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_REPEAT</name></expr>:</case> <block>{<block_content>  <comment type="block">/* stat -&gt; repeatstat */</comment>
      <expr_stmt><expr><call><name>repeatstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_FUNCTION</name></expr>:</case> <block>{<block_content>  <comment type="block">/* stat -&gt; funcstat */</comment>
      <expr_stmt><expr><call><name>funcstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_LOCAL</name></expr>:</case> <block>{<block_content>  <comment type="block">/* stat -&gt; localstat */</comment>
      <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip LOCAL */</comment>
      <if_stmt><if>if <condition>(<expr><call><name>testnext</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_FUNCTION</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>  <comment type="block">/* local function? */</comment>
        <expr_stmt><expr><call><name>localfunc</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>localstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_DBCOLON</name></expr>:</case> <block>{<block_content>  <comment type="block">/* stat -&gt; label */</comment>
      <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip double colon */</comment>
      <expr_stmt><expr><call><name>labelstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><call><name>str_checkname</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_RETURN</name></expr>:</case> <block>{<block_content>  <comment type="block">/* stat -&gt; retstat */</comment>
      <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip RETURN */</comment>
      <expr_stmt><expr><call><name>retstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_BREAK</name></expr>:</case> <block>{<block_content>  <comment type="block">/* stat -&gt; breakstat */</comment>
      <expr_stmt><expr><call><name>breakstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>TK_GOTO</name></expr>:</case> <block>{<block_content>  <comment type="block">/* stat -&gt; 'goto' NAME */</comment>
      <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* skip 'goto' */</comment>
      <expr_stmt><expr><call><name>gotostat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>  <comment type="block">/* stat -&gt; func | assignment */</comment>
      <expr_stmt><expr><call><name>exprstat</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block>
  </block_content>}</block></switch>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>f</name><operator>-&gt;</operator><name>maxstacksize</name></name> <operator>&gt;=</operator> <name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>&amp;&amp;</operator>
             <name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>&gt;=</operator> <call><name>luaY_nvarstack</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name><operator>-&gt;</operator><name>freereg</name></name> <operator>=</operator> <call><name>luaY_nvarstack</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* free registers */</comment>
  <expr_stmt><expr><call><name>leavelevel</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* }====================================================================== */</comment>


<comment type="block">/*
** compiles the main function, which is a regular vararg function with an
** upvalue named LUA_ENV
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>mainfunc</name> <parameter_list>(<parameter><decl><type><name>LexState</name> <modifier>*</modifier></type><name>ls</name></decl></parameter>, <parameter><decl><type><name>FuncState</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BlockCnt</name></type> <name>bl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>Upvaldesc</name> <modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>open_func</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setvararg</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* main function is always declared vararg */</comment>
  <expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>allocupvalue</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* ...set environment upvalue */</comment>
  <expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>instack</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>VDKREG</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>env</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>ls</name><operator>-&gt;</operator><name>envn</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaC_objbarrier</name><argument_list>(<argument><expr><name><name>ls</name><operator>-&gt;</operator><name>L</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>env</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaX_next</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* read first token */</comment>
  <expr_stmt><expr><call><name>statlist</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* parse main body */</comment>
  <expr_stmt><expr><call><name>check</name><argument_list>(<argument><expr><name>ls</name></expr></argument>, <argument><expr><name>TK_EOS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>close_func</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>LClosure</name> <modifier>*</modifier></type><name>luaY_parser</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>ZIO</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>Mbuffer</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>,
                       <parameter><decl><type><name>Dyndata</name> <modifier>*</modifier></type><name>dyd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>firstchar</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>LexState</name></type> <name>lexstate</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FuncState</name></type> <name>funcstate</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LClosure</name> <modifier>*</modifier></type><name>cl</name> <init>= <expr><call><name>luaF_newLclosure</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* create main closure */</comment>
  <expr_stmt><expr><call><name>setclLvalue2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>, <argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* anchor it (to avoid being collected) */</comment>
  <expr_stmt><expr><call><name>luaD_inctop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lexstate</name><operator>.</operator><name>h</name></name> <operator>=</operator> <call><name>luaH_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* create table for scanner */</comment>
  <expr_stmt><expr><call><name>sethvalue2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>, <argument><expr><name><name>lexstate</name><operator>.</operator><name>h</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* anchor it */</comment>
  <expr_stmt><expr><call><name>luaD_inctop</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>funcstate</name><operator>.</operator><name>f</name></name> <operator>=</operator> <name><name>cl</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <call><name>luaF_newproto</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaC_objbarrier</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>cl</name></expr></argument>, <argument><expr><name><name>cl</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>funcstate</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <call><name>luaS_new</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* create and anchor TString */</comment>
  <expr_stmt><expr><call><name>luaC_objbarrier</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>funcstate</name><operator>.</operator><name>f</name></name></expr></argument>, <argument><expr><name><name>funcstate</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>source</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lexstate</name><operator>.</operator><name>buff</name></name> <operator>=</operator> <name>buff</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lexstate</name><operator>.</operator><name>dyd</name></name> <operator>=</operator> <name>dyd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dyd</name><operator>-&gt;</operator><name>actvar</name><operator>.</operator><name>n</name></name> <operator>=</operator> <name><name>dyd</name><operator>-&gt;</operator><name>gt</name><operator>.</operator><name>n</name></name> <operator>=</operator> <name><name>dyd</name><operator>-&gt;</operator><name>label</name><operator>.</operator><name>n</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>luaX_setinput</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lexstate</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><name><name>funcstate</name><operator>.</operator><name>f</name><operator>-&gt;</operator><name>source</name></name></expr></argument>, <argument><expr><name>firstchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>mainfunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lexstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>funcstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>funcstate</name><operator>.</operator><name>prev</name></name> <operator>&amp;&amp;</operator> <name><name>funcstate</name><operator>.</operator><name>nups</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>lexstate</name><operator>.</operator><name>fs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* all scopes should be correctly finished */</comment>
  <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>dyd</name><operator>-&gt;</operator><name>actvar</name><operator>.</operator><name>n</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>dyd</name><operator>-&gt;</operator><name>gt</name><operator>.</operator><name>n</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>dyd</name><operator>-&gt;</operator><name>label</name><operator>.</operator><name>n</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>--</operator></expr>;</expr_stmt>  <comment type="block">/* remove scanner's table */</comment>
  <return>return <expr><name>cl</name></expr>;</return>  <comment type="block">/* closure is on the stack, too */</comment>
</block_content>}</block></function>

</unit>
