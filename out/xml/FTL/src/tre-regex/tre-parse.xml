<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/tre-regex/tre-parse.c"><comment type="block">/*
  tre-parse.c - Regexp parser

  This software is released under a BSD-style license.
  See the file LICENSE for details and copyright.

*/</comment>

<comment type="block">/*
  This parser is just a simple recursive descent parser for POSIX.2
  regexps.  The parser supports both the obsolete default syntax and
  the "extended" syntax, and some nonstandard extensions.
*/</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;config.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_CONFIG_H */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmalloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre-mem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre-ast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre-stack.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre-parse.h"</cpp:file></cpp:include>


<comment type="block">/* Characters with special meanings in regexp syntax. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_PIPE</name></cpp:macro>	   <cpp:value>L'|'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_LPAREN</name></cpp:macro>	   <cpp:value>L'('</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_RPAREN</name></cpp:macro>	   <cpp:value>L')'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_LBRACE</name></cpp:macro>	   <cpp:value>L'{'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_RBRACE</name></cpp:macro>	   <cpp:value>L'}'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_LBRACKET</name></cpp:macro>	   <cpp:value>L'['</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_RBRACKET</name></cpp:macro>	   <cpp:value>L']'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_MINUS</name></cpp:macro>	   <cpp:value>L'-'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_STAR</name></cpp:macro>	   <cpp:value>L'*'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_QUESTIONMARK</name></cpp:macro>  <cpp:value>L'?'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_PLUS</name></cpp:macro>	   <cpp:value>L'+'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_PERIOD</name></cpp:macro>	   <cpp:value>L'.'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_COLON</name></cpp:macro>	   <cpp:value>L':'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_EQUAL</name></cpp:macro>	   <cpp:value>L'='</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_COMMA</name></cpp:macro>	   <cpp:value>L','</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_CARET</name></cpp:macro>	   <cpp:value>L'^'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_DOLLAR</name></cpp:macro>	   <cpp:value>L'$'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_BACKSLASH</name></cpp:macro>	   <cpp:value>L'\\'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_HASH</name></cpp:macro>	   <cpp:value>L'#'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_TILDE</name></cpp:macro>	   <cpp:value>L'~'</cpp:value></cpp:define>


<comment type="block">/* Some macros for expanding \w, \s, etc. */</comment>
<struct><specifier>static</specifier> <specifier>const</specifier> struct <name>tre_macro_struct</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>expansion</name></decl>;</decl_stmt>
}</block> <decl><name><name>tre_macros</name><index>[]</index></name> <init>=
  <expr><block>{ <expr><block>{<expr><literal type="char">'t'</literal></expr>, <expr><literal type="string">"\t"</literal></expr>}</block></expr>,	   <expr><block>{<expr><literal type="char">'n'</literal></expr>, <expr><literal type="string">"\n"</literal></expr>}</block></expr>,		   <expr><block>{<expr><literal type="char">'r'</literal></expr>, <expr><literal type="string">"\r"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="char">'f'</literal></expr>, <expr><literal type="string">"\f"</literal></expr>}</block></expr>,	   <expr><block>{<expr><literal type="char">'a'</literal></expr>, <expr><literal type="string">"\a"</literal></expr>}</block></expr>,		   <expr><block>{<expr><literal type="char">'e'</literal></expr>, <expr><literal type="string">"\033"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="char">'w'</literal></expr>, <expr><literal type="string">"[[:alnum:]_]"</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="char">'W'</literal></expr>, <expr><literal type="string">"[^[:alnum:]_]"</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="char">'s'</literal></expr>, <expr><literal type="string">"[[:space:]]"</literal></expr>}</block></expr>,
    <expr><block>{<expr><literal type="char">'S'</literal></expr>, <expr><literal type="string">"[^[:space:]]"</literal></expr>}</block></expr>, <expr><block>{<expr><literal type="char">'d'</literal></expr>, <expr><literal type="string">"[[:digit:]]"</literal></expr>}</block></expr>,   <expr><block>{<expr><literal type="char">'D'</literal></expr>, <expr><literal type="string">"[^[:digit:]]"</literal></expr>}</block></expr>,
    <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>
  }</block></expr></init></decl>;</struct>


<comment type="block">/* Expands a macro delimited by `regex' and `regex_end' to `buf', which
   must have at least `len' items.  Sets buf[0] to zero if the there
   is no match in `tre_macros'. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tre_expand_macro</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>tre_char_t</name> <modifier>*</modifier></type><name>regex</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>tre_char_t</name> <modifier>*</modifier></type><name>regex_end</name></decl></parameter>,
		 <parameter><decl><type><name>tre_char_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>buf_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>regex</name> <operator>&gt;=</operator> <name>regex_end</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>tre_macros</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>expansion</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>tre_macros</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>c</name> <operator>==</operator> <operator>*</operator><name>regex</name></expr>)</condition>
	<block>{<block_content>
	  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>j</name></decl>;</decl_stmt>
	  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Expanding macro '%c' =&gt; '%s'\n"</literal><operator>,</operator>
		  <name><name>tre_macros</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>c</name><operator>,</operator> <name><name>tre_macros</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>expansion</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>tre_macros</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>expansion</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>buf_len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	    <expr_stmt><expr><name><name>buf</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>tre_macros</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>expansion</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	  <expr_stmt><expr><name><name>buf</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	  <break>break;</break>
	</block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>reg_errcode_t</name></type>
<name>tre_new_item</name><parameter_list>(<parameter><decl><type><name>tre_mem_t</name></type> <name>mem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>i</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>max_i</name></decl></parameter>,
	 <parameter><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>items</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>reg_errcode_t</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>array</name> <init>= <expr><operator>*</operator><name>items</name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Allocate more space if necessary. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>i</name> <operator>&gt;=</operator> <operator>*</operator><name>max_i</name></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>new_items</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"out of array space, i = %d\n"</literal><operator>,</operator> <operator>*</operator><name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* If the array is already 1024 items large, give up -- there's
	 probably an error in the regexp (e.g. not a '\0' terminated
	 string and missing ']') */</comment>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>max_i</name> <operator>&gt;</operator> <literal type="number">1024</literal></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>max_i</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>new_items</name> <operator>=</operator> <call><name>xrealloc</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>items</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>*</operator><name>max_i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>new_items</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>items</name> <operator>=</operator> <name>array</name> <operator>=</operator> <name>new_items</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>array</name><index>[<expr><operator>*</operator><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>status</name> <operator>=</operator> <ternary><condition><expr><name><name>array</name><index>[<expr><operator>*</operator><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>REG_ESPACE</name></expr> </then><else>: <expr><name>REG_OK</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><operator>*</operator><name>i</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Expands a character class to character ranges. */</comment>
<function><type><specifier>static</specifier> <name>reg_errcode_t</name></type>
<name>tre_expand_ctype</name><parameter_list>(<parameter><decl><type><name>tre_mem_t</name></type> <name>mem</name></decl></parameter>, <parameter><decl><type><name>tre_ctype_t</name></type> <name>class</name></decl></parameter>, <parameter><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>items</name></decl></parameter>,
		 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>i</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>max_i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>reg_errcode_t</name></type> <name>status</name> <init>= <expr><name>REG_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_cint_t</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>min</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>max</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>TRE_MB_CUR_MAX</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  expanding class to character ranges\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>j</name> <operator>&lt;</operator> <literal type="number">256</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>status</name> <operator>==</operator> <name>REG_OK</name><operator>)</operator></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>tre_cint_t</name><operator>)</operator> <name>j</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>tre_isctype</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>class</name></expr></argument>)</argument_list></call>
	  <operator>||</operator> <operator>(</operator><operator>(</operator><name>cflags</name> <operator>&amp;</operator> <name>REG_ICASE</name><operator>)</operator>
	      <operator>&amp;&amp;</operator> <operator>(</operator><call><name>tre_isctype</name><argument_list>(<argument><expr><call><name>tre_tolower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>class</name></expr></argument>)</argument_list></call>
		  <operator>||</operator> <call><name>tre_isctype</name><argument_list>(<argument><expr><call><name>tre_toupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>class</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>
<block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>min</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>min</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <expr_stmt><expr><name>max</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
	</block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>min</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  range %c (%d) to %c (%d)\n"</literal><operator>,</operator> <name>min</name><operator>,</operator> <name>min</name><operator>,</operator> <name>max</name><operator>,</operator> <name>max</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_new_item</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>max_i</name></expr></argument>, <argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>min</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><name>min</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>status</name> <operator>==</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_new_item</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>max_i</name></expr></argument>, <argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>tre_compare_items</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>tre_ast_node_t</name> <modifier>*</modifier></type><name>node_a</name> <init>= <expr><operator>*</operator><operator>(</operator><name>tre_ast_node_t</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name>a</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>tre_ast_node_t</name> <modifier>*</modifier></type><name>node_b</name> <init>= <expr><operator>*</operator><operator>(</operator><name>tre_ast_node_t</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name>b</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_literal_t</name> <modifier>*</modifier></type><name>l_a</name> <init>= <expr><name><name>node_a</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>l_b</name> <init>= <expr><name><name>node_b</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>a_min</name> <init>= <expr><name><name>l_a</name><operator>-&gt;</operator><name>code_min</name></name></expr></init></decl>, <decl><type ref="prev"/><name>b_min</name> <init>= <expr><name><name>l_b</name><operator>-&gt;</operator><name>code_min</name></name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>a_min</name> <operator>&lt;</operator> <name>b_min</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>a_min</name> <operator>&gt;</operator> <name>b_min</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TRE_USE_SYSTEM_WCTYPE</name></cpp:ifndef>

<comment type="block">/* isalnum() and the rest may be macros, so wrap them to functions. */</comment>
<function><type><name>int</name></type> <name>tre_isalnum_func</name><parameter_list>(<parameter><decl><type><name>tre_cint_t</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>tre_isalnum</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>tre_isalpha_func</name><parameter_list>(<parameter><decl><type><name>tre_cint_t</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>tre_isalpha</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>tre_isascii</name></cpp:ifdef>
<function><type><name>int</name></type> <name>tre_isascii_func</name><parameter_list>(<parameter><decl><type><name>tre_cint_t</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>tre_isascii</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !tre_isascii */</comment>
<function><type><name>int</name></type> <name>tre_isascii_func</name><parameter_list>(<parameter><decl><type><name>tre_cint_t</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>!</operator><operator>(</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">7</literal><operator>)</operator></expr>;</return> </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !tre_isascii */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>tre_isblank</name></cpp:ifdef>
<function><type><name>int</name></type> <name>tre_isblank_func</name><parameter_list>(<parameter><decl><type><name>tre_cint_t</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>tre_isblank</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !tre_isblank */</comment>
<function><type><name>int</name></type> <name>tre_isblank_func</name><parameter_list>(<parameter><decl><type><name>tre_cint_t</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>(</operator><operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">' '</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'\t'</literal><operator>)</operator><operator>)</operator></expr>;</return> </block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !tre_isblank */</comment>

<function><type><name>int</name></type> <name>tre_iscntrl_func</name><parameter_list>(<parameter><decl><type><name>tre_cint_t</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>tre_iscntrl</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>tre_isdigit_func</name><parameter_list>(<parameter><decl><type><name>tre_cint_t</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>tre_isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>tre_isgraph_func</name><parameter_list>(<parameter><decl><type><name>tre_cint_t</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>tre_isgraph</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>tre_islower_func</name><parameter_list>(<parameter><decl><type><name>tre_cint_t</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>tre_islower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>tre_isprint_func</name><parameter_list>(<parameter><decl><type><name>tre_cint_t</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>tre_isprint</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>tre_ispunct_func</name><parameter_list>(<parameter><decl><type><name>tre_cint_t</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>tre_ispunct</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>tre_isspace_func</name><parameter_list>(<parameter><decl><type><name>tre_cint_t</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>tre_isspace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>tre_isupper_func</name><parameter_list>(<parameter><decl><type><name>tre_cint_t</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>tre_isupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>int</name></type> <name>tre_isxdigit_func</name><parameter_list>(<parameter><decl><type><name>tre_cint_t</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>tre_isxdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<struct>struct <block>{
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
  <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>tre_cint_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
}</block> <decl><name><name>tre_ctype_map</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{ <expr><literal type="string">"alnum"</literal></expr>, <expr><operator>&amp;</operator><name>tre_isalnum_func</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"alpha"</literal></expr>, <expr><operator>&amp;</operator><name>tre_isalpha_func</name></expr> }</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>tre_isascii</name></cpp:ifdef>
  <expr><block>{ <expr><literal type="string">"ascii"</literal></expr>, <expr><operator>&amp;</operator><name>tre_isascii_func</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* tre_isascii */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>tre_isblank</name></cpp:ifdef>
  <expr><block>{ <expr><literal type="string">"blank"</literal></expr>, <expr><operator>&amp;</operator><name>tre_isblank_func</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* tre_isblank */</comment>
  <expr><block>{ <expr><literal type="string">"cntrl"</literal></expr>, <expr><operator>&amp;</operator><name>tre_iscntrl_func</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"digit"</literal></expr>, <expr><operator>&amp;</operator><name>tre_isdigit_func</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"graph"</literal></expr>, <expr><operator>&amp;</operator><name>tre_isgraph_func</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"lower"</literal></expr>, <expr><operator>&amp;</operator><name>tre_islower_func</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"print"</literal></expr>, <expr><operator>&amp;</operator><name>tre_isprint_func</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"punct"</literal></expr>, <expr><operator>&amp;</operator><name>tre_ispunct_func</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"space"</literal></expr>, <expr><operator>&amp;</operator><name>tre_isspace_func</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"upper"</literal></expr>, <expr><operator>&amp;</operator><name>tre_isupper_func</name></expr> }</block></expr>,
  <expr><block>{ <expr><literal type="string">"xdigit"</literal></expr>, <expr><operator>&amp;</operator><name>tre_isxdigit_func</name></expr> }</block></expr>,
  <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</struct>

<function><type><name>tre_ctype_t</name></type> <name>tre_ctype</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>tre_ctype_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>tre_ctype_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name><name>tre_ctype_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>func</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  <return>return <expr><operator>(</operator><name>tre_ctype_t</name><operator>)</operator><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !TRE_USE_SYSTEM_WCTYPE */</comment>

<comment type="block">/* Maximum number of character classes that can occur in a negated bracket
   expression.	*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_NEG_CLASSES</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>

<comment type="block">/* Maximum length of character class names. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_CLASS_NAME</name></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REST</name><parameter_list>(<parameter><type><name>re</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(int)(ctx-&gt;re_end - (re)), (re)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>reg_errcode_t</name></type>
<name>tre_parse_bracket_items</name><parameter_list>(<parameter><decl><type><name>tre_parse_ctx_t</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>negate</name></decl></parameter>,
			<parameter><decl><type><name>tre_ctype_t</name></type> <name><name>neg_classes</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_neg_classes</name></decl></parameter>,
			<parameter><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>items</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_items</name></decl></parameter>,
			<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>items_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>tre_char_t</name> <modifier>*</modifier></type><name>re</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>reg_errcode_t</name></type> <name>status</name> <init>= <expr><name>REG_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_ctype_t</name></type> <name>class</name> <init>= <expr><operator>(</operator><name>tre_ctype_t</name><operator>)</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><operator>*</operator><name>num_items</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>max_i</name> <init>= <expr><operator>*</operator><name>items_size</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>skip</name></decl>;</decl_stmt>

  <comment type="block">/* Build an array of the items in the bracket expression. */</comment>
  <while>while <condition>(<expr><name>status</name> <operator>==</operator> <name>REG_OK</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>skip</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>re</name> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><name>status</name> <operator>=</operator> <name>REG_EBRACK</name></expr>;</expr_stmt>
	</block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><operator>*</operator><name>re</name> <operator>==</operator> <name>CHAR_RBRACKET</name> <operator>&amp;&amp;</operator> <name>re</name> <operator>&gt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse_bracket:	done: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator> <call><name>REST</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>re</name><operator>++</operator></expr>;</expr_stmt>
	  <break>break;</break>
	</block_content>}</block></if>
      <else>else
	<block>{<block_content>
	  <decl_stmt><decl><type><name>tre_cint_t</name></type> <name>min</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>max</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	  <expr_stmt><expr><name>class</name> <operator>=</operator> <operator>(</operator><name>tre_ctype_t</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name>re</name> <operator>+</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name>
	      <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>re</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>CHAR_MINUS</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>re</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>!=</operator> <name>CHAR_RBRACKET</name></expr>)</condition>
	    <block>{<block_content>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse_bracket:  range: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator> <call><name>REST</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><name>min</name> <operator>=</operator> <operator>*</operator><name>re</name></expr>;</expr_stmt>
	      <expr_stmt><expr><name>max</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>re</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
	      <expr_stmt><expr><name>re</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	      <comment type="block">/* XXX - Should use collation order instead of encoding values
		 in character ranges. */</comment>
	      <if_stmt><if>if <condition>(<expr><name>min</name> <operator>&gt;</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>REG_ERANGE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	    </block_content>}</block></if>
	  <if type="elseif">else if <condition>(<expr><name>re</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name>
		   <operator>&amp;&amp;</operator> <operator>*</operator><name>re</name> <operator>==</operator> <name>CHAR_LBRACKET</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>re</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>CHAR_PERIOD</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>status</name> <operator>=</operator> <name>REG_ECOLLATE</name></expr>;</expr_stmt></block_content></block></if>
	  <if type="elseif">else if <condition>(<expr><name>re</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name>
		   <operator>&amp;&amp;</operator> <operator>*</operator><name>re</name> <operator>==</operator> <name>CHAR_LBRACKET</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>re</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>CHAR_EQUAL</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>status</name> <operator>=</operator> <name>REG_ECOLLATE</name></expr>;</expr_stmt></block_content></block></if>
	  <if type="elseif">else if <condition>(<expr><name>re</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name>
		   <operator>&amp;&amp;</operator> <operator>*</operator><name>re</name> <operator>==</operator> <name>CHAR_LBRACKET</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>re</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>CHAR_COLON</name></expr>)</condition>
	    <block>{<block_content>
	      <decl_stmt><decl><type><name>char</name></type> <name><name>tmp_str</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
	      <decl_stmt><decl><type><specifier>const</specifier> <name>tre_char_t</name> <modifier>*</modifier></type><name>endptr</name> <init>= <expr><name>re</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
	      <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse_bracket:  class: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator> <call><name>REST</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <while>while <condition>(<expr><name>endptr</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>endptr</name> <operator>!=</operator> <name>CHAR_COLON</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	      <if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>!=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>endptr</name> <operator>-</operator> <name>re</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">63</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_WCHAR</name></cpp:ifdef>
		  <block>{<block_content>
		    <decl_stmt><decl><type><name>tre_char_t</name></type> <name><name>tmp_wcs</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
		    <expr_stmt><expr><call><name>wcsncpy</name><argument_list>(<argument><expr><name>tmp_wcs</name></expr></argument>, <argument><expr><name>re</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name><name>tmp_wcs</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>L</name><literal type="char">'\0'</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>HAVE_WCSRTOMBS</name></expr></cpp:if>
		    <block>{<block_content>
		      <decl_stmt><decl><type><name>mbstate_t</name></type> <name>state</name></decl>;</decl_stmt>
		      <decl_stmt><decl><type><specifier>const</specifier> <name>tre_char_t</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name>tmp_wcs</name></expr></init></decl>;</decl_stmt>
		      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>wcsrtombs</name><argument_list>(<argument><expr><name>tmp_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>src</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp_str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    </block_content>}</block>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>HAVE_WCSTOMBS</name></expr></cpp:elif>
		    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>wcstombs</name><argument_list>(<argument><expr><name>tmp_str</name></expr></argument>, <argument><expr><name>tmp_wcs</name></expr></argument>, <argument><expr><literal type="number">63</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined HAVE_WCSTOMBS */</comment>
		  </block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !TRE_WCHAR */</comment>
		  <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>tmp_str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>re</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !TRE_WCHAR */</comment>
		  <expr_stmt><expr><name><name>tmp_str</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  class name: %s\n"</literal><operator>,</operator> <name>tmp_str</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><name>class</name> <operator>=</operator> <call><name>tre_ctype</name><argument_list>(<argument><expr><name>tmp_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>class</name></expr>)</condition><block type="pseudo"><block_content>
		    <expr_stmt><expr><name>status</name> <operator>=</operator> <name>REG_ECTYPE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		  <comment type="block">/* Optimize character classes for 8 bit character sets. */</comment>
		  <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>REG_OK</name> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>cur_max</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		    <block>{<block_content>
		      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_expand_ctype</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>class</name></expr></argument>, <argument><expr><name>items</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max_i</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name>class</name> <operator>=</operator> <operator>(</operator><name>tre_ctype_t</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
		      <expr_stmt><expr><name>skip</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		    </block_content>}</block></if></if_stmt>
		  <expr_stmt><expr><name>re</name> <operator>=</operator> <name>endptr</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
	      <else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>REG_ECTYPE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	      <expr_stmt><expr><name>min</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	      <expr_stmt><expr><name>max</name> <operator>=</operator> <name>TRE_CHAR_MAX</name></expr>;</expr_stmt>
	    </block_content>}</block></if>
	  <else>else
	    <block>{<block_content>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse_bracket:   char: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator> <call><name>REST</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>re</name> <operator>==</operator> <name>CHAR_MINUS</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>re</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <name>CHAR_RBRACKET</name>
		  <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>!=</operator> <name>re</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* Two ranges are not allowed to share and endpoint. */</comment>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>REG_ERANGE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	      <expr_stmt><expr><name>min</name> <operator>=</operator> <name>max</name> <operator>=</operator> <operator>*</operator><name>re</name><operator>++</operator></expr>;</expr_stmt>
	    </block_content>}</block></else></if_stmt>

	  <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
	    <break>break;</break></block_content></block></if></if_stmt>

	  <if_stmt><if>if <condition>(<expr><name>class</name> <operator>&amp;&amp;</operator> <name>negate</name></expr>)</condition><block type="pseudo"><block_content>
	    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>num_neg_classes</name> <operator>&gt;=</operator> <name>MAX_NEG_CLASSES</name></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><name>status</name> <operator>=</operator> <name>REG_ESPACE</name></expr>;</expr_stmt></block_content></block></if>
	    <else>else<block type="pseudo"><block_content>
	      <expr_stmt><expr><name><name>neg_classes</name><index>[<expr><operator>(</operator><operator>*</operator><name>num_neg_classes</name><operator>)</operator><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>class</name></expr>;</expr_stmt></block_content></block></else></if_stmt></block_content></block></if>
	  <if type="elseif">else if <condition>(<expr><operator>!</operator><name>skip</name></expr>)</condition>
	    <block>{<block_content>
	      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_new_item</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max_i</name></expr></argument>, <argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<break>break;</break></block_content></block></if></if_stmt>
	      <expr_stmt><expr><operator>(</operator><operator>(</operator><name>tre_literal_t</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>*</operator><name>items</name><operator>)</operator><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index><operator>)</operator><operator>-&gt;</operator><name>obj</name><operator>)</operator><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>class</name></name> <operator>=</operator> <name>class</name></expr>;</expr_stmt>
	    </block_content>}</block></if></if_stmt>

	  <comment type="block">/* Add opposite-case counterpoints if REG_ICASE is present.
	     This is broken if there are more than two "same" characters. */</comment>
	  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_ICASE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>class</name> <operator>&amp;&amp;</operator> <name>status</name> <operator>==</operator> <name>REG_OK</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>skip</name></expr>)</condition>
	    <block>{<block_content>
	      <decl_stmt><decl><type><name>tre_cint_t</name></type> <name>cmin</name></decl>, <decl><type ref="prev"/><name>ccurr</name></decl>;</decl_stmt>

	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"adding opposite-case counterpoints\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <while>while <condition>(<expr><name>min</name> <operator>&lt;=</operator> <name>max</name></expr>)</condition>
		<block>{<block_content>
		  <if_stmt><if>if <condition>(<expr><call><name>tre_islower</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>)</condition>
		    <block>{<block_content>
		      <expr_stmt><expr><name>cmin</name> <operator>=</operator> <name>ccurr</name> <operator>=</operator> <call><name>tre_toupper</name><argument_list>(<argument><expr><name>min</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <while>while <condition>(<expr><call><name>tre_islower</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tre_toupper</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ccurr</name> <operator>+</operator> <literal type="number">1</literal>
			     <operator>&amp;&amp;</operator> <name>min</name> <operator>&lt;=</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ccurr</name> <operator>=</operator> <call><name>tre_toupper</name><argument_list>(<argument><expr><name>min</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
		      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_new_item</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>cmin</name></expr></argument>, <argument><expr><name>ccurr</name></expr></argument>,
					    <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max_i</name></expr></argument>, <argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    </block_content>}</block></if>
		  <if type="elseif">else if <condition>(<expr><call><name>tre_isupper</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>)</condition>
		    <block>{<block_content>
		      <expr_stmt><expr><name>cmin</name> <operator>=</operator> <name>ccurr</name> <operator>=</operator> <call><name>tre_tolower</name><argument_list>(<argument><expr><name>min</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <while>while <condition>(<expr><call><name>tre_isupper</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>tre_tolower</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ccurr</name> <operator>+</operator> <literal type="number">1</literal>
			     <operator>&amp;&amp;</operator> <name>min</name> <operator>&lt;=</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ccurr</name> <operator>=</operator> <call><name>tre_tolower</name><argument_list>(<argument><expr><name>min</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
		      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_new_item</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>cmin</name></expr></argument>, <argument><expr><name>ccurr</name></expr></argument>,
					    <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max_i</name></expr></argument>, <argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    </block_content>}</block></if>
		  <else>else<block type="pseudo"><block_content> <expr_stmt><expr><name>min</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		  <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
		    <break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></while>
	      <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<break>break;</break></block_content></block></if></if_stmt>
	    </block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
  <expr_stmt><expr><operator>*</operator><name>num_items</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>items_size</name> <operator>=</operator> <name>max_i</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>=</operator> <name>re</name></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>reg_errcode_t</name></type>
<name>tre_parse_bracket</name><parameter_list>(<parameter><decl><type><name>tre_parse_ctx_t</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>negate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>reg_errcode_t</name></type> <name>status</name> <init>= <expr><name>REG_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>items</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>u</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>max_i</name> <init>= <expr><literal type="number">32</literal></expr></init></decl>, <decl><type ref="prev"/><name>curr_max</name></decl>, <decl><type ref="prev"/><name>curr_min</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_ctype_t</name></type> <name><name>neg_classes</name><index>[<expr><name>MAX_NEG_CLASSES</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>num_neg_classes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Start off with an array of `max_i' elements. */</comment>
  <expr_stmt><expr><name>items</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>items</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>max_i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>items</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>==</operator> <name>CHAR_CARET</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse_bracket: negate: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator> <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>negate</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_parse_bracket_items</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>negate</name></expr></argument>, <argument><expr><name>neg_classes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_neg_classes</name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>items</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max_i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
    <goto>goto <name>parse_bracket_done</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Sort the array if we need to negate it. */</comment>
  <if_stmt><if>if <condition>(<expr><name>negate</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>i</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>items</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>tre_compare_items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>curr_max</name> <operator>=</operator> <name>curr_min</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <comment type="block">/* Build a union of the items in the array, negated if necessary. */</comment>
  <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name> <operator>&amp;&amp;</operator> <name>status</name> <operator>==</operator> <name>REG_OK</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>min</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>tre_literal_t</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><name><name>items</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>obj</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>min</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>code_min</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>code_max</name></name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"item: %d - %d, class %ld, curr_max = %d\n"</literal><operator>,</operator>
	      <operator>(</operator><name>int</name><operator>)</operator><name><name>l</name><operator>-&gt;</operator><name>code_min</name></name><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>l</name><operator>-&gt;</operator><name>code_max</name></name><operator>,</operator> <operator>(</operator><name>long</name><operator>)</operator><name><name>l</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>class</name></name><operator>,</operator> <name>curr_max</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>negate</name></expr>)</condition>
	<block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>min</name> <operator>&lt;</operator> <name>curr_max</name></expr>)</condition>
	    <block>{<block_content>
	      <comment type="block">/* Overlap. */</comment>
	      <expr_stmt><expr><name>curr_max</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>max</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>curr_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"overlap, curr_max = %d\n"</literal><operator>,</operator> <name>curr_max</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><name>l</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	    </block_content>}</block></if>
	  <else>else
	    <block>{<block_content>
	      <comment type="block">/* No overlap. */</comment>
	      <expr_stmt><expr><name>curr_max</name> <operator>=</operator> <name>min</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name>curr_max</name> <operator>&gt;=</operator> <name>curr_min</name></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"no overlap\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>code_min</name></name> <operator>=</operator> <name>curr_min</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>code_max</name></name> <operator>=</operator> <name>curr_max</name></expr>;</expr_stmt>
		</block_content>}</block></if>
	      <else>else
		<block>{<block_content>
		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"no overlap, zero room\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><name>l</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	      <expr_stmt><expr><name>curr_min</name> <operator>=</operator> <name>curr_max</name> <operator>=</operator> <name>max</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	    </block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
	  <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
	  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"creating %d - %d\n"</literal><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>l</name><operator>-&gt;</operator><name>code_min</name></name><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>l</name><operator>-&gt;</operator><name>code_max</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>position</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>position</name></name></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name>num_neg_classes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	    <block>{<block_content>
	      <expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>neg_classes</name></name> <operator>=</operator> <call><name>tre_mem_alloc</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>,
					     <argument><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>l</name><operator>-&gt;</operator><name>neg_classes</name></name></expr></argument>)</argument_list></sizeof>
					      <operator>*</operator> <operator>(</operator><name>num_neg_classes</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name><name>l</name><operator>-&gt;</operator><name>neg_classes</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><name>status</name> <operator>=</operator> <name>REG_ESPACE</name></expr>;</expr_stmt>
		  <break>break;</break>
		</block_content>}</block></if></if_stmt>
	      <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>num_neg_classes</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>neg_classes</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>neg_classes</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	      <expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>neg_classes</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>tre_ctype_t</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
	    </block_content>}</block></if>
	  <else>else<block type="pseudo"><block_content>
	    <expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>neg_classes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	  <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>items</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
	  <else>else
	    <block>{<block_content>
	      <expr_stmt><expr><name>u</name> <operator>=</operator> <call><name>tre_ast_new_union</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name>u</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>REG_ESPACE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	      <expr_stmt><expr><name>node</name> <operator>=</operator> <name>u</name></expr>;</expr_stmt>
	    </block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
    <goto>goto <name>parse_bracket_done</name>;</goto></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>negate</name></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"final: creating %d - %d\n"</literal><operator>,</operator> <name>curr_min</name><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><name>TRE_CHAR_MAX</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>curr_min</name></expr></argument>, <argument><expr><name>TRE_CHAR_MAX</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>status</name> <operator>=</operator> <name>REG_ESPACE</name></expr>;</expr_stmt></block_content></block></if>
      <else>else
	<block>{<block_content>
	  <decl_stmt><decl><type><name>tre_literal_t</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>
	  <if_stmt><if>if <condition>(<expr><name>num_neg_classes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	    <block>{<block_content>
	      <expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>neg_classes</name></name> <operator>=</operator> <call><name>tre_mem_alloc</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>,
					     <argument><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>l</name><operator>-&gt;</operator><name>neg_classes</name></name></expr></argument>)</argument_list></sizeof>
					      <operator>*</operator> <operator>(</operator><name>num_neg_classes</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name><name>l</name><operator>-&gt;</operator><name>neg_classes</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><name>status</name> <operator>=</operator> <name>REG_ESPACE</name></expr>;</expr_stmt>
		  <goto>goto <name>parse_bracket_done</name>;</goto>
		</block_content>}</block></if></if_stmt>
	      <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>num_neg_classes</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>neg_classes</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name><name>neg_classes</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	      <expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>neg_classes</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>tre_ctype_t</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
	    </block_content>}</block></if>
	  <else>else<block type="pseudo"><block_content>
	    <expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>neg_classes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	  <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>node</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if>
	  <else>else
	    <block>{<block_content>
	      <expr_stmt><expr><name>u</name> <operator>=</operator> <call><name>tre_ast_new_union</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name>u</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>REG_ESPACE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	      <expr_stmt><expr><name>node</name> <operator>=</operator> <name>u</name></expr>;</expr_stmt>
	    </block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
    <goto>goto <name>parse_bracket_done</name>;</goto></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><call><name>tre_ast_print</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_DEBUG */</comment>

 <label><name>parse_bracket_done</name>:</label>
  <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>position</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Parses a positive decimal integer.  Returns -1 if the string does not
   contain a valid number. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tre_parse_int</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>tre_char_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>regex</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>tre_char_t</name> <modifier>*</modifier></type><name>regex_end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>num</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>tre_char_t</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><operator>*</operator><name>regex</name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>r</name> <operator>&lt;</operator> <name>regex_end</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>r</name> <operator>&gt;=</operator> <name>L</name><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>r</name> <operator>&lt;=</operator> <name>L</name><literal type="char">'9'</literal></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>num</name> <operator>=</operator> <name>num</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>*</operator><name>r</name> <operator>-</operator> <name>L</name><literal type="char">'0'</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  <expr_stmt><expr><operator>*</operator><name>regex</name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
  <return>return <expr><name>num</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>reg_errcode_t</name></type>
<name>tre_parse_bound</name><parameter_list>(<parameter><decl><type><name>tre_parse_ctx_t</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>min</name></decl>, <decl><type ref="prev"/><name>max</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>cost_ins</name></decl>, <decl><type ref="prev"/><name>cost_del</name></decl>, <decl><type ref="prev"/><name>cost_subst</name></decl>, <decl><type ref="prev"/><name>cost_max</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>limit_ins</name></decl>, <decl><type ref="prev"/><name>limit_del</name></decl>, <decl><type ref="prev"/><name>limit_subst</name></decl>, <decl><type ref="prev"/><name>limit_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>tre_char_t</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>tre_char_t</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>minimal</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_UNGREEDY</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>approx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>costs_set</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>counts_set</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>cost_ins</name> <operator>=</operator> <name>cost_del</name> <operator>=</operator> <name>cost_subst</name> <operator>=</operator> <name>cost_max</name> <operator>=</operator> <name>TRE_PARAM_UNSET</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>limit_ins</name> <operator>=</operator> <name>limit_del</name> <operator>=</operator> <name>limit_subst</name> <operator>=</operator> <name>limit_err</name> <operator>=</operator> <name>TRE_PARAM_UNSET</name></expr>;</expr_stmt>

  <comment type="block">/* Parse number (minimum repetition count). */</comment>
  <expr_stmt><expr><name>min</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>r</name> <operator>&gt;=</operator> <name>L</name><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>r</name> <operator>&lt;=</operator> <name>L</name><literal type="char">'9'</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:	  min count: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator> <call><name>REST</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>min</name> <operator>=</operator> <call><name>tre_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* Parse comma and second number (maximum repetition count). */</comment>
  <expr_stmt><expr><name>max</name> <operator>=</operator> <name>min</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>r</name> <operator>==</operator> <name>CHAR_COMMA</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:   max count: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator> <call><name>REST</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>tre_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Check that the repeat counts are sane. */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>max</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>min</name> <operator>&gt;</operator> <name>max</name><operator>)</operator> <operator>||</operator> <name>max</name> <operator>&gt;</operator> <name>RE_DUP_MAX</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>REG_BADBR</name></expr>;</return></block_content></block></if></if_stmt>


  <comment type="block">/*
   '{'
     optionally followed immediately by a number == minimum repcount
     optionally followed by , then a number == maximum repcount
      + then a number == maximum insertion count
      - then a number == maximum deletion count
      # then a number == maximum substitution count
      ~ then a number == maximum number of errors
      Any of +, -, # or ~ without followed by a number means that
      the maximum count/number of errors is infinite.

      An equation of the form
	Xi + Yd + Zs &lt; C
      can be specified to set costs and the cost limit to a value
      different from the default value:
	- X is the cost of an insertion
	- Y is the cost of a deletion
	- Z is the cost of a substitution
	- C is the maximum cost

      If no count limit or cost is set for an operation, the operation
      is not allowed at all.
  */</comment>


  <do>do <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>done</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>start</name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>

    <comment type="block">/* Parse count limit settings */</comment>
    <expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>counts_set</name></expr>)</condition><block type="pseudo"><block_content>
      <while>while <condition>(<expr><name>r</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>done</name></expr>)</condition>
	<block>{<block_content>
	  <switch>switch <condition>(<expr><operator>*</operator><name>r</name></expr>)</condition>
	    <block>{<block_content>
	    <case>case <expr><name>CHAR_PLUS</name></expr>:</case>  <comment type="block">/* Insert limit */</comment>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:   ins limit: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator> <call><name>REST</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt>
	      <expr_stmt><expr><name>limit_ins</name> <operator>=</operator> <call><name>tre_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name>limit_ins</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>limit_ins</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	      <expr_stmt><expr><name>counts_set</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	      <break>break;</break>
	    <case>case <expr><name>CHAR_MINUS</name></expr>:</case> <comment type="block">/* Delete limit */</comment>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:   del limit: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator> <call><name>REST</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt>
	      <expr_stmt><expr><name>limit_del</name> <operator>=</operator> <call><name>tre_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name>limit_del</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>limit_del</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	      <expr_stmt><expr><name>counts_set</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	      <break>break;</break>
	    <case>case <expr><name>CHAR_HASH</name></expr>:</case>  <comment type="block">/* Substitute limit */</comment>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse: subst limit: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator> <call><name>REST</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt>
	      <expr_stmt><expr><name>limit_subst</name> <operator>=</operator> <call><name>tre_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name>limit_subst</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>limit_subst</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	      <expr_stmt><expr><name>counts_set</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	      <break>break;</break>
	    <case>case <expr><name>CHAR_TILDE</name></expr>:</case> <comment type="block">/* Maximum number of changes */</comment>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse: count limit: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator> <call><name>REST</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt>
	      <expr_stmt><expr><name>limit_err</name> <operator>=</operator> <call><name>tre_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name>limit_err</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>limit_err</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	      <expr_stmt><expr><name>approx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	      <break>break;</break>
	    <case>case <expr><name>CHAR_COMMA</name></expr>:</case>
	      <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt>
	      <break>break;</break>
	    <case>case <expr><name>L</name><literal type="char">' '</literal></expr>:</case>
	      <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt>
	      <break>break;</break>
	    <case>case <expr><name>L</name><literal type="char">'}'</literal></expr>:</case>
	      <expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	      <break>break;</break>
	    <default>default:</default>
	      <expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	      <break>break;</break>
	    </block_content>}</block></switch>
	</block_content>}</block></while></block_content></block></if></if_stmt>

    <comment type="block">/* Parse cost restriction equation. */</comment>
    <expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>costs_set</name></expr>)</condition><block type="pseudo"><block_content>
      <while>while <condition>(<expr><name>r</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>done</name></expr>)</condition>
	<block>{<block_content>
	  <switch>switch <condition>(<expr><operator>*</operator><name>r</name></expr>)</condition>
	    <block>{<block_content>
	    <case>case <expr><name>CHAR_PLUS</name></expr>:</case>
	    <case>case <expr><name>L</name><literal type="char">' '</literal></expr>:</case>
	      <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt>
	      <break>break;</break>
	    <case>case <expr><name>L</name><literal type="char">'&lt;'</literal></expr>:</case>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:    max cost: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator> <call><name>REST</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt>
	      <while>while <condition>(<expr><operator>*</operator><name>r</name> <operator>==</operator> <name>L</name><literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	      <expr_stmt><expr><name>cost_max</name> <operator>=</operator> <call><name>tre_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name>cost_max</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cost_max</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt></block_content></block></if>
	      <else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>cost_max</name><operator>--</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
	      <expr_stmt><expr><name>approx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	      <break>break;</break>
	    <case>case <expr><name>CHAR_COMMA</name></expr>:</case>
	      <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt>
	      <expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	      <break>break;</break>
	    <default>default:</default>
	      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>r</name> <operator>&gt;=</operator> <name>L</name><literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>r</name> <operator>&lt;=</operator> <name>L</name><literal type="char">'9'</literal></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_DEBUG</name></cpp:ifdef>
		  <decl_stmt><decl><type><specifier>const</specifier> <name>tre_char_t</name> <modifier>*</modifier></type><name>sr</name> <init>= <expr><name>r</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_DEBUG */</comment>
		  <decl_stmt><decl><type><name>int</name></type> <name>cost</name> <init>= <expr><call><name>tre_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		  <comment type="block">/* XXX - make sure r is not past end. */</comment>
		  <switch>switch <condition>(<expr><operator>*</operator><name>r</name></expr>)</condition>
		    <block>{<block_content>
		    <case>case <expr><name>L</name><literal type="char">'i'</literal></expr>:</case>	<comment type="block">/* Insert cost */</comment>
		      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:    ins cost: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator>
			      <call><name>REST</name><argument_list>(<argument><expr><name>sr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt>
		      <expr_stmt><expr><name>cost_ins</name> <operator>=</operator> <name>cost</name></expr>;</expr_stmt>
		      <expr_stmt><expr><name>costs_set</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		      <break>break;</break>
		    <case>case <expr><name>L</name><literal type="char">'d'</literal></expr>:</case>	<comment type="block">/* Delete cost */</comment>
		      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:    del cost: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator>
			      <call><name>REST</name><argument_list>(<argument><expr><name>sr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt>
		      <expr_stmt><expr><name>cost_del</name> <operator>=</operator> <name>cost</name></expr>;</expr_stmt>
		      <expr_stmt><expr><name>costs_set</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		      <break>break;</break>
		    <case>case <expr><name>L</name><literal type="char">'s'</literal></expr>:</case>	<comment type="block">/* Substitute cost */</comment>
		      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:  subst cost: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator>
			      <call><name>REST</name><argument_list>(<argument><expr><name>sr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt>
		      <expr_stmt><expr><name>cost_subst</name> <operator>=</operator> <name>cost</name></expr>;</expr_stmt>
		      <expr_stmt><expr><name>costs_set</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		      <break>break;</break>
		    <default>default:</default>
		      <return>return <expr><name>REG_BADBR</name></expr>;</return>
		    </block_content>}</block></switch>
		</block_content>}</block></if>
	      <else>else
		<block>{<block_content>
		  <expr_stmt><expr><name>done</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		  <break>break;</break>
		</block_content>}</block></else></if_stmt>
	    </block_content>}</block></switch>
	</block_content>}</block></while></block_content></block></if></if_stmt>
  </block_content>}</block> while <condition>(<expr><name>start</name> <operator>!=</operator> <name>r</name></expr>)</condition>;</do>

  <comment type="block">/* Missing }. */</comment>
  <if_stmt><if>if <condition>(<expr><name>r</name> <operator>&gt;=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>REG_EBRACE</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Empty contents of {}. */</comment>
  <if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>REG_BADBR</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Parse the ending '}' or '\}'.*/</comment>
  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_EXTENDED</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>r</name> <operator>&gt;=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name> <operator>||</operator> <operator>*</operator><name>r</name> <operator>!=</operator> <name>CHAR_RBRACE</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>REG_BADBR</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>r</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name>
	  <operator>||</operator> <operator>*</operator><name>r</name> <operator>!=</operator> <name>CHAR_BACKSLASH</name>
	  <operator>||</operator> <operator>*</operator><operator>(</operator><name>r</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <name>CHAR_RBRACE</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>REG_BADBR</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>r</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>


  <comment type="block">/* Parse trailing '?' marking minimal repetition. */</comment>
  <if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>r</name> <operator>==</operator> <name>CHAR_QUESTIONMARK</name></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><name>minimal</name> <operator>=</operator> <operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_UNGREEDY</name><operator>)</operator></expr>;</expr_stmt>
	  <expr_stmt><expr><name>r</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><operator>*</operator><name>r</name> <operator>==</operator> <name>CHAR_STAR</name> <operator>||</operator> <operator>*</operator><name>r</name> <operator>==</operator> <name>CHAR_PLUS</name></expr>)</condition>
	<block>{<block_content>
	  <comment type="block">/* These are reserved for future extensions. */</comment>
	  <return>return <expr><name>REG_BADRPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Create the AST node(s). */</comment>
  <if_stmt><if>if <condition>(<expr><name>min</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>max</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>min</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>max</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<comment type="block">/* Only approximate parameters set, no repetitions. */</comment>
	<expr_stmt><expr><name>min</name> <operator>=</operator> <name>max</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>tre_ast_new_iter</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><operator>*</operator><name>result</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>minimal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>

      <comment type="block">/* If approximate matching parameters are set, add them to the
	 iteration node. */</comment>
      <if_stmt><if>if <condition>(<expr><name>approx</name> <operator>||</operator> <name>costs_set</name> <operator>||</operator> <name>counts_set</name></expr>)</condition>
	<block>{<block_content>
	  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>params</name></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>tre_iteration_t</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><name><operator>(</operator><operator>*</operator><name>result</name><operator>)</operator><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>

	  <if_stmt><if>if <condition>(<expr><name>costs_set</name> <operator>||</operator> <name>counts_set</name></expr>)</condition>
	    <block>{<block_content>
	      <if_stmt><if>if <condition>(<expr><name>limit_ins</name> <operator>==</operator> <name>TRE_PARAM_UNSET</name></expr>)</condition>
		<block>{<block_content>
		  <if_stmt><if>if <condition>(<expr><name>cost_ins</name> <operator>==</operator> <name>TRE_PARAM_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
		    <expr_stmt><expr><name>limit_ins</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		  <else>else<block type="pseudo"><block_content>
		    <expr_stmt><expr><name>limit_ins</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

	      <if_stmt><if>if <condition>(<expr><name>limit_del</name> <operator>==</operator> <name>TRE_PARAM_UNSET</name></expr>)</condition>
		<block>{<block_content>
		  <if_stmt><if>if <condition>(<expr><name>cost_del</name> <operator>==</operator> <name>TRE_PARAM_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
		    <expr_stmt><expr><name>limit_del</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		  <else>else<block type="pseudo"><block_content>
		    <expr_stmt><expr><name>limit_del</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

	      <if_stmt><if>if <condition>(<expr><name>limit_subst</name> <operator>==</operator> <name>TRE_PARAM_UNSET</name></expr>)</condition>
		<block>{<block_content>
		  <if_stmt><if>if <condition>(<expr><name>cost_subst</name> <operator>==</operator> <name>TRE_PARAM_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
		    <expr_stmt><expr><name>limit_subst</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		  <else>else<block type="pseudo"><block_content>
		    <expr_stmt><expr><name>limit_subst</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	    </block_content>}</block></if></if_stmt>

	  <if_stmt><if>if <condition>(<expr><name>cost_max</name> <operator>==</operator> <name>TRE_PARAM_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>cost_max</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <if_stmt><if>if <condition>(<expr><name>limit_err</name> <operator>==</operator> <name>TRE_PARAM_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>limit_err</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>have_approx</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	  <expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>tre_mem_alloc</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>params</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>TRE_PARAM_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>params</name></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
	  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TRE_PARAM_LAST</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	    <expr_stmt><expr><name><name>params</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>TRE_PARAM_UNSET</name></expr>;</expr_stmt></block_content></block></for>
	  <expr_stmt><expr><name><name>params</name><index>[<expr><name>TRE_PARAM_COST_INS</name></expr>]</index></name> <operator>=</operator> <name>cost_ins</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>params</name><index>[<expr><name>TRE_PARAM_COST_DEL</name></expr>]</index></name> <operator>=</operator> <name>cost_del</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>params</name><index>[<expr><name>TRE_PARAM_COST_SUBST</name></expr>]</index></name> <operator>=</operator> <name>cost_subst</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>params</name><index>[<expr><name>TRE_PARAM_COST_MAX</name></expr>]</index></name> <operator>=</operator> <name>cost_max</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>params</name><index>[<expr><name>TRE_PARAM_MAX_INS</name></expr>]</index></name> <operator>=</operator> <name>limit_ins</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>params</name><index>[<expr><name>TRE_PARAM_MAX_DEL</name></expr>]</index></name> <operator>=</operator> <name>limit_del</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>params</name><index>[<expr><name>TRE_PARAM_MAX_SUBST</name></expr>]</index></name> <operator>=</operator> <name>limit_subst</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>params</name><index>[<expr><name>TRE_PARAM_MAX_ERR</name></expr>]</index></name> <operator>=</operator> <name>limit_err</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>params</name></name> <operator>=</operator> <name>params</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse_bound: min %d, max %d, costs [%d,%d,%d, total %d], "</literal>
	  <literal type="string">"limits [%d,%d,%d, total %d]\n"</literal><operator>,</operator>
	  <name>min</name><operator>,</operator> <name>max</name><operator>,</operator> <name>cost_ins</name><operator>,</operator> <name>cost_del</name><operator>,</operator> <name>cost_subst</name><operator>,</operator> <name>cost_max</name><operator>,</operator>
	  <name>limit_ins</name><operator>,</operator> <name>limit_del</name><operator>,</operator> <name>limit_subst</name><operator>,</operator> <name>limit_err</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>


  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
  <return>return <expr><name>REG_OK</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><enum>enum <block>{
  <decl><name>PARSE_RE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
  <decl><name>PARSE_ATOM</name></decl>,
  <decl><name>PARSE_MARK_FOR_SUBMATCH</name></decl>,
  <decl><name>PARSE_BRANCH</name></decl>,
  <decl><name>PARSE_PIECE</name></decl>,
  <decl><name>PARSE_CATENATION</name></decl>,
  <decl><name>PARSE_POST_CATENATION</name></decl>,
  <decl><name>PARSE_UNION</name></decl>,
  <decl><name>PARSE_POST_UNION</name></decl>,
  <decl><name>PARSE_POSTFIX</name></decl>,
  <decl><name>PARSE_RESTORE_CFLAGS</name></decl>
}</block></enum></type> <name>tre_parse_re_stack_symbol_t</name>;</typedef>


<function><type><name>reg_errcode_t</name></type>
<name>tre_parse</name><parameter_list>(<parameter><decl><type><name>tre_parse_ctx_t</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_parse_re_stack_symbol_t</name></type> <name>symbol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>reg_errcode_t</name></type> <name>status</name> <init>= <expr><name>REG_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_stack_t</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>stack</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bottom</name> <init>= <expr><call><name>tre_stack_num_objects</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>temporary_cflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse: parsing '%.*"</literal> <name>STRF</name> <literal type="string">"', len = %d\n"</literal><operator>,</operator>
	  <name><name>ctx</name><operator>-&gt;</operator><name>len</name></name><operator>,</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>,</operator> <name><name>ctx</name><operator>-&gt;</operator><name>len</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>nofirstsub</name></name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>STACK_PUSH</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>submatch_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>STACK_PUSH</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_MARK_FOR_SUBMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>submatch_id</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>STACK_PUSH</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_RE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re_start</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <name><name>ctx</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>


  <comment type="block">/* The following is basically just a recursive descent parser.  I use
     an explicit stack instead of recursive functions mostly because of
     two reasons: compatibility with systems which have an overflowable
     call stack, and efficiency (both in lines of code and speed).  */</comment>
  <while>while <condition>(<expr><call><name>tre_stack_num_objects</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>bottom</name> <operator>&amp;&amp;</operator> <name>status</name> <operator>==</operator> <name>REG_OK</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
	<break>break;</break></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>symbol</name> <operator>=</operator> <call><name>tre_stack_pop_int</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <switch>switch <condition>(<expr><name>symbol</name></expr>)</condition>
	<block>{<block_content>
	<case>case <expr><name>PARSE_RE</name></expr>:</case>
	  <comment type="block">/* Parse a full regexp.  A regexp is one or more branches,
	     separated by the union operator `|'. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_LITERAL</name></cpp:ifdef>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_LITERAL</name><operator>)</operator>
	      <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_EXTENDED</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* REG_LITERAL */</comment>
	    <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_UNION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_BRANCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>

	<case>case <expr><name>PARSE_BRANCH</name></expr>:</case>
	  <comment type="block">/* Parse a branch.  A branch is one or more pieces, concatenated.
	     A piece is an atom possibly followed by a postfix operator. */</comment>
	  <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_CATENATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_PIECE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>

	<case>case <expr><name>PARSE_PIECE</name></expr>:</case>
	  <comment type="block">/* Parse a piece.  A piece is an atom possibly followed by one
	     or more postfix operators. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_LITERAL</name></cpp:ifdef>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_LITERAL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* REG_LITERAL */</comment>
	    <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_POSTFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_ATOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>

	<case>case <expr><name>PARSE_CATENATION</name></expr>:</case>
	  <comment type="block">/* If the expression has not ended, parse another piece. */</comment>
	  <block>{<block_content>
	    <decl_stmt><decl><type><name>tre_char_t</name></type> <name>c</name></decl>;</decl_stmt>
	    <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>&gt;=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr>)</condition><block type="pseudo"><block_content>
	      <break>break;</break></block_content></block></if></if_stmt>
	    <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_LITERAL</name></cpp:ifdef>
	    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_LITERAL</name><operator>)</operator></expr>)</condition>
	      <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* REG_LITERAL */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_EXTENDED</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <name>CHAR_PIPE</name></expr>)</condition><block type="pseudo"><block_content>
		  <break>break;</break></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_EXTENDED</name>
		     <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <name>CHAR_RPAREN</name> <operator>&amp;&amp;</operator> <name>depth</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator>
		    <operator>||</operator> <operator>(</operator><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_EXTENDED</name><operator>)</operator>
			<operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>==</operator> <name>CHAR_BACKSLASH</name>
			    <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>CHAR_RPAREN</name><operator>)</operator><operator>)</operator></expr>)</condition>
		  <block>{<block_content>
		    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_EXTENDED</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>depth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		      <expr_stmt><expr><name>status</name> <operator>=</operator> <name>REG_EPAREN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		    <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:	  group end: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator>
			    <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>depth</name><operator>--</operator></expr>;</expr_stmt>
		    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_EXTENDED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		    <break>break;</break>
		  </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_LITERAL</name></cpp:ifdef>
	      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* REG_LITERAL */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_RIGHT_ASSOC</name></cpp:ifdef>
	    <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_RIGHT_ASSOC</name></expr>)</condition>
	      <block>{<block_content>
		<comment type="block">/* Right associative concatenation. */</comment>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_POST_CATENATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_CATENATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_PIECE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      </block_content>}</block></if>
	    <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* REG_RIGHT_ASSOC */</comment>
	      <block>{<block_content>
		<comment type="block">/* Default case, left associative concatenation. */</comment>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_CATENATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_POST_CATENATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_PIECE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      </block_content>}</block></else></if_stmt>
	    <break>break;</break>
	  </block_content>}</block>

	<case>case <expr><name>PARSE_POST_CATENATION</name></expr>:</case>
	  <block>{<block_content>
	    <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>tree</name> <init>= <expr><call><name>tre_stack_pop_voidptr</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>tmp_node</name></decl>;</decl_stmt>
	    <expr_stmt><expr><name>tmp_node</name> <operator>=</operator> <call><name>tre_ast_new_catenation</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp_node</name></expr>)</condition><block type="pseudo"><block_content>
	      <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
	    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>tmp_node</name></expr>;</expr_stmt>
	    <break>break;</break>
	  </block_content>}</block>

	<case>case <expr><name>PARSE_UNION</name></expr>:</case>
	  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>&gt;=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr>)</condition><block type="pseudo"><block_content>
	    <break>break;</break></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_LITERAL</name></cpp:ifdef>
	  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_LITERAL</name></expr>)</condition><block type="pseudo"><block_content>
	    <break>break;</break></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* REG_LITERAL */</comment>
	  <switch>switch <condition>(<expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr>)</condition>
	    <block>{<block_content>
	    <case>case <expr><name>CHAR_PIPE</name></expr>:</case>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:	union: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator>
		      <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_UNION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_POST_UNION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_BRANCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
	      <break>break;</break>

	    <case>case <expr><name>CHAR_RPAREN</name></expr>:</case>
	      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
	      <break>break;</break>

	    <default>default:</default>
	      <break>break;</break>
	    </block_content>}</block></switch>
	  <break>break;</break>

	<case>case <expr><name>PARSE_POST_UNION</name></expr>:</case>
	  <block>{<block_content>
	    <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>tmp_node</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>tree</name> <init>= <expr><call><name>tre_stack_pop_voidptr</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <expr_stmt><expr><name>tmp_node</name> <operator>=</operator> <call><name>tre_ast_new_union</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp_node</name></expr>)</condition><block type="pseudo"><block_content>
	      <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
	    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>tmp_node</name></expr>;</expr_stmt>
	    <break>break;</break>
	  </block_content>}</block>

	<case>case <expr><name>PARSE_POSTFIX</name></expr>:</case>
	  <comment type="block">/* Parse postfix operators. */</comment>
	  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>&gt;=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr>)</condition><block type="pseudo"><block_content>
	    <break>break;</break></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_LITERAL</name></cpp:ifdef>
	  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_LITERAL</name></expr>)</condition><block type="pseudo"><block_content>
	    <break>break;</break></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* REG_LITERAL */</comment>
	  <switch>switch <condition>(<expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr>)</condition>
	    <block>{<block_content>
	    <case>case <expr><name>CHAR_PLUS</name></expr>:</case>
	    <case>case <expr><name>CHAR_QUESTIONMARK</name></expr>:</case>
	      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_EXTENDED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<break>break;</break></block_content></block></if></if_stmt>
		<comment type="block">/*FALLTHROUGH*/</comment>
	    <case>case <expr><name>CHAR_STAR</name></expr>:</case>
	      <block>{<block_content>
		<decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>tmp_node</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>minimal</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_UNGREEDY</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>rep_min</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>rep_max</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_DEBUG</name></cpp:ifdef>
		<decl_stmt><decl><type><specifier>const</specifier> <name>tre_char_t</name> <modifier>*</modifier></type><name>tmp_re</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>==</operator> <name>CHAR_PLUS</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><name>rep_min</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>==</operator> <name>CHAR_QUESTIONMARK</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><name>rep_max</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_DEBUG</name></cpp:ifdef>
		<expr_stmt><expr><name>tmp_re</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr>)</condition>
		  <block>{<block_content>
		    <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>CHAR_QUESTIONMARK</name></expr>)</condition>
		      <block>{<block_content>
			<expr_stmt><expr><name>minimal</name> <operator>=</operator> <operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_UNGREEDY</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
		      </block_content>}</block></if>
		    <if type="elseif">else if <condition>(<expr><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>CHAR_STAR</name>
			     <operator>||</operator> <operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>CHAR_PLUS</name></expr>)</condition>
		      <block>{<block_content>
			<comment type="block">/* These are reserved for future extensions. */</comment>
			<return>return <expr><name>REG_BADRPT</name></expr>;</return>
		      </block_content>}</block></if></if_stmt>
		  </block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse: %s star: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator>
			<ternary><condition><expr><name>minimal</name></expr> ?</condition><then> <expr><literal type="string">"  minimal"</literal></expr> </then><else>: <expr><literal type="string">"greedy"</literal></expr></else></ternary><operator>,</operator> <call><name>REST</name><argument_list>(<argument><expr><name>tmp_re</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmp_node</name> <operator>=</operator> <call><name>tre_ast_new_iter</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>rep_min</name></expr></argument>, <argument><expr><name>rep_max</name></expr></argument>,
					    <argument><expr><name>minimal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tmp_node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>tmp_node</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_POSTFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      </block_content>}</block>
	      <break>break;</break>

	    <case>case <expr><name>CHAR_BACKSLASH</name></expr>:</case>
	      <comment type="block">/* "\{" is special without REG_EXTENDED */</comment>
	      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_EXTENDED</name><operator>)</operator>
		  <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name>
		  <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>CHAR_LBRACE</name></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
		  <goto>goto <name>parse_brace</name>;</goto>
		</block_content>}</block></if>
	      <else>else<block type="pseudo"><block_content>
		<break>break;</break></block_content></block></else></if_stmt>

	    <case>case <expr><name>CHAR_LBRACE</name></expr>:</case>
	      <comment type="block">/* "{" is literal without REG_EXTENDED */</comment>
	      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_EXTENDED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<break>break;</break></block_content></block></if></if_stmt>

	    <label><name>parse_brace</name>:</label>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:	bound: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator>
		      <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>

	      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_parse_bound</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>
	      <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_POSTFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <break>break;</break>
	    </block_content>}</block></switch>
	  <break>break;</break>

	<case>case <expr><name>PARSE_ATOM</name></expr>:</case>
	  <comment type="block">/* Parse an atom.  An atom is a regular expression enclosed in `()',
	     an empty set of `()', a bracket expression, `.', `^', `$',
	     a `\' followed by a character, or a single character. */</comment>

	  <comment type="block">/* End of regexp? (empty string). */</comment>
	  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>&gt;=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr>)</condition><block type="pseudo"><block_content>
	    <goto>goto <name>parse_literal</name>;</goto></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_LITERAL</name></cpp:ifdef>
	  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_LITERAL</name></expr>)</condition><block type="pseudo"><block_content>
	    <goto>goto <name>parse_literal</name>;</goto></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* REG_LITERAL */</comment>

	  <switch>switch <condition>(<expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr>)</condition>
	    <block>{<block_content>
	    <case>case <expr><name>CHAR_LPAREN</name></expr>:</case>  <comment type="block">/* parenthesized subexpression */</comment>

	      <comment type="block">/* Handle "(?...)" extensions.  They work in a way similar
		 to Perls corresponding extensions. */</comment>
	      <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_EXTENDED</name>
		  <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>CHAR_QUESTIONMARK</name></expr>)</condition>
		<block>{<block_content>
		  <decl_stmt><decl><type><name>int</name></type> <name>new_cflags</name> <init>= <expr><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name></expr></init></decl>;</decl_stmt>
		  <decl_stmt><decl><type><name>int</name></type> <name>bit</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:	extension: '%.*"</literal> <name>STRF</name> <literal type="string">"\n"</literal><operator>,</operator>
			  <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		  <while>while <condition>(<comment type="block">/*CONSTCOND*/</comment><expr><operator>(</operator><name>void</name><operator>)</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">1</literal></expr>)</condition>
		    <block>{<block_content>
		      <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>==</operator> <name>L</name><literal type="char">'i'</literal></expr>)</condition>
			<block>{<block_content>
			  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:	    icase: '%.*"</literal> <name>STRF</name> <literal type="string">"\n"</literal><operator>,</operator>
				  <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			  <if_stmt><if>if <condition>(<expr><name>bit</name></expr>)</condition><block type="pseudo"><block_content>
			    <expr_stmt><expr><name>new_cflags</name> <operator>|=</operator> <name>REG_ICASE</name></expr>;</expr_stmt></block_content></block></if>
			  <else>else<block type="pseudo"><block_content>
			    <expr_stmt><expr><name>new_cflags</name> <operator>&amp;=</operator> <operator>~</operator><name>REG_ICASE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
		      <if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>==</operator> <name>L</name><literal type="char">'n'</literal></expr>)</condition>
			<block>{<block_content>
			  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:	  newline: '%.*"</literal> <name>STRF</name> <literal type="string">"\n"</literal><operator>,</operator>
				  <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			  <if_stmt><if>if <condition>(<expr><name>bit</name></expr>)</condition><block type="pseudo"><block_content>
			    <expr_stmt><expr><name>new_cflags</name> <operator>|=</operator> <name>REG_NEWLINE</name></expr>;</expr_stmt></block_content></block></if>
			  <else>else<block type="pseudo"><block_content>
			    <expr_stmt><expr><name>new_cflags</name> <operator>&amp;=</operator> <operator>~</operator><name>REG_NEWLINE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_RIGHT_ASSOC</name></cpp:ifdef>
		      <if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>==</operator> <name>L</name><literal type="char">'r'</literal></expr>)</condition>
			<block>{<block_content>
			  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse: right assoc: '%.*"</literal> <name>STRF</name> <literal type="string">"\n"</literal><operator>,</operator>
				  <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			  <if_stmt><if>if <condition>(<expr><name>bit</name></expr>)</condition><block type="pseudo"><block_content>
			    <expr_stmt><expr><name>new_cflags</name> <operator>|=</operator> <name>REG_RIGHT_ASSOC</name></expr>;</expr_stmt></block_content></block></if>
			  <else>else<block type="pseudo"><block_content>
			    <expr_stmt><expr><name>new_cflags</name> <operator>&amp;=</operator> <operator>~</operator><name>REG_RIGHT_ASSOC</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* REG_RIGHT_ASSOC */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_UNGREEDY</name></cpp:ifdef>
		      <if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>==</operator> <name>L</name><literal type="char">'U'</literal></expr>)</condition>
			<block>{<block_content>
			  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:    ungreedy: '%.*"</literal> <name>STRF</name> <literal type="string">"\n"</literal><operator>,</operator>
				  <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			  <if_stmt><if>if <condition>(<expr><name>bit</name></expr>)</condition><block type="pseudo"><block_content>
			    <expr_stmt><expr><name>new_cflags</name> <operator>|=</operator> <name>REG_UNGREEDY</name></expr>;</expr_stmt></block_content></block></if>
			  <else>else<block type="pseudo"><block_content>
			    <expr_stmt><expr><name>new_cflags</name> <operator>&amp;=</operator> <operator>~</operator><name>REG_UNGREEDY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* REG_UNGREEDY */</comment>
		      <if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>==</operator> <name>CHAR_MINUS</name></expr>)</condition>
			<block>{<block_content>
			  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:	 turn off: '%.*"</literal> <name>STRF</name> <literal type="string">"\n"</literal><operator>,</operator>
				  <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
			  <expr_stmt><expr><name>bit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
		      <if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>==</operator> <name>CHAR_COLON</name></expr>)</condition>
			<block>{<block_content>
			  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:	 no group: '%.*"</literal> <name>STRF</name> <literal type="string">"\n"</literal><operator>,</operator>
				  <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
			  <expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt>
			  <break>break;</break>
			</block_content>}</block></if>
		      <if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>==</operator> <name>CHAR_HASH</name></expr>)</condition>
			<block>{<block_content>
			  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:    comment: '%.*"</literal> <name>STRF</name> <literal type="string">"\n"</literal><operator>,</operator>
				  <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			  <comment type="block">/* A comment can contain any character except a
			     right parenthesis */</comment>
			  <while>while <condition>(<expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>!=</operator> <name>CHAR_RPAREN</name>
				 <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr>)</condition><block type="pseudo"><block_content>
			    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			  <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>==</operator> <name>CHAR_RPAREN</name> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr>)</condition>
			    <block>{<block_content>
			      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
			      <break>break;</break>
			    </block_content>}</block></if>
			  <else>else<block type="pseudo"><block_content>
			    <return>return <expr><name>REG_BADPAT</name></expr>;</return></block_content></block></else></if_stmt>
			</block_content>}</block></if>
		      <if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>==</operator> <name>CHAR_RPAREN</name></expr>)</condition>
			<block>{<block_content>
			  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
			  <break>break;</break>
			</block_content>}</block></if>
		      <else>else<block type="pseudo"><block_content>
			<return>return <expr><name>REG_BADPAT</name></expr>;</return></block_content></block></else></if_stmt>
		    </block_content>}</block></while>

		  <comment type="block">/* Turn on the cflags changes for the rest of the
		     enclosing group. */</comment>
		  <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_RESTORE_CFLAGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_RE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>=</operator> <name>new_cflags</name></expr>;</expr_stmt>
		  <break>break;</break>
		</block_content>}</block></if></if_stmt>

	      <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_EXTENDED</name>
		  <operator>||</operator> <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>&gt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_start</name></name>
		      <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>CHAR_BACKSLASH</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><name>depth</name><operator>++</operator></expr>;</expr_stmt>
		  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name>
		      <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>CHAR_QUESTIONMARK</name>
		      <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>==</operator> <name>CHAR_COLON</name></expr>)</condition>
		    <block>{<block_content>
		      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse: group begin: '%.*"</literal> <name>STRF</name>
			      <literal type="string">"', no submatch\n"</literal><operator>,</operator> <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <comment type="block">/* Don't mark for submatching. */</comment>
		      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		      <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_RE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    </block_content>}</block></if>
		  <else>else
		    <block>{<block_content>
		      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse: group begin: '%.*"</literal> <name>STRF</name>
			      <literal type="string">"', submatch %d\n"</literal><operator>,</operator> <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>,</operator>
			      <name><name>ctx</name><operator>-&gt;</operator><name>submatch_id</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
		      <comment type="block">/* First parse a whole RE, then mark the resulting tree
			 for submatching. */</comment>
		      <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>submatch_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_MARK_FOR_SUBMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_RE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>submatch_id</name></name><operator>++</operator></expr>;</expr_stmt>
		    </block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
	      <else>else<block type="pseudo"><block_content>
		<goto>goto <name>parse_literal</name>;</goto></block_content></block></else></if_stmt>
	      <break>break;</break>

	    <case>case <expr><name>CHAR_RPAREN</name></expr>:</case>  <comment type="block">/* end of current subexpression */</comment>
	      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_EXTENDED</name> <operator>&amp;&amp;</operator> <name>depth</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator>
		  <operator>||</operator> <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>&gt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_start</name></name>
		      <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>CHAR_BACKSLASH</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:	    empty: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator>
			  <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <comment type="block">/* We were expecting an atom, but instead the current
		     subexpression was closed.	POSIX leaves the meaning of
		     this to be implementation-defined.	 We interpret this as
		     an empty expression (which matches an empty string).  */</comment>
		  <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_EXTENDED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
	      <else>else<block type="pseudo"><block_content>
		<goto>goto <name>parse_literal</name>;</goto></block_content></block></else></if_stmt>
	      <break>break;</break>

	    <case>case <expr><name>CHAR_LBRACKET</name></expr>:</case> <comment type="block">/* bracket expression */</comment>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:     bracket: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator>
		      <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
	      <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_parse_bracket</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>
	      <break>break;</break>

	    <case>case <expr><name>CHAR_BACKSLASH</name></expr>:</case>
	      <comment type="block">/* If this is "\(" or "\)" chew off the backslash and
		 try again. */</comment>
	      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_EXTENDED</name><operator>)</operator>
		  <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name>
		  <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>CHAR_LPAREN</name>
		      <operator>||</operator> <operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>CHAR_RPAREN</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
		  <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_ATOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <break>break;</break>
		</block_content>}</block></if></if_stmt>

	      <comment type="block">/* If a macro is used, parse the expanded macro recursively. */</comment>
	      <block>{<block_content>
		<decl_stmt><decl><type><name>tre_char_t</name></type> <name><name>buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>tre_expand_macro</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr></argument>,
				 <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>elementsof</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		  <block>{<block_content>
		    <decl_stmt><decl><type><name>tre_parse_ctx_t</name></type> <name>subctx</name></decl>;</decl_stmt>
		    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>subctx</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>subctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name><name>subctx</name><operator>.</operator><name>re</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name><name>subctx</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>tre_strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name><name>subctx</name><operator>.</operator><name>nofirstsub</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_parse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>subctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
		      <return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>
		    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>position</name></name> <operator>=</operator> <name><name>subctx</name><operator>.</operator><name>position</name></name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>subctx</name><operator>.</operator><name>result</name></name></expr>;</expr_stmt>
		    <break>break;</break>
		  </block_content>}</block></if></if_stmt>
	      </block_content>}</block>

	      <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* Trailing backslash. */</comment>
		<return>return <expr><name>REG_EESCAPE</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_LITERAL</name></cpp:ifdef>
	      <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>L</name><literal type="char">'Q'</literal></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse: tmp literal: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator>
			  <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>|=</operator> <name>REG_LITERAL</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name>temporary_cflags</name> <operator>|=</operator> <name>REG_LITERAL</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		  <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_ATOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <break>break;</break>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* REG_LITERAL */</comment>

	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:  bleep: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator> <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
	      <switch>switch <condition>(<expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr>)</condition>
		<block>{<block_content>
		<case>case <expr><name>L</name><literal type="char">'b'</literal></expr>:</case>
		  <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>ASSERTION</name></expr></argument>,
					       <argument><expr><name>ASSERT_AT_WB</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
		  <break>break;</break>
		<case>case <expr><name>L</name><literal type="char">'B'</literal></expr>:</case>
		  <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>ASSERTION</name></expr></argument>,
					       <argument><expr><name>ASSERT_AT_WB_NEG</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
		  <break>break;</break>
		<case>case <expr><name>L</name><literal type="char">'&lt;'</literal></expr>:</case>
		  <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>ASSERTION</name></expr></argument>,
					       <argument><expr><name>ASSERT_AT_BOW</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
		  <break>break;</break>
		<case>case <expr><name>L</name><literal type="char">'&gt;'</literal></expr>:</case>
		  <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>ASSERTION</name></expr></argument>,
					       <argument><expr><name>ASSERT_AT_EOW</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
		  <break>break;</break>
		<case>case <expr><name>L</name><literal type="char">'x'</literal></expr>:</case>
		  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
		  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>CHAR_LBRACE</name> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr>)</condition>
		    <block>{<block_content>
		      <comment type="block">/* 8 bit hex char. */</comment>
		      <decl_stmt><decl><type><name>char</name></type> <name><name>tmp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		      <decl_stmt><decl><type><name>long</name></type> <name>val</name></decl>;</decl_stmt>
		      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:  8 bit hex: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator>
			      <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		      <if_stmt><if>if <condition>(<expr><call><name>tre_isxdigit</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr>)</condition>
			<block>{<block_content>
			  <expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		      <if_stmt><if>if <condition>(<expr><call><name>tre_isxdigit</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr>)</condition>
			<block>{<block_content>
			  <expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		      <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>val</name></expr></argument>,
						   <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>val</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>position</name></name><operator>++</operator></expr>;</expr_stmt>
		      <break>break;</break>
		    </block_content>}</block></if>
		  <if type="elseif">else if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr>)</condition>
		    <block>{<block_content>
		      <comment type="block">/* Wide char. */</comment>
		      <decl_stmt><decl><type><name>char</name></type> <name><name>tmp</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
		      <decl_stmt><decl><type><name>long</name></type> <name>val</name></decl>;</decl_stmt>
		      <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
		      <while>while <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name> <operator>-</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
			  <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>CHAR_RBRACE</name></expr>)</condition><block type="pseudo"><block_content>
			    <break>break;</break></block_content></block></if></if_stmt>
			  <if_stmt><if>if <condition>(<expr><call><name>tre_isxdigit</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
			    <block>{<block_content>
			      <expr_stmt><expr><name><name>tmp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
			      <continue>continue;</continue>
			    </block_content>}</block></if></if_stmt>
			  <return>return <expr><name>REG_EBRACE</name></expr>;</return>
			</block_content>}</block></while>
		      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
		      <expr_stmt><expr><name><name>tmp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		      <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>val</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>val</name></expr></argument>,
						   <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>position</name></name><operator>++</operator></expr>;</expr_stmt>
		      <break>break;</break>
		    </block_content>}</block></if></if_stmt>
		  <comment type="block">/*FALLTHROUGH*/</comment>

		<default>default:</default>
		  <if_stmt><if>if <condition>(<expr><call><name>tre_isdigit</name><argument_list>(<argument><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		    <block>{<block_content>
		      <comment type="block">/* Back reference. */</comment>
		      <decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>-</operator> <name>L</name><literal type="char">'0'</literal></expr></init></decl>;</decl_stmt>
		      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:     backref: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator>
			      <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>BACKREF</name></expr></argument>, <argument><expr><name>val</name></expr></argument>,
						   <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>position</name></name><operator>++</operator></expr>;</expr_stmt>
		      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>max_backref</name></name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>max_backref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
		    </block_content>}</block></if>
		  <else>else
		    <block>{<block_content>
		      <comment type="block">/* Escaped character. */</comment>
		      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:     escaped: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator>
			      <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>, <argument><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>,
						   <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>position</name></name><operator>++</operator></expr>;</expr_stmt>
		      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
		    </block_content>}</block></else></if_stmt>
		  <break>break;</break>
		</block_content>}</block></switch>
	      <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
	      <break>break;</break>

	    <case>case <expr><name>CHAR_PERIOD</name></expr>:</case>	 <comment type="block">/* the any-symbol */</comment>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:	  any: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator>
		      <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_NEWLINE</name></expr>)</condition>
		<block>{<block_content>
		  <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>tmp1</name></decl>;</decl_stmt>
		  <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>tmp2</name></decl>;</decl_stmt>
		  <expr_stmt><expr><name>tmp1</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>L</name><literal type="char">'\n'</literal> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
					     <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp1</name></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		  <expr_stmt><expr><name>tmp2</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>L</name><literal type="char">'\n'</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>TRE_CHAR_MAX</name></expr></argument>,
					     <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>position</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp2</name></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		  <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tre_ast_new_union</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>tmp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>position</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
	      <else>else
		<block>{<block_content>
		  <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRE_CHAR_MAX</name></expr></argument>,
					       <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>position</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
	      <break>break;</break>

	    <case>case <expr><name>CHAR_CARET</name></expr>:</case>	 <comment type="block">/* beginning of line assertion */</comment>
	      <comment type="block">/* '^' has a special meaning everywhere in EREs, and in the
		 beginning of the RE and after \( is BREs. */</comment>
	      <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_EXTENDED</name>
		  <operator>||</operator> <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>-</operator> <literal type="number">2</literal> <operator>&gt;=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_start</name></name>
		      <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>==</operator> <name>CHAR_BACKSLASH</name>
		      <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>CHAR_LPAREN</name><operator>)</operator>
		  <operator>||</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_start</name></name></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:	      BOL: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator>
			  <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>ASSERTION</name></expr></argument>,
					       <argument><expr><name>ASSERT_AT_BOL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
	      <else>else<block type="pseudo"><block_content>
		<goto>goto <name>parse_literal</name>;</goto></block_content></block></else></if_stmt>
	      <break>break;</break>

	    <case>case <expr><name>CHAR_DOLLAR</name></expr>:</case>	 <comment type="block">/* end of line assertion. */</comment>
	      <comment type="block">/* '$' is special everywhere in EREs, and in the end of the
		 string and before \) is BREs. */</comment>
	      <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_EXTENDED</name>
		  <operator>||</operator> <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name>
		      <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>CHAR_BACKSLASH</name>
		      <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>==</operator> <name>CHAR_RPAREN</name><operator>)</operator>
		  <operator>||</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:	      EOL: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator>
			  <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>ASSERTION</name></expr></argument>,
					       <argument><expr><name>ASSERT_AT_EOL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
	      <else>else<block type="pseudo"><block_content>
		<goto>goto <name>parse_literal</name>;</goto></block_content></block></else></if_stmt>
	      <break>break;</break>

	    <default>default:</default>
	    <label><name>parse_literal</name>:</label>

	      <if_stmt><if>if <condition>(<expr><name>temporary_cflags</name> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name>
		  <operator>&amp;&amp;</operator> <operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>==</operator> <name>CHAR_BACKSLASH</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>L</name><literal type="char">'E'</literal></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:	 end tmps: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator>
			  <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>temporary_cflags</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name>temporary_cflags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		  <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>PARSE_PIECE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <break>break;</break>
		</block_content>}</block></if></if_stmt>


	      <comment type="block">/* We are expecting an atom.  If the subexpression (or the whole
		 regexp ends here, we interpret it as an empty expression
		 (which matches an empty string).  */</comment>
	      <if_stmt><if>if <condition>(
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REG_LITERAL</name></cpp:ifdef>
		  <expr><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_LITERAL</name><operator>)</operator> <operator>&amp;&amp;</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* REG_LITERAL */</comment>
		  <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>&gt;=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name>
		   <operator>||</operator> <operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>==</operator> <name>CHAR_STAR</name>
		   <operator>||</operator> <operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_EXTENDED</name>
		       <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>==</operator> <name>CHAR_PIPE</name>
			   <operator>||</operator> <operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>==</operator> <name>CHAR_LBRACE</name>
			   <operator>||</operator> <operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>==</operator> <name>CHAR_PLUS</name>
			   <operator>||</operator> <operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>==</operator> <name>CHAR_QUESTIONMARK</name><operator>)</operator><operator>)</operator>
		   <comment type="block">/* Test for "\)" in BRE mode. */</comment>
		   <operator>||</operator> <operator>(</operator><operator>!</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_EXTENDED</name><operator>)</operator>
		       <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>re_end</name></name>
		       <operator>&amp;&amp;</operator> <operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>==</operator> <name>CHAR_BACKSLASH</name>
		       <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <name>CHAR_LBRACE</name><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:	    empty: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator>
			  <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		  <break>break;</break>
		</block_content>}</block></if></if_stmt>

	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_parse:     literal: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator>
		      <call><name>REST</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <comment type="block">/* Note that we can't use an tre_isalpha() test here, since there
		 may be characters which are alphabetic but neither upper or
		 lower case. */</comment>
	      <if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_ICASE</name>
		  <operator>&amp;&amp;</operator> <operator>(</operator><call><name>tre_isupper</name><argument_list>(<argument><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>tre_islower</name><argument_list>(<argument><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
		  <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>tmp1</name></decl>;</decl_stmt>
		  <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>tmp2</name></decl>;</decl_stmt>

		  <comment type="block">/* XXX - Can there be more than one opposite-case
		     counterpoints for some character in some locale?  Or
		     more than two characters which all should be regarded
		     the same character if case is ignored?  If yes, there
		     does not seem to be a portable way to detect it.  I guess
		     that at least for multi-character collating elements there
		     could be several opposite-case counterpoints, but they
		     cannot be supported portably anyway. */</comment>
		  <expr_stmt><expr><name>tmp1</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><call><name>tre_toupper</name><argument_list>(<argument><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr></argument>,
					     <argument><expr><call><name>tre_toupper</name><argument_list>(<argument><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr></argument>,
					     <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp1</name></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		  <expr_stmt><expr><name>tmp2</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><call><name>tre_tolower</name><argument_list>(<argument><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr></argument>,
					     <argument><expr><call><name>tre_tolower</name><argument_list>(<argument><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>)</argument_list></call></expr></argument>,
					     <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp2</name></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		  <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tre_ast_new_union</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>tmp1</name></expr></argument>, <argument><expr><name>tmp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
	      <else>else
		<block>{<block_content>
		  <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>, <argument><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name></expr></argument>,
					       <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>position</name></name><operator>++</operator></expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>re</name></name><operator>++</operator></expr>;</expr_stmt>
	      <break>break;</break>
	    </block_content>}</block></switch>
	  <break>break;</break>

	<case>case <expr><name>PARSE_MARK_FOR_SUBMATCH</name></expr>:</case>
	  <block>{<block_content>
	    <decl_stmt><decl><type><name>int</name></type> <name>submatch_id</name> <init>= <expr><call><name>tre_stack_pop_int</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	    <if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>submatch_id</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	      <block>{<block_content>
		<decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>n</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp_node</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>tmp_node</name> <operator>=</operator> <call><name>tre_ast_new_catenation</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>mem</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tmp_node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>tmp_node</name><operator>-&gt;</operator><name>num_submatches</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>num_submatches</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>tmp_node</name></expr>;</expr_stmt>
	      </block_content>}</block></if></if_stmt>
	    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>submatch_id</name></name> <operator>=</operator> <name>submatch_id</name></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>num_submatches</name></name><operator>++</operator></expr>;</expr_stmt>
	    <break>break;</break>
	  </block_content>}</block>

	<case>case <expr><name>PARSE_RESTORE_CFLAGS</name></expr>:</case>
	  <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>cflags</name></name> <operator>=</operator> <call><name>tre_stack_pop_int</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>

	<default>default:</default>
	  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>
	</block_content>}</block></switch>
    </block_content>}</block></while>

  <comment type="block">/* Check for missing closing parentheses. */</comment>
  <if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>REG_EPAREN</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* EOF */</comment>
</unit>
