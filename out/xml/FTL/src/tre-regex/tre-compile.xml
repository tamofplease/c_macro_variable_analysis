<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/tre-regex/tre-compile.c"><comment type="block">/*
  tre-compile.c - TRE regex compiler

  This software is released under a BSD-style license.
  See the file LICENSE for details and copyright.

*/</comment>

<comment type="block">/*
  TODO:
   - Fix tre_ast_to_tnfa() to recurse using a stack instead of recursive
     function calls.
*/</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;config.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_CONFIG_H */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre-internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre-mem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre-stack.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre-ast.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre-parse.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre-compile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmalloc.h"</cpp:file></cpp:include>

<comment type="block">/*
  Algorithms to setup tags so that submatch addressing can be done.
*/</comment>


<comment type="block">/* Inserts a catenation node to the root of the tree given in `node'.
   As the left child a new tag with number `tag_id' to `node' is added,
   and the right child is the old root. */</comment>
<function><type><specifier>static</specifier> <name>reg_errcode_t</name></type>
<name>tre_add_tag_left</name><parameter_list>(<parameter><decl><type><name>tre_mem_t</name></type> <name>mem</name></decl></parameter>, <parameter><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>tre_catenation_t</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"add_tag_left: tag %d\n"</literal><operator>,</operator> <name>tag_id</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>tre_mem_alloc</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>TAG</name></expr></argument>, <argument><expr><name>tag_id</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>left</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <call><name>tre_mem_alloc</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tre_ast_node_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>right</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>obj</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>nullable</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>submatch_id</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>firstpos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>lastpos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>num_tags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>obj</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>CATENATION</name></expr>;</expr_stmt>
  <return>return <expr><name>REG_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Inserts a catenation node to the root of the tree given in `node'.
   As the right child a new tag with number `tag_id' to `node' is added,
   and the left child is the old root. */</comment>
<function><type><specifier>static</specifier> <name>reg_errcode_t</name></type>
<name>tre_add_tag_right</name><parameter_list>(<parameter><decl><type><name>tre_mem_t</name></type> <name>mem</name></decl></parameter>, <parameter><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>tre_catenation_t</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_add_tag_right: tag %d\n"</literal><operator>,</operator> <name>tag_id</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>tre_mem_alloc</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>TAG</name></expr></argument>, <argument><expr><name>tag_id</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>right</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <call><name>tre_mem_alloc</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tre_ast_node_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>left</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>obj</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>nullable</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>submatch_id</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>firstpos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>lastpos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>num_tags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>obj</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>CATENATION</name></expr>;</expr_stmt>
  <return>return <expr><name>REG_OK</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><enum>enum <block>{
  <decl><name>ADDTAGS_RECURSE</name></decl>,
  <decl><name>ADDTAGS_AFTER_ITERATION</name></decl>,
  <decl><name>ADDTAGS_AFTER_UNION_LEFT</name></decl>,
  <decl><name>ADDTAGS_AFTER_UNION_RIGHT</name></decl>,
  <decl><name>ADDTAGS_AFTER_CAT_LEFT</name></decl>,
  <decl><name>ADDTAGS_AFTER_CAT_RIGHT</name></decl>,
  <decl><name>ADDTAGS_SET_SUBMATCH_END</name></decl>
}</block></enum></type> <name>tre_addtags_symbol_t</name>;</typedef>


<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>tag</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>next_tag</name></decl>;</decl_stmt>
}</block></struct></type> <name>tre_tag_states_t</name>;</typedef>


<comment type="block">/* Go through `regset' and set submatch data for submatches that are
   using this tag. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tre_purge_regset</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>regset</name></decl></parameter>, <parameter><decl><type><name>tre_tnfa_t</name> <modifier>*</modifier></type><name>tnfa</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>regset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><name><name>regset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>start</name> <init>= <expr><operator>!</operator><operator>(</operator><name><name>regset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>%</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  Using tag %d for %s offset of "</literal>
	      <literal type="string">"submatch %d\n"</literal><operator>,</operator> <name>tag</name><operator>,</operator>
	      <ternary><condition><expr><name>start</name></expr> ?</condition><then> <expr><literal type="string">"start"</literal></expr> </then><else>: <expr><literal type="string">"end"</literal></expr></else></ternary><operator>,</operator> <name>id</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>start</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>submatch_data</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>so_tag</name> <operator>=</operator> <name>tag</name></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>submatch_data</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>eo_tag</name> <operator>=</operator> <name>tag</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>
  <expr_stmt><expr><name><name>regset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Adds tags to appropriate locations in the parse tree in `tree', so that
   subexpressions marked for submatch addressing can be traced. */</comment>
<function><type><specifier>static</specifier> <name>reg_errcode_t</name></type>
<name>tre_add_tags</name><parameter_list>(<parameter><decl><type><name>tre_mem_t</name></type> <name>mem</name></decl></parameter>, <parameter><decl><type><name>tre_stack_t</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>, <parameter><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>,
	     <parameter><decl><type><name>tre_tnfa_t</name> <modifier>*</modifier></type><name>tnfa</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>reg_errcode_t</name></type> <name>status</name> <init>= <expr><name>REG_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_addtags_symbol_t</name></type> <name>symbol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>tree</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Tree node we are currently looking at. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>bottom</name> <init>= <expr><call><name>tre_stack_num_objects</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="block">/* True for first pass (counting number of needed tags) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>first_pass</name> <init>= <expr><operator>(</operator><name>mem</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>tnfa</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>regset</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>orig_regset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>num_tags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Total number of tags. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>num_minimals</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	 <comment type="block">/* Number of special minimal tags. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>tag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	    <comment type="block">/* The tag that is to be added next. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>next_tag</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Next tag to use after this one. */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>parents</name></decl>;</decl_stmt>	    <comment type="block">/* Stack of submatches the current submatch is
		       contained in. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>minimal_tag</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Tag that marks the beginning of a minimal match. */</comment>
  <decl_stmt><decl><type><name>tre_tag_states_t</name> <modifier>*</modifier></type><name>saved_states</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>tre_tag_direction_t</name></type> <name>direction</name> <init>= <expr><name>TRE_TAG_MINIMIZE</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>first_pass</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>end_tag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>regset</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>regset</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><operator>(</operator><name><name>tnfa</name><operator>-&gt;</operator><name>num_submatches</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>regset</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>regset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>orig_regset</name> <operator>=</operator> <name>regset</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>parents</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>parents</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>tnfa</name><operator>-&gt;</operator><name>num_submatches</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>parents</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>regset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>REG_ESPACE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>parents</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>saved_states</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>saved_states</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>tnfa</name><operator>-&gt;</operator><name>num_submatches</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>saved_states</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>regset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>parents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>REG_ESPACE</name></expr>;</return>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
      <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>num_submatches</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>saved_states</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tag</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>STACK_PUSH</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>STACK_PUSH</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>ADDTAGS_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while <condition>(<expr><call><name>tre_stack_num_objects</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>bottom</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
	<break>break;</break></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>symbol</name> <operator>=</operator> <operator>(</operator><name>tre_addtags_symbol_t</name><operator>)</operator><call><name>tre_stack_pop_int</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <switch>switch <condition>(<expr><name>symbol</name></expr>)</condition>
	<block>{<block_content>

	<case>case <expr><name>ADDTAGS_SET_SUBMATCH_END</name></expr>:</case>
	  <block>{<block_content>
	    <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><call><name>tre_stack_pop_int</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	    <comment type="block">/* Add end of this submatch to regset. */</comment>
	    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>regset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
	    <expr_stmt><expr><name><name>regset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>id</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>regset</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	    <comment type="block">/* Pop this submatch from the parents stack. */</comment>
	    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>parents</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
	    <expr_stmt><expr><name><name>parents</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	    <break>break;</break>
	  </block_content>}</block>

	<case>case <expr><name>ADDTAGS_RECURSE</name></expr>:</case>
	  <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>tre_stack_pop_voidptr</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	  <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>submatch_id</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	    <block>{<block_content>
	      <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>submatch_id</name></name></expr></init></decl>;</decl_stmt>
	      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>


	      <comment type="block">/* Add start of this submatch to regset. */</comment>
	      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>regset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
	      <expr_stmt><expr><name><name>regset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>id</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>regset</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>first_pass</name></expr>)</condition>
		<block>{<block_content>
		  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>parents</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
		  <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>submatch_data</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>parents</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		  <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		    <block>{<block_content>
		      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		      <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
			  <expr_stmt><expr><name>status</name> <operator>=</operator> <name>REG_ESPACE</name></expr>;</expr_stmt>
			  <break>break;</break>
			</block_content>}</block></if></if_stmt>
		      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tnfa</name><operator>-&gt;</operator><name>submatch_data</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>parents</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>submatch_data</name><index>[<expr><name>id</name></expr>]</index></name><operator>.</operator><name>parents</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
		      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>parents</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>parents</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
		      <expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		    </block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

	      <comment type="block">/* Add end of this submatch to regset after processing this
		 node. */</comment>
	      <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>submatch_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>ADDTAGS_SET_SUBMATCH_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    </block_content>}</block></if></if_stmt>

	  <switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	    <block>{<block_content>
	    <case>case <expr><name>LITERAL</name></expr>:</case>
	      <block>{<block_content>
		<decl_stmt><decl><type><name>tre_literal_t</name> <modifier>*</modifier></type><name>lit</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_SPECIAL</name><argument_list>(<argument><expr><name>lit</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_BACKREF</name><argument_list>(<argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>)</condition>
		  <block>{<block_content>
		    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		    <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Literal %d-%d\n"</literal><operator>,</operator>
			    <operator>(</operator><name>int</name><operator>)</operator><name><name>lit</name><operator>-&gt;</operator><name>code_min</name></name><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>lit</name><operator>-&gt;</operator><name>code_max</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if_stmt><if>if <condition>(<expr><name><name>regset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		      <block>{<block_content>
			<comment type="block">/* Regset is not empty, so add a tag before the
			   literal or backref. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first_pass</name></expr>)</condition>
			  <block>{<block_content>
			    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_add_tag_left</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>tag_directions</name><index>[<expr><name>tag</name></expr>]</index></name> <operator>=</operator> <name>direction</name></expr>;</expr_stmt>
			    <if_stmt><if>if <condition>(<expr><name>minimal_tag</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			      <block>{<block_content>
				<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Minimal %d, %d\n"</literal><operator>,</operator> <name>minimal_tag</name><operator>,</operator> <name>tag</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
				<expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>tag</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>minimal_tag</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>minimal_tag</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>num_minimals</name><operator>++</operator></expr>;</expr_stmt>
			      </block_content>}</block></if></if_stmt>
			    <expr_stmt><expr><call><name>tre_purge_regset</name><argument_list>(<argument><expr><name>regset</name></expr></argument>, <argument><expr><name>tnfa</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			  </block_content>}</block></if>
			<else>else
			  <block>{<block_content>
			    <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  num_tags = 1\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>num_tags</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			  </block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  num_tags++\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>regset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>next_tag</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>num_tags</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>next_tag</name><operator>++</operator></expr>;</expr_stmt>
		      </block_content>}</block></if></if_stmt>
		  </block_content>}</block></if>
		<else>else
		  <block>{<block_content>
		    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_TAG</name><argument_list>(<argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  </block_content>}</block></else></if_stmt>
		<break>break;</break>
	      </block_content>}</block>
	    <case>case <expr><name>CATENATION</name></expr>:</case>
	      <block>{<block_content>
		<decl_stmt><decl><type><name>tre_catenation_t</name> <modifier>*</modifier></type><name>cat</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>left</name> <init>= <expr><name><name>cat</name><operator>-&gt;</operator><name>left</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>right</name> <init>= <expr><name><name>cat</name><operator>-&gt;</operator><name>right</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>reserved_tag</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Catenation, next_tag = %d\n"</literal><operator>,</operator> <name>next_tag</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>


		<comment type="block">/* After processing right child. */</comment>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>ADDTAGS_AFTER_CAT_RIGHT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Process right child. */</comment>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>ADDTAGS_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* After processing left child. */</comment>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>next_tag</name> <operator>+</operator> <name><name>left</name><operator>-&gt;</operator><name>num_tags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  Pushing %d for after left\n"</literal><operator>,</operator>
			<name>next_tag</name> <operator>+</operator> <name><name>left</name><operator>-&gt;</operator><name>num_tags</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>left</name><operator>-&gt;</operator><name>num_tags</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>right</name><operator>-&gt;</operator><name>num_tags</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		  <block>{<block_content>
		    <comment type="block">/* Reserve the next tag to the right child. */</comment>
		    <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  Reserving next_tag %d to right child\n"</literal><operator>,</operator>
			    <name>next_tag</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>reserved_tag</name> <operator>=</operator> <name>next_tag</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>next_tag</name><operator>++</operator></expr>;</expr_stmt>
		  </block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>reserved_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>ADDTAGS_AFTER_CAT_LEFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Process left child. */</comment>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>ADDTAGS_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		</block_content>}</block>
	      <break>break;</break>
	    <case>case <expr><name>ITERATION</name></expr>:</case>
	      <block>{<block_content>
		<decl_stmt><decl><type><name>tre_iteration_t</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Iteration\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>first_pass</name></expr>)</condition>
		  <block>{<block_content>
		    <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name><name>regset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>iter</name><operator>-&gt;</operator><name>minimal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  </block_content>}</block></if>
		<else>else
		  <block>{<block_content>
		    <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>minimal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  </block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>ADDTAGS_AFTER_ITERATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>ADDTAGS_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Regset is not empty, so add a tag here. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>regset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>iter</name><operator>-&gt;</operator><name>minimal</name></name></expr>)</condition>
		  <block>{<block_content>
		    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>first_pass</name></expr>)</condition>
		      <block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_add_tag_left</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>minimal</name></name></expr>)</condition><block type="pseudo"><block_content>
			  <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>tag_directions</name><index>[<expr><name>tag</name></expr>]</index></name> <operator>=</operator> <name>TRE_TAG_MAXIMIZE</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
			  <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>tag_directions</name><index>[<expr><name>tag</name></expr>]</index></name> <operator>=</operator> <name>direction</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>minimal_tag</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			  <block>{<block_content>
			    <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Minimal %d, %d\n"</literal><operator>,</operator> <name>minimal_tag</name><operator>,</operator> <name>tag</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
			    <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>tag</name></expr>;</expr_stmt>
			    <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>minimal_tag</name></expr>;</expr_stmt>
			    <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			    <expr_stmt><expr><name>minimal_tag</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			    <expr_stmt><expr><name>num_minimals</name><operator>++</operator></expr>;</expr_stmt>
			  </block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>tre_purge_regset</name><argument_list>(<argument><expr><name>regset</name></expr></argument>, <argument><expr><name>tnfa</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      </block_content>}</block></if></if_stmt>

		    <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  num_tags++\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name><name>regset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		    <expr_stmt><expr><name>tag</name> <operator>=</operator> <name>next_tag</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>num_tags</name><operator>++</operator></expr>;</expr_stmt>
		    <expr_stmt><expr><name>next_tag</name><operator>++</operator></expr>;</expr_stmt>
		  </block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>TRE_TAG_MINIMIZE</name></expr>;</expr_stmt>
	      </block_content>}</block>
	      <break>break;</break>
	    <case>case <expr><name>UNION</name></expr>:</case>
	      <block>{<block_content>
		<decl_stmt><decl><type><name>tre_union_t</name> <modifier>*</modifier></type><name>uni</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>left</name> <init>= <expr><name><name>uni</name><operator>-&gt;</operator><name>left</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>right</name> <init>= <expr><name><name>uni</name><operator>-&gt;</operator><name>right</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>left_tag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>right_tag</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>regset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		  <block>{<block_content>
		    <expr_stmt><expr><name>left_tag</name> <operator>=</operator> <name>next_tag</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>right_tag</name> <operator>=</operator> <name>next_tag</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		  </block_content>}</block></if>
		<else>else
		  <block>{<block_content>
		    <expr_stmt><expr><name>left_tag</name> <operator>=</operator> <name>tag</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>right_tag</name> <operator>=</operator> <name>next_tag</name></expr>;</expr_stmt>
		  </block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Union\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* After processing right child. */</comment>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>right_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>left_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name>regset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name><name>regset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>ADDTAGS_AFTER_UNION_RIGHT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Process right child. */</comment>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>ADDTAGS_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* After processing left child. */</comment>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>ADDTAGS_AFTER_UNION_LEFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Process left child. */</comment>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>ADDTAGS_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Regset is not empty, so add a tag here. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>regset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		  <block>{<block_content>
		    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>first_pass</name></expr>)</condition>
		      <block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_add_tag_left</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>tag_directions</name><index>[<expr><name>tag</name></expr>]</index></name> <operator>=</operator> <name>direction</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>minimal_tag</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			  <block>{<block_content>
			    <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Minimal %d, %d\n"</literal><operator>,</operator> <name>minimal_tag</name><operator>,</operator> <name>tag</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
			    <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>tag</name></expr>;</expr_stmt>
			    <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>minimal_tag</name></expr>;</expr_stmt>
			    <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			    <expr_stmt><expr><name>minimal_tag</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			    <expr_stmt><expr><name>num_minimals</name><operator>++</operator></expr>;</expr_stmt>
			  </block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>tre_purge_regset</name><argument_list>(<argument><expr><name>regset</name></expr></argument>, <argument><expr><name>tnfa</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      </block_content>}</block></if></if_stmt>

		    <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  num_tags++\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name><name>regset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		    <expr_stmt><expr><name>tag</name> <operator>=</operator> <name>next_tag</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>num_tags</name><operator>++</operator></expr>;</expr_stmt>
		    <expr_stmt><expr><name>next_tag</name><operator>++</operator></expr>;</expr_stmt>
		  </block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>num_submatches</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		  <block>{<block_content>
		    <comment type="block">/* The next two tags are reserved for markers. */</comment>
		    <expr_stmt><expr><name>next_tag</name><operator>++</operator></expr>;</expr_stmt>
		    <expr_stmt><expr><name>tag</name> <operator>=</operator> <name>next_tag</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>next_tag</name><operator>++</operator></expr>;</expr_stmt>
		  </block_content>}</block></if></if_stmt>

		<break>break;</break>
	      </block_content>}</block>
	    </block_content>}</block></switch>

	  <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>submatch_id</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	    <block>{<block_content>
	      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	      <comment type="block">/* Push this submatch on the parents stack. */</comment>
	      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>parents</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
	      <expr_stmt><expr><name><name>parents</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>submatch_id</name></name></expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>parents</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	    </block_content>}</block></if></if_stmt>

	  <break>break;</break> <comment type="block">/* end case: ADDTAGS_RECURSE */</comment>

	<case>case <expr><name>ADDTAGS_AFTER_ITERATION</name></expr>:</case>
	  <block>{<block_content>
	    <decl_stmt><decl><type><name>int</name></type> <name>minimal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int</name></type> <name>enter_tag</name></decl>;</decl_stmt>
	    <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>tre_stack_pop_voidptr</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><name>first_pass</name></expr>)</condition>
	      <block>{<block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>num_tags</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>tre_iteration_t</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>obj</name></name><operator>)</operator><operator>-&gt;</operator><name><name>arg</name><operator>-&gt;</operator><name>num_tags</name></name>
		  <operator>+</operator> <call><name>tre_stack_pop_int</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>minimal_tag</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	      </block_content>}</block></if>
	    <else>else
	      <block>{<block_content>
		<expr_stmt><expr><name>minimal</name> <operator>=</operator> <call><name>tre_stack_pop_int</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>enter_tag</name> <operator>=</operator> <call><name>tre_stack_pop_int</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>minimal</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><name>minimal_tag</name> <operator>=</operator> <name>enter_tag</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	      </block_content>}</block></else></if_stmt>

	    <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"After iteration\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>first_pass</name></expr>)</condition>
	      <block>{<block_content>
		<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  Setting direction to %s\n"</literal><operator>,</operator>
			<ternary><condition><expr><name>minimal</name></expr> ?</condition><then> <expr><literal type="string">"minimize"</literal></expr> </then><else>: <expr><literal type="string">"maximize"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>minimal</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><name>direction</name> <operator>=</operator> <name>TRE_TAG_MINIMIZE</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
		  <expr_stmt><expr><name>direction</name> <operator>=</operator> <name>TRE_TAG_MAXIMIZE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	      </block_content>}</block></if></if_stmt>
	    <break>break;</break>
	  </block_content>}</block>

	<case>case <expr><name>ADDTAGS_AFTER_CAT_LEFT</name></expr>:</case>
	  <block>{<block_content>
	    <decl_stmt><decl><type><name>int</name></type> <name>new_tag</name> <init>= <expr><call><name>tre_stack_pop_int</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <expr_stmt><expr><name>next_tag</name> <operator>=</operator> <call><name>tre_stack_pop_int</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"After cat left, tag = %d, next_tag = %d\n"</literal><operator>,</operator>
		    <name>tag</name><operator>,</operator> <name>next_tag</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><name>new_tag</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	      <block>{<block_content>
		<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  Setting tag to %d\n"</literal><operator>,</operator> <name>new_tag</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>new_tag</name></expr>;</expr_stmt>
	      </block_content>}</block></if></if_stmt>
	    <break>break;</break>
	  </block_content>}</block>

	<case>case <expr><name>ADDTAGS_AFTER_CAT_RIGHT</name></expr>:</case>
	  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"After cat right\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>tre_stack_pop_voidptr</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name>first_pass</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>num_tags</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>tre_catenation_t</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>obj</name></name><operator>)</operator><operator>-&gt;</operator><name><name>left</name><operator>-&gt;</operator><name>num_tags</name></name>
	      <operator>+</operator> <operator>(</operator><operator>(</operator><name>tre_catenation_t</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>obj</name></name><operator>)</operator><operator>-&gt;</operator><name><name>right</name><operator>-&gt;</operator><name>num_tags</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <break>break;</break>

	<case>case <expr><name>ADDTAGS_AFTER_UNION_LEFT</name></expr>:</case>
	  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"After union left\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <comment type="block">/* Lift the bottom of the `regset' array so that when processing
	     the right operand the items currently in the array are
	     invisible.	 The original bottom was saved at ADDTAGS_UNION and
	     will be restored at ADDTAGS_AFTER_UNION_RIGHT below. */</comment>
	  <while>while <condition>(<expr><operator>*</operator><name>regset</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>regset</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	  <break>break;</break>

	<case>case <expr><name>ADDTAGS_AFTER_UNION_RIGHT</name></expr>:</case>
	  <block>{<block_content>
	    <decl_stmt><decl><type><name>int</name></type> <name>added_tags</name></decl>, <decl><type ref="prev"/><name>tag_left</name></decl>, <decl><type ref="prev"/><name>tag_right</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>left</name> <init>= <expr><call><name>tre_stack_pop_voidptr</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>right</name> <init>= <expr><call><name>tre_stack_pop_voidptr</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"After union right\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>tre_stack_pop_voidptr</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>added_tags</name> <operator>=</operator> <call><name>tre_stack_pop_int</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><name>first_pass</name></expr>)</condition>
	      <block>{<block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>num_tags</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>tre_union_t</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>obj</name></name><operator>)</operator><operator>-&gt;</operator><name><name>left</name><operator>-&gt;</operator><name>num_tags</name></name>
		  <operator>+</operator> <operator>(</operator><operator>(</operator><name>tre_union_t</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>obj</name></name><operator>)</operator><operator>-&gt;</operator><name><name>right</name><operator>-&gt;</operator><name>num_tags</name></name> <operator>+</operator> <name>added_tags</name>
		  <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>num_submatches</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	      </block_content>}</block></if></if_stmt>
	    <expr_stmt><expr><name>regset</name> <operator>=</operator> <call><name>tre_stack_pop_voidptr</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>tag_left</name> <operator>=</operator> <call><name>tre_stack_pop_int</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>tag_right</name> <operator>=</operator> <call><name>tre_stack_pop_int</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <comment type="block">/* Add tags after both children, the left child gets a smaller
	       tag than the right child.  This guarantees that we prefer
	       the left child over the right child. */</comment>
	    <comment type="block">/* XXX - This is not always necessary (if the children have
	       tags which must be seen for every match of that child). */</comment>
	    <comment type="block">/* XXX - Check if this is the only place where tre_add_tag_right
	       is used.	 If so, use tre_add_tag_left (putting the tag before
	       the child as opposed after the child) and throw away
	       tre_add_tag_right. */</comment>
	    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>num_submatches</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	      <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first_pass</name></expr>)</condition>
		  <block>{<block_content>
		    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_add_tag_right</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>tag_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>tag_directions</name><index>[<expr><name>tag_left</name></expr>]</index></name> <operator>=</operator> <name>TRE_TAG_MAXIMIZE</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_add_tag_right</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>tag_right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>tag_directions</name><index>[<expr><name>tag_right</name></expr>]</index></name> <operator>=</operator> <name>TRE_TAG_MAXIMIZE</name></expr>;</expr_stmt>
		  </block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  num_tags += 2\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_tags</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	      </block_content>}</block></if></if_stmt>
	    <expr_stmt><expr><name>direction</name> <operator>=</operator> <name>TRE_TAG_MAXIMIZE</name></expr>;</expr_stmt>
	    <break>break;</break>
	  </block_content>}</block>

	<default>default:</default>
	  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>

	</block_content>}</block></switch> <comment type="block">/* end switch(symbol) */</comment>
    </block_content>}</block></while> <comment type="block">/* end while(tre_stack_num_objects(stack) &gt; bottom) */</comment>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>first_pass</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>tre_purge_regset</name><argument_list>(<argument><expr><name>regset</name></expr></argument>, <argument><expr><name>tnfa</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>first_pass</name> <operator>&amp;&amp;</operator> <name>minimal_tag</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Minimal %d, %d\n"</literal><operator>,</operator> <name>minimal_tag</name><operator>,</operator> <name>tag</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
      <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>tag</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>minimal_tag</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>minimal_tag</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>num_minimals</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_add_tags: %s complete.  Number of tags %d.\n"</literal><operator>,</operator>
	  <ternary><condition><expr><name>first_pass</name></expr>?</condition><then> <expr><literal type="string">"First pass"</literal></expr> </then><else>: <expr><literal type="string">"Second pass"</literal></expr></else></ternary><operator>,</operator> <name>num_tags</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tree</name><operator>-&gt;</operator><name>num_tags</name></name> <operator>==</operator> <name>num_tags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>end_tag</name></name> <operator>=</operator> <name>num_tags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>num_tags</name></name> <operator>=</operator> <name>num_tags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>num_minimals</name></name> <operator>=</operator> <name>num_minimals</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>orig_regset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>parents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>saved_states</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
  AST to TNFA compilation routines.
*/</comment>

<typedef>typedef <type><enum>enum <block>{
  <decl><name>COPY_RECURSE</name></decl>,
  <decl><name>COPY_SET_RESULT_PTR</name></decl>
}</block></enum></type> <name>tre_copyast_symbol_t</name>;</typedef>

<comment type="block">/* Flags for tre_copy_ast(). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPY_REMOVE_TAGS</name></cpp:macro>	 <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPY_MAXIMIZE_FIRST_TAG</name></cpp:macro>	 <cpp:value>2</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>reg_errcode_t</name></type>
<name>tre_copy_ast</name><parameter_list>(<parameter><decl><type><name>tre_mem_t</name></type> <name>mem</name></decl></parameter>, <parameter><decl><type><name>tre_stack_t</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>, <parameter><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>,
	     <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pos_add</name></decl></parameter>, <parameter><decl><type><name>tre_tag_direction_t</name> <modifier>*</modifier></type><name>tag_directions</name></decl></parameter>,
	     <parameter><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>copy</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>max_pos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>reg_errcode_t</name></type> <name>status</name> <init>= <expr><name>REG_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bottom</name> <init>= <expr><call><name>tre_stack_num_objects</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>num_copied</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>first_tag</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name> <init>= <expr><name>copy</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_copyast_symbol_t</name></type> <name>symbol</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>STACK_PUSH</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name>ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>STACK_PUSH</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>COPY_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while <condition>(<expr><name>status</name> <operator>==</operator> <name>REG_OK</name> <operator>&amp;&amp;</operator> <call><name>tre_stack_num_objects</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>bottom</name></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
	<break>break;</break></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>symbol</name> <operator>=</operator> <operator>(</operator><name>tre_copyast_symbol_t</name><operator>)</operator><call><name>tre_stack_pop_int</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <switch>switch <condition>(<expr><name>symbol</name></expr>)</condition>
	<block>{<block_content>
	<case>case <expr><name>COPY_SET_RESULT_PTR</name></expr>:</case>
	  <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>tre_stack_pop_voidptr</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>
	<case>case <expr><name>COPY_RECURSE</name></expr>:</case>
	  <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>tre_stack_pop_voidptr</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	    <block>{<block_content>
	    <case>case <expr><name>LITERAL</name></expr>:</case>
	      <block>{<block_content>
		<decl_stmt><decl><type><name>tre_literal_t</name> <modifier>*</modifier></type><name>lit</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><name><name>lit</name><operator>-&gt;</operator><name>position</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>min</name> <init>= <expr><name><name>lit</name><operator>-&gt;</operator><name>code_min</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>max</name> <init>= <expr><name><name>lit</name><operator>-&gt;</operator><name>code_max</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_SPECIAL</name><argument_list>(<argument><expr><name>lit</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_BACKREF</name><argument_list>(<argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>)</condition>
		  <block>{<block_content>
		    <comment type="block">/* XXX - e.g. [ab] has only one position but two
		       nodes, so we are creating holes in the state space
		       here.  Not fatal, just wastes memory. */</comment>
		    <expr_stmt><expr><name>pos</name> <operator>+=</operator> <operator>*</operator><name>pos_add</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>num_copied</name><operator>++</operator></expr>;</expr_stmt>
		  </block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_TAG</name><argument_list>(<argument><expr><name>lit</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>COPY_REMOVE_TAGS</name><operator>)</operator></expr>)</condition>
		  <block>{<block_content>
		    <comment type="block">/* Change this tag to empty. */</comment>
		    <expr_stmt><expr><name>min</name> <operator>=</operator> <name>EMPTY</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>max</name> <operator>=</operator> <name>pos</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		  </block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_TAG</name><argument_list>(<argument><expr><name>lit</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>COPY_MAXIMIZE_FIRST_TAG</name><operator>)</operator>
			 <operator>&amp;&amp;</operator> <name>first_tag</name></expr>)</condition>
		  <block>{<block_content>
		    <comment type="block">/* Maximize the first tag. */</comment>
		    <expr_stmt><expr><name><name>tag_directions</name><index>[<expr><name>max</name></expr>]</index></name> <operator>=</operator> <name>TRE_TAG_MAXIMIZE</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>first_tag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		  </block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><name>status</name> <operator>=</operator> <name>REG_ESPACE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;</operator> <operator>*</operator><name>max_pos</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><operator>*</operator><name>max_pos</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<break>break;</break>
	      </block_content>}</block>
	    <case>case <expr><name>UNION</name></expr>:</case>
	      <block>{<block_content>
		<decl_stmt><decl><type><name>tre_union_t</name> <modifier>*</modifier></type><name>uni</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>tre_union_t</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>tre_ast_new_union</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name><name>uni</name><operator>-&gt;</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>uni</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		  <block>{<block_content>
		    <expr_stmt><expr><name>status</name> <operator>=</operator> <name>REG_ESPACE</name></expr>;</expr_stmt>
		    <break>break;</break>
		  </block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>result</name><operator>)</operator><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>&amp;</operator><name><name>tmp</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name><name>uni</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>COPY_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tmp</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>COPY_SET_RESULT_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name><name>uni</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>COPY_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	      </block_content>}</block>
	    <case>case <expr><name>CATENATION</name></expr>:</case>
	      <block>{<block_content>
		<decl_stmt><decl><type><name>tre_catenation_t</name> <modifier>*</modifier></type><name>cat</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>tre_catenation_t</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>tre_ast_new_catenation</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name><name>cat</name><operator>-&gt;</operator><name>left</name></name></expr></argument>, <argument><expr><name><name>cat</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		  <block>{<block_content>
		    <expr_stmt><expr><name>status</name> <operator>=</operator> <name>REG_ESPACE</name></expr>;</expr_stmt>
		    <break>break;</break>
		  </block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>result</name><operator>)</operator><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>&amp;</operator><name><name>tmp</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name><name>cat</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>COPY_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tmp</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>COPY_SET_RESULT_PTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name><name>cat</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>COPY_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	      </block_content>}</block>
	    <case>case <expr><name>ITERATION</name></expr>:</case>
	      <block>{<block_content>
		<decl_stmt><decl><type><name>tre_iteration_t</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>COPY_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>tre_ast_new_iter</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>min</name></name></expr></argument>,
					   <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>max</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>minimal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		  <block>{<block_content>
		    <expr_stmt><expr><name>status</name> <operator>=</operator> <name>REG_ESPACE</name></expr>;</expr_stmt>
		    <break>break;</break>
		  </block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>iter</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>result</name><operator>)</operator><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
		<break>break;</break>
	      </block_content>}</block>
	    <default>default:</default>
	      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <break>break;</break>
	    </block_content>}</block></switch>
	  <break>break;</break>
	</block_content>}</block></switch>
    </block_content>}</block></while>
  <expr_stmt><expr><operator>*</operator><name>pos_add</name> <operator>+=</operator> <name>num_copied</name></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><enum>enum <block>{
  <decl><name>EXPAND_RECURSE</name></decl>,
  <decl><name>EXPAND_AFTER_ITER</name></decl>
}</block></enum></type> <name>tre_expand_ast_symbol_t</name>;</typedef>

<comment type="block">/* Expands each iteration node that has a finite nonzero minimum or maximum
   iteration count to a catenated sequence of copies of the node. */</comment>
<function><type><specifier>static</specifier> <name>reg_errcode_t</name></type>
<name>tre_expand_ast</name><parameter_list>(<parameter><decl><type><name>tre_mem_t</name></type> <name>mem</name></decl></parameter>, <parameter><decl><type><name>tre_stack_t</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>, <parameter><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>ast</name></decl></parameter>,
	       <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>position</name></decl></parameter>, <parameter><decl><type><name>tre_tag_direction_t</name> <modifier>*</modifier></type><name>tag_directions</name></decl></parameter>,
	       <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>max_depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>reg_errcode_t</name></type> <name>status</name> <init>= <expr><name>REG_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bottom</name> <init>= <expr><call><name>tre_stack_num_objects</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pos_add</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pos_add_total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>max_pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Current approximate matching parameters. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name><name>params</name><index>[<expr><name>TRE_PARAM_LAST</name></expr>]</index></name></decl>;</decl_stmt>
  <comment type="block">/* Approximate parameter nesting level. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>params_depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>iter_depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TRE_PARAM_LAST</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>params</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>TRE_PARAM_DEFAULT</name></expr>;</expr_stmt></block_content></block></for>

  <expr_stmt><expr><call><name>STACK_PUSHR</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name>ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>STACK_PUSHR</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>EXPAND_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>status</name> <operator>==</operator> <name>REG_OK</name> <operator>&amp;&amp;</operator> <call><name>tre_stack_num_objects</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>bottom</name></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>tre_expand_ast_symbol_t</name></type> <name>symbol</name></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
	<break>break;</break></block_content></block></if></if_stmt>

      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"pos_add %d\n"</literal><operator>,</operator> <name>pos_add</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>symbol</name> <operator>=</operator> <operator>(</operator><name>tre_expand_ast_symbol_t</name><operator>)</operator><call><name>tre_stack_pop_int</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>tre_stack_pop_voidptr</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <switch>switch <condition>(<expr><name>symbol</name></expr>)</condition>
	<block>{<block_content>
	<case>case <expr><name>EXPAND_RECURSE</name></expr>:</case>
	  <switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	    <block>{<block_content>
	    <case>case <expr><name>LITERAL</name></expr>:</case>
	      <block>{<block_content>
		<decl_stmt><decl><type><name>tre_literal_t</name> <modifier>*</modifier></type><name>lit</name><init>= <expr><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_SPECIAL</name><argument_list>(<argument><expr><name>lit</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_BACKREF</name><argument_list>(<argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>)</condition>
		  <block>{<block_content>
		    <expr_stmt><expr><name><name>lit</name><operator>-&gt;</operator><name>position</name></name> <operator>+=</operator> <name>pos_add</name></expr>;</expr_stmt>
		    <if_stmt><if>if <condition>(<expr><name><name>lit</name><operator>-&gt;</operator><name>position</name></name> <operator>&gt;</operator> <name>max_pos</name></expr>)</condition><block type="pseudo"><block_content>
		      <expr_stmt><expr><name>max_pos</name> <operator>=</operator> <name><name>lit</name><operator>-&gt;</operator><name>position</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		  </block_content>}</block></if></if_stmt>
		<break>break;</break>
	      </block_content>}</block>
	    <case>case <expr><name>UNION</name></expr>:</case>
	      <block>{<block_content>
		<decl_stmt><decl><type><name>tre_union_t</name> <modifier>*</modifier></type><name>uni</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name><name>uni</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>EXPAND_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name><name>uni</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>EXPAND_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	      </block_content>}</block>
	    <case>case <expr><name>CATENATION</name></expr>:</case>
	      <block>{<block_content>
		<decl_stmt><decl><type><name>tre_catenation_t</name> <modifier>*</modifier></type><name>cat</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name><name>cat</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>EXPAND_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name><name>cat</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>EXPAND_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	      </block_content>}</block>
	    <case>case <expr><name>ITERATION</name></expr>:</case>
	      <block>{<block_content>
		<decl_stmt><decl><type><name>tre_iteration_t</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>pos_add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>EXPAND_AFTER_ITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>EXPAND_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* If we are going to expand this node at EXPAND_AFTER_ITER
		   then don't increase the `pos' fields of the nodes now, it
		   will get done when expanding. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>min</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>iter</name><operator>-&gt;</operator><name>max</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><name>pos_add</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>iter_depth</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"iter\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	      </block_content>}</block>
	    <default>default:</default>
	      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <break>break;</break>
	    </block_content>}</block></switch>
	  <break>break;</break>
	<case>case <expr><name>EXPAND_AFTER_ITER</name></expr>:</case>
	  <block>{<block_content>
	    <decl_stmt><decl><type><name>tre_iteration_t</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int</name></type> <name>pos_add_last</name></decl>;</decl_stmt>
	    <expr_stmt><expr><name>pos_add</name> <operator>=</operator> <call><name>tre_stack_pop_int</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>pos_add_last</name> <operator>=</operator> <name>pos_add</name></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>min</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>iter</name><operator>-&gt;</operator><name>max</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	      <block>{<block_content>
		<decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>seq1</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>seq2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>pos_add_save</name> <init>= <expr><name>pos_add</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Create a catenated sequence of copies of the node. */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>iter</name><operator>-&gt;</operator><name>min</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		  <block>{<block_content>
		    <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>copy</name></decl>;</decl_stmt>
		    <comment type="block">/* Remove tags from all but the last copy. */</comment>
		    <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>j</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>iter</name><operator>-&gt;</operator><name>min</name></name><operator>)</operator></expr>
				 ?</condition><then> <expr><name>COPY_REMOVE_TAGS</name></expr>
				 </then><else>: <expr><name>COPY_MAXIMIZE_FIRST_TAG</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
		    <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  pos_add %d\n"</literal><operator>,</operator> <name>pos_add</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><name>pos_add_save</name> <operator>=</operator> <name>pos_add</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_copy_ast</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>pos_add</name></expr></argument>, <argument><expr><name>tag_directions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copy</name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>max_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
		      <return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>
		    <if_stmt><if>if <condition>(<expr><name>seq1</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		      <expr_stmt><expr><name>seq1</name> <operator>=</operator> <call><name>tre_ast_new_catenation</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>seq1</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		    <else>else<block type="pseudo"><block_content>
		      <expr_stmt><expr><name>seq1</name> <operator>=</operator> <name>copy</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		    <if_stmt><if>if <condition>(<expr><name>seq1</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		      <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		  </block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>max</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		  <block>{<block_content>
		    <comment type="block">/* No upper limit. */</comment>
		    <expr_stmt><expr><name>pos_add_save</name> <operator>=</operator> <name>pos_add</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_copy_ast</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>pos_add</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seq2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
		      <return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>
		    <expr_stmt><expr><name>seq2</name> <operator>=</operator> <call><name>tre_ast_new_iter</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>seq2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if_stmt><if>if <condition>(<expr><name>seq2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		      <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		  </block_content>}</block></if>
		<else>else
		  <block>{<block_content>
		    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>min</name></name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>iter</name><operator>-&gt;</operator><name>max</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		      <block>{<block_content>
			<decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>tmp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>copy</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>pos_add_save</name> <operator>=</operator> <name>pos_add</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_copy_ast</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					      <argument><expr><operator>&amp;</operator><name>pos_add</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>max_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
			  <return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>seq2</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			  <expr_stmt><expr><name>seq2</name> <operator>=</operator> <call><name>tre_ast_new_catenation</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>, <argument><expr><name>seq2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
			  <expr_stmt><expr><name>seq2</name> <operator>=</operator> <name>copy</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>seq2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			  <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>EMPTY</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			  <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>seq2</name> <operator>=</operator> <call><name>tre_ast_new_union</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>seq2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>seq2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			  <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		      </block_content>}</block></for>
		  </block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>pos_add</name> <operator>=</operator> <name>pos_add_save</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>seq1</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><name>seq1</name> <operator>=</operator> <name>seq2</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>seq2</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><name>seq1</name> <operator>=</operator> <call><name>tre_ast_new_catenation</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>seq1</name></expr></argument>, <argument><expr><name>seq2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>seq1</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>obj</name></name> <operator>=</operator> <name><name>seq1</name><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>seq1</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
	      </block_content>}</block></if></if_stmt>

	    <expr_stmt><expr><name>iter_depth</name><operator>--</operator></expr>;</expr_stmt>
	    <expr_stmt><expr><name>pos_add_total</name> <operator>+=</operator> <name>pos_add</name> <operator>-</operator> <name>pos_add_last</name></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><name>iter_depth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><name>pos_add</name> <operator>=</operator> <name>pos_add_total</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	    <comment type="block">/* If approximate parameters are specified, surround the result
	       with two parameter setting nodes.  The one on the left sets
	       the specified parameters, and the one on the right restores
	       the old parameters. */</comment>
	    <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>params</name></name></expr>)</condition>
	      <block>{<block_content>
		<decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>tmp_l</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp_r</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp_node</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>node_copy</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>old_params</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tmp_l</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>PARAMETER</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp_l</name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>tre_literal_t</name> <operator>*</operator><operator>)</operator><name><name>tmp_l</name><operator>-&gt;</operator><name>obj</name></name><operator>)</operator><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>params</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>params</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>TRE_PARAM_DEPTH</name></expr>]</index></name> <operator>=</operator> <name>params_depth</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmp_r</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>PARAMETER</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp_r</name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>old_params</name> <operator>=</operator> <call><name>tre_mem_alloc</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>old_params</name></expr></argument>)</argument_list></sizeof>
					   <operator>*</operator> <name>TRE_PARAM_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>old_params</name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TRE_PARAM_LAST</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		  <expr_stmt><expr><name><name>old_params</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>params</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>tre_literal_t</name> <operator>*</operator><operator>)</operator><name><name>tmp_r</name><operator>-&gt;</operator><name>obj</name></name><operator>)</operator><operator>-&gt;</operator><name><name>u</name><operator>.</operator><name>params</name></name> <operator>=</operator> <name>old_params</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>old_params</name><index>[<expr><name>TRE_PARAM_DEPTH</name></expr>]</index></name> <operator>=</operator> <name>params_depth</name></expr>;</expr_stmt>
		<comment type="block">/* XXX - this is the only place where ast_new_node is
		   needed -- should be moved inside AST module. */</comment>
		<expr_stmt><expr><name>node_copy</name> <operator>=</operator> <call><name>tre_ast_new_node</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>ITERATION</name></expr></argument>,
					     <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tre_iteration_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>node_copy</name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>node_copy</name><operator>-&gt;</operator><name>obj</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmp_node</name> <operator>=</operator> <call><name>tre_ast_new_catenation</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>tmp_l</name></expr></argument>, <argument><expr><name>node_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp_node</name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>tmp_node</name> <operator>=</operator> <call><name>tre_ast_new_catenation</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>tmp_node</name></expr></argument>, <argument><expr><name>tmp_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp_node</name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Replace the contents of `node' with `tmp_node'. */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>tmp_node</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>obj</name></name> <operator>=</operator> <name><name>tmp_node</name><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>tmp_node</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>params_depth</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>params_depth</name> <operator>&gt;</operator> <operator>*</operator><name>max_depth</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><operator>*</operator><name>max_depth</name> <operator>=</operator> <name>params_depth</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	      </block_content>}</block></if></if_stmt>
	    <break>break;</break>
	  </block_content>}</block>
	<default>default:</default>
	  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>
	</block_content>}</block></switch>
    </block_content>}</block></while>

  <expr_stmt><expr><operator>*</operator><name>position</name> <operator>+=</operator> <name>pos_add_total</name></expr>;</expr_stmt>

  <comment type="block">/* `max_pos' should never be larger than `*position' if the above
     code works, but just an extra safeguard let's make sure
     `*position' is set large enough so enough memory will be
     allocated for the transition table. */</comment>
  <if_stmt><if>if <condition>(<expr><name>max_pos</name> <operator>&gt;</operator> <operator>*</operator><name>position</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>position</name> <operator>=</operator> <name>max_pos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Expanded AST:\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>tre_ast_print</name><argument_list>(<argument><expr><name>ast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"*position %d, max_pos %d\n"</literal><operator>,</operator> <operator>*</operator><name>position</name><operator>,</operator> <name>max_pos</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>tre_pos_and_tags_t</name> <modifier>*</modifier></type>
<name>tre_set_empty</name><parameter_list>(<parameter><decl><type><name>tre_mem_t</name></type> <name>mem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>tre_pos_and_tags_t</name> <modifier>*</modifier></type><name>new_set</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>new_set</name> <operator>=</operator> <call><name>tre_mem_calloc</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>new_set</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>new_set</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>new_set</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>position</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_set</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>code_min</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_set</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>code_max</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

  <return>return <expr><name>new_set</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>tre_pos_and_tags_t</name> <modifier>*</modifier></type>
<name>tre_set_one</name><parameter_list>(<parameter><decl><type><name>tre_mem_t</name></type> <name>mem</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>position</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>code_min</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>code_max</name></decl></parameter>,
	    <parameter><decl><type><name>tre_ctype_t</name></type> <name>class</name></decl></parameter>, <parameter><decl><type><name>tre_ctype_t</name> <modifier>*</modifier></type><name>neg_classes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>backref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>tre_pos_and_tags_t</name> <modifier>*</modifier></type><name>new_set</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>new_set</name> <operator>=</operator> <call><name>tre_mem_calloc</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>new_set</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>new_set</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>new_set</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>position</name> <operator>=</operator> <name>position</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_set</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>code_min</name> <operator>=</operator> <name>code_min</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_set</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>code_max</name> <operator>=</operator> <name>code_max</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_set</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>class</name> <operator>=</operator> <name>class</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_set</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>neg_classes</name> <operator>=</operator> <name>neg_classes</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_set</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>backref</name> <operator>=</operator> <name>backref</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_set</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>position</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_set</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>code_min</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_set</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>code_max</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

  <return>return <expr><name>new_set</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>tre_pos_and_tags_t</name> <modifier>*</modifier></type>
<name>tre_set_union</name><parameter_list>(<parameter><decl><type><name>tre_mem_t</name></type> <name>mem</name></decl></parameter>, <parameter><decl><type><name>tre_pos_and_tags_t</name> <modifier>*</modifier></type><name>set1</name></decl></parameter>, <parameter><decl><type><name>tre_pos_and_tags_t</name> <modifier>*</modifier></type><name>set2</name></decl></parameter>,
	      <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>assertions</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>s1</name></decl>, <decl><type ref="prev"/><name>s2</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_pos_and_tags_t</name> <modifier>*</modifier></type><name>new_set</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>new_tags</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>num_tags</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>num_tags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>tags</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>tags</name><index>[<expr><name>num_tags</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>num_tags</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <for>for <control>(<init><expr><name>s1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>set1</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>position</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>s1</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <for>for <control>(<init><expr><name>s2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>set2</name><index>[<expr><name>s2</name></expr>]</index></name><operator>.</operator><name>position</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>s2</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  <expr_stmt><expr><name>new_set</name> <operator>=</operator> <call><name>tre_mem_calloc</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>new_set</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>s1</name> <operator>+</operator> <name>s2</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_set</name></expr> )</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

  <for>for <control>(<init><expr><name>s1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>set1</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>position</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>s1</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>position</name> <operator>=</operator> <name><name>set1</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>position</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>code_min</name> <operator>=</operator> <name><name>set1</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>code_min</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>code_max</name> <operator>=</operator> <name><name>set1</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>code_max</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>assertions</name> <operator>=</operator> <name><name>set1</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>assertions</name> <operator>|</operator> <name>assertions</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>class</name> <operator>=</operator> <name><name>set1</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>class</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>neg_classes</name> <operator>=</operator> <name><name>set1</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>neg_classes</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>backref</name> <operator>=</operator> <name><name>set1</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>backref</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>set1</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>tags</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>tags</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>tags</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
      <else>else
	<block>{<block_content>
	  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>set1</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>tags</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>set1</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
	  <expr_stmt><expr><name>new_tags</name> <operator>=</operator> <call><name>tre_mem_alloc</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>new_tags</name></expr></argument>)</argument_list></sizeof>
					 <operator>*</operator> <operator>(</operator><name>i</name> <operator>+</operator> <name>num_tags</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name>new_tags</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	  <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	    <expr_stmt><expr><name><name>new_tags</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>set1</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name><name>tags</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_tags</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	    <expr_stmt><expr><name><name>new_tags</name><index>[<expr><name>j</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	  <expr_stmt><expr><name><name>new_tags</name><index>[<expr><name>j</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>tags</name> <operator>=</operator> <name>new_tags</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>set1</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>params</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>params</name> <operator>=</operator> <name><name>set1</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>params</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>params</name></expr>)</condition>
	<block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>new_set</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>params</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>params</name> <operator>=</operator> <name>params</name></expr>;</expr_stmt></block_content></block></if>
	  <else>else
	    <block>{<block_content>
	      <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>params</name> <operator>=</operator> <call><name>tre_mem_alloc</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>params</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
						 <name>TRE_PARAM_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>new_set</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name>params</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TRE_PARAM_LAST</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>params</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>TRE_PARAM_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name></expr>]</index></name><operator>.</operator><name><name>params</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>params</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
	    </block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

  <for>for <control>(<init><expr><name>s2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>set2</name><index>[<expr><name>s2</name></expr>]</index></name><operator>.</operator><name>position</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>s2</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name> <operator>+</operator> <name>s2</name></expr>]</index></name><operator>.</operator><name>position</name> <operator>=</operator> <name><name>set2</name><index>[<expr><name>s2</name></expr>]</index></name><operator>.</operator><name>position</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name> <operator>+</operator> <name>s2</name></expr>]</index></name><operator>.</operator><name>code_min</name> <operator>=</operator> <name><name>set2</name><index>[<expr><name>s2</name></expr>]</index></name><operator>.</operator><name>code_min</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name> <operator>+</operator> <name>s2</name></expr>]</index></name><operator>.</operator><name>code_max</name> <operator>=</operator> <name><name>set2</name><index>[<expr><name>s2</name></expr>]</index></name><operator>.</operator><name>code_max</name></expr>;</expr_stmt>
      <comment type="block">/* XXX - why not | assertions here as well? */</comment>
      <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name> <operator>+</operator> <name>s2</name></expr>]</index></name><operator>.</operator><name>assertions</name> <operator>=</operator> <name><name>set2</name><index>[<expr><name>s2</name></expr>]</index></name><operator>.</operator><name>assertions</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name> <operator>+</operator> <name>s2</name></expr>]</index></name><operator>.</operator><name>class</name> <operator>=</operator> <name><name>set2</name><index>[<expr><name>s2</name></expr>]</index></name><operator>.</operator><name>class</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name> <operator>+</operator> <name>s2</name></expr>]</index></name><operator>.</operator><name>neg_classes</name> <operator>=</operator> <name><name>set2</name><index>[<expr><name>s2</name></expr>]</index></name><operator>.</operator><name>neg_classes</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name> <operator>+</operator> <name>s2</name></expr>]</index></name><operator>.</operator><name>backref</name> <operator>=</operator> <name><name>set2</name><index>[<expr><name>s2</name></expr>]</index></name><operator>.</operator><name>backref</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>set2</name><index>[<expr><name>s2</name></expr>]</index></name><operator>.</operator><name>tags</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name> <operator>+</operator> <name>s2</name></expr>]</index></name><operator>.</operator><name>tags</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
      <else>else
	<block>{<block_content>
	  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>set2</name><index>[<expr><name>s2</name></expr>]</index></name><operator>.</operator><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
	  <expr_stmt><expr><name>new_tags</name> <operator>=</operator> <call><name>tre_mem_alloc</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>new_tags</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name>new_tags</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	  <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	    <expr_stmt><expr><name><name>new_tags</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>set2</name><index>[<expr><name>s2</name></expr>]</index></name><operator>.</operator><name><name>tags</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	  <expr_stmt><expr><name><name>new_tags</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name> <operator>+</operator> <name>s2</name></expr>]</index></name><operator>.</operator><name>tags</name> <operator>=</operator> <name>new_tags</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>set2</name><index>[<expr><name>s2</name></expr>]</index></name><operator>.</operator><name>params</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name> <operator>+</operator> <name>s2</name></expr>]</index></name><operator>.</operator><name>params</name> <operator>=</operator> <name><name>set2</name><index>[<expr><name>s2</name></expr>]</index></name><operator>.</operator><name>params</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>params</name></expr>)</condition>
	<block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>new_set</name><index>[<expr><name>s1</name> <operator>+</operator> <name>s2</name></expr>]</index></name><operator>.</operator><name>params</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name> <operator>+</operator> <name>s2</name></expr>]</index></name><operator>.</operator><name>params</name> <operator>=</operator> <name>params</name></expr>;</expr_stmt></block_content></block></if>
	  <else>else
	    <block>{<block_content>
	      <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name> <operator>+</operator> <name>s2</name></expr>]</index></name><operator>.</operator><name>params</name> <operator>=</operator> <call><name>tre_mem_alloc</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>params</name></expr></argument>)</argument_list></sizeof> <operator>*</operator>
						      <name>TRE_PARAM_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>new_set</name><index>[<expr><name>s1</name> <operator>+</operator> <name>s2</name></expr>]</index></name><operator>.</operator><name>params</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TRE_PARAM_LAST</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>params</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>TRE_PARAM_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name> <operator>+</operator> <name>s2</name></expr>]</index></name><operator>.</operator><name><name>params</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>params</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
	    </block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
  <expr_stmt><expr><name><name>new_set</name><index>[<expr><name>s1</name> <operator>+</operator> <name>s2</name></expr>]</index></name><operator>.</operator><name>position</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <return>return <expr><name>new_set</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Finds the empty path through `node' which is the one that should be
   taken according to POSIX.2 rules, and adds the tags on that path to
   `tags'.   `tags' may be NULL.  If `num_tags_seen' is not NULL, it is
   set to the number of tags seen on the path. */</comment>
<function><type><specifier>static</specifier> <name>reg_errcode_t</name></type>
<name>tre_match_empty</name><parameter_list>(<parameter><decl><type><name>tre_stack_t</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>, <parameter><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tags</name></decl></parameter>,
		<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>assertions</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_tags_seen</name></decl></parameter>,
		<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>params_seen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>tre_literal_t</name> <modifier>*</modifier></type><name>lit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_union_t</name> <modifier>*</modifier></type><name>uni</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_catenation_t</name> <modifier>*</modifier></type><name>cat</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_iteration_t</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bottom</name> <init>= <expr><call><name>tre_stack_num_objects</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>reg_errcode_t</name></type> <name>status</name> <init>= <expr><name>REG_OK</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>num_tags_seen</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>num_tags_seen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>params_seen</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>params_seen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_stack_push_voidptr</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Walk through the tree recursively. */</comment>
  <while>while <condition>(<expr><name>status</name> <operator>==</operator> <name>REG_OK</name> <operator>&amp;&amp;</operator> <call><name>tre_stack_num_objects</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>bottom</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>tre_stack_pop_voidptr</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
	<case>case <expr><name>LITERAL</name></expr>:</case>
	  <expr_stmt><expr><name>lit</name> <operator>=</operator> <operator>(</operator><name>tre_literal_t</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>
	  <switch>switch <condition>(<expr><name><name>lit</name><operator>-&gt;</operator><name>code_min</name></name></expr>)</condition>
	    <block>{<block_content>
	    <case>case <expr><name>TAG</name></expr>:</case>
	      <if_stmt><if>if <condition>(<expr><name><name>lit</name><operator>-&gt;</operator><name>code_max</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
		  <if_stmt><if>if <condition>(<expr><name>tags</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		    <block>{<block_content>
		      <comment type="block">/* Add the tag to `tags'. */</comment>
		      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>lit</name><operator>-&gt;</operator><name>code_max</name></name></expr>)</condition><block type="pseudo"><block_content>
			  <break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
		      <if_stmt><if>if <condition>(<expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
			  <expr_stmt><expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>lit</name><operator>-&gt;</operator><name>code_max</name></name></expr>;</expr_stmt>
			  <expr_stmt><expr><name><name>tags</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		    </block_content>}</block></if></if_stmt>
		  <if_stmt><if>if <condition>(<expr><name>num_tags_seen</name></expr>)</condition><block type="pseudo"><block_content>
		    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>num_tags_seen</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	      <break>break;</break>
	    <case>case <expr><name>ASSERTION</name></expr>:</case>
	      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lit</name><operator>-&gt;</operator><name>code_max</name></name> <operator>&gt;=</operator> <literal type="number">1</literal>
		     <operator>||</operator> <name><name>lit</name><operator>-&gt;</operator><name>code_max</name></name> <operator>&lt;=</operator> <name>ASSERT_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name>assertions</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>assertions</name> <operator>|=</operator> <name><name>lit</name><operator>-&gt;</operator><name>code_max</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	      <break>break;</break>
	    <case>case <expr><name>PARAMETER</name></expr>:</case>
	      <if_stmt><if>if <condition>(<expr><name>params</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TRE_PARAM_LAST</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		  <expr_stmt><expr><name><name>params</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>lit</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>params</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>
	      <if_stmt><if>if <condition>(<expr><name>params_seen</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>params_seen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	      <break>break;</break>
	    <case>case <expr><name>EMPTY</name></expr>:</case>
	      <break>break;</break>
	    <default>default:</default>
	      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <break>break;</break>
	    </block_content>}</block></switch>
	  <break>break;</break>

	<case>case <expr><name>UNION</name></expr>:</case>
	  <comment type="block">/* Subexpressions starting earlier take priority over ones
	     starting later, so we prefer the left subexpression over the
	     right subexpression. */</comment>
	  <expr_stmt><expr><name>uni</name> <operator>=</operator> <operator>(</operator><name>tre_union_t</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name><name>uni</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>nullable</name></name></expr>)</condition><block type="pseudo"><block_content>
	    <macro><name>STACK_PUSHX</name><argument_list>(<argument>stack</argument>, <argument>voidptr</argument>, <argument>uni-&gt;left</argument>)</argument_list></macro></block_content></block>
	  <if_stmt><if type="elseif">else if <condition>(<expr><name><name>uni</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>nullable</name></name></expr>)</condition><block type="pseudo"><block_content>
	    <macro><name>STACK_PUSHX</name><argument_list>(<argument>stack</argument>, <argument>voidptr</argument>, <argument>uni-&gt;right</argument>)</argument_list></macro></block_content></block>
	  <if_stmt><else>else<block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt></if></if_stmt></if></if_stmt>
	  <break>break;</break>

	<case>case <expr><name>CATENATION</name></expr>:</case>
	  <comment type="block">/* The path must go through both children. */</comment>
	  <expr_stmt><expr><name>cat</name> <operator>=</operator> <operator>(</operator><name>tre_catenation_t</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cat</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>nullable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cat</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>nullable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name><name>cat</name><operator>-&gt;</operator><name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name><name>cat</name><operator>-&gt;</operator><name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>

	<case>case <expr><name>ITERATION</name></expr>:</case>
	  <comment type="block">/* A match with an empty string is preferred over no match at
	     all, so we go through the argument if possible. */</comment>
	  <expr_stmt><expr><name>iter</name> <operator>=</operator> <operator>(</operator><name>tre_iteration_t</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>arg</name><operator>-&gt;</operator><name>nullable</name></name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>STACK_PUSHX</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <break>break;</break>

	<default>default:</default>
	  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>
	</block_content>}</block></switch>
    </block_content>}</block></while>

  <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>


<typedef>typedef <type><enum>enum <block>{
  <decl><name>NFL_RECURSE</name></decl>,
  <decl><name>NFL_POST_UNION</name></decl>,
  <decl><name>NFL_POST_CATENATION</name></decl>,
  <decl><name>NFL_POST_ITERATION</name></decl>
}</block></enum></type> <name>tre_nfl_stack_symbol_t</name>;</typedef>


<comment type="block">/* Computes and fills in the fields `nullable', `firstpos', and `lastpos' for
   the nodes of the AST `tree'. */</comment>
<function><type><specifier>static</specifier> <name>reg_errcode_t</name></type>
<name>tre_compute_nfl</name><parameter_list>(<parameter><decl><type><name>tre_mem_t</name></type> <name>mem</name></decl></parameter>, <parameter><decl><type><name>tre_stack_t</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>, <parameter><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>bottom</name> <init>= <expr><call><name>tre_stack_num_objects</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>STACK_PUSHR</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>STACK_PUSHR</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>NFL_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while <condition>(<expr><call><name>tre_stack_num_objects</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>bottom</name></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>tre_nfl_stack_symbol_t</name></type> <name>symbol</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>symbol</name> <operator>=</operator> <operator>(</operator><name>tre_nfl_stack_symbol_t</name><operator>)</operator><call><name>tre_stack_pop_int</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>tre_stack_pop_voidptr</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <switch>switch <condition>(<expr><name>symbol</name></expr>)</condition>
	<block>{<block_content>
	<case>case <expr><name>NFL_RECURSE</name></expr>:</case>
	  <switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	    <block>{<block_content>
	    <case>case <expr><name>LITERAL</name></expr>:</case>
	      <block>{<block_content>
		<decl_stmt><decl><type><name>tre_literal_t</name> <modifier>*</modifier></type><name>lit</name> <init>= <expr><operator>(</operator><name>tre_literal_t</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IS_BACKREF</name><argument_list>(<argument><expr><name>lit</name></expr></argument>)</argument_list></call></expr>)</condition>
		  <block>{<block_content>
		    <comment type="block">/* Back references: nullable = false, firstpos = {i},
		       lastpos = {i}. */</comment>
		    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nullable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>firstpos</name></name> <operator>=</operator> <call><name>tre_set_one</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name><name>lit</name><operator>-&gt;</operator><name>position</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					     <argument><expr><name>TRE_CHAR_MAX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>firstpos</name></name></expr>)</condition><block type="pseudo"><block_content>
		      <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>lastpos</name></name> <operator>=</operator> <call><name>tre_set_one</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name><name>lit</name><operator>-&gt;</operator><name>position</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
						<argument><expr><name>TRE_CHAR_MAX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>lit</name><operator>-&gt;</operator><name>code_max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>lastpos</name></name></expr>)</condition><block type="pseudo"><block_content>
		      <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		  </block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>lit</name><operator>-&gt;</operator><name>code_min</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		  <block>{<block_content>
		    <comment type="block">/* Tags, empty strings, params, and zero width assertions:
		       nullable = true, firstpos = {}, and lastpos = {}. */</comment>
		    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nullable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>firstpos</name></name> <operator>=</operator> <call><name>tre_set_empty</name><argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>firstpos</name></name></expr>)</condition><block type="pseudo"><block_content>
		      <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>lastpos</name></name> <operator>=</operator> <call><name>tre_set_empty</name><argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>lastpos</name></name></expr>)</condition><block type="pseudo"><block_content>
		      <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		  </block_content>}</block></if>
		<else>else
		  <block>{<block_content>
		    <comment type="block">/* Literal at position i: nullable = false, firstpos = {i},
		       lastpos = {i}. */</comment>
		    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nullable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>firstpos</name></name> <operator>=</operator>
		      <call><name>tre_set_one</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name><name>lit</name><operator>-&gt;</operator><name>position</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>lit</name><operator>-&gt;</operator><name>code_min</name></name></expr></argument>,
				  <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>lit</name><operator>-&gt;</operator><name>code_max</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>firstpos</name></name></expr>)</condition><block type="pseudo"><block_content>
		      <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>lastpos</name></name> <operator>=</operator> <call><name>tre_set_one</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name><name>lit</name><operator>-&gt;</operator><name>position</name></name></expr></argument>,
						<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>lit</name><operator>-&gt;</operator><name>code_min</name></name></expr></argument>,
						<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>lit</name><operator>-&gt;</operator><name>code_max</name></name></expr></argument>,
						<argument><expr><name><name>lit</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>class</name></name></expr></argument>, <argument><expr><name><name>lit</name><operator>-&gt;</operator><name>neg_classes</name></name></expr></argument>,
						<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>lastpos</name></name></expr>)</condition><block type="pseudo"><block_content>
		      <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		  </block_content>}</block></else></if_stmt>
		<break>break;</break>
	      </block_content>}</block>

	    <case>case <expr><name>UNION</name></expr>:</case>
	      <comment type="block">/* Compute the attributes for the two subtrees, and after that
		 for this node. */</comment>
	      <expr_stmt><expr><call><name>STACK_PUSHR</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>STACK_PUSHR</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>NFL_POST_UNION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>STACK_PUSHR</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>tre_union_t</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>obj</name></name><operator>)</operator><operator>-&gt;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>STACK_PUSHR</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>NFL_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>STACK_PUSHR</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>tre_union_t</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>obj</name></name><operator>)</operator><operator>-&gt;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>STACK_PUSHR</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>NFL_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <break>break;</break>

	    <case>case <expr><name>CATENATION</name></expr>:</case>
	      <comment type="block">/* Compute the attributes for the two subtrees, and after that
		 for this node. */</comment>
	      <expr_stmt><expr><call><name>STACK_PUSHR</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>STACK_PUSHR</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>NFL_POST_CATENATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>STACK_PUSHR</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>tre_catenation_t</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>obj</name></name><operator>)</operator><operator>-&gt;</operator><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>STACK_PUSHR</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>NFL_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>STACK_PUSHR</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>tre_catenation_t</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>obj</name></name><operator>)</operator><operator>-&gt;</operator><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>STACK_PUSHR</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>NFL_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <break>break;</break>

	    <case>case <expr><name>ITERATION</name></expr>:</case>
	      <comment type="block">/* Compute the attributes for the subtree, and after that for
		 this node. */</comment>
	      <expr_stmt><expr><call><name>STACK_PUSHR</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>STACK_PUSHR</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>NFL_POST_ITERATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>STACK_PUSHR</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>voidptr</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>tre_iteration_t</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>obj</name></name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>STACK_PUSHR</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>NFL_RECURSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <break>break;</break>
	    </block_content>}</block></switch>
	  <break>break;</break> <comment type="block">/* end case: NFL_RECURSE */</comment>

	<case>case <expr><name>NFL_POST_UNION</name></expr>:</case>
	  <block>{<block_content>
	    <decl_stmt><decl><type><name>tre_union_t</name> <modifier>*</modifier></type><name>uni</name> <init>= <expr><operator>(</operator><name>tre_union_t</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>
	    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nullable</name></name> <operator>=</operator> <name><name>uni</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>nullable</name></name> <operator>||</operator> <name><name>uni</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>nullable</name></name></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>firstpos</name></name> <operator>=</operator> <call><name>tre_set_union</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name><name>uni</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>firstpos</name></name></expr></argument>,
					   <argument><expr><name><name>uni</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>firstpos</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>firstpos</name></name></expr>)</condition><block type="pseudo"><block_content>
	      <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
	    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>lastpos</name></name> <operator>=</operator> <call><name>tre_set_union</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name><name>uni</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>lastpos</name></name></expr></argument>,
					  <argument><expr><name><name>uni</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>lastpos</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>lastpos</name></name></expr>)</condition><block type="pseudo"><block_content>
	      <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
	    <break>break;</break>
	  </block_content>}</block>

	<case>case <expr><name>NFL_POST_ITERATION</name></expr>:</case>
	  <block>{<block_content>
	    <decl_stmt><decl><type><name>tre_iteration_t</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><operator>(</operator><name>tre_iteration_t</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>

	    <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>min</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>iter</name><operator>-&gt;</operator><name>arg</name><operator>-&gt;</operator><name>nullable</name></name></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nullable</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	    <else>else<block type="pseudo"><block_content>
	      <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nullable</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>firstpos</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>arg</name><operator>-&gt;</operator><name>firstpos</name></name></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>lastpos</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>arg</name><operator>-&gt;</operator><name>lastpos</name></name></expr>;</expr_stmt>
	    <break>break;</break>
	  </block_content>}</block>

	<case>case <expr><name>NFL_POST_CATENATION</name></expr>:</case>
	  <block>{<block_content>
	    <decl_stmt><decl><type><name>int</name></type> <name>num_tags</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tags</name></decl>, <decl><type ref="prev"/><name>assertions</name></decl>, <decl><type ref="prev"/><name>params_seen</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>params</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>reg_errcode_t</name></type> <name>status</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>tre_catenation_t</name> <modifier>*</modifier></type><name>cat</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr></init></decl>;</decl_stmt>
	    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nullable</name></name> <operator>=</operator> <name><name>cat</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>nullable</name></name> <operator>&amp;&amp;</operator> <name><name>cat</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>nullable</name></name></expr>;</expr_stmt>

	    <comment type="block">/* Compute firstpos. */</comment>
	    <if_stmt><if>if <condition>(<expr><name><name>cat</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>nullable</name></name></expr>)</condition>
	      <block>{<block_content>
		<comment type="block">/* The left side matches the empty string.  Make a first pass
		   with tre_match_empty() to get the number of tags and
		   parameters. */</comment>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_match_empty</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name><name>cat</name><operator>-&gt;</operator><name>left</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_tags</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>params_seen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Allocate arrays for the tags and parameters. */</comment>
		<expr_stmt><expr><name>tags</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tags</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>num_tags</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tags</name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>tags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>assertions</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>params</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>params_seen</name></expr>)</condition>
		  <block>{<block_content>
		    <expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>tre_mem_alloc</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>params</name></expr></argument>)</argument_list></sizeof>
					   <operator>*</operator> <name>TRE_PARAM_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>params</name></expr>)</condition>
		      <block>{<block_content>
			<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>tags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>REG_ESPACE</name></expr>;</return>
		      </block_content>}</block></if></if_stmt>
		  </block_content>}</block></if></if_stmt>
		<comment type="block">/* Second pass with tre_mach_empty() to get the list of
		   tags and parameters. */</comment>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_match_empty</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name><name>cat</name><operator>-&gt;</operator><name>left</name></name></expr></argument>, <argument><expr><name>tags</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>assertions</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition>
		  <block>{<block_content>
		    <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>tags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <return>return <expr><name>status</name></expr>;</return>
		  </block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>firstpos</name></name> <operator>=</operator>
		  <call><name>tre_set_union</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name><name>cat</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>firstpos</name></name></expr></argument>, <argument><expr><name><name>cat</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>firstpos</name></name></expr></argument>,
				<argument><expr><name>tags</name></expr></argument>, <argument><expr><name>assertions</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>tags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>firstpos</name></name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
	      </block_content>}</block></if>
	    <else>else
	      <block>{<block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>firstpos</name></name> <operator>=</operator> <name><name>cat</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>firstpos</name></name></expr>;</expr_stmt>
	      </block_content>}</block></else></if_stmt>

	    <comment type="block">/* Compute lastpos. */</comment>
	    <if_stmt><if>if <condition>(<expr><name><name>cat</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>nullable</name></name></expr>)</condition>
	      <block>{<block_content>
		<comment type="block">/* The right side matches the empty string.  Make a first pass
		   with tre_match_empty() to get the number of tags and
		   parameters. */</comment>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_match_empty</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name><name>cat</name><operator>-&gt;</operator><name>right</name></name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_tags</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>params_seen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Allocate arrays for the tags and parameters. */</comment>
		<expr_stmt><expr><name>tags</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>num_tags</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tags</name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>tags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>assertions</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>params</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>params_seen</name></expr>)</condition>
		  <block>{<block_content>
		    <expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>tre_mem_alloc</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>params</name></expr></argument>)</argument_list></sizeof>
					   <operator>*</operator> <name>TRE_PARAM_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>params</name></expr>)</condition>
		      <block>{<block_content>
			<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>tags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>REG_ESPACE</name></expr>;</return>
		      </block_content>}</block></if></if_stmt>
		  </block_content>}</block></if></if_stmt>
		<comment type="block">/* Second pass with tre_mach_empty() to get the list of
		   tags and parameters. */</comment>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tre_match_empty</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name><name>cat</name><operator>-&gt;</operator><name>right</name></name></expr></argument>, <argument><expr><name>tags</name></expr></argument>,
					 <argument><expr><operator>&amp;</operator><name>assertions</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition>
		  <block>{<block_content>
		    <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>tags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <return>return <expr><name>status</name></expr>;</return>
		  </block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>lastpos</name></name> <operator>=</operator>
		  <call><name>tre_set_union</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name><name>cat</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>lastpos</name></name></expr></argument>, <argument><expr><name><name>cat</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>lastpos</name></name></expr></argument>,
				<argument><expr><name>tags</name></expr></argument>, <argument><expr><name>assertions</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>tags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>lastpos</name></name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
	      </block_content>}</block></if>
	    <else>else
	      <block>{<block_content>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>lastpos</name></name> <operator>=</operator> <name><name>cat</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>lastpos</name></name></expr>;</expr_stmt>
	      </block_content>}</block></else></if_stmt>
	    <break>break;</break>
	  </block_content>}</block>

	<default>default:</default>
	  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <break>break;</break>
	</block_content>}</block></switch>
    </block_content>}</block></while>

  <return>return <expr><name>REG_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Adds a transition from each position in `p1' to each position in `p2'. */</comment>
<function><type><specifier>static</specifier> <name>reg_errcode_t</name></type>
<name>tre_make_trans</name><parameter_list>(<parameter><decl><type><name>tre_pos_and_tags_t</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><name>tre_pos_and_tags_t</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>,
	       <parameter><decl><type><name>tre_tnfa_transition_t</name> <modifier>*</modifier></type><name>transitions</name></decl></parameter>,
	       <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>counts</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>offs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>tre_pos_and_tags_t</name> <modifier>*</modifier></type><name>orig_p2</name> <init>= <expr><name>p2</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_tnfa_transition_t</name> <modifier>*</modifier></type><name>trans</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>l</name></decl>, <decl><type ref="prev"/><name>dup</name></decl>, <decl><type ref="prev"/><name>prev_p2_pos</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>transitions</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <while>while <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>position</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
	<expr_stmt><expr><name>p2</name> <operator>=</operator> <name>orig_p2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev_p2_pos</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name><name>p2</name><operator>-&gt;</operator><name>position</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	  <block>{<block_content>
	    <comment type="block">/* Optimization: if this position was already handled, skip it. */</comment>
	    <if_stmt><if>if <condition>(<expr><name><name>p2</name><operator>-&gt;</operator><name>position</name></name> <operator>==</operator> <name>prev_p2_pos</name></expr>)</condition>
	      <block>{<block_content>
		<expr_stmt><expr><name>p2</name><operator>++</operator></expr>;</expr_stmt>
		<continue>continue;</continue>
	      </block_content>}</block></if></if_stmt>
	    <expr_stmt><expr><name>prev_p2_pos</name> <operator>=</operator> <name><name>p2</name><operator>-&gt;</operator><name>position</name></name></expr>;</expr_stmt>
	    <comment type="block">/* Set `trans' to point to the next unused transition from
	       position `p1-&gt;position'. */</comment>
	    <expr_stmt><expr><name>trans</name> <operator>=</operator> <name>transitions</name> <operator>+</operator> <name><name>offs</name><index>[<expr><name><name>p1</name><operator>-&gt;</operator><name>position</name></name></expr>]</index></name></expr>;</expr_stmt>
	    <while>while <condition>(<expr><name><name>trans</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	      <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
		<comment type="block">/* If we find a previous transition from `p1-&gt;position' to
		   `p2-&gt;position', it is overwritten.  This can happen only
		   if there are nested loops in the regexp, like in "((a)*)*".
		   In POSIX.2 repetition using the outer loop is always
		   preferred over using the inner loop.	 Therefore the
		   transition for the inner loop is useless and can be thrown
		   away. */</comment>
		<comment type="block">/* XXX - The same position is used for all nodes in a bracket
		   expression, so this optimization cannot be used (it will
		   break bracket expressions) unless I figure out a way to
		   detect it here. */</comment>
		if (trans-&gt;state_id == p2-&gt;position)
		  {
		    DPRINT(("*"));
		    break;
		  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>trans</name><operator>++</operator></expr>;</expr_stmt>
	      </block_content>}</block></while>

	    <if_stmt><if>if <condition>(<expr><name><name>trans</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><operator>(</operator><name>trans</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>-&gt;</operator><name>state</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	    <comment type="block">/* Use the character ranges, assertions, etc. from `p1' for
	       the transition from `p1' to `p2'. */</comment>
	    <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>code_min</name></name> <operator>=</operator> <operator>(</operator><name>tre_cint_t</name><operator>)</operator> <name><name>p1</name><operator>-&gt;</operator><name>code_min</name></name></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>code_max</name></name> <operator>=</operator> <operator>(</operator><name>tre_cint_t</name><operator>)</operator> <name><name>p1</name><operator>-&gt;</operator><name>code_max</name></name></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>transitions</name> <operator>+</operator> <name><name>offs</name><index>[<expr><name><name>p2</name><operator>-&gt;</operator><name>position</name></name></expr>]</index></name></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>state_id</name></name> <operator>=</operator> <name><name>p2</name><operator>-&gt;</operator><name>position</name></name></expr>;</expr_stmt>
	    <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>assertions</name></name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>assertions</name></name> <operator>|</operator> <name><name>p2</name><operator>-&gt;</operator><name>assertions</name></name>
	      <operator>|</operator> <operator>(</operator><ternary><condition><expr><name><name>p1</name><operator>-&gt;</operator><name>class</name></name></expr> ?</condition><then> <expr><name>ASSERT_CHAR_CLASS</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator>
	      <operator>|</operator> <operator>(</operator><ternary><condition><expr><name><name>p1</name><operator>-&gt;</operator><name>neg_classes</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>ASSERT_CHAR_CLASS_NEG</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>backref</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	      <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>trans</name><operator>-&gt;</operator><name>assertions</name></name> <operator>&amp;</operator> <name>ASSERT_CHAR_CLASS</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p2</name><operator>-&gt;</operator><name>backref</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name></name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>backref</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>assertions</name></name> <operator>|=</operator> <name>ASSERT_BACKREF</name></expr>;</expr_stmt>
	      </block_content>}</block></if>
	    <else>else<block type="pseudo"><block_content>
	      <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>class</name></name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>class</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	    <if_stmt><if>if <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>neg_classes</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	      <block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>p1</name><operator>-&gt;</operator><name>neg_classes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <operator>(</operator><name>tre_ctype_t</name><operator>)</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
		<expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>neg_classes</name></name> <operator>=</operator>
		  <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>trans</name><operator>-&gt;</operator><name>neg_classes</name></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>trans</name><operator>-&gt;</operator><name>neg_classes</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>p1</name><operator>-&gt;</operator><name>neg_classes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <operator>(</operator><name>tre_ctype_t</name><operator>)</operator><literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		  <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>neg_classes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>neg_classes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>neg_classes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>tre_ctype_t</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>
	      </block_content>}</block></if>
	    <else>else<block type="pseudo"><block_content>
	      <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>neg_classes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	    <comment type="block">/* Find out how many tags this transition has. */</comment>
	    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>tags</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	      <while>while<condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while></block_content></block></if></if_stmt>
	    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><name><name>p2</name><operator>-&gt;</operator><name>tags</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	      <while>while<condition>(<expr><name><name>p2</name><operator>-&gt;</operator><name>tags</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while></block_content></block></if></if_stmt>

	    <comment type="block">/* If we are overwriting a transition, free the old tag array. */</comment>
	    <if_stmt><if>if <condition>(<expr><name><name>trans</name><operator>-&gt;</operator><name>tags</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>trans</name><operator>-&gt;</operator><name>tags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	    <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>tags</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	    <comment type="block">/* If there were any tags, allocate an array and fill it. */</comment>
	    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	      <block>{<block_content>
		<expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>tags</name></name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>trans</name><operator>-&gt;</operator><name>tags</name></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>i</name> <operator>+</operator> <name>j</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>trans</name><operator>-&gt;</operator><name>tags</name></name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>tags</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		  <while>while<condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		    <block>{<block_content>
		      <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>tags</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		    </block_content>}</block></while></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>l</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>p2</name><operator>-&gt;</operator><name>tags</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		  <while>while <condition>(<expr><name><name>p2</name><operator>-&gt;</operator><name>tags</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		    <block>{<block_content>
		      <comment type="block">/* Don't add duplicates. */</comment>
		      <expr_stmt><expr><name>dup</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		      <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><name><name>trans</name><operator>-&gt;</operator><name>tags</name><index>[<expr><name>k</name></expr>]</index></name> <operator>==</operator> <name><name>p2</name><operator>-&gt;</operator><name>tags</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition>
			  <block>{<block_content>
			    <expr_stmt><expr><name>dup</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			    <break>break;</break>
			  </block_content>}</block></if></if_stmt></block_content></block></for>
		      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dup</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>tags</name><index>[<expr><name>l</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>p2</name><operator>-&gt;</operator><name>tags</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		      <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
		    </block_content>}</block></while></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>tags</name><index>[<expr><name>l</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	      </block_content>}</block></if></if_stmt>

	    <comment type="block">/* Set the parameter array.	 If both `p2' and `p1' have same
	       parameters, the values in `p2' override those in `p1'. */</comment>
	    <if_stmt><if>if <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>params</name></name> <operator>||</operator> <name><name>p2</name><operator>-&gt;</operator><name>params</name></name></expr>)</condition>
	      <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>trans</name><operator>-&gt;</operator><name>params</name></name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>params</name></name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>trans</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></sizeof>
					  <operator>*</operator> <name>TRE_PARAM_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>trans</name><operator>-&gt;</operator><name>params</name></name></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TRE_PARAM_LAST</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		  <block>{<block_content>
		    <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>TRE_PARAM_UNSET</name></expr>;</expr_stmt>
		    <if_stmt><if>if <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>params</name></name> <operator>&amp;&amp;</operator> <name><name>p1</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>TRE_PARAM_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
		      <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		    <if_stmt><if>if <condition>(<expr><name><name>p2</name><operator>-&gt;</operator><name>params</name></name> <operator>&amp;&amp;</operator> <name><name>p2</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>TRE_PARAM_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
		      <expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>p2</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		  </block_content>}</block></for>
	      </block_content>}</block></if>
	    <else>else
	      <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>trans</name><operator>-&gt;</operator><name>params</name></name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>trans</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>trans</name><operator>-&gt;</operator><name>params</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	      </block_content>}</block></else></if_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_DEBUG</name></cpp:ifdef>
	    <block>{<block_content>
	      <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>tags</name></decl>;</decl_stmt>

	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"	 %2d -&gt; %2d on %3d"</literal><operator>,</operator> <name><name>p1</name><operator>-&gt;</operator><name>position</name></name><operator>,</operator> <name><name>p2</name><operator>-&gt;</operator><name>position</name></name><operator>,</operator>
		      <name><name>p1</name><operator>-&gt;</operator><name>code_min</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>code_max</name></name> <operator>!=</operator> <name><name>p1</name><operator>-&gt;</operator><name>code_min</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"-%3d"</literal><operator>,</operator> <name><name>p1</name><operator>-&gt;</operator><name>code_max</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	      <expr_stmt><expr><name>tags</name> <operator>=</operator> <name><name>trans</name><operator>-&gt;</operator><name>tags</name></name></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name>tags</name></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">", tags ["</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <while>while <condition>(<expr><operator>*</operator><name>tags</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		    <block>{<block_content>
		      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"%d"</literal><operator>,</operator> <operator>*</operator><name>tags</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name>tags</name><operator>++</operator></expr>;</expr_stmt>
		      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>tags</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">","</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		    </block_content>}</block></while>
		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"]"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	      <if_stmt><if>if <condition>(<expr><name><name>trans</name><operator>-&gt;</operator><name>assertions</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">", assert %d"</literal><operator>,</operator> <name><name>trans</name><operator>-&gt;</operator><name>assertions</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	      <if_stmt><if>if <condition>(<expr><name><name>trans</name><operator>-&gt;</operator><name>assertions</name></name> <operator>&amp;</operator> <name>ASSERT_BACKREF</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">", backref %d"</literal><operator>,</operator> <name><name>trans</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	      <if type="elseif">else if <condition>(<expr><name><name>trans</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>class</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">", class %ld"</literal><operator>,</operator> <operator>(</operator><name>long</name><operator>)</operator><name><name>trans</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>class</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	      <if_stmt><if>if <condition>(<expr><name><name>trans</name><operator>-&gt;</operator><name>neg_classes</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">", neg_classes %p"</literal><operator>,</operator> <name><name>trans</name><operator>-&gt;</operator><name>neg_classes</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	      <if_stmt><if>if <condition>(<expr><name><name>trans</name><operator>-&gt;</operator><name>params</name></name></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">", "</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><call><name>tre_print_params</name><argument_list>(<argument><expr><name><name>trans</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_DEBUG */</comment>
	    <expr_stmt><expr><name>p2</name><operator>++</operator></expr>;</expr_stmt>
	  </block_content>}</block></while>
	<expr_stmt><expr><name>p1</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <comment type="block">/* Compute a maximum limit for the number of transitions leaving
       from each state. */</comment>
    <while>while <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>position</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
      <block>{<block_content>
	<expr_stmt><expr><name>p2</name> <operator>=</operator> <name>orig_p2</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name><name>p2</name><operator>-&gt;</operator><name>position</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	  <block>{<block_content>
	    <expr_stmt><expr><name><name>counts</name><index>[<expr><name><name>p1</name><operator>-&gt;</operator><name>position</name></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
	    <expr_stmt><expr><name>p2</name><operator>++</operator></expr>;</expr_stmt>
	  </block_content>}</block></while>
	<expr_stmt><expr><name>p1</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></while></block_content></block></else></if_stmt>
  <return>return <expr><name>REG_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Converts the syntax tree to a TNFA.	All the transitions in the TNFA are
   labelled with one character range (there are no transitions on empty
   strings).  The TNFA takes O(n^2) space in the worst case, `n' is size of
   the regexp. */</comment>
<function><type><specifier>static</specifier> <name>reg_errcode_t</name></type>
<name>tre_ast_to_tnfa</name><parameter_list>(<parameter><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>tre_tnfa_transition_t</name> <modifier>*</modifier></type><name>transitions</name></decl></parameter>,
		<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>counts</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>offs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>tre_union_t</name> <modifier>*</modifier></type><name>uni</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_catenation_t</name> <modifier>*</modifier></type><name>cat</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_iteration_t</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>reg_errcode_t</name></type> <name>errcode</name> <init>= <expr><name>REG_OK</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* XXX - recurse using a stack!. */</comment>
  <switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>LITERAL</name></expr>:</case>
      <break>break;</break>
    <case>case <expr><name>UNION</name></expr>:</case>
      <expr_stmt><expr><name>uni</name> <operator>=</operator> <operator>(</operator><name>tre_union_t</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>tre_ast_to_tnfa</name><argument_list>(<argument><expr><name><name>uni</name><operator>-&gt;</operator><name>left</name></name></expr></argument>, <argument><expr><name>transitions</name></expr></argument>, <argument><expr><name>counts</name></expr></argument>, <argument><expr><name>offs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>errcode</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>errcode</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>tre_ast_to_tnfa</name><argument_list>(<argument><expr><name><name>uni</name><operator>-&gt;</operator><name>right</name></name></expr></argument>, <argument><expr><name>transitions</name></expr></argument>, <argument><expr><name>counts</name></expr></argument>, <argument><expr><name>offs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>CATENATION</name></expr>:</case>
      <expr_stmt><expr><name>cat</name> <operator>=</operator> <operator>(</operator><name>tre_catenation_t</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>
      <comment type="block">/* Add a transition from each position in cat-&gt;left-&gt;lastpos
	 to each position in cat-&gt;right-&gt;firstpos. */</comment>
      <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>tre_make_trans</name><argument_list>(<argument><expr><name><name>cat</name><operator>-&gt;</operator><name>left</name><operator>-&gt;</operator><name>lastpos</name></name></expr></argument>, <argument><expr><name><name>cat</name><operator>-&gt;</operator><name>right</name><operator>-&gt;</operator><name>firstpos</name></name></expr></argument>,
			       <argument><expr><name>transitions</name></expr></argument>, <argument><expr><name>counts</name></expr></argument>, <argument><expr><name>offs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>errcode</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>errcode</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>tre_ast_to_tnfa</name><argument_list>(<argument><expr><name><name>cat</name><operator>-&gt;</operator><name>left</name></name></expr></argument>, <argument><expr><name>transitions</name></expr></argument>, <argument><expr><name>counts</name></expr></argument>, <argument><expr><name>offs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>errcode</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>errcode</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>tre_ast_to_tnfa</name><argument_list>(<argument><expr><name><name>cat</name><operator>-&gt;</operator><name>right</name></name></expr></argument>, <argument><expr><name>transitions</name></expr></argument>, <argument><expr><name>counts</name></expr></argument>, <argument><expr><name>offs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    <case>case <expr><name>ITERATION</name></expr>:</case>
      <expr_stmt><expr><name>iter</name> <operator>=</operator> <operator>(</operator><name>tre_iteration_t</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>obj</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>max</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name><name>iter</name><operator>-&gt;</operator><name>max</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>max</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>min</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>iter</name><operator>-&gt;</operator><name>min</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <comment type="block">/* Add a transition from each last position in the iterated
	     expression to each first position. */</comment>
	  <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>tre_make_trans</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>arg</name><operator>-&gt;</operator><name>lastpos</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>arg</name><operator>-&gt;</operator><name>firstpos</name></name></expr></argument>,
				   <argument><expr><name>transitions</name></expr></argument>, <argument><expr><name>counts</name></expr></argument>, <argument><expr><name>offs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name>errcode</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>errcode</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>tre_ast_to_tnfa</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>transitions</name></expr></argument>, <argument><expr><name>counts</name></expr></argument>, <argument><expr><name>offs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </block_content>}</block></switch>
  <return>return <expr><name>errcode</name></expr>;</return>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERROR_EXIT</name><parameter_list>(<parameter><type><name>err</name></type></parameter>)</parameter_list></cpp:macro>		  \
  <cpp:value>do				  \
    {				  \
      errcode = err;		  \
      if (<comment type="block">/*CONSTCOND*/</comment>(void)1,1)	  \
      	goto error_exit;	  \
    }				  \
 while (<comment type="block">/*CONSTCOND*/</comment>(void)0,0)</cpp:value></cpp:define>


<function><type><name>int</name></type>
<name>tre_compile</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>preg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>tre_char_t</name> <modifier>*</modifier></type><name>regex</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>tre_stack_t</name> <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_ast_node_t</name> <modifier>*</modifier></type><name>tree</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp_ast_l</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp_ast_r</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_pos_and_tags_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>counts</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>offs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>add</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_tnfa_transition_t</name> <modifier>*</modifier></type><name>transitions</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>initial</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_tnfa_t</name> <modifier>*</modifier></type><name>tnfa</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_submatch_data_t</name> <modifier>*</modifier></type><name>submatch_data</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_tag_direction_t</name> <modifier>*</modifier></type><name>tag_directions</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>reg_errcode_t</name></type> <name>errcode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_mem_t</name></type> <name>mem</name></decl>;</decl_stmt>

  <comment type="block">/* Parse context. */</comment>
  <decl_stmt><decl><type><name>tre_parse_ctx_t</name></type> <name>parse_ctx</name></decl>;</decl_stmt>

  <comment type="block">/* Allocate a stack used throughout the compilation process for various
     purposes. */</comment>
  <expr_stmt><expr><name>stack</name> <operator>=</operator> <call><name>tre_stack_new</name><argument_list>(<argument><expr><literal type="number">512</literal></expr></argument>, <argument><expr><literal type="number">10240</literal></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>stack</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
  <comment type="block">/* Allocate a fast memory allocator. */</comment>
  <expr_stmt><expr><name>mem</name> <operator>=</operator> <call><name>tre_mem_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>mem</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>tre_stack_destroy</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>REG_ESPACE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Parse the regexp. */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parse_ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>parse_ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>parse_ctx</name><operator>.</operator><name>mem</name></name> <operator>=</operator> <name>mem</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>parse_ctx</name><operator>.</operator><name>stack</name></name> <operator>=</operator> <name>stack</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>parse_ctx</name><operator>.</operator><name>re</name></name> <operator>=</operator> <name>regex</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>parse_ctx</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>parse_ctx</name><operator>.</operator><name>cflags</name></name> <operator>=</operator> <name>cflags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>parse_ctx</name><operator>.</operator><name>max_backref</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <comment type="block">/* workaround for PR#14408: use 8-bit optimizations in 8-bit mode */</comment>
  <expr_stmt><expr><name><name>parse_ctx</name><operator>.</operator><name>cur_max</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>cflags</name> <operator>&amp;</operator> <name>REG_USEBYTES</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>TRE_MB_CUR_MAX</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_compile: parsing '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><name>n</name><operator>,</operator> <name>regex</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>tre_parse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parse_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>errcode</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ERROR_EXIT</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>preg</name><operator>-&gt;</operator><name>re_nsub</name></name> <operator>=</operator> <name><name>parse_ctx</name><operator>.</operator><name>submatch_id</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>tree</name> <operator>=</operator> <name><name>parse_ctx</name><operator>.</operator><name>result</name></name></expr>;</expr_stmt>

  <comment type="block">/* Back references and approximate matching cannot currently be used
     in the same regexp. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>parse_ctx</name><operator>.</operator><name>max_backref</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>parse_ctx</name><operator>.</operator><name>have_approx</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ERROR_EXIT</name><argument_list>(<argument><expr><name>REG_BADPAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><call><name>tre_ast_print</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_DEBUG */</comment>

  <comment type="block">/* Referring to nonexistent subexpressions is illegal. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>parse_ctx</name><operator>.</operator><name>max_backref</name></name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>preg</name><operator>-&gt;</operator><name>re_nsub</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ERROR_EXIT</name><argument_list>(<argument><expr><name>REG_ESUBREG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Allocate the TNFA struct. */</comment>
  <expr_stmt><expr><name>tnfa</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tre_tnfa_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>tnfa</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ERROR_EXIT</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>have_backrefs</name></name> <operator>=</operator> <name><name>parse_ctx</name><operator>.</operator><name>max_backref</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>have_approx</name></name> <operator>=</operator> <name><name>parse_ctx</name><operator>.</operator><name>have_approx</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>num_submatches</name></name> <operator>=</operator> <name><name>parse_ctx</name><operator>.</operator><name>submatch_id</name></name></expr>;</expr_stmt>

  <comment type="block">/* Set up tags for submatch addressing.  If REG_NOSUB is set and the
     regexp does not have back references, this can be skipped. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>tnfa</name><operator>-&gt;</operator><name>have_backrefs</name></name> <operator>||</operator> <operator>!</operator><operator>(</operator><name>cflags</name> <operator>&amp;</operator> <name>REG_NOSUB</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_compile: setting up tags\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Figure out how many tags we will need. */</comment>
      <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>tre_add_tags</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>tnfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>errcode</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>ERROR_EXIT</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_DEBUG</name></cpp:ifdef>
      <expr_stmt><expr><call><name>tre_ast_print</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_DEBUG */</comment>

      <if_stmt><if>if <condition>(<expr><name><name>tnfa</name><operator>-&gt;</operator><name>num_tags</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><name>tag_directions</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tag_directions</name></expr></argument>)</argument_list></sizeof>
				   <operator>*</operator> <operator>(</operator><name><name>tnfa</name><operator>-&gt;</operator><name>num_tags</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name>tag_directions</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>ERROR_EXIT</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>tag_directions</name></name> <operator>=</operator> <name>tag_directions</name></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>tag_directions</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
		 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tag_directions</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>tnfa</name><operator>-&gt;</operator><name>num_tags</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name></name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>tnfa</name><operator>-&gt;</operator><name>num_tags</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>ERROR_EXIT</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <expr_stmt><expr><name>submatch_data</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name><name>parse_ctx</name><operator>.</operator><name>submatch_id</name></name></expr></argument>,
			      <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>submatch_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>submatch_data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>ERROR_EXIT</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>submatch_data</name></name> <operator>=</operator> <name>submatch_data</name></expr>;</expr_stmt>

      <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>tre_add_tags</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><name>tnfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>errcode</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>ERROR_EXIT</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_DEBUG</name></cpp:ifdef>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>parse_ctx</name><operator>.</operator><name>submatch_id</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"pmatch[%d] = {t%d, t%d}\n"</literal><operator>,</operator>
		<name>i</name><operator>,</operator> <name><name>submatch_data</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>so_tag</name><operator>,</operator> <name><name>submatch_data</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eo_tag</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>num_tags</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"t%d is %s\n"</literal><operator>,</operator> <name>i</name><operator>,</operator>
		<ternary><condition><expr><name><name>tag_directions</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>TRE_TAG_MINIMIZE</name></expr> ?</condition><then>
		<expr><literal type="string">"minimized"</literal></expr> </then><else>: <expr><literal type="string">"maximized"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_DEBUG */</comment>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Expand iteration nodes. */</comment>
  <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>tre_expand_ast</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parse_ctx</name><operator>.</operator><name>position</name></name></expr></argument>,
			   <argument><expr><name>tag_directions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tnfa</name><operator>-&gt;</operator><name>params_depth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>errcode</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ERROR_EXIT</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* Add a dummy node for the final state.
     XXX - For certain patterns this dummy node can be optimized away,
	   for example "a*" or "ab*".	Figure out a simple way to detect
	   this possibility. */</comment>
  <expr_stmt><expr><name>tmp_ast_l</name> <operator>=</operator> <name>tree</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tmp_ast_r</name> <operator>=</operator> <call><name>tre_ast_new_literal</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>parse_ctx</name><operator>.</operator><name>position</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>tmp_ast_r</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ERROR_EXIT</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>tree</name> <operator>=</operator> <call><name>tre_ast_new_catenation</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>tmp_ast_l</name></expr></argument>, <argument><expr><name>tmp_ast_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>tree</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ERROR_EXIT</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_DEBUG</name></cpp:ifdef>
  <expr_stmt><expr><call><name>tre_ast_print</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Number of states: %d\n"</literal><operator>,</operator> <name><name>parse_ctx</name><operator>.</operator><name>position</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_DEBUG */</comment>

  <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>tre_compute_nfl</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>errcode</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ERROR_EXIT</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>counts</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>parse_ctx</name><operator>.</operator><name>position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>counts</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ERROR_EXIT</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>offs</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>parse_ctx</name><operator>.</operator><name>position</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>offs</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ERROR_EXIT</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>parse_ctx</name><operator>.</operator><name>position</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>counts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
  <expr_stmt><expr><call><name>tre_ast_to_tnfa</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>counts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>add</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>parse_ctx</name><operator>.</operator><name>position</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><name><name>offs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>add</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>add</name> <operator>+=</operator> <name><name>counts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>counts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
  <expr_stmt><expr><name>transitions</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>add</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>transitions</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>transitions</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ERROR_EXIT</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>transitions</name></name> <operator>=</operator> <name>transitions</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>num_transitions</name></name> <operator>=</operator> <name>add</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Converting to TNFA:\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>tre_ast_to_tnfa</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>transitions</name></expr></argument>, <argument><expr><name>counts</name></expr></argument>, <argument><expr><name>offs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>errcode</name> <operator>!=</operator> <name>REG_OK</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ERROR_EXIT</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <comment type="block">/* If in eight bit mode, compute a table of characters that can be the
     first character of a match. */</comment>
  <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>first_char</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>TRE_MB_CUR_MAX</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tmp_ast_l</name><operator>-&gt;</operator><name>nullable</name></name></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>tre_cint_t</name></type> <name>k</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Characters that can start a match:"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>firstpos_chars</name></name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><literal type="number">256</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>tnfa</name><operator>-&gt;</operator><name>firstpos_chars</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>ERROR_EXIT</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>tree</name><operator>-&gt;</operator><name>firstpos</name></name></expr>;</init> <condition><expr><name><name>p</name><operator>-&gt;</operator><name>position</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
	  <decl_stmt><decl><type><name>tre_tnfa_transition_t</name> <modifier>*</modifier></type><name>j</name> <init>= <expr><name>transitions</name> <operator>+</operator> <name><name>offs</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>position</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	  <while>while <condition>(<expr><name><name>j</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	    <block>{<block_content>
	      <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name><name>j</name><operator>-&gt;</operator><name>code_min</name></name></expr>;</init> <condition><expr><name>k</name> <operator>&lt;=</operator> <name><name>j</name><operator>-&gt;</operator><name>code_max</name></name> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">" %d"</literal><operator>,</operator> <name>k</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>firstpos_chars</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		  <expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
	      <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
	    </block_content>}</block></while>
	</block_content>}</block></for>
      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRE_OPTIMIZE_FIRST_CHAR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TRE_OPTIMIZE_FIRST_CHAR</name></expr></cpp:if>
      <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
	  <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	    <if_stmt><if>if <condition>(<expr><name><name>tnfa</name><operator>-&gt;</operator><name>firstpos_chars</name><index>[<expr><name>k</name></expr>]</index></name></expr>)</condition>
	      <block>{<block_content>
		<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"first char must be %d\n"</literal><operator>,</operator> <name>k</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>first_char</name></name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>tnfa</name><operator>-&gt;</operator><name>firstpos_chars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>firstpos_chars</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<break>break;</break>
	      </block_content>}</block></if></if_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>firstpos_chars</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>


  <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>tree</name><operator>-&gt;</operator><name>firstpos</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <while>while <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>position</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_DEBUG</name></cpp:ifdef>
      <block>{<block_content>
	<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>tags</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"initial: %d"</literal><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>position</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tags</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>tags</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tags</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	  <block>{<block_content>
	    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>tags</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"/"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	    <while>while <condition>(<expr><operator>*</operator><name>tags</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	      <block>{<block_content>
		<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"%d"</literal><operator>,</operator> <operator>*</operator><name>tags</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tags</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>tags</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">","</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	      </block_content>}</block></while>
	  </block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">", assert %d"</literal><operator>,</operator> <name><name>p</name><operator>-&gt;</operator><name>assertions</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>params</name></name></expr>)</condition>
	  <block>{<block_content>
	    <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">", "</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>tre_print_params</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  </block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_DEBUG */</comment>

      <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

  <expr_stmt><expr><name>initial</name> <operator>=</operator> <call><name>xcalloc</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tre_tnfa_transition_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>initial</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>ERROR_EXIT</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>initial</name></name> <operator>=</operator> <name>initial</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>tree</name><operator>-&gt;</operator><name>firstpos</name></name></expr>;</init> <condition><expr><name><name>p</name><operator>-&gt;</operator><name>position</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><name><name>initial</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>transitions</name> <operator>+</operator> <name><name>offs</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>position</name></name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>initial</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>state_id</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>position</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>initial</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tags</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <comment type="block">/* Copy the arrays p-&gt;tags, and p-&gt;params, they are allocated
	 from a tre_mem object. */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>tags</name></name></expr>)</condition>
	<block>{<block_content>
	  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
	  <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>p</name><operator>-&gt;</operator><name>tags</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
	  <expr_stmt><expr><name><name>initial</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tags</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>tags</name></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>j</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>initial</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tags</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>ERROR_EXIT</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>initial</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tags</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>tags</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>tags</name></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>j</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>initial</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>params</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>params</name></name></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><name><name>initial</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>params</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>TRE_PARAM_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>initial</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>params</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>ERROR_EXIT</name><argument_list>(<argument><expr><name>REG_ESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>initial</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>params</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>params</name></name></expr></argument>,
		 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>TRE_PARAM_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>initial</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>assertions</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>assertions</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></for>
  <expr_stmt><expr><name><name>initial</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>num_transitions</name></name> <operator>=</operator> <name>add</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>final</name></name> <operator>=</operator> <name>transitions</name> <operator>+</operator> <name><name>offs</name><index>[<expr><name><name>tree</name><operator>-&gt;</operator><name>lastpos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>position</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>num_states</name></name> <operator>=</operator> <name><name>parse_ctx</name><operator>.</operator><name>position</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tnfa</name><operator>-&gt;</operator><name>cflags</name></name> <operator>=</operator> <name>cflags</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"final state %p\n"</literal><operator>,</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>tnfa</name><operator>-&gt;</operator><name>final</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>tre_mem_destroy</name><argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>tre_stack_destroy</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>counts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>offs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>preg</name><operator>-&gt;</operator><name>TRE_REGEX_T_FIELD</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>tnfa</name></expr>;</expr_stmt>
  <return>return <expr><name>REG_OK</name></expr>;</return>

 <label><name>error_exit</name>:</label>
  <comment type="block">/* Free everything that was allocated and return the error code. */</comment>
  <expr_stmt><expr><call><name>tre_mem_destroy</name><argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>stack</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>tre_stack_destroy</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>counts</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>counts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>offs</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>offs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>preg</name><operator>-&gt;</operator><name>TRE_REGEX_T_FIELD</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>tnfa</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>tre_free</name><argument_list>(<argument><expr><name>preg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>errcode</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>void</name></type>
<name>tre_free</name><parameter_list>(<parameter><decl><type><name>regex_t</name> <modifier>*</modifier></type><name>preg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>tre_tnfa_t</name> <modifier>*</modifier></type><name>tnfa</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_tnfa_transition_t</name> <modifier>*</modifier></type><name>trans</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>tnfa</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>preg</name><operator>-&gt;</operator><name>TRE_REGEX_T_FIELD</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tnfa</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>num_transitions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><name><name>tnfa</name><operator>-&gt;</operator><name>transitions</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>state</name></expr>)</condition>
      <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>tnfa</name><operator>-&gt;</operator><name>transitions</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tags</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>tnfa</name><operator>-&gt;</operator><name>transitions</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tnfa</name><operator>-&gt;</operator><name>transitions</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>neg_classes</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>tnfa</name><operator>-&gt;</operator><name>transitions</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>neg_classes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tnfa</name><operator>-&gt;</operator><name>transitions</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>params</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>tnfa</name><operator>-&gt;</operator><name>transitions</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></if></if_stmt></block_content></block></for>
  <if_stmt><if>if <condition>(<expr><name><name>tnfa</name><operator>-&gt;</operator><name>transitions</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>tnfa</name><operator>-&gt;</operator><name>transitions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>tnfa</name><operator>-&gt;</operator><name>initial</name></name></expr>)</condition>
    <block>{<block_content>
      <for>for <control>(<init><expr><name>trans</name> <operator>=</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>initial</name></name></expr>;</init> <condition><expr><name><name>trans</name><operator>-&gt;</operator><name>state</name></name></expr>;</condition> <incr><expr><name>trans</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name><name>trans</name><operator>-&gt;</operator><name>tags</name></name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>trans</name><operator>-&gt;</operator><name>tags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <if_stmt><if>if <condition>(<expr><name><name>trans</name><operator>-&gt;</operator><name>params</name></name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>trans</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
      <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>tnfa</name><operator>-&gt;</operator><name>initial</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>tnfa</name><operator>-&gt;</operator><name>submatch_data</name></name></expr>)</condition>
    <block>{<block_content>
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>num_submatches</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	<if_stmt><if>if <condition>(<expr><name><name>tnfa</name><operator>-&gt;</operator><name>submatch_data</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>parents</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>tnfa</name><operator>-&gt;</operator><name>submatch_data</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>parents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
      <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>tnfa</name><operator>-&gt;</operator><name>submatch_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>tnfa</name><operator>-&gt;</operator><name>tag_directions</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>tnfa</name><operator>-&gt;</operator><name>tag_directions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>tnfa</name><operator>-&gt;</operator><name>firstpos_chars</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>tnfa</name><operator>-&gt;</operator><name>firstpos_chars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>tnfa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>tre_version</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>str</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>version</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>tre_config</name><argument_list>(<argument><expr><name>TRE_CONFIG_VERSION</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"TRE %s (BSD)"</literal></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>tre_config</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>query</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>int_result</name> <init>= <expr><name>result</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>string_result</name> <init>= <expr><name>result</name></expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name>query</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>TRE_CONFIG_APPROX</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_APPROX</name></cpp:ifdef>
      <expr_stmt><expr><operator>*</operator><name>int_result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !TRE_APPROX */</comment>
      <expr_stmt><expr><operator>*</operator><name>int_result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !TRE_APPROX */</comment>
      <return>return <expr><name>REG_OK</name></expr>;</return>

    <case>case <expr><name>TRE_CONFIG_WCHAR</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_WCHAR</name></cpp:ifdef>
      <expr_stmt><expr><operator>*</operator><name>int_result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !TRE_WCHAR */</comment>
      <expr_stmt><expr><operator>*</operator><name>int_result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !TRE_WCHAR */</comment>
      <return>return <expr><name>REG_OK</name></expr>;</return>

    <case>case <expr><name>TRE_CONFIG_MULTIBYTE</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_MULTIBYTE</name></cpp:ifdef>
      <expr_stmt><expr><operator>*</operator><name>int_result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !TRE_MULTIBYTE */</comment>
      <expr_stmt><expr><operator>*</operator><name>int_result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !TRE_MULTIBYTE */</comment>
      <return>return <expr><name>REG_OK</name></expr>;</return>

    <case>case <expr><name>TRE_CONFIG_SYSTEM_ABI</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_CONFIG_SYSTEM_ABI</name></cpp:ifdef>
      <expr_stmt><expr><operator>*</operator><name>int_result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !TRE_CONFIG_SYSTEM_ABI */</comment>
      <expr_stmt><expr><operator>*</operator><name>int_result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !TRE_CONFIG_SYSTEM_ABI */</comment>
      <return>return <expr><name>REG_OK</name></expr>;</return>

    <case>case <expr><name>TRE_CONFIG_VERSION</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>string_result</name> <operator>=</operator> <name>TRE_VERSION</name></expr>;</expr_stmt>
      <return>return <expr><name>REG_OK</name></expr>;</return>
    </block_content>}</block></switch>

  <return>return <expr><name>REG_NOMATCH</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* EOF */</comment>
</unit>
