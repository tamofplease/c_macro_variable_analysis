<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/tre-regex/tre-match-parallel.c"><comment type="block">/*
  tre-match-parallel.c - TRE parallel regex matching engine

  This software is released under a BSD-style license.
  See the file LICENSE for details and copyright.

*/</comment>

<comment type="block">/*
  This algorithm searches for matches basically by reading characters
  in the searched string one by one, starting at the beginning.	 All
  matching paths in the TNFA are traversed in parallel.	 When two or
  more paths reach the same state, exactly one is chosen according to
  tag ordering rules; if returning submatches is not required it does
  not matter which path is chosen.

  The worst case time required for finding the leftmost and longest
  match, or determining that there is no match, is always linearly
  dependent on the length of the text being searched.

  This algorithm cannot handle TNFAs with back referencing nodes.
  See `tre-match-backtrack.c'.
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre-config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre-internal.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;config.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_CONFIG_H */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_USE_ALLOCA</name></cpp:ifdef>
<comment type="block">/* AIX requires this to be the first thing in the file.	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__GNUC__</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>HAVE_ALLOCA_H</name></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;alloca.h&gt;</cpp:file></cpp:include>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>_AIX</name></cpp:ifdef>
 <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>alloca</name></cpp:pragma>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifndef>#   <cpp:directive>ifndef</cpp:directive> <name>alloca</name></cpp:ifndef> <comment type="block">/* predefined by HP cc +Olibcalls */</comment>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>alloca</name> <parameter_list>()</parameter_list>;</function_decl>
<cpp:endif>#   <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_USE_ALLOCA */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_WCHAR_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wchar.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_WCHAR_H */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_WCTYPE_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wctype.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_WCTYPE_H */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TRE_WCHAR</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !TRE_WCHAR */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_MALLOC_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_MALLOC_H */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre-internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre-match-utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmalloc.h"</cpp:file></cpp:include>



<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>tre_tnfa_transition_t</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>tags</name></decl>;</decl_stmt>
}</block></struct></type> <name>tre_tnfa_reach_t</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>tags</name></decl>;</decl_stmt>
}</block></struct></type> <name>tre_reach_pos_t</name>;</typedef>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_DEBUG</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tre_print_reach</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>tre_tnfa_t</name> <modifier>*</modifier></type><name>tnfa</name></decl></parameter>, <parameter><decl><type><name>tre_tnfa_reach_t</name> <modifier>*</modifier></type><name>reach</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_tags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <while>while <condition>(<expr><name><name>reach</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">" %p"</literal><operator>,</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>reach</name><operator>-&gt;</operator><name>state</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>num_tags</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"/"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_tags</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	    <block>{<block_content>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"%d:%d"</literal><operator>,</operator> <name>i</name><operator>,</operator> <name><name>reach</name><operator>-&gt;</operator><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>num_tags</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">","</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	    </block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>reach</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_DEBUG */</comment>

<function><type><name>reg_errcode_t</name></type>
<name>tre_tnfa_run_parallel</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>tre_tnfa_t</name> <modifier>*</modifier></type><name>tnfa</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
		      <parameter><decl><type><name>tre_str_type_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>match_tags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>,
		      <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>match_end_ofs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* State variables required by GET_NEXT_WCHAR. */</comment>
  <decl_stmt><decl><type><name>tre_char_t</name></type> <name>prev_c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>next_c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str_byte</name> <init>= <expr><name>string</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pos_add_next</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_WCHAR</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type><name>str_wide</name> <init>= <expr><name>string</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_MBSTATE</name></cpp:ifdef>
  <decl_stmt><decl><type><name>mbstate_t</name></type> <name>mbstate</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_MBSTATE */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_WCHAR */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>reg_notbol</name> <init>= <expr><name>eflags</name> <operator>&amp;</operator> <name>REG_NOTBOL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>reg_noteol</name> <init>= <expr><name>eflags</name> <operator>&amp;</operator> <name>REG_NOTEOL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>reg_newline</name> <init>= <expr><name><name>tnfa</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_NEWLINE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>str_user_end</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_tnfa_transition_t</name> <modifier>*</modifier></type><name>trans_i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_tnfa_reach_t</name> <modifier>*</modifier></type><name>reach</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>reach_next</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>reach_i</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>reach_next_i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>tre_reach_pos_t</name> <modifier>*</modifier></type><name>reach_pos</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>tag_i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>num_tags</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int</name></type> <name>match_eo</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>	   <comment type="block">/* end offset of match (-1 if no match found yet) */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>new_match</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>tmp_tags</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>tmp_iptr</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_MBSTATE</name></cpp:ifdef>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mbstate</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mbstate</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_MBSTATE */</comment>

  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tre_tnfa_run_parallel, input type %d\n"</literal><operator>,</operator> <name>type</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>match_tags</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>num_tags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name>num_tags</name> <operator>=</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>num_tags</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <comment type="block">/* Allocate memory for temporary data required for matching.	This needs to
     be done for every matching operation to be thread safe.  This allocates
     everything in a single large block from the stack frame using alloca()
     or with malloc() if alloca is unavailable. */</comment>
  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>tbytes</name></decl>, <decl><type ref="prev"/><name>rbytes</name></decl>, <decl><type ref="prev"/><name>pbytes</name></decl>, <decl><type ref="prev"/><name>xbytes</name></decl>, <decl><type ref="prev"/><name>total_bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp_buf</name></decl>;</decl_stmt>
    <comment type="block">/* Compute the length of the block we need. */</comment>
    <expr_stmt><expr><name>tbytes</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tmp_tags</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_tags</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rbytes</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>reach_next</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>tnfa</name><operator>-&gt;</operator><name>num_states</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>pbytes</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>reach_pos</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>num_states</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>xbytes</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_tags</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>total_bytes</name> <operator>=</operator>
      <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">4</literal> <comment type="block">/* for alignment paddings */</comment>
      <operator>+</operator> <operator>(</operator><name>rbytes</name> <operator>+</operator> <name>xbytes</name> <operator>*</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>num_states</name></name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <name>tbytes</name> <operator>+</operator> <name>pbytes</name></expr>;</expr_stmt>

    <comment type="block">/* Allocate the memory. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_USE_ALLOCA</name></cpp:ifdef>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><name>total_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !TRE_USE_ALLOCA */</comment>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>total_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !TRE_USE_ALLOCA */</comment>
    <if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>total_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get the various pointers within tmp_buf (properly aligned). */</comment>
    <expr_stmt><expr><name>tmp_tags</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp_buf</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>tbytes</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp_buf</name> <operator>+=</operator> <call><name>ALIGN</name><argument_list>(<argument><expr><name>tmp_buf</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>reach_next</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>tmp_buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp_buf</name> <operator>+=</operator> <name>rbytes</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp_buf</name> <operator>+=</operator> <call><name>ALIGN</name><argument_list>(<argument><expr><name>tmp_buf</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>reach</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>tmp_buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp_buf</name> <operator>+=</operator> <name>rbytes</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp_buf</name> <operator>+=</operator> <call><name>ALIGN</name><argument_list>(<argument><expr><name>tmp_buf</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>reach_pos</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>tmp_buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp_buf</name> <operator>+=</operator> <name>pbytes</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp_buf</name> <operator>+=</operator> <call><name>ALIGN</name><argument_list>(<argument><expr><name>tmp_buf</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>num_states</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
	<expr_stmt><expr><name><name>reach</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tags</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>tmp_buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp_buf</name> <operator>+=</operator> <name>xbytes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>reach_next</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tags</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>tmp_buf</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp_buf</name> <operator>+=</operator> <name>xbytes</name></expr>;</expr_stmt>
      </block_content>}</block></for>
  </block_content>}</block>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>num_states</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>reach_pos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pos</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

  <comment type="block">/* If only one character can start a match, find it first. */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>tnfa</name><operator>-&gt;</operator><name>first_char</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>STR_BYTE</name> <operator>&amp;&amp;</operator> <name>str_byte</name></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orig_str</name> <init>= <expr><name>str_byte</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>first</name> <init>= <expr><name><name>tnfa</name><operator>-&gt;</operator><name>first_char</name></name></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>str_byte</name> <operator>=</operator> <call><name>memchr</name><argument_list>(<argument><expr><name>orig_str</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><name>str_byte</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>orig_str</name></expr></argument>, <argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>str_byte</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TRE_USE_ALLOCA</name></cpp:ifndef>
	  <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !TRE_USE_ALLOCA */</comment>
	  <return>return <expr><name>REG_NOMATCH</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"skipped %lu chars\n"</literal><operator>,</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><operator>(</operator><name>str_byte</name> <operator>-</operator> <name>orig_str</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>str_byte</name> <operator>&gt;=</operator> <name>orig_str</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>prev_c</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><operator>(</operator><name>str_byte</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>next_c</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>str_byte</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>pos</name> <operator>=</operator> <name>str_byte</name> <operator>-</operator> <name>orig_str</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>pos</name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>str_byte</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
      <expr_stmt><expr><call><name>GET_NEXT_WCHAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
  <comment type="block">/* Skip over characters that cannot possibly be the first character
     of a match. */</comment>
  if (tnfa-&gt;firstpos_chars != NULL)
    {
      char *chars = tnfa-&gt;firstpos_chars;

      if (len &lt; 0)
	{
	  const char *orig_str = str_byte;
	  <comment type="block">/* XXX - use strpbrk() and wcspbrk() because they might be
	     optimized for the target architecture.  Try also strcspn()
	     and wcscspn() and compare the speeds. */</comment>
	  while (next_c != L'\0' &amp;&amp; !chars[next_c])
	    {
	      next_c = *str_byte++;
	    }
	  prev_c = *(str_byte - 2);
	  pos += str_byte - orig_str;
	  DPRINT(("skipped %d chars\n", str_byte - orig_str));
	}
      else
	{
	  while (pos &lt;= len &amp;&amp; !chars[next_c])
	    {
	      prev_c = next_c;
	      next_c = (unsigned char)(*str_byte++);
	      pos++;
	    }
	}
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"length: %d\n"</literal><operator>,</operator> <name>len</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"pos:chr/code | states and tags\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"-------------+------------------------------------------------\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>reach_next_i</name> <operator>=</operator> <name>reach_next</name></expr>;</expr_stmt>
  <while>while <condition>(<comment type="block">/*CONSTCOND*/</comment><expr><operator>(</operator><name>void</name><operator>)</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* If no match found yet, add the initial states to `reach_next'. */</comment>
      <if_stmt><if>if <condition>(<expr><name>match_eo</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">" init &gt;"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>trans_i</name> <operator>=</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>initial</name></name></expr>;</expr_stmt>
	  <while>while <condition>(<expr><name><name>trans_i</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	    <block>{<block_content>
	      <if_stmt><if>if <condition>(<expr><name><name>reach_pos</name><index>[<expr><name><name>trans_i</name><operator>-&gt;</operator><name>state_id</name></name></expr>]</index></name><operator>.</operator><name>pos</name> <operator>&lt;</operator> <name>pos</name></expr>)</condition>
		<block>{<block_content>
		  <if_stmt><if>if <condition>(<expr><name><name>trans_i</name><operator>-&gt;</operator><name>assertions</name></name>
		      <operator>&amp;&amp;</operator> <call><name>CHECK_ASSERTIONS</name><argument_list>(<argument><expr><name><name>trans_i</name><operator>-&gt;</operator><name>assertions</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		    <block>{<block_content>
		      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"assertion failed\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name>trans_i</name><operator>++</operator></expr>;</expr_stmt>
		      <continue>continue;</continue>
		    </block_content>}</block></if></if_stmt>

		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">" %p"</literal><operator>,</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>trans_i</name><operator>-&gt;</operator><name>state</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>reach_next_i</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name><name>trans_i</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
		  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_tags</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		    <expr_stmt><expr><name><name>reach_next_i</name><operator>-&gt;</operator><name>tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
		  <expr_stmt><expr><name>tag_i</name> <operator>=</operator> <name><name>trans_i</name><operator>-&gt;</operator><name>tags</name></name></expr>;</expr_stmt>
		  <if_stmt><if>if <condition>(<expr><name>tag_i</name></expr>)</condition><block type="pseudo"><block_content>
		    <while>while <condition>(<expr><operator>*</operator><name>tag_i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		      <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>tag_i</name> <operator>&lt;</operator> <name>num_tags</name></expr>)</condition><block type="pseudo"><block_content>
			  <expr_stmt><expr><name><name>reach_next_i</name><operator>-&gt;</operator><name>tags</name><index>[<expr><operator>*</operator><name>tag_i</name></expr>]</index></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>tag_i</name><operator>++</operator></expr>;</expr_stmt>
		      </block_content>}</block></while></block_content></block></if></if_stmt>
		  <if_stmt><if>if <condition>(<expr><name><name>reach_next_i</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>final</name></name></expr>)</condition>
		    <block>{<block_content>
		      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"	 found empty match\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name>match_eo</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
		      <expr_stmt><expr><name>new_match</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_tags</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>match_tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>reach_next_i</name><operator>-&gt;</operator><name>tags</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
		    </block_content>}</block></if></if_stmt>
		  <expr_stmt><expr><name><name>reach_pos</name><index>[<expr><name><name>trans_i</name><operator>-&gt;</operator><name>state_id</name></name></expr>]</index></name><operator>.</operator><name>pos</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>reach_pos</name><index>[<expr><name><name>trans_i</name><operator>-&gt;</operator><name>state_id</name></name></expr>]</index></name><operator>.</operator><name>tags</name> <operator>=</operator> <operator>&amp;</operator><name><name>reach_next_i</name><operator>-&gt;</operator><name>tags</name></name></expr>;</expr_stmt>
		  <expr_stmt><expr><name>reach_next_i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	      <expr_stmt><expr><name>trans_i</name><operator>++</operator></expr>;</expr_stmt>
	    </block_content>}</block></while>
	  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>reach_next_i</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
      <else>else
	<block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>num_tags</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>reach_next_i</name> <operator>==</operator> <name>reach_next</name></expr>)</condition><block type="pseudo"><block_content>
	    <comment type="block">/* We have found a match. */</comment>
	    <break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

      <comment type="block">/* Check for end of string. */</comment>
      <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>STR_USER</name></expr>)</condition>
	    <block>{<block_content>
	      <if_stmt><if>if <condition>(<expr><name>str_user_end</name></expr>)</condition><block type="pseudo"><block_content>
		<break>break;</break></block_content></block></if></if_stmt>
	    </block_content>}</block></if>
	  <if type="elseif">else if <condition>(<expr><name>next_c</name> <operator>==</operator> <name>L</name><literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
	    <break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></if>
      <else>else
	<block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
	    <break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

      <expr_stmt><expr><call><name>GET_NEXT_WCHAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_DEBUG</name></cpp:ifdef>
      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"%3d:%2lc/%05d |"</literal><operator>,</operator> <name>pos</name> <operator>-</operator> <literal type="number">1</literal><operator>,</operator> <operator>(</operator><name>tre_cint_t</name><operator>)</operator><name>prev_c</name><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><name>prev_c</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>tre_print_reach</name><argument_list>(<argument><expr><name>tnfa</name></expr></argument>, <argument><expr><name>reach_next</name></expr></argument>, <argument><expr><name>num_tags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"%3d:%2lc/%05d |"</literal><operator>,</operator> <name>pos</name><operator>,</operator> <operator>(</operator><name>tre_cint_t</name><operator>)</operator><name>next_c</name><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><name>next_c</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>tre_print_reach</name><argument_list>(<argument><expr><name>tnfa</name></expr></argument>, <argument><expr><name>reach_next</name></expr></argument>, <argument><expr><name>num_tags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_DEBUG */</comment>

      <comment type="block">/* Swap `reach' and `reach_next'. */</comment>
      <expr_stmt><expr><name>reach_i</name> <operator>=</operator> <name>reach</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>reach</name> <operator>=</operator> <name>reach_next</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>reach_next</name> <operator>=</operator> <name>reach_i</name></expr>;</expr_stmt>

      <comment type="block">/* For each state in `reach', weed out states that don't fulfill the
	 minimal matching conditions. */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>tnfa</name><operator>-&gt;</operator><name>num_minimals</name></name> <operator>&amp;&amp;</operator> <name>new_match</name></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><name>new_match</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	  <expr_stmt><expr><name>reach_next_i</name> <operator>=</operator> <name>reach_next</name></expr>;</expr_stmt>
	  <for>for <control>(<init><expr><name>reach_i</name> <operator>=</operator> <name>reach</name></expr>;</init> <condition><expr><name><name>reach_i</name><operator>-&gt;</operator><name>state</name></name></expr>;</condition> <incr><expr><name>reach_i</name><operator>++</operator></expr></incr>)</control>
	    <block>{<block_content>
	      <decl_stmt><decl><type><name>int</name></type> <name>skip</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control>
		<block>{<block_content>
		  <decl_stmt><decl><type><name>int</name></type> <name>end</name> <init>= <expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		  <decl_stmt><decl><type><name>int</name></type> <name>start</name> <init>= <expr><name><name>tnfa</name><operator>-&gt;</operator><name>minimal_tags</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  Minimal start %d, end %d\n"</literal><operator>,</operator> <name>start</name><operator>,</operator> <name>end</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <if_stmt><if>if <condition>(<expr><name>end</name> <operator>&gt;=</operator> <name>num_tags</name></expr>)</condition>
		    <block>{<block_content>
		      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"	 Throwing %p out.\n"</literal><operator>,</operator> <name><name>reach_i</name><operator>-&gt;</operator><name>state</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name>skip</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		      <break>break;</break>
		    </block_content>}</block></if>
		  <if type="elseif">else if <condition>(<expr><name><name>reach_i</name><operator>-&gt;</operator><name>tags</name><index>[<expr><name>start</name></expr>]</index></name> <operator>==</operator> <name><name>match_tags</name><index>[<expr><name>start</name></expr>]</index></name>
			   <operator>&amp;&amp;</operator> <name><name>reach_i</name><operator>-&gt;</operator><name>tags</name><index>[<expr><name>end</name></expr>]</index></name> <operator>&lt;</operator> <name><name>match_tags</name><index>[<expr><name>end</name></expr>]</index></name></expr>)</condition>
		    <block>{<block_content>
		      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"	 Throwing %p out because t%d &lt; %d\n"</literal><operator>,</operator>
			      <name><name>reach_i</name><operator>-&gt;</operator><name>state</name></name><operator>,</operator> <name>end</name><operator>,</operator> <name><name>match_tags</name><index>[<expr><name>end</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name>skip</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		      <break>break;</break>
		    </block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip</name></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><name><name>reach_next_i</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name><name>reach_i</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
		  <expr_stmt><expr><name>tmp_iptr</name> <operator>=</operator> <name><name>reach_next_i</name><operator>-&gt;</operator><name>tags</name></name></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>reach_next_i</name><operator>-&gt;</operator><name>tags</name></name> <operator>=</operator> <name><name>reach_i</name><operator>-&gt;</operator><name>tags</name></name></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>reach_i</name><operator>-&gt;</operator><name>tags</name></name> <operator>=</operator> <name>tmp_iptr</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name>reach_next_i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	    </block_content>}</block></for>
	  <expr_stmt><expr><name><name>reach_next_i</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	  <comment type="block">/* Swap `reach' and `reach_next'. */</comment>
	  <expr_stmt><expr><name>reach_i</name> <operator>=</operator> <name>reach</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name>reach</name> <operator>=</operator> <name>reach_next</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name>reach_next</name> <operator>=</operator> <name>reach_i</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

      <comment type="block">/* For each state in `reach' see if there is a transition leaving with
	 the current input symbol to a state not yet in `reach_next', and
	 add the destination states to `reach_next'. */</comment>
      <expr_stmt><expr><name>reach_next_i</name> <operator>=</operator> <name>reach_next</name></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>reach_i</name> <operator>=</operator> <name>reach</name></expr>;</init> <condition><expr><name><name>reach_i</name><operator>-&gt;</operator><name>state</name></name></expr>;</condition> <incr><expr><name>reach_i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
	  <for>for <control>(<init><expr><name>trans_i</name> <operator>=</operator> <name><name>reach_i</name><operator>-&gt;</operator><name>state</name></name></expr>;</init> <condition><expr><name><name>trans_i</name><operator>-&gt;</operator><name>state</name></name></expr>;</condition> <incr><expr><name>trans_i</name><operator>++</operator></expr></incr>)</control>
	    <block>{<block_content>
	      <comment type="block">/* Does this transition match the input symbol? */</comment>
	      <if_stmt><if>if <condition>(<expr><name><name>trans_i</name><operator>-&gt;</operator><name>code_min</name></name> <operator>&lt;=</operator> <operator>(</operator><name>tre_cint_t</name><operator>)</operator><name>prev_c</name> <operator>&amp;&amp;</operator>
		  <name><name>trans_i</name><operator>-&gt;</operator><name>code_max</name></name> <operator>&gt;=</operator> <operator>(</operator><name>tre_cint_t</name><operator>)</operator><name>prev_c</name></expr>)</condition>
		<block>{<block_content>
		  <if_stmt><if>if <condition>(<expr><name><name>trans_i</name><operator>-&gt;</operator><name>assertions</name></name>
		      <operator>&amp;&amp;</operator> <operator>(</operator><call><name>CHECK_ASSERTIONS</name><argument_list>(<argument><expr><name><name>trans_i</name><operator>-&gt;</operator><name>assertions</name></name></expr></argument>)</argument_list></call>
			  <operator>||</operator> <call><name>CHECK_CHAR_CLASSES</name><argument_list>(<argument><expr><name>trans_i</name></expr></argument>, <argument><expr><name>tnfa</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		    <block>{<block_content>
		      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"assertion failed\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <continue>continue;</continue>
		    </block_content>}</block></if></if_stmt>

		  <comment type="block">/* Compute the tags after this transition. */</comment>
		  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_tags</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		    <expr_stmt><expr><name><name>tmp_tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>reach_i</name><operator>-&gt;</operator><name>tags</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
		  <expr_stmt><expr><name>tag_i</name> <operator>=</operator> <name><name>trans_i</name><operator>-&gt;</operator><name>tags</name></name></expr>;</expr_stmt>
		  <if_stmt><if>if <condition>(<expr><name>tag_i</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		    <while>while <condition>(<expr><operator>*</operator><name>tag_i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		      <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>tag_i</name> <operator>&lt;</operator> <name>num_tags</name></expr>)</condition><block type="pseudo"><block_content>
			  <expr_stmt><expr><name><name>tmp_tags</name><index>[<expr><operator>*</operator><name>tag_i</name></expr>]</index></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>tag_i</name><operator>++</operator></expr>;</expr_stmt>
		      </block_content>}</block></while></block_content></block></if></if_stmt>

		  <if_stmt><if>if <condition>(<expr><name><name>reach_pos</name><index>[<expr><name><name>trans_i</name><operator>-&gt;</operator><name>state_id</name></name></expr>]</index></name><operator>.</operator><name>pos</name> <operator>&lt;</operator> <name>pos</name></expr>)</condition>
		    <block>{<block_content>
		      <comment type="block">/* Found an unvisited node. */</comment>
		      <expr_stmt><expr><name><name>reach_next_i</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name><name>trans_i</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
		      <expr_stmt><expr><name>tmp_iptr</name> <operator>=</operator> <name><name>reach_next_i</name><operator>-&gt;</operator><name>tags</name></name></expr>;</expr_stmt>
		      <expr_stmt><expr><name><name>reach_next_i</name><operator>-&gt;</operator><name>tags</name></name> <operator>=</operator> <name>tmp_tags</name></expr>;</expr_stmt>
		      <expr_stmt><expr><name>tmp_tags</name> <operator>=</operator> <name>tmp_iptr</name></expr>;</expr_stmt>
		      <expr_stmt><expr><name><name>reach_pos</name><index>[<expr><name><name>trans_i</name><operator>-&gt;</operator><name>state_id</name></name></expr>]</index></name><operator>.</operator><name>pos</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
		      <expr_stmt><expr><name><name>reach_pos</name><index>[<expr><name><name>trans_i</name><operator>-&gt;</operator><name>state_id</name></name></expr>]</index></name><operator>.</operator><name>tags</name> <operator>=</operator> <operator>&amp;</operator><name><name>reach_next_i</name><operator>-&gt;</operator><name>tags</name></name></expr>;</expr_stmt>

		      <if_stmt><if>if <condition>(<expr><name><name>reach_next_i</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>final</name></name>
			  <operator>&amp;&amp;</operator> <operator>(</operator><name>match_eo</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal>
			      <operator>||</operator> <operator>(</operator><name>num_tags</name> <operator>&gt;</operator> <literal type="number">0</literal>
				  <operator>&amp;&amp;</operator> <name><name>reach_next_i</name><operator>-&gt;</operator><name>tags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <name><name>match_tags</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>)</operator></expr>)</condition>
			<block>{<block_content>
			  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  found match %p\n"</literal><operator>,</operator> <name><name>trans_i</name><operator>-&gt;</operator><name>state</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			  <expr_stmt><expr><name>match_eo</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
			  <expr_stmt><expr><name>new_match</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_tags</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			    <expr_stmt><expr><name><name>match_tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>reach_next_i</name><operator>-&gt;</operator><name>tags</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
			</block_content>}</block></if></if_stmt>
		      <expr_stmt><expr><name>reach_next_i</name><operator>++</operator></expr>;</expr_stmt>

		    </block_content>}</block></if>
		  <else>else
		    <block>{<block_content>
		      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>reach_pos</name><index>[<expr><name><name>trans_i</name><operator>-&gt;</operator><name>state_id</name></name></expr>]</index></name><operator>.</operator><name>pos</name> <operator>==</operator> <name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <comment type="block">/* Another path has also reached this state.  We choose
			 the winner by examining the tag values for both
			 paths. */</comment>
		      <if_stmt><if>if <condition>(<expr><call><name>tre_tag_order</name><argument_list>(<argument><expr><name>num_tags</name></expr></argument>, <argument><expr><name><name>tnfa</name><operator>-&gt;</operator><name>tag_directions</name></name></expr></argument>,
					<argument><expr><name>tmp_tags</name></expr></argument>,
					<argument><expr><operator>*</operator><name><name>reach_pos</name><index>[<expr><name><name>trans_i</name><operator>-&gt;</operator><name>state_id</name></name></expr>]</index></name><operator>.</operator><name>tags</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
			  <comment type="block">/* The new path wins. */</comment>
			  <expr_stmt><expr><name>tmp_iptr</name> <operator>=</operator> <operator>*</operator><name><name>reach_pos</name><index>[<expr><name><name>trans_i</name><operator>-&gt;</operator><name>state_id</name></name></expr>]</index></name><operator>.</operator><name>tags</name></expr>;</expr_stmt>
			  <expr_stmt><expr><operator>*</operator><name><name>reach_pos</name><index>[<expr><name><name>trans_i</name><operator>-&gt;</operator><name>state_id</name></name></expr>]</index></name><operator>.</operator><name>tags</name> <operator>=</operator> <name>tmp_tags</name></expr>;</expr_stmt>
			  <if_stmt><if>if <condition>(<expr><name><name>trans_i</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>final</name></name></expr>)</condition>
			    <block>{<block_content>
			      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"	 found better match\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			      <expr_stmt><expr><name>match_eo</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
			      <expr_stmt><expr><name>new_match</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_tags</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>match_tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>tmp_tags</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
			    </block_content>}</block></if></if_stmt>
			  <expr_stmt><expr><name>tmp_tags</name> <operator>=</operator> <name>tmp_iptr</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		    </block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	    </block_content>}</block></for>
	</block_content>}</block></for>
      <expr_stmt><expr><name><name>reach_next_i</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></while>

  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"match end offset = %d\n"</literal><operator>,</operator> <name>match_eo</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TRE_USE_ALLOCA</name></cpp:ifndef>
  <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !TRE_USE_ALLOCA */</comment>

  <expr_stmt><expr><operator>*</operator><name>match_end_ofs</name> <operator>=</operator> <name>match_eo</name></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><name>match_eo</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>REG_OK</name></expr> </then><else>: <expr><name>REG_NOMATCH</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* EOF */</comment>
</unit>
