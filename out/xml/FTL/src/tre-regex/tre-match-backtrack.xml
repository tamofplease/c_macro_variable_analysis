<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/tre-regex/tre-match-backtrack.c"><comment type="block">/*
  tre-match-backtrack.c - TRE backtracking regex matching engine

  This software is released under a BSD-style license.
  See the file LICENSE for details and copyright.

*/</comment>

<comment type="block">/*
  This matcher is for regexps that use back referencing.  Regexp matching
  with back referencing is an NP-complete problem on the number of back
  references.  The easiest way to match them is to use a backtracking
  routine which basically goes through all possible paths in the TNFA
  and chooses the one which results in the best (leftmost and longest)
  match.  This can be spectacularly expensive and may run out of stack
  space, but there really is no better known generic algorithm.	 Quoting
  Henry Spencer from comp.compilers:
  &lt;URL: http://compilers.iecc.com/comparch/article/93-03-102&gt;

    POSIX.2 REs require longest match, which is really exciting to
    implement since the obsolete ("basic") variant also includes
    \&lt;digit&gt;.  I haven't found a better way of tackling this than doing
    a preliminary match using a DFA (or simulation) on a modified RE
    that just replicates subREs for \&lt;digit&gt;, and then doing a
    backtracking match to determine whether the subRE matches were
    right.  This can be rather slow, but I console myself with the
    thought that people who use \&lt;digit&gt; deserve very slow execution.
    (Pun unintentional but very appropriate.)

*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre-config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre-internal.h"</cpp:file></cpp:include>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;config.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_CONFIG_H */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_USE_ALLOCA</name></cpp:ifdef>
<comment type="block">/* AIX requires this to be the first thing in the file.	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__GNUC__</name></cpp:ifndef>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>HAVE_ALLOCA_H</name></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;alloca.h&gt;</cpp:file></cpp:include>
<cpp:else># <cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifdef>#  <cpp:directive>ifdef</cpp:directive> <name>_AIX</name></cpp:ifdef>
 <cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>alloca</name></cpp:pragma>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifndef>#   <cpp:directive>ifndef</cpp:directive> <name>alloca</name></cpp:ifndef> <comment type="block">/* predefined by HP cc +Olibcalls */</comment>
<function_decl><type><name>char</name> <modifier>*</modifier></type><name>alloca</name> <parameter_list>()</parameter_list>;</function_decl>
<cpp:endif>#   <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_USE_ALLOCA */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_WCHAR_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wchar.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_WCHAR_H */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_WCTYPE_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wctype.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_WCTYPE_H */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TRE_WCHAR</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !TRE_WCHAR */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_MALLOC_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_MALLOC_H */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre-internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre-mem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre-match-utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tre.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmalloc.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str_byte</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_WCHAR</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type><name>str_wide</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_WCHAR */</comment>
  <decl_stmt><decl><type><name>tre_tnfa_transition_t</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>state_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>next_c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>tags</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_MBSTATE</name></cpp:ifdef>
  <decl_stmt><decl><type><name>mbstate_t</name></type> <name>mbstate</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_MBSTATE */</comment>
}</block></struct></type> <name>tre_backtrack_item_t</name>;</typedef>

<typedef>typedef <type><struct>struct <name>tre_backtrack_struct</name> <block>{
  <decl_stmt><decl><type><name>tre_backtrack_item_t</name></type> <name>item</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>tre_backtrack_struct</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>tre_backtrack_struct</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
}</block></struct></type> *<name>tre_backtrack_t</name>;</typedef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_WCHAR</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_STACK_WIDE_IN</name><parameter_list>(<parameter><type><name>_str_wide</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>stack-&gt;item.str_wide = (_str_wide)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_STACK_WIDE_OUT</name></cpp:macro>		<cpp:value>(str_wide) = stack-&gt;item.str_wide</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !TRE_WCHAR */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_STACK_WIDE_IN</name><parameter_list>(<parameter><type><name>_str_wide</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_STACK_WIDE_OUT</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !TRE_WCHAR */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_MBSTATE</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_STACK_MBSTATE_IN</name></cpp:macro>  <cpp:value>stack-&gt;item.mbstate = (mbstate)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_STACK_MBSTATE_OUT</name></cpp:macro> <cpp:value>(mbstate) = stack-&gt;item.mbstate</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !TRE_MBSTATE */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_STACK_MBSTATE_IN</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_STACK_MBSTATE_OUT</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !TRE_MBSTATE */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_USE_ALLOCA</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tre_bt_mem_new</name></cpp:macro>		  <cpp:value>tre_mem_newa</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tre_bt_mem_alloc</name></cpp:macro>	  <cpp:value>tre_mem_alloca</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tre_bt_mem_destroy</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro>	  <cpp:value>do { } while (0,0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !TRE_USE_ALLOCA */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tre_bt_mem_new</name></cpp:macro>		  <cpp:value>tre_mem_new</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tre_bt_mem_alloc</name></cpp:macro>	  <cpp:value>tre_mem_alloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tre_bt_mem_destroy</name></cpp:macro>	  <cpp:value>tre_mem_destroy</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !TRE_USE_ALLOCA */</comment>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_STACK_PUSH</name><parameter_list>(<parameter><type><name>_pos</name></type></parameter>, <parameter><type><name>_str_byte</name></type></parameter>, <parameter><type><name>_str_wide</name></type></parameter>, <parameter><type><name>_state</name></type></parameter>, <parameter><type><name>_state_id</name></type></parameter>, <parameter><type><name>_next_c</name></type></parameter>, <parameter><type><name>_tags</name></type></parameter>, <parameter><type><name>_mbstate</name></type></parameter>)</parameter_list></cpp:macro> \
  <cpp:value>do									      \
    {									      \
      int i;								      \
      if (!stack-&gt;next)							      \
	{								      \
	  tre_backtrack_t s;						      \
	  s = tre_bt_mem_alloc(mem, sizeof(*s));			      \
	  if (!s)							      \
	    {								      \
	      tre_bt_mem_destroy(mem);					      \
	      if (tags)							      \
		xfree(tags);						      \
	      if (pmatch)						      \
		xfree(pmatch);						      \
	      if (states_seen)						      \
		xfree(states_seen);					      \
	      return REG_ESPACE;					      \
	    }								      \
	  s-&gt;prev = stack;						      \
	  s-&gt;next = NULL;						      \
	  s-&gt;item.tags = tre_bt_mem_alloc(mem,				      \
					  sizeof(*tags) * tnfa-&gt;num_tags);    \
	  if (!s-&gt;item.tags)						      \
	    {								      \
	      tre_bt_mem_destroy(mem);					      \
	      if (tags)							      \
		xfree(tags);						      \
	      if (pmatch)						      \
		xfree(pmatch);						      \
	      if (states_seen)						      \
		xfree(states_seen);					      \
	      return REG_ESPACE;					      \
	    }								      \
	  stack-&gt;next = s;						      \
	  stack = s;							      \
	}								      \
      else								      \
	stack = stack-&gt;next;						      \
      stack-&gt;item.pos = (_pos);						      \
      stack-&gt;item.str_byte = (_str_byte);				      \
      BT_STACK_WIDE_IN(_str_wide);					      \
      stack-&gt;item.state = (_state);					      \
      stack-&gt;item.state_id = (_state_id);				      \
      stack-&gt;item.next_c = (_next_c);					      \
      for (i = 0; i &lt; tnfa-&gt;num_tags; i++)				      \
	stack-&gt;item.tags[i] = (_tags)[i];				      \
      BT_STACK_MBSTATE_IN;						      \
    }									      \
  while (<comment type="block">/*CONSTCOND*/</comment>(void)0,0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_STACK_POP</name><parameter_list>()</parameter_list></cpp:macro>							      \
  <cpp:value>do									      \
    {									      \
      int i;								      \
      assert(stack-&gt;prev);						      \
      pos = stack-&gt;item.pos;						      \
      if (type == STR_USER)                                                   \
        str_source-&gt;rewind(pos + pos_add_next, str_source-&gt;context);          \
      str_byte = stack-&gt;item.str_byte;					      \
      BT_STACK_WIDE_OUT;						      \
      state = stack-&gt;item.state;					      \
      next_c = (tre_char_t) stack-&gt;item.next_c;					      \
      for (i = 0; i &lt; tnfa-&gt;num_tags; i++)				      \
	tags[i] = stack-&gt;item.tags[i];					      \
      BT_STACK_MBSTATE_OUT;						      \
      stack = stack-&gt;prev;						      \
    }									      \
  while (<comment type="block">/*CONSTCOND*/</comment>(void)0,0)</cpp:value></cpp:define>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MIN</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((a) &lt;= (b) ? (a) : (b))</cpp:value></cpp:define>

<function><type><name>reg_errcode_t</name></type>
<name>tre_tnfa_run_backtrack</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>tre_tnfa_t</name> <modifier>*</modifier></type><name>tnfa</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>string</name></decl></parameter>,
		       <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>tre_str_type_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>match_tags</name></decl></parameter>,
		       <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>match_end_ofs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* State variables required by GET_NEXT_WCHAR. */</comment>
  <decl_stmt><decl><type><name>tre_char_t</name></type> <name>prev_c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>next_c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str_byte</name> <init>= <expr><name>string</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>pos_add_next</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_WCHAR</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type><name>str_wide</name> <init>= <expr><name>string</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_MBSTATE</name></cpp:ifdef>
  <decl_stmt><decl><type><name>mbstate_t</name></type> <name>mbstate</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_MBSTATE */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_WCHAR */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>reg_notbol</name> <init>= <expr><name>eflags</name> <operator>&amp;</operator> <name>REG_NOTBOL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>reg_noteol</name> <init>= <expr><name>eflags</name> <operator>&amp;</operator> <name>REG_NOTEOL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>reg_newline</name> <init>= <expr><name><name>tnfa</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <name>REG_NEWLINE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>str_user_end</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <comment type="block">/* These are used to remember the necessary values of the above
     variables to return to the position where the current search
     started from. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>next_c_start</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str_byte_start</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pos_start</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_WCHAR</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>const</specifier> <name>wchar_t</name> <modifier>*</modifier></type><name>str_wide_start</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_WCHAR */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_MBSTATE</name></cpp:ifdef>
  <decl_stmt><decl><type><name>mbstate_t</name></type> <name>mbstate_start</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_MBSTATE */</comment>

  <comment type="block">/* End offset of best match so far, or -1 if no match found yet. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>match_eo</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Tag arrays. */</comment>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>next_tags</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tags</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Current TNFA state. */</comment>
  <decl_stmt><decl><type><name>tre_tnfa_transition_t</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>states_seen</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Memory allocator to for allocating the backtracking stack. */</comment>
  <decl_stmt><decl><type><name>tre_mem_t</name></type> <name>mem</name> <init>= <expr><call><name>tre_bt_mem_new</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* The backtracking stack. */</comment>
  <decl_stmt><decl><type><name>tre_backtrack_t</name></type> <name>stack</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>tre_tnfa_transition_t</name> <modifier>*</modifier></type><name>trans_i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>regmatch_t</name> <modifier>*</modifier></type><name>pmatch</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_MBSTATE</name></cpp:ifdef>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mbstate</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mbstate</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_MBSTATE */</comment>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>mem</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>REG_ESPACE</name></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>stack</name> <operator>=</operator> <call><name>tre_bt_mem_alloc</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>stack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>stack</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>REG_ESPACE</name></expr>;</expr_stmt>
      <goto>goto <name>error_exit</name>;</goto>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"tnfa_execute_backtrack, input type %d\n"</literal><operator>,</operator> <name>type</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"len = %d\n"</literal><operator>,</operator> <name>len</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_USE_ALLOCA</name></cpp:ifdef>
  <expr_stmt><expr><name>tags</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tags</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>num_tags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pmatch</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pmatch</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>num_submatches</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>states_seen</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>states_seen</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>num_states</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !TRE_USE_ALLOCA */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>tnfa</name><operator>-&gt;</operator><name>num_tags</name></name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>tags</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tags</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>num_tags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tags</name></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>REG_ESPACE</name></expr>;</expr_stmt>
	  <goto>goto <name>error_exit</name>;</goto>
	</block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>tnfa</name><operator>-&gt;</operator><name>num_submatches</name></name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>pmatch</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pmatch</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>num_submatches</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pmatch</name></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>REG_ESPACE</name></expr>;</expr_stmt>
	  <goto>goto <name>error_exit</name>;</goto>
	</block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>tnfa</name><operator>-&gt;</operator><name>num_states</name></name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>states_seen</name> <operator>=</operator> <call><name>xmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>states_seen</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>num_states</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>states_seen</name></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>REG_ESPACE</name></expr>;</expr_stmt>
	  <goto>goto <name>error_exit</name>;</goto>
	</block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !TRE_USE_ALLOCA */</comment>

 <label><name>retry</name>:</label>
  <block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>num_tags</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
      <block>{<block_content>
	<expr_stmt><expr><name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>match_tags</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><name><name>match_tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
      </block_content>}</block></for>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>num_states</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>states_seen</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
  </block_content>}</block>

  <expr_stmt><expr><name>state</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pos</name> <operator>=</operator> <name>pos_start</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>STR_USER</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name><name>str_source</name><operator>-&gt;</operator><name>rewind</name></name><argument_list>(<argument><expr><name>pos</name> <operator>+</operator> <name>pos_add_next</name></expr></argument>, <argument><expr><name><name>str_source</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>GET_NEXT_WCHAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>pos_start</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>next_c_start</name> <operator>=</operator> <name>next_c</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>str_byte_start</name> <operator>=</operator> <name>str_byte</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_WCHAR</name></cpp:ifdef>
  <expr_stmt><expr><name>str_wide_start</name> <operator>=</operator> <name>str_wide</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_WCHAR */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_MBSTATE</name></cpp:ifdef>
  <expr_stmt><expr><name>mbstate_start</name> <operator>=</operator> <name>mbstate</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_MBSTATE */</comment>

  <comment type="block">/* Handle initial states. */</comment>
  <expr_stmt><expr><name>next_tags</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>trans_i</name> <operator>=</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>initial</name></name></expr>;</init> <condition><expr><name><name>trans_i</name><operator>-&gt;</operator><name>state</name></name></expr>;</condition> <incr><expr><name>trans_i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"&gt; init %p, prev_c %lc\n"</literal><operator>,</operator> <name><name>trans_i</name><operator>-&gt;</operator><name>state</name></name><operator>,</operator> <operator>(</operator><name>tre_cint_t</name><operator>)</operator><name>prev_c</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>trans_i</name><operator>-&gt;</operator><name>assertions</name></name> <operator>&amp;&amp;</operator> <call><name>CHECK_ASSERTIONS</name><argument_list>(<argument><expr><name><name>trans_i</name><operator>-&gt;</operator><name>assertions</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"assert failed\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <continue>continue;</continue>
	</block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
	  <comment type="block">/* Start from this state. */</comment>
	  <expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>trans_i</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
	  <expr_stmt><expr><name>next_tags</name> <operator>=</operator> <name><name>trans_i</name><operator>-&gt;</operator><name>tags</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
      <else>else
	<block>{<block_content>
	  <comment type="block">/* Backtrack to this state. */</comment>
	  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"saving state %d for backtracking\n"</literal><operator>,</operator> <name><name>trans_i</name><operator>-&gt;</operator><name>state_id</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>BT_STACK_PUSH</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>str_byte</name></expr></argument>, <argument><expr><name>str_wide</name></expr></argument>, <argument><expr><name><name>trans_i</name><operator>-&gt;</operator><name>state</name></name></expr></argument>,
			<argument><expr><name><name>trans_i</name><operator>-&gt;</operator><name>state_id</name></name></expr></argument>, <argument><expr><name>next_c</name></expr></argument>, <argument><expr><name>tags</name></expr></argument>, <argument><expr><name>mbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <block>{<block_content>
	    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name><name>trans_i</name><operator>-&gt;</operator><name>tags</name></name></expr></init></decl>;</decl_stmt>
	    <if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition><block type="pseudo"><block_content>
	      <while>while <condition>(<expr><operator>*</operator><name>tmp</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>item</name><operator>.</operator><name>tags</name><index>[<expr><operator>*</operator><name>tmp</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt></block_content></block></while></block_content></block></if></if_stmt>
	  </block_content>}</block>
	</block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><name>next_tags</name></expr>)</condition><block type="pseudo"><block_content>
    <for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>next_tags</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>next_tags</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
      <expr_stmt><expr><name><name>tags</name><index>[<expr><operator>*</operator><name>next_tags</name></expr>]</index></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>


  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"entering match loop, pos %d, str_byte %p\n"</literal><operator>,</operator> <name>pos</name><operator>,</operator> <name>str_byte</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"pos:chr/code | state and tags\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"-------------+------------------------------------------------\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <goto>goto <name>backtrack</name>;</goto></block_content></block></if></if_stmt>

  <while>while <condition>(<comment type="block">/*CONSTCOND*/</comment><expr><operator>(</operator><name>void</name><operator>)</operator><literal type="number">1</literal></expr><operator>,</operator><expr><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>tre_tnfa_transition_t</name> <modifier>*</modifier></type><name>next_state</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>empty_br_match</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"start loop\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>final</name></name></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  match found, %d %d\n"</literal><operator>,</operator> <name>match_eo</name><operator>,</operator> <name>pos</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name>match_eo</name> <operator>&lt;</operator> <name>pos</name>
	      <operator>||</operator> <operator>(</operator><name>match_eo</name> <operator>==</operator> <name>pos</name>
		  <operator>&amp;&amp;</operator> <name>match_tags</name>
		  <operator>&amp;&amp;</operator> <call><name>tre_tag_order</name><argument_list>(<argument><expr><name><name>tnfa</name><operator>-&gt;</operator><name>num_tags</name></name></expr></argument>, <argument><expr><name><name>tnfa</name><operator>-&gt;</operator><name>tag_directions</name></name></expr></argument>,
				   <argument><expr><name>tags</name></expr></argument>, <argument><expr><name>match_tags</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	    <block>{<block_content>
	      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	      <comment type="block">/* This match wins the previous match. */</comment>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"	 win previous\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><name>match_eo</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name>match_tags</name></expr>)</condition><block type="pseudo"><block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>num_tags</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		  <expr_stmt><expr><name><name>match_tags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>
	    </block_content>}</block></if></if_stmt>
	  <comment type="block">/* Our TNFAs never have transitions leaving from the final state,
	     so we jump right to backtracking. */</comment>
	  <goto>goto <name>backtrack</name>;</goto>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_DEBUG</name></cpp:ifdef>
      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"%3d:%2lc/%05d | %p "</literal><operator>,</operator> <name>pos</name><operator>,</operator> <operator>(</operator><name>tre_cint_t</name><operator>)</operator><name>next_c</name><operator>,</operator> <operator>(</operator><name>int</name><operator>)</operator><name>next_c</name><operator>,</operator>
	      <name>state</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>num_tags</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"%d%s"</literal><operator>,</operator> <name><name>tags</name><index>[<expr><name>i</name></expr>]</index></name><operator>,</operator> <ternary><condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tnfa</name><operator>-&gt;</operator><name>num_tags</name></name> <operator>-</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_DEBUG */</comment>

      <comment type="block">/* Go to the next character in the input string. */</comment>
      <expr_stmt><expr><name>empty_br_match</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>trans_i</name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>trans_i</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;&amp;</operator> <name><name>trans_i</name><operator>-&gt;</operator><name>assertions</name></name> <operator>&amp;</operator> <name>ASSERT_BACKREF</name></expr>)</condition>
	<block>{<block_content>
	  <comment type="block">/* This is a back reference state.  All transitions leaving from
	     this state have the same back reference "assertion".  Instead
	     of reading the next character, we match the back reference. */</comment>
	  <decl_stmt><decl><type><name>int</name></type> <name>so</name></decl>, <decl><type ref="prev"/><name>eo</name></decl>, <decl><type ref="prev"/><name>bt</name> <init>= <expr><name><name>trans_i</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>backref</name></name></expr></init></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>int</name></type> <name>bt_len</name></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

	  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  should match back reference %d\n"</literal><operator>,</operator> <name>bt</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <comment type="block">/* Get the substring we need to match against.  Remember to
	     turn off REG_NOSUB temporarily. */</comment>
	  <expr_stmt><expr><call><name>tre_fill_pmatch</name><argument_list>(<argument><expr><name>bt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>pmatch</name></expr></argument>, <argument><expr><name><name>tnfa</name><operator>-&gt;</operator><name>cflags</name></name> <operator>&amp;</operator> <comment type="block">/*LINTED*/</comment><operator>!</operator><name>REG_NOSUB</name></expr></argument>,
			  <argument><expr><name>tnfa</name></expr></argument>, <argument><expr><name>tags</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>so</name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><name>bt</name></expr>]</index></name><operator>.</operator><name>rm_so</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name>eo</name> <operator>=</operator> <name><name>pmatch</name><index>[<expr><name>bt</name></expr>]</index></name><operator>.</operator><name>rm_eo</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name>bt_len</name> <operator>=</operator> <name>eo</name> <operator>-</operator> <name>so</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_DEBUG</name></cpp:ifdef>
	  <block>{<block_content>
	    <decl_stmt><decl><type><name>int</name></type> <name>slen</name></decl>;</decl_stmt>
	    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><name>slen</name> <operator>=</operator> <name>bt_len</name></expr>;</expr_stmt></block_content></block></if>
	    <else>else<block type="pseudo"><block_content>
	      <expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name>MIN</name><argument_list>(<argument><expr><name>bt_len</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>STR_BYTE</name></expr>)</condition>
	      <block>{<block_content>
		<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  substring (len %d) is [%d, %d[: '%.*s'\n"</literal><operator>,</operator>
			<name>bt_len</name><operator>,</operator> <name>so</name><operator>,</operator> <name>eo</name><operator>,</operator> <name>bt_len</name><operator>,</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>string</name> <operator>+</operator> <name>so</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  current string is '%.*s'\n"</literal><operator>,</operator> <name>slen</name><operator>,</operator> <name>str_byte</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_WCHAR</name></cpp:ifdef>
	    <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>STR_WIDE</name></expr>)</condition>
	      <block>{<block_content>
		<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  substring (len %d) is [%d, %d[: '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator>
			<name>bt_len</name><operator>,</operator> <name>so</name><operator>,</operator> <name>eo</name><operator>,</operator> <name>bt_len</name><operator>,</operator> <operator>(</operator><name>wchar_t</name><operator>*</operator><operator>)</operator><name>string</name> <operator>+</operator> <name>so</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  current string is '%.*"</literal> <name>STRF</name> <literal type="string">"'\n"</literal><operator>,</operator>
			<name>slen</name><operator>,</operator> <name>str_wide</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_WCHAR */</comment>
	  </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	  <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	    <block>{<block_content>
	      <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>STR_USER</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>str_source</name><operator>-&gt;</operator><name>compare</name></name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>so</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>pos</name></expr></argument>,
					     <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>bt_len</name></expr></argument>,
					     <argument><expr><name><name>str_source</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_WCHAR</name></cpp:ifdef>
	      <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>STR_WIDE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>wcsncmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>wchar_t</name><operator>*</operator><operator>)</operator><name>string</name> <operator>+</operator> <name>so</name></expr></argument>, <argument><expr><name>str_wide</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>bt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_WCHAR */</comment>
	      <else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>string</name> <operator>+</operator> <name>so</name></expr></argument>, <argument><expr><name>str_byte</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>bt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	    </block_content>}</block></if>
	  <if type="elseif">else if <condition>(<expr><name>len</name> <operator>-</operator> <name>pos</name> <operator>&lt;</operator> <name>bt_len</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_WCHAR</name></cpp:ifdef>
	  <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>STR_WIDE</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>wmemcmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>wchar_t</name><operator>*</operator><operator>)</operator><name>string</name> <operator>+</operator> <name>so</name></expr></argument>, <argument><expr><name>str_wide</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
			     <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>bt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_WCHAR */</comment>
	  <else>else<block type="pseudo"><block_content>
	    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>string</name> <operator>+</operator> <name>so</name></expr></argument>, <argument><expr><name>str_byte</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
			    <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>bt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	  <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	    <block>{<block_content>
	      <comment type="block">/* Back reference matched.  Check for infinite loop. */</comment>
	      <if_stmt><if>if <condition>(<expr><name>bt_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>empty_br_match</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	      <if_stmt><if>if <condition>(<expr><name>empty_br_match</name> <operator>&amp;&amp;</operator> <name><name>states_seen</name><index>[<expr><name><name>trans_i</name><operator>-&gt;</operator><name>state_id</name></name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  avoid loop\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <goto>goto <name>backtrack</name>;</goto>
		</block_content>}</block></if></if_stmt>

	      <expr_stmt><expr><name><name>states_seen</name><index>[<expr><name><name>trans_i</name><operator>-&gt;</operator><name>state_id</name></name></expr>]</index></name> <operator>=</operator> <name>empty_br_match</name></expr>;</expr_stmt>

	      <comment type="block">/* Advance in input string and resync `prev_c', `next_c'
		 and pos. */</comment>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"	 back reference matched\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><name>str_byte</name> <operator>+=</operator> <name>bt_len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_WCHAR</name></cpp:ifdef>
	      <expr_stmt><expr><name>str_wide</name> <operator>+=</operator> <name>bt_len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_WCHAR */</comment>
	      <expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>bt_len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>GET_NEXT_WCHAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"	 pos now %d\n"</literal><operator>,</operator> <name>pos</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    </block_content>}</block></if>
	  <else>else
	    <block>{<block_content>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"	 back reference did not match\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <goto>goto <name>backtrack</name>;</goto>
	    </block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
      <else>else
	<block>{<block_content>
	  <comment type="block">/* Check for end of string. */</comment>
	  <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	    <block>{<block_content>
	      <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>STR_USER</name></expr>)</condition>
		<block>{<block_content>
		  <if_stmt><if>if <condition>(<expr><name>str_user_end</name></expr>)</condition><block type="pseudo"><block_content>
		    <goto>goto <name>backtrack</name>;</goto></block_content></block></if></if_stmt>
		</block_content>}</block></if>
	      <if type="elseif">else if <condition>(<expr><name>next_c</name> <operator>==</operator> <name>L</name><literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>backtrack</name>;</goto></block_content></block></if></if_stmt>
	    </block_content>}</block></if>
	  <else>else
	    <block>{<block_content>
	      <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>backtrack</name>;</goto></block_content></block></if></if_stmt>
	    </block_content>}</block></else></if_stmt>

	  <comment type="block">/* Read the next character. */</comment>
	  <expr_stmt><expr><call><name>GET_NEXT_WCHAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

      <expr_stmt><expr><name>next_state</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>trans_i</name> <operator>=</operator> <name>state</name></expr>;</init> <condition><expr><name><name>trans_i</name><operator>-&gt;</operator><name>state</name></name></expr>;</condition> <incr><expr><name>trans_i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
	  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  transition %d-%d (%c-%c) %d to %d\n"</literal><operator>,</operator>
		  <name><name>trans_i</name><operator>-&gt;</operator><name>code_min</name></name><operator>,</operator> <name><name>trans_i</name><operator>-&gt;</operator><name>code_max</name></name><operator>,</operator>
		  <name><name>trans_i</name><operator>-&gt;</operator><name>code_min</name></name><operator>,</operator> <name><name>trans_i</name><operator>-&gt;</operator><name>code_max</name></name><operator>,</operator>
		  <name><name>trans_i</name><operator>-&gt;</operator><name>assertions</name></name><operator>,</operator> <name><name>trans_i</name><operator>-&gt;</operator><name>state_id</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name><name>trans_i</name><operator>-&gt;</operator><name>code_min</name></name> <operator>&lt;=</operator> <operator>(</operator><name>tre_cint_t</name><operator>)</operator><name>prev_c</name>
	      <operator>&amp;&amp;</operator> <name><name>trans_i</name><operator>-&gt;</operator><name>code_max</name></name> <operator>&gt;=</operator> <operator>(</operator><name>tre_cint_t</name><operator>)</operator><name>prev_c</name></expr>)</condition>
	    <block>{<block_content>
	      <if_stmt><if>if <condition>(<expr><name><name>trans_i</name><operator>-&gt;</operator><name>assertions</name></name>
		  <operator>&amp;&amp;</operator> <operator>(</operator><call><name>CHECK_ASSERTIONS</name><argument_list>(<argument><expr><name><name>trans_i</name><operator>-&gt;</operator><name>assertions</name></name></expr></argument>)</argument_list></call>
		      <operator>||</operator> <call><name>CHECK_CHAR_CLASSES</name><argument_list>(<argument><expr><name>trans_i</name></expr></argument>, <argument><expr><name>tnfa</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  assertion failed\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

	      <if_stmt><if>if <condition>(<expr><name>next_state</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
		  <comment type="block">/* First matching transition. */</comment>
		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  Next state is %d\n"</literal><operator>,</operator> <name><name>trans_i</name><operator>-&gt;</operator><name>state_id</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><name>next_state</name> <operator>=</operator> <name><name>trans_i</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
		  <expr_stmt><expr><name>next_tags</name> <operator>=</operator> <name><name>trans_i</name><operator>-&gt;</operator><name>tags</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
	      <else>else
		<block>{<block_content>
		  <comment type="block">/* Second matching transition.  We may need to backtrack here
		     to take this transition instead of the first one, so we
		     push this transition in the backtracking stack so we can
		     jump back here if needed. */</comment>
		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  saving state %d for backtracking\n"</literal><operator>,</operator>
			  <name><name>trans_i</name><operator>-&gt;</operator><name>state_id</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><call><name>BT_STACK_PUSH</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>str_byte</name></expr></argument>, <argument><expr><name>str_wide</name></expr></argument>, <argument><expr><name><name>trans_i</name><operator>-&gt;</operator><name>state</name></name></expr></argument>,
				<argument><expr><name><name>trans_i</name><operator>-&gt;</operator><name>state_id</name></name></expr></argument>, <argument><expr><name>next_c</name></expr></argument>, <argument><expr><name>tags</name></expr></argument>, <argument><expr><name>mbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <block>{<block_content>
		    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
		    <for>for <control>(<init><expr><name>tmp</name> <operator>=</operator> <name><name>trans_i</name><operator>-&gt;</operator><name>tags</name></name></expr>;</init> <condition><expr><name>tmp</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>tmp</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>tmp</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		      <expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>item</name><operator>.</operator><name>tags</name><index>[<expr><operator>*</operator><name>tmp</name></expr>]</index></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt></block_content></block></for>
		  </block_content>}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> <comment type="block">/* XXX - it's important not to look at all transitions here to keep
	 the stack small! */</comment>
		  break;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></else></if_stmt>
	    </block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

      <if_stmt><if>if <condition>(<expr><name>next_state</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
	  <comment type="block">/* Matching transitions were found.  Take the first one. */</comment>
	  <expr_stmt><expr><name>state</name> <operator>=</operator> <name>next_state</name></expr>;</expr_stmt>

	  <comment type="block">/* Update the tag values. */</comment>
	  <if_stmt><if>if <condition>(<expr><name>next_tags</name></expr>)</condition><block type="pseudo"><block_content>
	    <while>while <condition>(<expr><operator>*</operator><name>next_tags</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><name><name>tags</name><index>[<expr><operator>*</operator><name>next_tags</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt></block_content></block></while></block_content></block></if></if_stmt>
	</block_content>}</block></if>
      <else>else
	<block>{<block_content>
	<label><name>backtrack</name>:</label>
	  <comment type="block">/* A matching transition was not found.  Try to backtrack. */</comment>
	  <if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition>
	    <block>{<block_content>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"	 backtracking\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>item</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>assertions</name></name> <operator>&amp;&amp;</operator> <name>ASSERT_BACKREF</name></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"  states_seen[%d] = 0\n"</literal><operator>,</operator>
			  <name><name>stack</name><operator>-&gt;</operator><name>item</name><operator>.</operator><name>state_id</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>states_seen</name><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>item</name><operator>.</operator><name>state_id</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

	      <expr_stmt><expr><call><name>BT_STACK_POP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    </block_content>}</block></if>
	  <if type="elseif">else if <condition>(<expr><name>match_eo</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	    <block>{<block_content>
	      <comment type="block">/* Try starting from a later position in the input string. */</comment>
	      <comment type="block">/* Check for end of string. */</comment>
	      <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
		  <if_stmt><if>if <condition>(<expr><name>next_c</name> <operator>==</operator> <name>L</name><literal type="char">'\0'</literal></expr>)</condition>
		    <block>{<block_content>
		      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"end of string.\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <break>break;</break>
		    </block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
	      <else>else
		<block>{<block_content>
		  <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <name>len</name></expr>)</condition>
		    <block>{<block_content>
		      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"end of string.\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <break>break;</break>
		    </block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"restarting from next start position\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><name>next_c</name> <operator>=</operator> <operator>(</operator><name>tre_char_t</name><operator>)</operator> <name>next_c_start</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_MBSTATE</name></cpp:ifdef>
	      <expr_stmt><expr><name>mbstate</name> <operator>=</operator> <name>mbstate_start</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_MBSTATE */</comment>
	      <expr_stmt><expr><name>str_byte</name> <operator>=</operator> <name>str_byte_start</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRE_WCHAR</name></cpp:ifdef>
	      <expr_stmt><expr><name>str_wide</name> <operator>=</operator> <name>str_wide_start</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRE_WCHAR */</comment>
	      <goto>goto <name>retry</name>;</goto>
	    </block_content>}</block></if>
	  <else>else
	    <block>{<block_content>
	      <expr_stmt><expr><call><name>DPRINT</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"finished\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <break>break;</break>
	    </block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

  <expr_stmt><expr><name>ret</name> <operator>=</operator> <ternary><condition><expr><name>match_eo</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>REG_OK</name></expr> </then><else>: <expr><name>REG_NOMATCH</name></expr></else></ternary></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>match_end_ofs</name> <operator>=</operator> <name>match_eo</name></expr>;</expr_stmt>

 <label><name>error_exit</name>:</label>
  <expr_stmt><expr><call><name>tre_bt_mem_destroy</name><argument_list>(<argument><expr><name>mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TRE_USE_ALLOCA</name></cpp:ifndef>
  <if_stmt><if>if <condition>(<expr><name>tags</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>tags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>pmatch</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>pmatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>states_seen</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>xfree</name><argument_list>(<argument><expr><name>states_seen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !TRE_USE_ALLOCA */</comment>

  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
</unit>
