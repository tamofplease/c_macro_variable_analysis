<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/regex.c"><comment type="block">/* Pi-hole: A black hole for Internet advertisements
*  (c) 2017 Pi-hole, LLC (https://pi-hole.net)
*  Network-wide ad blocking via your own hardware.
*
*  FTL Engine
*  Regular Expressions
*
*  This file is copyright under the latest version of the EUPL.
*  Please see LICENSE file for your rights under this license. */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"FTL.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regex_r.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"timers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<comment type="line">// data getter functions</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"datastructure.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"database/gravity-db.h"</cpp:file></cpp:include>
<comment type="line">// add_per_client_regex_client()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"database/message-table.h"</cpp:file></cpp:include>
<comment type="line">// init_shmem()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"shmem.h"</cpp:file></cpp:include>
<comment type="line">// read_FTL_config()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<comment type="line">// cli_stuff()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"args.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>regextype</name><index>[<expr><name>REGEX_MAX</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="string">"blacklist"</literal></expr>, <expr><literal type="string">"whitelist"</literal></expr>, <expr><literal type="string">"CLI"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>regexData</name> <modifier>*</modifier></type><name>white_regex</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>regexData</name> <modifier>*</modifier></type><name>black_regex</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>regexData</name>   <modifier>*</modifier></type><name>cli_regex</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name><name>num_regex</name><index>[<expr><name>REGEX_MAX</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>regex_change</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>regexData</name> <modifier>*</modifier></type><name>get_regex_ptr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>enum</name> <name>regex_type</name></name></type> <name>regexid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>regexid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>REGEX_BLACKLIST</name></expr>:</case>
			<return>return <expr><name>black_regex</name></expr>;</return>
		<case>case <expr><name>REGEX_WHITELIST</name></expr>:</case>
			<return>return <expr><name>white_regex</name></expr>;</return>
		<case>case <expr><name>REGEX_CLI</name></expr>:</case>
			<return>return <expr><name>cli_regex</name></expr>;</return>
		<case>case <expr><name>REGEX_MAX</name></expr>:</case> <comment type="line">// Fall through</comment>
		<default>default:</default> <comment type="line">// This is not possible</comment>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>free_regex_ptr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>enum</name> <name>regex_type</name></name></type> <name>regexid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>regexData</name> <modifier>*</modifier><modifier>*</modifier></type><name>regex</name></decl>;</decl_stmt>
	<switch>switch <condition>(<expr><name>regexid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>REGEX_BLACKLIST</name></expr>:</case>
			<expr_stmt><expr><name>regex</name> <operator>=</operator> <operator>&amp;</operator><name>black_regex</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>REGEX_WHITELIST</name></expr>:</case>
			<expr_stmt><expr><name>regex</name> <operator>=</operator> <operator>&amp;</operator><name>white_regex</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>REGEX_CLI</name></expr>:</case>
			<expr_stmt><expr><name>regex</name> <operator>=</operator> <operator>&amp;</operator><name>cli_regex</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>REGEX_MAX</name></expr>:</case> <comment type="line">// Fall through</comment>
		<default>default:</default> <comment type="line">// This is not possible</comment>
			<return>return;</return>
	</block_content>}</block></switch>

	<comment type="line">// Free pointer (if not already NULL)</comment>
	<if_stmt><if>if<condition>(<expr><operator>*</operator><name>regex</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>regex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>regex</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<expr_stmt><expr><specifier>static</specifier> <macro><name>__attribute__</name> <argument_list>(<argument>(pure)</argument>)</argument_list></macro> <name>regexData</name> <operator>*</operator><macro><name>get_regex_ptr_from_id</name><argument_list>(<argument>unsigned int regexID</argument>)</argument_list></macro>
<block>{
	<expr><name>unsigned</name> <name>int</name> <name>maxi</name></expr>;
	enum <expr><name>regex_type</name> <name>regex_type</name></expr>;
	<if_stmt><if>if<condition>(<expr><name>regexID</name> <operator>&lt;</operator> <name><name>num_regex</name><index>[<expr><name>REGEX_BLACKLIST</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Regex blacklist</comment>
		<expr_stmt><expr><name>regex_type</name> <operator>=</operator> <name>REGEX_BLACKLIST</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxi</name> <operator>=</operator> <name><name>num_regex</name><index>[<expr><name>REGEX_BLACKLIST</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>
	<if_stmt><else>else
	<block>{<block_content>
		<comment type="line">// Subtract regex blacklist</comment>
		<expr_stmt><expr><name>regexID</name> <operator>-=</operator> <name><name>num_regex</name><index>[<expr><name>REGEX_BLACKLIST</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="line">// Check for regex whitelist</comment>
		<if_stmt><if>if<condition>(<expr><name>regexID</name> <operator>&lt;</operator> <name><name>num_regex</name><index>[<expr><name>REGEX_WHITELIST</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// Regex whitelist</comment>
			<expr_stmt><expr><name>regex_type</name> <operator>=</operator> <name>REGEX_WHITELIST</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>maxi</name> <operator>=</operator> <name><name>num_regex</name><index>[<expr><name>REGEX_WHITELIST</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="line">// Subtract regex whitelist</comment>
			<expr_stmt><expr><name>regexID</name> <operator>-=</operator> <name><name>num_regex</name><index>[<expr><name>REGEX_WHITELIST</name></expr>]</index></name></expr>;</expr_stmt>

			<comment type="line">// CLI regex</comment>
			<expr_stmt><expr><name>regex_type</name> <operator>=</operator> <name>REGEX_CLI</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>maxi</name> <operator>=</operator> <name><name>num_regex</name><index>[<expr><name>REGEX_CLI</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<decl_stmt><decl><type><name>regexData</name> <modifier>*</modifier></type><name>regex</name> <init>= <expr><call><name>get_regex_ptr</name><argument_list>(<argument><expr><name>regex_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>regex</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>regexID</name> <operator>&lt;</operator> <name>maxi</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>&amp;</operator><operator>(</operator><name><name>regex</name><index>[<expr><name>regexID</name></expr>]</index></name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
}

unsigned <decl_stmt><decl><type><name>int</name></type> <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>pure</name><operator>)</operator></expr></argument>)</argument_list> <name>get_num_regex</name><argument_list>(<argument><expr><specifier>const</specifier> enum <name>regex_type</name> <name>regexid</name></expr></argument>)</argument_list>
<block>{<block_content>
	<comment type="line">// count number of all available reges</comment>
	<if_stmt><if>if<condition>(<expr><name>regexid</name> <operator>==</operator> <name>REGEX_MAX</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<for>for<control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>REGEX_MAX</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name>num</name> <operator>+=</operator> <name><name>num_regex</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
		<return>return <expr><name>num</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// else: specific regex type</comment>
	<return>return <expr><name><name>num_regex</name><index>[<expr><name>regexid</name></expr>]</index></name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTL_REGEX_SEP</name></cpp:macro> <cpp:value>";"</cpp:value></cpp:define>
<comment type="block">/* Compile regular expressions into data structures that can be used with
   regexec() to match against a string */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>compile_regex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>regexin</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>enum</name> <name>regex_type</name></name></type> <name>regexid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>dbidx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>regexData</name> <modifier>*</modifier></type><name>regex</name> <init>= <expr><call><name>get_regex_ptr</name><argument_list>(<argument><expr><name>regexid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><name><name>num_regex</name><index>[<expr><name>regexid</name></expr>]</index></name><operator>++</operator></expr></init></decl>;</decl_stmt>

	<comment type="line">// Extract possible Pi-hole extensions</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>rgxbuf</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>regexin</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1u</literal></expr>]</index></name></decl>;</decl_stmt>
	<comment type="line">// Parse special FTL syntax if present</comment>
	<if_stmt><if>if<condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>regexin</name></expr></argument>, <argument><expr><name>FTL_REGEX_SEP</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>strdup</name><argument_list>(<argument><expr><name>regexin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// Extract regular expression pattern in front of FTL-specific syntax</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>saveptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>part</name> <init>= <expr><call><name>strtok_r</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>FTL_REGEX_SEP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saveptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>rgxbuf</name></expr></argument>, <argument><expr><name>part</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rgxbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Analyze FTL-specific parts</comment>
		<while>while<condition>(<expr><operator>(</operator><name>part</name> <operator>=</operator> <call><name>strtok_r</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FTL_REGEX_SEP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>saveptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type> <name><name>extra</name><index>[<expr><literal type="number">17</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
			<comment type="line">// options ";querytype=!AAAA" and ";querytype=AAAA"</comment>
			<if_stmt><if>if<condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><literal type="string">"querytype=%16s"</literal></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="line">// Warn if specified more than one querytype option</comment>
				<if_stmt><if>if<condition>(<expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>query_type</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>logg_regex_warning</name><argument_list>(<argument><expr><name><name>regextype</name><index>[<expr><name>regexid</name></expr>]</index></name></expr></argument>,
					                   <argument><expr><literal type="string">"Overwriting previous querytype setting"</literal></expr></argument>,
					                   <argument><expr><name>dbidx</name></expr></argument>, <argument><expr><name>regexin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="line">// Test input string against all implemented query types</comment>
				<for>for<control>(<init><decl><type><name><name>enum</name> <name>query_types</name></name></type> <name>type</name> <init>= <expr><name>TYPE_A</name></expr></init></decl>;</init> <condition><expr><name>type</name> <operator>&lt;</operator> <name>TYPE_MAX</name></expr>;</condition> <incr><expr><name>type</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<comment type="line">// Check for querytype</comment>
					<if_stmt><if>if<condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>extra</name></expr></argument>, <argument><expr><name><name>querytypes</name><index>[<expr><name>type</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>query_type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>query_type_inverted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if>
					<comment type="line">// Check for INVERTED querytype</comment>
					<if type="elseif">else if<condition>(<expr><name><name>extra</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'!'</literal> <operator>&amp;&amp;</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name>extra</name> <operator>+</operator> <literal type="number">1u</literal></expr></argument>, <argument><expr><name><name>querytypes</name><index>[<expr><name>type</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>query_type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>query_type_inverted</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<comment type="line">// Nothing found</comment>
				<if_stmt><if>if<condition>(<expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>query_type</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name></type> <name><name>msg</name><index>[<expr><literal type="number">64</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Unknown querytype \"%s\""</literal></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>logg_regex_warning</name><argument_list>(<argument><expr><name><name>regextype</name><index>[<expr><name>regexid</name></expr>]</index></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>dbidx</name></expr></argument>, <argument><expr><name>regexin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>

				<comment type="line">// Debug output</comment>
				<if type="elseif">else if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_REGEX</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"   This regex will %s match query type %s"</literal></expr></argument>,
					     <argument><expr><ternary><condition><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>query_type_inverted</name></name></expr> ?</condition><then> <expr><literal type="string">"NOT"</literal></expr> </then><else>: <expr><literal type="string">"ONLY"</literal></expr></else></ternary></expr></argument>,
					     <argument><expr><name><name>querytypes</name><index>[<expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>query_type</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<comment type="line">// option: ";invert"</comment>
			<if type="elseif">else if<condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><literal type="string">"invert"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>inverted</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="line">// Debug output</comment>
				<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_REGEX</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"   This regex will match in inverted mode."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<comment type="line">// options ";reply=NXDOMAIN", etc.</comment>
			<if type="elseif">else if<condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><literal type="string">"reply=%16s"</literal></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="line">// Test input string against all implemented reply types</comment>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if<condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>extra</name></expr></argument>, <argument><expr><literal type="string">"NODATA"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"NODATA"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>reply</name></name> <operator>=</operator> <name>REPLY_NODATA</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if<condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>extra</name></expr></argument>, <argument><expr><literal type="string">"NXDOMAIN"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"NXDOMAIN"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>reply</name></name> <operator>=</operator> <name>REPLY_NXDOMAIN</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if<condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>extra</name></expr></argument>, <argument><expr><literal type="string">"REFUSED"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"REFUSED"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>reply</name></name> <operator>=</operator> <name>REPLY_REFUSED</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if<condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>extra</name></expr></argument>, <argument><expr><literal type="string">"IP"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"IP"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>reply</name></name> <operator>=</operator> <name>REPLY_IP</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if<condition>(<expr><call><name>inet_pton</name><argument_list>(<argument><expr><name>AF_INET</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>addr4</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="line">// Custom IPv4 target</comment>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>reply</name></name> <operator>=</operator> <name>REPLY_IP</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>custom_ip4</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if<condition>(<expr><call><name>inet_pton</name><argument_list>(<argument><expr><name>AF_INET6</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>addr6</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="line">// Custom IPv6 target</comment>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>reply</name></name> <operator>=</operator> <name>REPLY_IP</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>custom_ip6</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if<condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>extra</name></expr></argument>, <argument><expr><literal type="string">"NONE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"NONE"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>reply</name></name> <operator>=</operator> <name>REPLY_NONE</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name></type> <name><name>msg</name><index>[<expr><literal type="number">64</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"Unknown reply type \"%s\""</literal></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>logg_regex_warning</name><argument_list>(<argument><expr><name><name>regextype</name><index>[<expr><name>regexid</name></expr>]</index></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>dbidx</name></expr></argument>, <argument><expr><name>regexin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="line">// Debug output</comment>
				<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_REGEX</name> <operator>&amp;&amp;</operator> <name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>reply</name></name> <operator>!=</operator> <name>REPLY_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"   This regex will result in a custom reply: %s"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type> <name><name>hint</name><index>[<expr><literal type="number">40</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>hint</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"Option \"%s\" not known, ignoring it."</literal></expr></argument>, <argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>logg_regex_warning</name><argument_list>(<argument><expr><name><name>regextype</name><index>[<expr><name>regexid</name></expr>]</index></name></expr></argument>, <argument><expr><name>hint</name></expr></argument>,
				                   <argument><expr><name>dbidx</name></expr></argument>, <argument><expr><name>regexin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="line">// Copy entire input string into buffer</comment>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>rgxbuf</name></expr></argument>, <argument><expr><name>regexin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="line">// We use the extended RegEx flavor (ERE) and specify that matching should</comment>
	<comment type="line">// always be case INsensitive</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>errcode</name> <init>= <expr><call><name>regcomp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>regex</name></expr></argument>, <argument><expr><name>rgxbuf</name></expr></argument>, <argument><expr><name>REG_EXTENDED</name> <operator>|</operator> <name>REG_ICASE</name> <operator>|</operator> <name>REG_NOSUB</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>errcode</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Get error string and log it</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>length</name> <init>= <expr><call><name>regerror</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>regex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><call><name>calloc</name><argument_list>(<argument><expr><name>length</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>regerror</name> <argument_list>(<argument><expr><name>errcode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>regex</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>logg_regex_warning</name><argument_list>(<argument><expr><name><name>regextype</name><index>[<expr><name>regexid</name></expr>]</index></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>dbidx</name></expr></argument>, <argument><expr><name>regexin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>available</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Store compiled regex string in buffer</comment>
	<expr_stmt><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>string</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>regexin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>available</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>match_regex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>DNSCacheData</name><modifier>*</modifier></type> <name>dns_cache</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>clientID</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name><name>enum</name> <name>regex_type</name></name></type> <name>regexid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>regextest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>match_idx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>regexData</name> <modifier>*</modifier></type><name>regex</name> <init>= <expr><call><name>get_regex_ptr</name><argument_list>(<argument><expr><name>regexid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_TRE_REGEX</name></cpp:ifdef>
	<decl_stmt><decl><type><name>regmatch_t</name></type> <name><name>match</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr>}</block></expr></init></decl>;</decl_stmt> <comment type="line">// This also disables any sub-matching</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="line">// Check if we need to recompile regex because they were changed in</comment>
	<comment type="line">// another fork. If this is the case, reload everything (regex</comment>
	<comment type="line">// themselves as well as per-client enabled/disabled state)</comment>
	<if_stmt><if>if<condition>(<expr><name>regex_change</name> <operator>!=</operator> <name><name>counters</name><operator>-&gt;</operator><name>regex_change</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Reloading externally changed regular expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>read_regex_from_database</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// Update regex pointer as it will have changed (free_regex has</comment>
		<comment type="line">// been called)</comment>
		<expr_stmt><expr><name>regex</name> <operator>=</operator> <call><name>get_regex_ptr</name><argument_list>(<argument><expr><name>regexid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Loop over all configured regex filters of this type</comment>
	<for>for<control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>num_regex</name><index>[<expr><name>regexid</name></expr>]</index></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="line">// Only check regex which have been successfully compiled ...</comment>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>available</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_REGEX</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Regex %s (%u, DB ID %d) \"%s\" is NOT AVAILABLE"</literal></expr></argument>,
				     <argument><expr><name><name>regextype</name><index>[<expr><name>regexid</name></expr>]</index></name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>database_id</name></expr></argument>,
				     <argument><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<comment type="line">// ... and are enabled for this client</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>regexID</name> <init>= <expr><name>index</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>regexid</name> <operator>==</operator> <name>REGEX_WHITELIST</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>regexID</name> <operator>+=</operator> <name><name>num_regex</name><index>[<expr><name>REGEX_BLACKLIST</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if<condition>(<expr><name>regexid</name> <operator>==</operator> <name>REGEX_CLI</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>regexID</name> <operator>+=</operator> <name><name>num_regex</name><index>[<expr><name>REGEX_BLACKLIST</name></expr>]</index></name> <operator>+</operator>
			           <name><name>num_regex</name><index>[<expr><name>REGEX_WHITELIST</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="line">// Only use regular expressions enabled for this client</comment>
		<comment type="line">// We allow clientID = -1 to get all regex (for testing)</comment>
		<if_stmt><if>if<condition>(<expr><name>clientID</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>get_per_client_regex</name><argument_list>(<argument><expr><name>clientID</name></expr></argument>, <argument><expr><name>regexID</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_REGEX</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>clientsData</name><modifier>*</modifier></type> <name>client</name> <init>= <expr><call><name>getClient</name><argument_list>(<argument><expr><name>clientID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if<condition>(<expr><name>client</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Regex %s (%u, DB ID %d) \"%s\" NOT ENABLED for client %s"</literal></expr></argument>,
					     <argument><expr><name><name>regextype</name><index>[<expr><name>regexid</name></expr>]</index></name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>database_id</name></expr></argument>,
					     <argument><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>string</name></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>ippos</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Try to match the compiled regular expression against input</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_REGEX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Executing: index = %d, preg = %p, str = \"%s\", pmatch = %p"</literal></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>regex</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_TRE_REGEX</name></cpp:ifdef>
		<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>tre_regexec</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>regex</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>regexec</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>regex</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<comment type="line">// regexec() returns REG_OK for a successful match or REG_NOMATCH for failure.</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>retval</name> <operator>==</operator> <name>REG_OK</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>inverted</name></name><operator>)</operator> <operator>||</operator>
		    <operator>(</operator><name>retval</name> <operator>==</operator> <name>REG_NOMATCH</name> <operator>&amp;&amp;</operator> <name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>inverted</name></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// Check possible additional regex settings</comment>
			<if_stmt><if>if<condition>(<expr><name>dns_cache</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="line">// Check query type filtering</comment>
				<if_stmt><if>if<condition>(<expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>query_type</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if<condition>(<expr><operator>(</operator><operator>!</operator><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>query_type_inverted</name></name> <operator>&amp;&amp;</operator> <name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>query_type</name></name> <operator>!=</operator> <name><name>dns_cache</name><operator>-&gt;</operator><name>query_type</name></name><operator>)</operator> <operator>||</operator>
					    <operator>(</operator><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>query_type_inverted</name></name> <operator>&amp;&amp;</operator> <name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>query_type</name></name> <operator>==</operator> <name><name>dns_cache</name><operator>-&gt;</operator><name>query_type</name></name><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_REGEX</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Regex %s (%u, DB ID %i) NO match: \"%s\" vs. \"%s\""</literal>
								<literal type="string">" (skipped because of query type %smatch)"</literal></expr></argument>,
							<argument><expr><name><name>regextype</name><index>[<expr><name>regexid</name></expr>]</index></name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>database_id</name></expr></argument>,
							<argument><expr><name>input</name></expr></argument>, <argument><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>string</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>query_type_inverted</name></name></expr> ?</condition><then> <expr><literal type="string">"inversion "</literal></expr> </then><else>: <expr><literal type="string">"mis"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<comment type="line">// Set special reply type if configured for this regex</comment>
				<if_stmt><if>if<condition>(<expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>reply</name></name> <operator>!=</operator> <name>REPLY_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>dns_cache</name><operator>-&gt;</operator><name>force_reply</name></name> <operator>=</operator> <name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>reply</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="line">// Match, return true</comment>
			<expr_stmt><expr><name>match_idx</name> <operator>=</operator> <name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>database_id</name></expr>;</expr_stmt>

			<comment type="line">// Print match message when in regex debug mode</comment>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_REGEX</name></expr>)</condition>
			<block>{<block_content>
				<comment type="line">// Approximate regex matching mode</comment>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Regex %s (%u, DB ID %i) &gt;&gt; MATCH: \"%s\" vs. \"%s\""</literal></expr></argument>,
				     <argument><expr><name><name>regextype</name><index>[<expr><name>regexid</name></expr>]</index></name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>database_id</name></expr></argument>,
				     <argument><expr><name>input</name></expr></argument>, <argument><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if<condition>(<expr><name>regextest</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if<condition>(<expr><name>regexid</name> <operator>==</operator> <name>REGEX_CLI</name></expr>)</condition>
				<block>{<block_content>
					<comment type="line">// CLI provided regular expression</comment>
					<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"    %s%s%s matches"</literal></expr></argument>,
					<argument><expr><call><name>cli_bold</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>string</name></expr></argument>, <argument><expr><call><name>cli_normal</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if<condition>(<expr><name>regextest</name> <operator>&amp;&amp;</operator> <name>regexid</name> <operator>==</operator> <name>REGEX_BLACKLIST</name></expr>)</condition>
				<block>{<block_content>
					<comment type="line">// Database-sourced regular expression</comment>
					<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"    %s%s%s matches (regex blacklist, DB ID %i)"</literal></expr></argument>,
					<argument><expr><call><name>cli_bold</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>string</name></expr></argument>, <argument><expr><call><name>cli_normal</name><argument_list>()</argument_list></call></expr></argument>,
					<argument><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>database_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if<condition>(<expr><name>regextest</name> <operator>&amp;&amp;</operator> <name>regexid</name> <operator>==</operator> <name>REGEX_WHITELIST</name></expr>)</condition>
				<block>{<block_content>
					<comment type="line">// Database-sourced regular expression</comment>
					<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"    %s%s%s matches (regex whitelist, DB ID %i)"</literal></expr></argument>,
					<argument><expr><call><name>cli_bold</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>string</name></expr></argument>, <argument><expr><call><name>cli_normal</name><argument_list>()</argument_list></call></expr></argument>,
					<argument><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>database_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="line">// Check query type filtering</comment>
				<if_stmt><if>if<condition>(<expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>query_type</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"    Hint: This regex %s type %s queries"</literal></expr></argument>,
					     <argument><expr><ternary><condition><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>query_type_inverted</name></name></expr> ?</condition><then> <expr><literal type="string">"does not match"</literal></expr> </then><else>: <expr><literal type="string">"matches only"</literal></expr></else></ternary></expr></argument>,
					     <argument><expr><name><name>querytypes</name><index>[<expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>query_type</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="line">// Check inversion</comment>
				<if_stmt><if>if<condition>(<expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>inverted</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"    Hint: This regex is inverted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="line">// Check special reply type</comment>
				<if_stmt><if>if<condition>(<expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>reply</name></name> <operator>!=</operator> <name>REPLY_UNKNOWN</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"    Hint: This regex forces reply type %s"</literal></expr></argument>,
					     <argument><expr><call><name>get_query_reply_str</name><argument_list>(<argument><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>ext</name><operator>.</operator><name>reply</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="line">// Only check the first match when not in regex-test mode</comment>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Print no match message when in regex debug mode</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_REGEX</name> <operator>&amp;&amp;</operator> <name>match_idx</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Regex %s (%u, DB ID %i) NO match: \"%s\" vs. \"%s\""</literal></expr></argument>,
			     <argument><expr><name><name>regextype</name><index>[<expr><name>regexid</name></expr>]</index></name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>database_id</name></expr></argument>,
			     <argument><expr><name>input</name></expr></argument>, <argument><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="line">// Return match_idx (-1 if there was no match)</comment>
	<return>return <expr><name>match_idx</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>in_regex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>domain</name></decl></parameter>, <parameter><decl><type><name>DNSCacheData</name> <modifier>*</modifier></type><name>dns_cache</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>clientID</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>enum</name> <name>regex_type</name></name></type> <name>regexid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// For performance reasons, the regex evaluations is executed only if the</comment>
	<comment type="line">// exact whitelist lookup does not deliver a positive match. This is an</comment>
	<comment type="line">// optimization as the database lookup will most likely hit (a) more domains</comment>
	<comment type="line">// and (b) will be faster (given a sufficiently large number of regex</comment>
	<comment type="line">// whitelisting filters).</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>regex_id</name> <init>= <expr><call><name>match_regex</name><argument_list>(<argument><expr><name>domain</name></expr></argument>, <argument><expr><name>dns_cache</name></expr></argument>, <argument><expr><name>clientID</name></expr></argument>, <argument><expr><name>regexid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>regex_id</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// We found a match</comment>
		<expr_stmt><expr><name><name>dns_cache</name><operator>-&gt;</operator><name>domainlist_id</name></name> <operator>=</operator> <name>regex_id</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_regex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Return early if we don't use any regex filters</comment>
	<if_stmt><if>if<condition>(<expr><name>white_regex</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
	   <name>black_regex</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
	     <name>cli_regex</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_DATABASE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Not using any regex filters, nothing to free or reset"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Reset client configuration</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_DATABASE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Resetting per-client regex settings"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>clientID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>clientID</name> <operator>&lt;</operator> <name><name>counters</name><operator>-&gt;</operator><name>clients</name></name></expr>;</condition> <incr><expr><name>clientID</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>reset_per_client_regex</name><argument_list>(<argument><expr><name>clientID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="line">// Free regex datastructure</comment>
	<comment type="line">// Loop over regex types</comment>
	<for>for<control>(<init><decl><type><name><name>enum</name> <name>regex_type</name></name></type> <name>regexid</name> <init>= <expr><name>REGEX_BLACKLIST</name></expr></init></decl>;</init> <condition><expr><name>regexid</name> <operator>&lt;</operator> <name>REGEX_MAX</name></expr>;</condition> <incr><expr><name>regexid</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>regexData</name> <modifier>*</modifier></type><name>regex</name> <init>= <expr><call><name>get_regex_ptr</name><argument_list>(<argument><expr><name>regexid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// Reset counter for number of regex</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>oldcount</name> <init>= <expr><name><name>num_regex</name><index>[<expr><name>regexid</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>num_regex</name><index>[<expr><name>regexid</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="line">// Exit early if the regex has already been freed (or has never been used)</comment>
		<if_stmt><if>if<condition>(<expr><name>regex</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_DATABASE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Going to free %i entries in %s regex struct"</literal></expr></argument>,
			     <argument><expr><name>oldcount</name></expr></argument>, <argument><expr><name><name>regextype</name><index>[<expr><name>regexid</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Loop over entries with this regex type</comment>
		<for>for<control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>oldcount</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>available</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>regfree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>regex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="line">// Also free buffered regex strings</comment>
			<if_stmt><if>if<condition>(<expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>string</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>regex</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_DATABASE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Loop done, freeing regex pointer (%p)"</literal></expr></argument>, <argument><expr><name>regex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Free array with regex datastructure</comment>
		<expr_stmt><expr><call><name>free_regex_ptr</name><argument_list>(<argument><expr><name>regexid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="line">// This function does three things:</comment>
<comment type="line">//   1. Allocate additional memory if required</comment>
<comment type="line">//   2. Reset all regex to false for this client</comment>
<comment type="line">//   3. Load regex enabled/disabled state</comment>
<function><type><name>void</name></type> <name>reload_per_client_regex</name><parameter_list>(<parameter><decl><type><name>clientsData</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Ensure there is enough memory in the shared memory object</comment>
	<expr_stmt><expr><call><name>add_per_client_regex</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Zero-initialize (or wipe previous) regex</comment>
	<expr_stmt><expr><call><name>reset_per_client_regex</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Load regex per-group regex blacklist for this client</comment>
	<if_stmt><if>if<condition>(<expr><name><name>num_regex</name><index>[<expr><name>REGEX_BLACKLIST</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>gravityDB_get_regex_client_groups</name><argument_list>(<argument><expr><name>client</name></expr></argument>, <argument><expr><name><name>num_regex</name><index>[<expr><name>REGEX_BLACKLIST</name></expr>]</index></name></expr></argument>,
		                                  <argument><expr><name>black_regex</name></expr></argument>, <argument><expr><name>REGEX_BLACKLIST</name></expr></argument>,
		                                  <argument><expr><literal type="string">"vw_regex_blacklist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Load regex per-group regex whitelist for this client</comment>
	<if_stmt><if>if<condition>(<expr><name><name>num_regex</name><index>[<expr><name>REGEX_WHITELIST</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>gravityDB_get_regex_client_groups</name><argument_list>(<argument><expr><name>client</name></expr></argument>, <argument><expr><name><name>num_regex</name><index>[<expr><name>REGEX_WHITELIST</name></expr>]</index></name></expr></argument>,
		                                  <argument><expr><name>white_regex</name></expr></argument>, <argument><expr><name>REGEX_WHITELIST</name></expr></argument>,
		                                  <argument><expr><literal type="string">"vw_regex_whitelist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>read_regex_table</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>enum</name> <name>regex_type</name></name></type> <name>regexid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Get table ID</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>enum</name> <name>gravity_tables</name></name></type> <name>tableID</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>regexid</name> <operator>==</operator> <name>REGEX_BLACKLIST</name><operator>)</operator></expr> ?</condition><then> <expr><name>REGEX_BLACKLIST_TABLE</name></expr> </then><else>: <expr><name>REGEX_WHITELIST_TABLE</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_DATABASE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Reading regex %s from database"</literal></expr></argument>, <argument><expr><name><name>regextype</name><index>[<expr><name>regexid</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Get number of lines in the regex table</comment>
	<expr_stmt><expr><name><name>num_regex</name><index>[<expr><name>regexid</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name>gravityDB_count</name><argument_list>(<argument><expr><name>tableID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"WARN: Database query failed, assuming there are no %s regex entries"</literal></expr></argument>, <argument><expr><name><name>regextype</name><index>[<expr><name>regexid</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Allocate memory for regex</comment>
	<decl_stmt><decl><type><name>regexData</name> <modifier>*</modifier></type><name>regex</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>regexid</name> <operator>==</operator> <name>REGEX_BLACKLIST</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>black_regex</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>regexData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>regex</name> <operator>=</operator> <name>black_regex</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>white_regex</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>regexData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>regex</name> <operator>=</operator> <name>white_regex</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="line">// Connect to regex table</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>gravityDB_getTable</name><argument_list>(<argument><expr><name>tableID</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"read_regex_from_database(): Error getting %s regex table from database"</literal></expr></argument>,
		     <argument><expr><name><name>regextype</name><index>[<expr><name>regexid</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Walk database table</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>domain</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rowid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<while>while<condition>(<expr><operator>(</operator><name>domain</name> <operator>=</operator> <call><name>gravityDB_getDomain</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rowid</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Avoid buffer overflow if database table changed</comment>
		<comment type="line">// since we counted its entries</comment>
		<if_stmt><if>if<condition>(<expr><name><name>num_regex</name><index>[<expr><name>regexid</name></expr>]</index></name> <operator>&gt;=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>count</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"INFO: read_regex_table(%s) exiting early to avoid overflow (%d/%d)."</literal></expr></argument>,
			     <argument><expr><name><name>regextype</name><index>[<expr><name>regexid</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>num_regex</name><index>[<expr><name>regexid</name></expr>]</index></name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Skip this entry if empty: an empty regex filter would match</comment>
		<comment type="line">// anything anywhere and hence match all incoming domains. A user</comment>
		<comment type="line">// can still achieve this with a filter such as ".*", however empty</comment>
		<comment type="line">// filters in the regex table are probably not expected to have such</comment>
		<comment type="line">// an effect and would immediately lead to "blocking or whitelisting</comment>
		<comment type="line">// the entire Internet"</comment>
		<if_stmt><if>if<condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>domain</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="line">// Compile this regex</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_REGEX</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Compiling %s regex %i (DB ID %i): %s"</literal></expr></argument>,
			     <argument><expr><name><name>regextype</name><index>[<expr><name>regexid</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>num_regex</name><index>[<expr><name>regexid</name></expr>]</index></name></expr></argument>, <argument><expr><name>rowid</name></expr></argument>, <argument><expr><name>domain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>compile_regex</name><argument_list>(<argument><expr><name>domain</name></expr></argument>, <argument><expr><name>regexid</name></expr></argument>, <argument><expr><name>rowid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>regex</name><index>[<expr><name><name>num_regex</name><index>[<expr><name>regexid</name></expr>]</index></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>database_id</name> <operator>=</operator> <name>rowid</name></expr>;</expr_stmt>

		<comment type="line">// Signal other forks that the regex data has changed and should be updated</comment>
		<expr_stmt><expr><name>regex_change</name> <operator>=</operator> <operator>++</operator><name><name>counters</name><operator>-&gt;</operator><name>regex_change</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="line">// Finalize statement and close gravity database handle</comment>
	<expr_stmt><expr><call><name>gravityDB_finalizeTable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_DATABASE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Read %i %s regex entries"</literal></expr></argument>,
		     <argument><expr><name><name>num_regex</name><index>[<expr><name>regexid</name></expr>]</index></name></expr></argument>,
		     <argument><expr><name><name>regextype</name><index>[<expr><name>regexid</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>read_regex_from_database</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Free regex filters</comment>
	<comment type="line">// This routine is safe to be called even when there</comment>
	<comment type="line">// are no regex filters at the moment</comment>
	<expr_stmt><expr><call><name>free_regex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Start timer for regex compilation analysis</comment>
	<expr_stmt><expr><call><name>timer_start</name><argument_list>(<argument><expr><name>REGEX_TIMER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Read and compile regex blacklist</comment>
	<expr_stmt><expr><call><name>read_regex_table</name><argument_list>(<argument><expr><name>REGEX_BLACKLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Read and compile regex whitelist</comment>
	<expr_stmt><expr><call><name>read_regex_table</name><argument_list>(<argument><expr><name>REGEX_WHITELIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Loop over all clients and ensure we have enough space and load</comment>
	<comment type="line">// per-client regex data, not all of the regex read and compiled above</comment>
	<comment type="line">// will also be used by all clients</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_DATABASE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Loading per-client regex data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>clientID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>clientID</name> <operator>&lt;</operator> <name><name>counters</name><operator>-&gt;</operator><name>clients</name></name></expr>;</condition> <incr><expr><name>clientID</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="line">// Get client pointer</comment>
		<decl_stmt><decl><type><name>clientsData</name> <modifier>*</modifier></type><name>client</name> <init>= <expr><call><name>getClient</name><argument_list>(<argument><expr><name>clientID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="line">// Skip invalid and alias-clients</comment>
		<if_stmt><if>if<condition>(<expr><name>client</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>client</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>aliasclient</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>reload_per_client_regex</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="line">// Print message to FTL's log after reloading regex filters</comment>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Compiled %i whitelist and %i blacklist regex filters for %i clients in %.1f msec"</literal></expr></argument>,
	     <argument><expr><name><name>num_regex</name><index>[<expr><name>REGEX_WHITELIST</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>num_regex</name><index>[<expr><name>REGEX_BLACKLIST</name></expr>]</index></name></expr></argument>,
	     <argument><expr><name><name>counters</name><operator>-&gt;</operator><name>clients</name></name></expr></argument>, <argument><expr><call><name>timer_elapsed_msec</name><argument_list>(<argument><expr><name>REGEX_TIMER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>regex_test</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>debug_mode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>quiet</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>domainin</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>regexin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Prepare counters and regex memories</comment>
	<expr_stmt><expr><name>counters</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>countersStruct</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// Disable terminal output during config config file parsing</comment>
	<expr_stmt><expr><call><name>log_ctrl</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// Process pihole-FTL.conf to get gravity.db</comment>
	<expr_stmt><expr><call><name>read_FTLconf</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Disable all debugging output if not explicitly in debug mode (CLI argument "d")</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>debug_mode</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="line">// Re-enable terminal output</comment>
	<expr_stmt><expr><call><name>log_ctrl</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><operator>!</operator><name>quiet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>matchidx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>regexin</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Read and compile regex lists from database</comment>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"%s Loading regex filters from database..."</literal></expr></argument>, <argument><expr><call><name>cli_info</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>timer_start</name><argument_list>(<argument><expr><name>REGEX_TIMER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>log_ctrl</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Temporarily re-enable terminal output for error logging</comment>
		<expr_stmt><expr><call><name>read_regex_table</name><argument_list>(<argument><expr><name>REGEX_BLACKLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>read_regex_table</name><argument_list>(<argument><expr><name>REGEX_WHITELIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>log_ctrl</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><operator>!</operator><name>quiet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Re-apply quiet option after compilation</comment>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"    Compiled %i black- and %i whitelist regex filters in %.3f msec\n"</literal></expr></argument>,
		     <argument><expr><name><name>num_regex</name><index>[<expr><name>REGEX_BLACKLIST</name></expr>]</index></name></expr></argument>,
		     <argument><expr><name><name>num_regex</name><index>[<expr><name>REGEX_WHITELIST</name></expr>]</index></name></expr></argument>,
		     <argument><expr><call><name>timer_elapsed_msec</name><argument_list>(<argument><expr><name>REGEX_TIMER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Check user-provided domain against all loaded regular blacklist expressions</comment>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"%s Checking domain against blacklist..."</literal></expr></argument>, <argument><expr><call><name>cli_info</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>timer_start</name><argument_list>(<argument><expr><name>REGEX_TIMER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>matchidx1</name> <init>= <expr><call><name>match_regex</name><argument_list>(<argument><expr><name>domainin</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>REGEX_BLACKLIST</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"    Time: %.3f msec"</literal></expr></argument>, <argument><expr><call><name>timer_elapsed_msec</name><argument_list>(<argument><expr><name>REGEX_TIMER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Check user-provided domain against all loaded regular whitelist expressions</comment>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"%s Checking domain against whitelist..."</literal></expr></argument>, <argument><expr><call><name>cli_info</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>timer_start</name><argument_list>(<argument><expr><name>REGEX_TIMER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>matchidx2</name> <init>= <expr><call><name>match_regex</name><argument_list>(<argument><expr><name>domainin</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>REGEX_WHITELIST</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"    Time: %.3f msec"</literal></expr></argument>, <argument><expr><call><name>timer_elapsed_msec</name><argument_list>(<argument><expr><name>REGEX_TIMER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>matchidx</name> <operator>=</operator> <call><name>MAX</name><argument_list>(<argument><expr><name>matchidx1</name></expr></argument>, <argument><expr><name>matchidx2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="line">// Compile CLI regex</comment>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"%s Compiling regex filter..."</literal></expr></argument>, <argument><expr><call><name>cli_info</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cli_regex</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>regexData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Compile CLI regex</comment>
		<expr_stmt><expr><call><name>timer_start</name><argument_list>(<argument><expr><name>REGEX_TIMER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>log_ctrl</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Temporarily re-enable terminal output for error logging</comment>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>compile_regex</name><argument_list>(<argument><expr><name>regexin</name></expr></argument>, <argument><expr><name>REGEX_CLI</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>EXIT_FAILURE</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>log_ctrl</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><operator>!</operator><name>quiet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Re-apply quiet option after compilation</comment>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"    Compiled regex filter in %.3f msec\n"</literal></expr></argument>, <argument><expr><call><name>timer_elapsed_msec</name><argument_list>(<argument><expr><name>REGEX_TIMER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Check user-provided domain against user-provided regular expression</comment>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Checking domain..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>timer_start</name><argument_list>(<argument><expr><name>REGEX_TIMER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>matchidx</name> <operator>=</operator> <call><name>match_regex</name><argument_list>(<argument><expr><name>domainin</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>REGEX_CLI</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>matchidx</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"    NO MATCH!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"   Time: %.3f msec"</literal></expr></argument>, <argument><expr><call><name>timer_elapsed_msec</name><argument_list>(<argument><expr><name>REGEX_TIMER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="line">// Return status 0 = MATCH, 1 = ERROR, 2 = NO MATCH</comment>
	<return>return <expr><ternary><condition><expr><name>matchidx</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name>EXIT_SUCCESS</name></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Get internal ID of regex with this database ID</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>__attribute__</name> <argument_list>(<argument><expr><operator>(</operator><name>pure</name><operator>)</operator></expr></argument>)</argument_list> <name>regex_id_from_database_id</name><argument_list>(<argument><expr><specifier>const</specifier> <name>int</name> <name>dbID</name></expr></argument>)</argument_list>
<block>{<block_content>
	<comment type="line">// Get number of defined regular expressions</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>sum_regex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>REGEX_MAX</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sum_regex</name> <operator>+=</operator> <name><name>num_regex</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

	<comment type="line">// Find internal ID of regular expression with this database ID</comment>
	<for>for<control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>sum_regex</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>regexData</name> <modifier>*</modifier></type><name>regex</name> <init>= <expr><call><name>get_regex_ptr_from_id</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>regex</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if<condition>(<expr><name><name>regex</name><operator>-&gt;</operator><name>database_id</name></name> <operator>==</operator> <name>dbID</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<comment type="line">// Return redirection addresses for a given blacklist regex (if specified)</comment>
<function><type><name>bool</name></type> <name>regex_get_redirect</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>dbID</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>in_addr</name></name> <modifier>*</modifier></type><name>addr4</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>in6_addr</name></name> <modifier>*</modifier></type><name>addr6</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Check dbID for validity, return early if negative</comment>
	<if_stmt><if>if<condition>(<expr><name>dbID</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// Get internal regex ID from database regex ID</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>regexID</name> <init>= <expr><call><name>regex_id_from_database_id</name><argument_list>(<argument><expr><name>dbID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_REGEX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Regex: %d (database) -&gt; %d (internal)"</literal></expr></argument>, <argument><expr><name>dbID</name></expr></argument>, <argument><expr><name>regexID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Check internal regex ID for validity, return early if negative</comment>
	<if_stmt><if>if<condition>(<expr><name>regexID</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// Get regex from regexID</comment>
	<decl_stmt><decl><type><name>regexData</name> <modifier>*</modifier></type><name>regex</name> <init>= <expr><call><name>get_regex_ptr_from_id</name><argument_list>(<argument><expr><name>regexID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>regex</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>custom_addr</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<comment type="line">// Check for IPv4 redirect</comment>
	<if_stmt><if>if<condition>(<expr><name><name>regex</name><operator>-&gt;</operator><name>ext</name><operator>.</operator><name>custom_ip4</name></name> <operator>&amp;&amp;</operator> <name>addr4</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>addr4</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>regex</name><operator>-&gt;</operator><name>ext</name><operator>.</operator><name>addr4</name></name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>addr4</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>custom_addr</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Check for IPv6 redirect</comment>
	<if_stmt><if>if<condition>(<expr><name><name>regex</name><operator>-&gt;</operator><name>ext</name><operator>.</operator><name>custom_ip6</name></name> <operator>&amp;&amp;</operator> <name>addr6</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>addr6</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>regex</name><operator>-&gt;</operator><name>ext</name><operator>.</operator><name>addr6</name></name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>addr6</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>custom_addr</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>custom_addr</name></expr>;</return>
</block_content>}</block></function>
</unit>
