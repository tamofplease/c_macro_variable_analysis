<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/dnsmasq_interface.c"><comment type="block">/* Pi-hole: A black hole for Internet advertisements
*  (c) 2017 Pi-hole, LLC (https://pi-hole.net)
*  Network-wide ad blocking via your own hardware.
*
*  FTL Engine
*  dnsmasq interfacing routines
*
*  This file is copyright under the latest version of the EUPL.
*  Please see LICENSE file for your rights under this license. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTLDNS</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dnsmasq/dnsmasq.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>__USE_XOPEN</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"FTL.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"enums.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dnsmasq_interface.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"overTime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"database/common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"database/database-thread.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"datastructure.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"database/gravity-db.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"setupVars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"daemon.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"timers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"api/socket.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regex_r.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"capabilities.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"resolve.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"files.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"log.h"</cpp:file></cpp:include>
<comment type="line">// Prototype of getCacheInformation()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"api/api.h"</cpp:file></cpp:include>
<comment type="line">// global variable daemonmode</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"args.h"</cpp:file></cpp:include>
<comment type="line">// handle_realtime_signals()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"signals.h"</cpp:file></cpp:include>
<comment type="line">// atomic_flag_test_and_set()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdatomic.h&gt;</cpp:file></cpp:include>
<comment type="line">// Eventqueue routines</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"events.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<comment type="line">// offsetof()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<comment type="line">// get_edestr()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"api/api_helper.h"</cpp:file></cpp:include>
<comment type="line">// logg_rate_limit_message()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"database/message-table.h"</cpp:file></cpp:include>
<comment type="line">// type struct sqlite3_stmt_vec</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vector.h"</cpp:file></cpp:include>
<comment type="line">// check_one_struct()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"struct_size.h"</cpp:file></cpp:include>

<comment type="line">// Private prototypes</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>print_flags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>query_set_reply</name><parameter_list>(<parameter><type><name>flags</name></type></parameter>, <parameter><type><name>type</name></type></parameter>, <parameter><type><name>addr</name></type></parameter>, <parameter><type><name>query</name></type></parameter>, <parameter><type><name>response</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_query_set_reply(flags, type, addr, query, response, __FILE__, __LINE__)</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_query_set_reply</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>enum</name> <name>reply_type</name></name></type> <name>reply</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>union</name> <name>all_addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>queriesData</name><modifier>*</modifier></type> <name>query</name></decl></parameter>,
                             <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>timeval</name></name></type> <name>response</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FTL_check_blocking</name><parameter_list>(<parameter><type><name>queryID</name></type></parameter>, <parameter><type><name>domainID</name></type></parameter>, <parameter><type><name>clientID</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_FTL_check_blocking(queryID, domainID, clientID, __FILE__, __LINE__)</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>_FTL_check_blocking</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>queryID</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>domainID</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>clientID</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>converttimeval</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>timeval</name></name></type> <name>time</name></decl></parameter>)</parameter_list> __attribute__<parameter_list>(<parameter/></parameter_list>(const</function_decl>))<empty_stmt>;</empty_stmt>
<function_decl><type><specifier>static</specifier> <name><name>enum</name> <name>query_status</name></name></type> <name>detect_blocked_IP</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>short</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>union</name> <name>all_addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>queriesData</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>domainsData</name> <modifier>*</modifier></type><name>domain</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>query_blocked</name><parameter_list>(<parameter><decl><type><name>queriesData</name><modifier>*</modifier></type> <name>query</name></decl></parameter>, <parameter><decl><type><name>domainsData</name><modifier>*</modifier></type> <name>domain</name></decl></parameter>, <parameter><decl><type><name>clientsData</name><modifier>*</modifier></type> <name>client</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>new_status</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FTL_forwarded</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>union</name> <name>all_addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>short</name></type> <name>port</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FTL_reply</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>union</name> <name>all_addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FTL_upstream_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>union</name> <name>all_addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FTL_dnssec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>union</name> <name>all_addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mysockaddr_extract_ip_port</name><parameter_list>(<parameter><decl><type><name><name>union</name> <name>mysockaddr</name></name> <modifier>*</modifier></type><name>server</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name><name>ip</name><index>[<expr><name>ADDRSTRLEN</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>in_port_t</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>alladdr_extract_ip</name><parameter_list>(<parameter><decl><type><name><name>union</name> <name>all_addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>sa_family_t</name></type> <name>family</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name><name>ip</name><index>[<expr><name>ADDRSTRLEN</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_pihole_PTR</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>domain</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>query_set_dnssec</name><parameter_list>(<parameter><type><name>query</name></type></parameter>, <parameter><type><name>dnssec</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_query_set_dnssec(query, dnssec, __FILE__, __LINE__)</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_query_set_dnssec</name><parameter_list>(<parameter><decl><type><name>queriesData</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>enum</name> <name>dnssec_status</name></name></type> <name>dnssec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_ptrname</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>in_addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>check_dnsmasq_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="line">// Static blocking metadata</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>blockingreason</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>enum</name> <name>reply_type</name></name></type> <name>force_next_DNS_reply</name> <init>= <expr><name>REPLY_UNKNOWN</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>last_regex_idx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>ptr_record</name></name> <modifier>*</modifier></type><name>pihole_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HOSTNAME</name></cpp:macro> <cpp:value>"Pi-hole hostname"</cpp:value></cpp:define>

<comment type="line">// Fork-private copy of the interface data the most recent query came from</comment>
<struct><specifier>static</specifier> struct <block>{
	<decl_stmt><decl><type><name>bool</name></type> <name>haveIPv4</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>haveIPv6</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><name>IFNAMSIZ</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>union</name> <name>all_addr</name></name></type> <name>addr4</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>union</name> <name>all_addr</name></name></type> <name>addr6</name></decl>;</decl_stmt>
}</block> <decl><name>next_iface</name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><literal type="string">""</literal></expr>, <expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr>, <expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr>}</block></expr></init></decl>;</struct>

<comment type="line">// Fork-private copy of the server data the most recent reply came from</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>union</name> <name>mysockaddr</name></name></type> <name>last_server</name> <init>= <expr><block>{<expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name><modifier>*</modifier></type> <name>pihole_privacylevel</name> <init>= <expr><operator>&amp;</operator><name><name>config</name><operator>.</operator><name>privacylevel</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>flagnames</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"F_IMMORTAL "</literal></expr>, <expr><literal type="string">"F_NAMEP "</literal></expr>, <expr><literal type="string">"F_REVERSE "</literal></expr>, <expr><literal type="string">"F_FORWARD "</literal></expr>, <expr><literal type="string">"F_DHCP "</literal></expr>, <expr><literal type="string">"F_NEG "</literal></expr>, <expr><literal type="string">"F_HOSTS "</literal></expr>, <expr><literal type="string">"F_IPV4 "</literal></expr>, <expr><literal type="string">"F_IPV6 "</literal></expr>, <expr><literal type="string">"F_BIGNAME "</literal></expr>, <expr><literal type="string">"F_NXDOMAIN "</literal></expr>, <expr><literal type="string">"F_CNAME "</literal></expr>, <expr><literal type="string">"F_DNSKEY "</literal></expr>, <expr><literal type="string">"F_CONFIG "</literal></expr>, <expr><literal type="string">"F_DS "</literal></expr>, <expr><literal type="string">"F_DNSSECOK "</literal></expr>, <expr><literal type="string">"F_UPSTREAM "</literal></expr>, <expr><literal type="string">"F_RRNAME "</literal></expr>, <expr><literal type="string">"F_SERVER "</literal></expr>, <expr><literal type="string">"F_QUERY "</literal></expr>, <expr><literal type="string">"F_NOERR "</literal></expr>, <expr><literal type="string">"F_AUTH "</literal></expr>, <expr><literal type="string">"F_DNSSEC "</literal></expr>, <expr><literal type="string">"F_KEYTAG "</literal></expr>, <expr><literal type="string">"F_SECSTAT "</literal></expr>, <expr><literal type="string">"F_NO_RR "</literal></expr>, <expr><literal type="string">"F_IPSET "</literal></expr>, <expr><literal type="string">"F_NOEXTRA "</literal></expr>, <expr><literal type="string">"F_SERVFAIL"</literal></expr>, <expr><literal type="string">"F_RCODE"</literal></expr>, <expr><literal type="string">"F_SRV"</literal></expr>, <expr><literal type="string">"F_STALE"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>FTL_hook</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name><name>union</name> <name>all_addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>short</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Extract filename from path</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>short_path</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_FLAGS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Processing FTL hook from %s:%d (name: \"%s\")..."</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>print_flags</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Check domain name received from dnsmasq</comment>
	<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>check_dnsmasq_name</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Note: The order matters here!</comment>
	<if_stmt><if>if<condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>F_QUERY</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>F_FORWARD</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<empty_stmt>;</empty_stmt></block_content></block></if> <comment type="line">// New query, handled by FTL_new_query via separate call</comment>
	<if type="elseif">else if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_FORWARD</name> <operator>&amp;&amp;</operator> <name>flags</name> <operator>&amp;</operator> <name>F_SERVER</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="line">// forwarded upstream (type is used to store the upstream port)</comment>
		<expr_stmt><expr><call><name>FTL_forwarded</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if<condition>(<expr><name>flags</name> <operator>==</operator> <name>F_SECSTAT</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="line">// DNSSEC validation result</comment>
		<expr_stmt><expr><call><name>FTL_dnssec</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_RCODE</name> <operator>&amp;&amp;</operator> <name>name</name> <operator>&amp;&amp;</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"error"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<comment type="line">// upstream sent something different than NOERROR or NXDOMAIN</comment>
		<expr_stmt><expr><call><name>FTL_upstream_error</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_NOEXTRA</name> <operator>&amp;&amp;</operator> <name>flags</name> <operator>&amp;</operator> <name>F_DNSSEC</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// This is a new DNSSEC query (dnssec-query[DS])</comment>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>config</name><operator>.</operator><name>show_dnssec</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><specifier>const</specifier> <name>ednsData</name></type> <name>edns</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

		<comment type="line">// Type is overloaded with port since 2d65d55, so we have to</comment>
		<comment type="line">// derive the real query type from the arg string</comment>
		<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>qtype</name> <init>= <expr><name>type</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"dnssec-query[DNSKEY]"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>qtype</name> <operator>=</operator> <name>T_DNSKEY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="string">"dnssec-query"</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"dnssec-query[DS]"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>qtype</name> <operator>=</operator> <name>T_DS</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="string">"dnssec-query"</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"dnssec-retry[DNSKEY]"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>qtype</name> <operator>=</operator> <name>T_DNSKEY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="string">"dnssec-retry"</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"dnssec-retry[DS]"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>qtype</name> <operator>=</operator> <name>T_DS</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="string">"dnssec-retry"</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="string">"dnssec-unknown"</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>_FTL_new_query</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>qtype</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>edns</name></expr></argument>, <argument><expr><name>INTERNAL</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// forwarded upstream (type is used to store the upstream port)</comment>
		<expr_stmt><expr><call><name>FTL_forwarded</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_AUTH</name></expr>)</condition><block type="pseudo"><block_content>
		<empty_stmt>;</empty_stmt></block_content></block></if> <comment type="line">// Ignored</comment>
	<if type="elseif">else if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_IPSET</name></expr>)</condition><block type="pseudo"><block_content>
		<empty_stmt>;</empty_stmt></block_content></block></if> <comment type="line">// Ignored</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FTL_reply</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">// This is inspired by make_local_answer()</comment>
<function><type><name>size_t</name></type> <name>_FTL_make_answer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dns_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>limit</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ede</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_FLAGS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"FTL_make_answer() called from %s:%d"</literal></expr></argument>, <argument><expr><call><name>short_path</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="line">// Exit early if there are no questions in this query</comment>
	<if_stmt><if>if<condition>(<expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>qdcount</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// Get question name</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><name>MAXDNAME</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>header</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// Debug logging</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_FLAGS</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><operator>*</operator><name>ede</name> <operator>!=</operator> <name>EDE_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Preparing reply for \"%s\", EDE: %s (%d)"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>edestr</name><argument_list>(<argument><expr><operator>*</operator><name>ede</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>ede</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Preparing reply for \"%s\", EDE: N/A"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Get question type</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>qtype</name></decl>, <decl><type ref="prev"/><name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>qtype</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Set flags based on what we will reply with</comment>
	<if_stmt><if>if<condition>(<expr><name>qtype</name> <operator>==</operator> <name>T_A</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>F_IPV4</name></expr>;</expr_stmt></block_content></block></if> <comment type="line">// A type</comment>
	<if type="elseif">else if<condition>(<expr><name>qtype</name> <operator>==</operator> <name>T_AAAA</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>F_IPV6</name></expr>;</expr_stmt></block_content></block></if> <comment type="line">// AAAA type</comment>
	<if type="elseif">else if<condition>(<expr><name>qtype</name> <operator>==</operator> <name>T_ANY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>F_IPV4</name> <operator>|</operator> <name>F_IPV6</name></expr>;</expr_stmt></block_content></block></if> <comment type="line">// ANY type</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>F_NOERR</name></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="line">// empty record</comment>

	<comment type="line">// Prepare answer records</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>forced_ip</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<comment type="line">// Check first if we need to force our reply to something different than the</comment>
	<comment type="line">// default/configured blocking mode. For instance, we need to force NXDOMAIN</comment>
	<comment type="line">// for intercepted _esni.* queries or the Mozilla canary domain.</comment>
	<if_stmt><if>if<condition>(<expr><name>force_next_DNS_reply</name> <operator>==</operator> <name>REPLY_NXDOMAIN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>F_NXDOMAIN</name></expr>;</expr_stmt>
		<comment type="line">// Reset DNS reply forcing</comment>
		<expr_stmt><expr><name>force_next_DNS_reply</name> <operator>=</operator> <name>REPLY_UNKNOWN</name></expr>;</expr_stmt>

		<comment type="line">// Debug logging</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_FLAGS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Forced DNS reply to NXDOMAIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name>force_next_DNS_reply</name> <operator>==</operator> <name>REPLY_NODATA</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>F_NOERR</name></expr>;</expr_stmt>
		<comment type="line">// Reset DNS reply forcing</comment>
		<expr_stmt><expr><name>force_next_DNS_reply</name> <operator>=</operator> <name>REPLY_UNKNOWN</name></expr>;</expr_stmt>

		<comment type="line">// Debug logging</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_FLAGS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Forced DNS reply to NODATA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name>force_next_DNS_reply</name> <operator>==</operator> <name>REPLY_REFUSED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Empty flags result in REFUSED</comment>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<comment type="line">// Reset DNS reply forcing</comment>
		<expr_stmt><expr><name>force_next_DNS_reply</name> <operator>=</operator> <name>REPLY_UNKNOWN</name></expr>;</expr_stmt>

		<comment type="line">// Debug logging</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_FLAGS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Forced DNS reply to REFUSED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="line">// Set EDE code to blocked</comment>
		<expr_stmt><expr><operator>*</operator><name>ede</name> <operator>=</operator> <name>EDE_BLOCKED</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name>force_next_DNS_reply</name> <operator>==</operator> <name>REPLY_IP</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// We do not need to change the flags here,</comment>
		<comment type="line">// they are already properly set (F_IPV4 and/or F_IPV6)</comment>
		<expr_stmt><expr><name>forced_ip</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="line">// Reset DNS reply forcing</comment>
		<expr_stmt><expr><name>force_next_DNS_reply</name> <operator>=</operator> <name>REPLY_UNKNOWN</name></expr>;</expr_stmt>

		<comment type="line">// Debug logging</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_FLAGS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Forced DNS reply to IP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name>force_next_DNS_reply</name> <operator>==</operator> <name>REPLY_NONE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Reset DNS reply forcing</comment>
		<expr_stmt><expr><name>force_next_DNS_reply</name> <operator>=</operator> <name>REPLY_UNKNOWN</name></expr>;</expr_stmt>

		<comment type="line">// Debug logging</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_FLAGS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Forced DNS reply to NONE - dropping this query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="line">// Overwrite flags only if not replying with a forced reply</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>blockingmode</name></name> <operator>==</operator> <name>MODE_NX</name></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// If we block in NXDOMAIN mode, we set flags to NXDOMAIN</comment>
			<comment type="line">// (NEG will be added after setup_reply() below)</comment>
			<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>F_NXDOMAIN</name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_FLAGS</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Configured blocking mode is NXDOMAIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if<condition>(<expr><name><name>config</name><operator>.</operator><name>blockingmode</name></name> <operator>==</operator> <name>MODE_NODATA</name> <operator>||</operator>
				<operator>(</operator><name><name>config</name><operator>.</operator><name>blockingmode</name></name> <operator>==</operator> <name>MODE_IP_NODATA_AAAA</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>F_IPV6</name><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// If we block in NODATA mode or NODATA for AAAA queries, we apply</comment>
			<comment type="line">// the NOERROR response flag. This ensures we're sending an empty response</comment>
			<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>F_NOERR</name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_FLAGS</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Configured blocking mode is NODATA%s"</literal></expr></argument>,
				     <argument><expr><ternary><condition><expr><name><name>config</name><operator>.</operator><name>blockingmode</name></name> <operator>==</operator> <name>MODE_IP_NODATA_AAAA</name></expr> ?</condition><then> <expr><literal type="string">"-IPv6"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="line">// Check for regex redirecting</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>redirecting</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>union</name> <name>all_addr</name></name></type> <name>redirect_addr4</name> <init>= <expr><block>{<expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr>}</block></expr></init></decl>, <decl><type ref="prev"/><name>redirect_addr6</name> <init>= <expr><block>{<expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr>}</block></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>last_regex_idx</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>redirecting</name> <operator>=</operator> <call><name>regex_get_redirect</name><argument_list>(<argument><expr><name>last_regex_idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>redirect_addr4</name><operator>.</operator><name>addr4</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>redirect_addr6</name><operator>.</operator><name>addr6</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// Reset regex redirection forcing</comment>
		<expr_stmt><expr><name>last_regex_idx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="line">// Debug logging</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_FLAGS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Regex match is %sredirected"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>redirecting</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"NOT "</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Debug logging</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_FLAGS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>print_flags</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Setup reply header</comment>
	<expr_stmt><expr><call><name>setup_reply</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>*</operator><name>ede</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Add NEG flag when replying with NXDOMAIN or NODATA. This is necessary</comment>
	<comment type="line">// to get proper logging in pihole.log At the same time, we cannot add</comment>
	<comment type="line">// NEG before calling setup_reply() as it would, otherwise, result in an</comment>
	<comment type="line">// incorrect "nowhere to forward to" log entry (because setup_reply()</comment>
	<comment type="line">// checks for equality of flags instead of doing a bitmask comparison).</comment>
	<if_stmt><if>if<condition>(<expr><name>flags</name> <operator>==</operator> <name>F_NXDOMAIN</name> <operator>||</operator> <name>flags</name> <operator>==</operator> <name>F_NOERR</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>F_NEG</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Add flags according to current blocking mode</comment>
	<comment type="line">// Set blocking_flags to F_HOSTS so dnsmasq logs blocked queries being answered from a specific source</comment>
	<comment type="line">// (it would otherwise assume it knew the blocking status from cache which would prevent us from</comment>
	<comment type="line">// printing the blocking source (blacklist, regex, gravity) in dnsmasq's log file, our pihole.log)</comment>
	<if_stmt><if>if<condition>(<expr><name>flags</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>F_HOSTS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Skip questions so we can start adding answers (if applicable)</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>p</name> <operator>=</operator> <call><name>skip_questions</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// Are we replying to pi.hole / &lt;hostname&gt; / pi.hole.&lt;local&gt; / &lt;hostname&gt;.&lt;local&gt; ?</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>hostname</name> <init>= <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>blockingreason</name></expr></argument>, <argument><expr><name>HOSTNAME</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>trunc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<comment type="line">// Add A answer record if requested</comment>
	<if_stmt><if>if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_IPV4</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>union</name> <name>all_addr</name></name></type> <name>addr</name> <init>= <expr><block>{<expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr>}</block></expr></init></decl>;</decl_stmt>

		<comment type="line">// Overwrite with IP address if requested</comment>
		<if_stmt><if>if<condition>(<expr><name>redirecting</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>redirect_addr4</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if<condition>(<expr><name><name>config</name><operator>.</operator><name>blockingmode</name></name> <operator>==</operator> <name>MODE_IP</name> <operator>||</operator>
		        <name><name>config</name><operator>.</operator><name>blockingmode</name></name> <operator>==</operator> <name>MODE_IP_NODATA_AAAA</name> <operator>||</operator>
		        <name>forced_ip</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name>hostname</name> <operator>&amp;&amp;</operator> <name><name>config</name><operator>.</operator><name>reply_addr</name><operator>.</operator><name>own_host</name><operator>.</operator><name>overwrite_v4</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>config</name><operator>.</operator><name>reply_addr</name><operator>.</operator><name>own_host</name><operator>.</operator><name>v4</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if<condition>(<expr><operator>!</operator><name>hostname</name> <operator>&amp;&amp;</operator> <name><name>config</name><operator>.</operator><name>reply_addr</name><operator>.</operator><name>ip_blocking</name><operator>.</operator><name>overwrite_v4</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>config</name><operator>.</operator><name>reply_addr</name><operator>.</operator><name>ip_blocking</name><operator>.</operator><name>v4</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>next_iface</name><operator>.</operator><name>addr4</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Debug logging</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type> <name><name>ip</name><index>[<expr><name>ADDRSTRLEN</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>alladdr_extract_ip</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><name>AF_INET</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"  Adding RR: \"%s A %s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Add A resource record</comment>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>ancount</name></name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>ancount</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>add_resource_record</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>trunc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>dns_header</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		                       <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><ternary><condition><expr><name>hostname</name></expr> ?</condition><then> <expr><name><name>daemon</name><operator>-&gt;</operator><name>local_ttl</name></name></expr> </then><else>: <expr><name><name>config</name><operator>.</operator><name>block_ttl</name></name></expr></else></ternary></expr></argument>,
		                       <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>T_A</name></expr></argument>, <argument><expr><name>C_IN</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="string">"4"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>addr</name><operator>.</operator><name>addr4</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>log_query</name><argument_list>(<argument><expr><name>flags</name> <operator>&amp;</operator> <operator>~</operator><name>F_IPV6</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>blockingreason</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Add AAAA answer record if requested</comment>
	<if_stmt><if>if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_IPV6</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>union</name> <name>all_addr</name></name></type> <name>addr</name> <init>= <expr><block>{<expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr>}</block></expr></init></decl>;</decl_stmt>

		<comment type="line">// Overwrite with IP address if requested</comment>
		<if_stmt><if>if<condition>(<expr><name>redirecting</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>redirect_addr6</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if<condition>(<expr><name><name>config</name><operator>.</operator><name>blockingmode</name></name> <operator>==</operator> <name>MODE_IP</name> <operator>||</operator>
		        <name>forced_ip</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name>hostname</name> <operator>&amp;&amp;</operator> <name><name>config</name><operator>.</operator><name>reply_addr</name><operator>.</operator><name>own_host</name><operator>.</operator><name>overwrite_v6</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>config</name><operator>.</operator><name>reply_addr</name><operator>.</operator><name>own_host</name><operator>.</operator><name>v6</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if<condition>(<expr><operator>!</operator><name>hostname</name> <operator>&amp;&amp;</operator> <name><name>config</name><operator>.</operator><name>reply_addr</name><operator>.</operator><name>ip_blocking</name><operator>.</operator><name>overwrite_v6</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>config</name><operator>.</operator><name>reply_addr</name><operator>.</operator><name>ip_blocking</name><operator>.</operator><name>v6</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>next_iface</name><operator>.</operator><name>addr6</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Debug logging</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type> <name><name>ip</name><index>[<expr><name>ADDRSTRLEN</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>alladdr_extract_ip</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><name>AF_INET6</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"  Adding RR: \"%s AAAA %s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Add AAAA resource record</comment>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>ancount</name></name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>ancount</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>add_resource_record</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>trunc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>dns_header</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		                       <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><ternary><condition><expr><name>hostname</name></expr> ?</condition><then> <expr><name><name>daemon</name><operator>-&gt;</operator><name>local_ttl</name></name></expr> </then><else>: <expr><name><name>config</name><operator>.</operator><name>block_ttl</name></name></expr></else></ternary></expr></argument>,
		                       <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>T_AAAA</name></expr></argument>, <argument><expr><name>C_IN</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="string">"6"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>addr</name><operator>.</operator><name>addr6</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>log_query</name><argument_list>(<argument><expr><name>flags</name> <operator>&amp;</operator> <operator>~</operator><name>F_IPV4</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>blockingreason</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Log empty replies</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>F_IPV4</name> <operator>|</operator> <name>F_IPV6</name><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name>flags</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// REFUSED</comment>
			<decl_stmt><decl><type><name><name>union</name> <name>all_addr</name></name></type> <name>addr</name> <init>= <expr><block>{<expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr>}</block></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>addr</name><operator>.</operator><name>log</name><operator>.</operator><name>rcode</name></name> <operator>=</operator> <name>REFUSED</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>addr</name><operator>.</operator><name>log</name><operator>.</operator><name>ede</name></name> <operator>=</operator> <name>EDE_BLOCKED</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>log_query</name><argument_list>(<argument><expr><name>F_RCODE</name> <operator>|</operator> <name>F_HOSTS</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>blockingreason</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="line">// NODATA/NXDOMAIN</comment>
			<comment type="line">// gravity blocked abc.com is NODATA/NXDOMAIN</comment>
			<expr_stmt><expr><call><name>log_query</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>blockingreason</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Indicate if truncated (client should retry over TCP)</comment>
	<if_stmt><if>if <condition>(<expr><name>trunc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>hb3</name></name> <operator>|=</operator> <name>HB3_TC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>p</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>header</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_pihole_domain</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>domain</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pihole_suffix</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>pihole_suffix</name> <operator>&amp;&amp;</operator> <name><name>daemon</name><operator>-&gt;</operator><name>domain_suffix</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Build "pi.hole.&lt;local suffix&gt;" domain</comment>
		<expr_stmt><expr><name>pihole_suffix</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>domain_suffix</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">9</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>pihole_suffix</name></expr></argument>, <argument><expr><literal type="string">"pi.hole."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>pihole_suffix</name></expr></argument>, <argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>domain_suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Domain suffix is \"%s\""</literal></expr></argument>, <argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>domain_suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname_suffix</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>hostname_suffix</name> <operator>&amp;&amp;</operator> <name><name>daemon</name><operator>-&gt;</operator><name>domain_suffix</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Build "&lt;hostname&gt;.&lt;local suffix&gt;" domain</comment>
		<expr_stmt><expr><name>hostname_suffix</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>hostname</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>domain_suffix</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>hostname_suffix</name></expr></argument>, <argument><expr><call><name>hostname</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>hostname_suffix</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>hostname_suffix</name></expr></argument>, <argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>domain_suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>domain</name></expr></argument>, <argument><expr><literal type="string">"pi.hole"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name>domain</name></expr></argument>, <argument><expr><call><name>hostname</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
	       <operator>(</operator><name>pihole_suffix</name> <operator>&amp;&amp;</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name>domain</name></expr></argument>, <argument><expr><name>pihole_suffix</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
	       <operator>(</operator><name>hostname_suffix</name> <operator>&amp;&amp;</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name>domain</name></expr></argument>, <argument><expr><name>hostname_suffix</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>_FTL_new_query</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
                    <parameter><decl><type><name><name>union</name> <name>mysockaddr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>short</name></type> <name>qtype</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>id</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>ednsData</name> <modifier>*</modifier></type><name>edns</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>enum</name> <name>protocol</name></name></type> <name>proto</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Create new query in data structure</comment>

	<comment type="line">// Get timestamp</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>time_t</name></type> <name>querytimestamp</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Save request time</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>request</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>request</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Determine query type</comment>
	<decl_stmt><decl><type><name><name>enum</name> <name>query_types</name></name></type> <name>querytype</name></decl>;</decl_stmt>
	<switch>switch<condition>(<expr><name>qtype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_A</name></expr>:</case>
			<expr_stmt><expr><name>querytype</name> <operator>=</operator> <name>TYPE_A</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AAAA</name></expr>:</case>
			<expr_stmt><expr><name>querytype</name> <operator>=</operator> <name>TYPE_AAAA</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ANY</name></expr>:</case>
			<expr_stmt><expr><name>querytype</name> <operator>=</operator> <name>TYPE_ANY</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SRV</name></expr>:</case>
			<expr_stmt><expr><name>querytype</name> <operator>=</operator> <name>TYPE_SRV</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SOA</name></expr>:</case>
			<expr_stmt><expr><name>querytype</name> <operator>=</operator> <name>TYPE_SOA</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_PTR</name></expr>:</case>
			<expr_stmt><expr><name>querytype</name> <operator>=</operator> <name>TYPE_PTR</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TXT</name></expr>:</case>
			<expr_stmt><expr><name>querytype</name> <operator>=</operator> <name>TYPE_TXT</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NAPTR</name></expr>:</case>
			<expr_stmt><expr><name>querytype</name> <operator>=</operator> <name>TYPE_NAPTR</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MX</name></expr>:</case>
			<expr_stmt><expr><name>querytype</name> <operator>=</operator> <name>TYPE_MX</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DS</name></expr>:</case>
			<expr_stmt><expr><name>querytype</name> <operator>=</operator> <name>TYPE_DS</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RRSIG</name></expr>:</case>
			<expr_stmt><expr><name>querytype</name> <operator>=</operator> <name>TYPE_RRSIG</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DNSKEY</name></expr>:</case>
			<expr_stmt><expr><name>querytype</name> <operator>=</operator> <name>TYPE_DNSKEY</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NS</name></expr>:</case>
			<expr_stmt><expr><name>querytype</name> <operator>=</operator> <name>TYPE_NS</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">64</literal></expr>:</case> <comment type="line">// Scn. 2 of https://datatracker.ietf.org/doc/draft-ietf-dnsop-svcb-https/</comment>
			<expr_stmt><expr><name>querytype</name> <operator>=</operator> <name>TYPE_SVCB</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">65</literal></expr>:</case> <comment type="line">// Scn. 2 of https://datatracker.ietf.org/doc/draft-ietf-dnsop-svcb-https/</comment>
			<expr_stmt><expr><name>querytype</name> <operator>=</operator> <name>TYPE_HTTPS</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>querytype</name> <operator>=</operator> <name>TYPE_OTHER</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="line">// Check domain name received from dnsmasq</comment>
	<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>check_dnsmasq_name</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// If domain is "pi.hole" or the local hostname we skip analyzing this query</comment>
	<comment type="line">// and, instead, immediately reply with the IP address - these queries are not further analyzed</comment>
	<if_stmt><if>if<condition>(<expr><call><name>is_pihole_domain</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name>querytype</name> <operator>==</operator> <name>TYPE_A</name> <operator>||</operator> <name>querytype</name> <operator>==</operator> <name>TYPE_AAAA</name> <operator>||</operator> <name>querytype</name> <operator>==</operator> <name>TYPE_ANY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// "Block" this query by sending the interface IP address</comment>
			<comment type="line">// Send NODATA when the current interface doesn't have</comment>
			<comment type="line">// the requested IP address, for instance AAAA on an</comment>
			<comment type="line">// virtual interface that has only an IPv4 address</comment>
			<if_stmt><if>if<condition>(<expr><operator>(</operator><name>querytype</name> <operator>==</operator> <name>TYPE_A</name> <operator>&amp;&amp;</operator>
			    <operator>!</operator><name><name>next_iface</name><operator>.</operator><name>haveIPv4</name></name> <operator>&amp;&amp;</operator>
			    <operator>!</operator><name><name>config</name><operator>.</operator><name>reply_addr</name><operator>.</operator><name>own_host</name><operator>.</operator><name>overwrite_v4</name></name><operator>)</operator> <operator>||</operator>
			   <operator>(</operator><name>querytype</name> <operator>==</operator> <name>TYPE_AAAA</name> <operator>&amp;&amp;</operator>
			    <operator>!</operator><name><name>next_iface</name><operator>.</operator><name>haveIPv6</name></name> <operator>&amp;&amp;</operator>
			    <operator>!</operator><name><name>config</name><operator>.</operator><name>reply_addr</name><operator>.</operator><name>own_host</name><operator>.</operator><name>overwrite_v6</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>force_next_DNS_reply</name> <operator>=</operator> <name>REPLY_NODATA</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>force_next_DNS_reply</name> <operator>=</operator> <name>REPLY_IP</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>blockingreason</name> <operator>=</operator> <name>HOSTNAME</name></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Replying to %s with %s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>,
				     <argument><expr><ternary><condition><expr><name>force_next_DNS_reply</name> <operator>==</operator> <name>REPLY_IP</name></expr> ?</condition><then>
				       <expr><literal type="string">"interface-local IP address"</literal></expr> </then><else>:
				       <expr><literal type="string">"NODATA due to missing iface address"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="line">// Don't block this query</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Check if this is a PTR request for a local interface.</comment>
	<comment type="line">// If so, we inject a "pi.hole" reply here</comment>
	<if_stmt><if>if<condition>(<expr><name>querytype</name> <operator>==</operator> <name>TYPE_PTR</name> <operator>&amp;&amp;</operator> <name><name>config</name><operator>.</operator><name>pihole_ptr</name></name> <operator>!=</operator> <name>PTR_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_pihole_PTR</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Skip AAAA queries if user doesn't want to have them analyzed</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>config</name><operator>.</operator><name>analyze_AAAA</name></name> <operator>&amp;&amp;</operator> <name>querytype</name> <operator>==</operator> <name>TYPE_AAAA</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Not analyzing AAAA query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Convert domain to lower case</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>domainString</name> <init>= <expr><call><name>strdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>strtolower</name><argument_list>(<argument><expr><name>domainString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Get client IP address</comment>
	<comment type="line">// The requestor's IP address can be rewritten using EDNS(0) client</comment>
	<comment type="line">// subnet (ECS) data), however, we do not rewrite the IPs ::1 and</comment>
	<comment type="line">// 127.0.0.1 to avoid queries originating from localhost of the</comment>
	<comment type="line">// *distant* machine as queries coming from the *local* machine</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>sa_family_t</name></type> <name>family</name> <init>= <expr><ternary><condition><expr><name>addr</name></expr> ?</condition><then> <expr><name><name>addr</name><operator>-&gt;</operator><name>sa</name><operator>.</operator><name>sa_family</name></name></expr> </then><else>: <expr><name>AF_INET</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>in_port_t</name></type> <name>clientPort</name> <init>= <expr><name><name>daemon</name><operator>-&gt;</operator><name>port</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>internal_query</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>clientIP</name><index>[<expr><name>ADDRSTRLEN</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>edns0_ecs</name></name> <operator>&amp;&amp;</operator> <name>edns</name> <operator>&amp;&amp;</operator> <name><name>edns</name><operator>-&gt;</operator><name>client_set</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Use ECS provided client</comment>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>clientIP</name></expr></argument>, <argument><expr><name><name>edns</name><operator>-&gt;</operator><name>client</name></name></expr></argument>, <argument><expr><name>ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>clientIP</name><index>[<expr><name>ADDRSTRLEN</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name>addr</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Use original requestor</comment>
		<expr_stmt><expr><call><name>mysockaddr_extract_ip_port</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>clientIP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>clientPort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="line">// No client address available, this is an automatically generated (e.g.</comment>
		<comment type="line">// DNSSEC) query</comment>
		<expr_stmt><expr><name>internal_query</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>clientIP</name></expr></argument>, <argument><expr><literal type="string">"::"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="line">// Check if user wants to skip queries coming from localhost</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>ignore_localhost</name></name> <operator>&amp;&amp;</operator>
	   <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>clientIP</name></expr></argument>, <argument><expr><literal type="string">"127.0.0.1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>clientIP</name></expr></argument>, <argument><expr><literal type="string">"::1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>domainString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Lock shared memory</comment>
	<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>queryID</name> <init>= <expr><name><name>counters</name><operator>-&gt;</operator><name>queries</name></name></expr></init></decl>;</decl_stmt>

	<comment type="line">// Find client IP</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>clientID</name> <init>= <expr><call><name>findClientID</name><argument_list>(<argument><expr><name>clientIP</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Get client pointer</comment>
	<decl_stmt><decl><type><name>clientsData</name><modifier>*</modifier></type> <name>client</name> <init>= <expr><call><name>getClient</name><argument_list>(<argument><expr><name>clientID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>client</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Encountered memory error, skip query</comment>
		<comment type="line">// Free allocated memory</comment>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>domainString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// Release thread lock</comment>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Interface name is only available for regular queries, not for</comment>
	<comment type="line">// automatically generated DNSSEC queries</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>interface</name> <init>= <expr><ternary><condition><expr><name>internal_query</name></expr> ?</condition><then> <expr><literal type="string">"-"</literal></expr> </then><else>: <expr><name><name>next_iface</name><operator>.</operator><name>name</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<comment type="line">// Check rate-limit for this client</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>internal_query</name> <operator>&amp;&amp;</operator> <name><name>config</name><operator>.</operator><name>rate_limit</name><operator>.</operator><name>count</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
	   <operator>(</operator><operator>++</operator><name><name>client</name><operator>-&gt;</operator><name>rate_limit</name></name> <operator>&gt;</operator> <name><name>config</name><operator>.</operator><name>rate_limit</name><operator>.</operator><name>count</name></name>  <operator>||</operator> <name><name>client</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>rate_limited</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>client</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>rate_limited</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// Log the first rate-limited query for this client in</comment>
			<comment type="line">// this interval. We do not log the blocked domain for</comment>
			<comment type="line">// privacy reasons</comment>
			<expr_stmt><expr><call><name>logg_rate_limit_message</name><argument_list>(<argument><expr><name>clientIP</name></expr></argument>, <argument><expr><name><name>client</name><operator>-&gt;</operator><name>rate_limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="line">// Reset rate-limiting counter so we can count what</comment>
			<comment type="line">// comes within the adjacent interval</comment>
			<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>rate_limit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Memorize this client needs rate-limiting</comment>
		<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>rate_limited</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="line">// Block this query</comment>
		<expr_stmt><expr><name>force_next_DNS_reply</name> <operator>=</operator> <name>REPLY_REFUSED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>blockingreason</name> <operator>=</operator> <literal type="string">"Rate-limiting"</literal></expr>;</expr_stmt>

		<comment type="line">// Free allocated memory</comment>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>domainString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Do not further process this query, Pi-hole has never seen it</comment>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Log new query if in debug mode</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><call><name>querystr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>qtype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"**** new %sIPv%d %s query \"%s\" from %s/%s#%d (ID %i, FTL %i, %s:%i)"</literal></expr></argument>,
		     <argument><expr><ternary><condition><expr><name>proto</name> <operator>==</operator> <name>TCP</name></expr> ?</condition><then> <expr><literal type="string">"TCP "</literal></expr> </then><else>: <expr><ternary><condition><expr><name>proto</name> <operator>==</operator> <name>UDP</name></expr> ?</condition><then> <expr><literal type="string">"UDP "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></else></ternary></expr></argument>,
		     <argument><expr><ternary><condition><expr><name>family</name> <operator>==</operator> <name>AF_INET</name></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">6</literal></expr></else></ternary></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>domainString</name></expr></argument>, <argument><expr><name>interface</name></expr></argument>,
		     <argument><expr><ternary><condition><expr><name>internal_query</name></expr> ?</condition><then> <expr><literal type="string">"&lt;internal&gt;"</literal></expr> </then><else>: <expr><name>clientIP</name></expr></else></ternary></expr></argument>, <argument><expr><name>clientPort</name></expr></argument>,
		     <argument><expr><name>id</name></expr></argument>, <argument><expr><name>queryID</name></expr></argument>, <argument><expr><call><name>short_path</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Update overTime</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>timeidx</name> <init>= <expr><call><name>getOverTimeID</name><argument_list>(<argument><expr><name>querytimestamp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Skip rest of the analysis if this query is not of type A or AAAA</comment>
	<comment type="line">// but user wants to see only A and AAAA queries (pre-v4.1 behavior)</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>analyze_only_A_AAAA</name></name> <operator>&amp;&amp;</operator> <name>querytype</name> <operator>!=</operator> <name>TYPE_A</name> <operator>&amp;&amp;</operator> <name>querytype</name> <operator>!=</operator> <name>TYPE_AAAA</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Don't process this query further here, we already counted it</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><call><name>querystr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>qtype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Notice: Skipping new query: %s (%i)"</literal></expr></argument>, <argument><expr><name>types</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>domainString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Go through already knows domains and see if it is one of them</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>domainID</name> <init>= <expr><call><name>findDomainID</name><argument_list>(<argument><expr><name>domainString</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Save everything</comment>
	<decl_stmt><decl><type><name>queriesData</name><modifier>*</modifier></type> <name>query</name> <init>= <expr><call><name>getQuery</name><argument_list>(<argument><expr><name>queryID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>query</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Encountered memory error, skip query</comment>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"WARN: No memory available, skipping query analysis"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// Free allocated memory</comment>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>domainString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// Release thread lock</comment>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Fill query object with available data</comment>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>MAGICBYTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>timestamp</name></name> <operator>=</operator> <name>querytimestamp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>querytype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>qtype</name></name> <operator>=</operator> <name>qtype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt> <comment type="line">// Has to be set before calling query_set_status()</comment>

	<comment type="line">// This query is unknown as long as no reply has been found and analyzed</comment>
	<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>status</name><index>[<expr><name>QUERY_UNKNOWN</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>query_set_status</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>QUERY_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>domainID</name></name> <operator>=</operator> <name>domainID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>clientID</name></name> <operator>=</operator> <name>clientID</name></expr>;</expr_stmt>
	<comment type="line">// Initialize database field, will be set when the query is stored in the long-term DB</comment>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>database</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>complete</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>response</name></name> <operator>=</operator> <call><name>converttimeval</name><argument_list>(<argument><expr><name>request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>response_calculated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="line">// Initialize reply type</comment>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <name>REPLY_UNKNOWN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>reply</name><index>[<expr><name>REPLY_UNKNOWN</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
	<comment type="line">// Store DNSSEC result for this domain</comment>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>dnssec</name></name> <operator>=</operator> <name>DNSSEC_UNSPECIFIED</name></expr>;</expr_stmt>
	<comment type="line">// Every domain is insecure in the beginning. It can get secure or bogus</comment>
	<comment type="line">// only if validation reveals this. If DNSSEC validation is not used, the</comment>
	<comment type="line">// original status (DNSSEC_UNSPECIFIED) is not changed.</comment>
	<expr_stmt><expr><call><name>query_set_dnssec</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>DNSSEC_INSECURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>CNAME_domainID</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<comment type="line">// This query is not yet known ad forwarded or blocked</comment>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>blocked</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>whitelisted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="line">// Indicator that this query was not forwarded so far</comment>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>upstreamID</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="line">// Check and apply possible privacy level rules</comment>
	<comment type="line">// The currently set privacy level (at the time the query is</comment>
	<comment type="line">// generated) is stored in the queries structure</comment>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>privacylevel</name></name> <operator>=</operator> <name><name>config</name><operator>.</operator><name>privacylevel</name></name></expr>;</expr_stmt>

	<comment type="line">// Query extended DNS error</comment>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>ede</name></name> <operator>=</operator> <name>EDE_UNSET</name></expr>;</expr_stmt>

	<comment type="line">// Increase DNS queries counter</comment>
	<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>queries</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="line">// Update overTime data</comment>
	<expr_stmt><expr><name><name>overTime</name><index>[<expr><name>timeidx</name></expr>]</index></name><operator>.</operator><name>total</name><operator>++</operator></expr>;</expr_stmt>

	<comment type="line">// Update overTime data structure with the new client</comment>
	<expr_stmt><expr><call><name>change_clientcount</name><argument_list>(<argument><expr><name>client</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>timeidx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Set lastQuery timer and add one query for network table</comment>
	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>lastQuery</name></name> <operator>=</operator> <name>querytimestamp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>numQueriesARP</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="line">// Update counters</comment>
	<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>querytype</name><index>[<expr><name>querytype</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="line">// Process interface information of client (if available)</comment>
	<comment type="line">// Skip interface name length 1 to skip "-". No real interface should</comment>
	<comment type="line">// have a name with a length of 1...</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>internal_query</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>interface</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>ifacepos</name></name> <operator>==</operator> <literal type="number">0u</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// Store in the client data if unknown so far</comment>
			<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>ifacepos</name></name> <operator>=</operator> <call><name>addstr</name><argument_list>(<argument><expr><name>interface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="line">// Check if this is still the same interface or</comment>
			<comment type="line">// if the client moved to another interface</comment>
			<comment type="line">// (may require group re-processing)</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldiface</name> <init>= <expr><call><name>getstr</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>ifacepos</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>oldiface</name></expr></argument>, <argument><expr><name>interface</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_CLIENTS</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>clientName</name> <init>= <expr><call><name>getstr</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>namepos</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Client %s (%s) changed interface: %s -&gt; %s"</literal></expr></argument>,
					     <argument><expr><name>clientIP</name></expr></argument>, <argument><expr><name>clientName</name></expr></argument>, <argument><expr><name>oldiface</name></expr></argument>, <argument><expr><name>interface</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>gravityDB_reload_groups</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Set client MAC address from EDNS(0) information (if available)</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>edns0_ecs</name></name> <operator>&amp;&amp;</operator> <name>edns</name> <operator>&amp;&amp;</operator> <name><name>edns</name><operator>-&gt;</operator><name>mac_set</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>hwaddr</name></name></expr></argument>, <argument><expr><name><name>edns</name><operator>-&gt;</operator><name>mac_byte</name></name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>hwlen</name></name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Try to obtain MAC address from dnsmasq's cache (also asks the kernel)</comment>
	<if_stmt><if>if<condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>hwlen</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>hwlen</name></name> <operator>=</operator> <call><name>find_mac</name><argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>client</name><operator>-&gt;</operator><name>hwaddr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_ARP</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>hwlen</name></name> <operator>==</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"find_mac(\"%s\") returned hardware address "</literal>
				     <literal type="string">"%02X:%02X:%02X:%02X:%02X:%02X"</literal></expr></argument>, <argument><expr><name>clientIP</name></expr></argument>,
				     <argument><expr><name><name>client</name><operator>-&gt;</operator><name>hwaddr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>client</name><operator>-&gt;</operator><name>hwaddr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>client</name><operator>-&gt;</operator><name>hwaddr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				     <argument><expr><name><name>client</name><operator>-&gt;</operator><name>hwaddr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>client</name><operator>-&gt;</operator><name>hwaddr</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>client</name><operator>-&gt;</operator><name>hwaddr</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"find_mac(\"%s\") returned %i bytes of data"</literal></expr></argument>,
				     <argument><expr><name>clientIP</name></expr></argument>, <argument><expr><name><name>client</name><operator>-&gt;</operator><name>hwlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>blockDomain</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<comment type="line">// Check if this should be blocked only for active queries</comment>
	<comment type="line">// (skipped for internally generated ones, e.g., DNSSEC)</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>internal_query</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>blockDomain</name> <operator>=</operator> <call><name>FTL_check_blocking</name><argument_list>(<argument><expr><name>queryID</name></expr></argument>, <argument><expr><name>domainID</name></expr></argument>, <argument><expr><name>clientID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Free allocated memory</comment>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>domainString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Release thread lock</comment>
	<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>blockDomain</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_FTL_iface</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>irec</name></name> <modifier>*</modifier></type><name>recviface</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>union</name> <name>all_addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>sa_family_t</name></type> <name>addrfamily</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Invalidate data we have from the last interface/query</comment>
	<comment type="line">// Set addresses to 0.0.0.0 and ::, respectively</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>next_iface</name><operator>.</operator><name>addr4</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>next_iface</name><operator>.</operator><name>addr4</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>next_iface</name><operator>.</operator><name>addr6</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>next_iface</name><operator>.</operator><name>addr6</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>next_iface</name><operator>.</operator><name>haveIPv4</name></name> <operator>=</operator> <name><name>next_iface</name><operator>.</operator><name>haveIPv6</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="line">// Debug logging</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_NETWORKING</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Interfaces: Called from %s:%d"</literal></expr></argument>, <argument><expr><call><name>short_path</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Use dummy when interface record is not available</comment>
	<expr_stmt><expr><name><name>next_iface</name><operator>.</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>next_iface</name><operator>.</operator><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="line">// Check if we need to identify the receiving interface by its address</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>recviface</name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&amp;&amp;</operator>
	   <operator>(</operator><operator>(</operator><name>addrfamily</name> <operator>==</operator> <name>AF_INET</name> <operator>&amp;&amp;</operator> <name><name>addr</name><operator>-&gt;</operator><name>addr4</name><operator>.</operator><name>s_addr</name></name> <operator>!=</operator> <name>INADDR_ANY</name><operator>)</operator> <operator>||</operator>
	    <operator>(</operator><name>addrfamily</name> <operator>==</operator> <name>AF_INET6</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IN6_IS_ADDR_UNSPECIFIED</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>addr</name><operator>-&gt;</operator><name>addr6</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_NETWORKING</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type> <name><name>addrstr</name><index>[<expr><name>INET6_ADDRSTRLEN</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><name>addrfamily</name> <operator>==</operator> <name>AF_INET</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name>AF_INET</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>addr</name><operator>-&gt;</operator><name>addr4</name></name></expr></argument>, <argument><expr><name>addrstr</name></expr></argument>, <argument><expr><name>INET6_ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content> <comment type="line">// if(addrfamily == AF_INET6)</comment>
				<expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name>AF_INET6</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>addr</name><operator>-&gt;</operator><name>addr6</name></name></expr></argument>, <argument><expr><name>addrstr</name></expr></argument>, <argument><expr><name>INET6_ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Identifying interface (looking for %s):"</literal></expr></argument>, <argument><expr><name>addrstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Loop over interfaces and try to find match</comment>
		<for>for <control>(<init><decl><type><name><name>struct</name> <name>irec</name></name> <modifier>*</modifier><name>iface</name></type> <init>= <expr><name><name>daemon</name><operator>-&gt;</operator><name>interfaces</name></name></expr></init></decl>;</init> <condition><expr><name>iface</name></expr>;</condition> <incr><expr><name>iface</name> <operator>=</operator> <name><name>iface</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type> <name><name>addrstr</name><index>[<expr><name>INET6_ADDRSTRLEN</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>iname</name> <init>= <expr><ternary><condition><expr><name><name>iface</name><operator>-&gt;</operator><name>slabel</name></name></expr> ?</condition><then> <expr><name><name>iface</name><operator>-&gt;</operator><name>slabel</name></name></expr> </then><else>: <expr><name><name>iface</name><operator>-&gt;</operator><name>name</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>sa</name><operator>.</operator><name>sa_family</name></name> <operator>==</operator> <name>AF_INET</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name>AF_INET</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in</name><operator>.</operator><name>sin_addr</name></name></expr></argument>, <argument><expr><name>addrstr</name></expr></argument>, <argument><expr><name>INET6_ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_NETWORKING</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"  - IPv4 interface %s (%d,%d) is %s"</literal></expr></argument>,
					     <argument><expr><name>iname</name></expr></argument>, <argument><expr><name><name>iface</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>iface</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name>addrstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if<condition>(<expr><name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in</name><operator>.</operator><name>sin_addr</name><operator>.</operator><name>s_addr</name></name> <operator>==</operator> <name><name>addr</name><operator>-&gt;</operator><name>addr4</name><operator>.</operator><name>s_addr</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="line">// Set receiving interface</comment>
					<expr_stmt><expr><name>recviface</name> <operator>=</operator> <name>iface</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if<condition>(<expr><name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>sa</name><operator>.</operator><name>sa_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name>AF_INET6</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in6</name><operator>.</operator><name>sin6_addr</name></name></expr></argument>, <argument><expr><name>addrstr</name></expr></argument>, <argument><expr><name>INET6_ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_NETWORKING</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"  - IPv6 interface %s (%d,%d) is %s"</literal></expr></argument>,
					     <argument><expr><name>iname</name></expr></argument>, <argument><expr><name><name>iface</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>iface</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name>addrstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if<condition>(<expr><call><name>IN6_ARE_ADDR_EQUAL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in6</name><operator>.</operator><name>sin6_addr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>addr</name><operator>-&gt;</operator><name>addr6</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="line">// Set receiving interface</comment>
					<expr_stmt><expr><name>recviface</name> <operator>=</operator> <name>iface</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_NETWORKING</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name>recviface</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"    ^^^ MATCH ^^^"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"    --&gt; NO MATCH &lt;--"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Return early when there is no interface available at this point</comment>
	<comment type="line">// This means we didn't get one passed + we didn't find one above</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>recviface</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_NETWORKING</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"No receiving interface available at this point"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Determine addresses of this interface, we have to loop over all interfaces as</comment>
	<comment type="line">// recviface will always only contain *either* IPv4 or IPv6 information</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>haveGUAv6</name> <init>= <expr><name>false</name></expr></init></decl>, <decl><type ref="prev"/><name>haveULAv6</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_NETWORKING</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Analyzing interfaces:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<for>for <control>(<init><decl><type><name><name>struct</name> <name>irec</name></name> <modifier>*</modifier><name>iface</name></type> <init>= <expr><name><name>daemon</name><operator>-&gt;</operator><name>interfaces</name></name></expr></init></decl>;</init> <condition><expr><name>iface</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>iface</name> <operator>=</operator> <name><name>iface</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>sa_family_t</name></type> <name>family</name> <init>= <expr><name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>sa</name><operator>.</operator><name>sa_family</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>iname</name> <init>= <expr><ternary><condition><expr><name><name>iface</name><operator>-&gt;</operator><name>slabel</name></name></expr> ?</condition><then> <expr><name><name>iface</name><operator>-&gt;</operator><name>slabel</name></name></expr> </then><else>: <expr><name><name>iface</name><operator>-&gt;</operator><name>name</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<comment type="line">// If this interface has no name, we skip it</comment>
		<if_stmt><if>if<condition>(<expr><name>iname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_NETWORKING</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"  - SKIP IPv%d interface (%d,%d): no name"</literal></expr></argument>,
				     <argument><expr><ternary><condition><expr><name>family</name> <operator>==</operator> <name>AF_INET</name></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">6</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>iface</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>iface</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Check if this is the interface we want</comment>
		<if_stmt><if>if<condition>(<expr><name><name>iface</name><operator>-&gt;</operator><name>index</name></name> <operator>!=</operator> <name><name>recviface</name><operator>-&gt;</operator><name>index</name></name> <operator>||</operator> <name><name>iface</name><operator>-&gt;</operator><name>label</name></name> <operator>!=</operator> <name><name>recviface</name><operator>-&gt;</operator><name>label</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_NETWORKING</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"  - SKIP IPv%d interface %s: (%d,%d) != (%d,%d)"</literal></expr></argument>,
				     <argument><expr><ternary><condition><expr><name>family</name> <operator>==</operator> <name>AF_INET</name></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">6</literal></expr></else></ternary></expr></argument>, <argument><expr><name>iname</name></expr></argument>, <argument><expr><name><name>iface</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>iface</name><operator>-&gt;</operator><name>label</name></name></expr></argument>,
				     <argument><expr><name><name>recviface</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>recviface</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// *** If we reach this point, we know this interface is the one we are looking for ***//</comment>

		<comment type="line">// Copy interface name</comment>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>next_iface</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>iname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>next_iface</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>next_iface</name><operator>.</operator><name>name</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>next_iface</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>bool</name></type> <name>isULA</name> <init>= <expr><name>false</name></expr></init></decl>, <decl><type ref="prev"/><name>isGUA</name> <init>= <expr><name>false</name></expr></init></decl>, <decl><type ref="prev"/><name>isLL</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<comment type="line">// Check if this address is different from 0000:0000:0000:0000:0000:0000:0000:0000</comment>
		<if_stmt><if>if<condition>(<expr><name>family</name> <operator>==</operator> <name>AF_INET6</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>next_iface</name><operator>.</operator><name>addr6</name><operator>.</operator><name>addr6</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in6</name><operator>.</operator><name>sin6_addr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in6</name><operator>.</operator><name>sin6_addr</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// Extract first byte</comment>
			<comment type="line">// We do not directly access the underlying union as</comment>
			<comment type="line">// MUSL defines it differently than GNU C</comment>
			<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>bytes</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bytes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in6</name><operator>.</operator><name>sin6_addr</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		        <comment type="line">// Global Unicast Address (2000::/3, RFC 4291)</comment>
			<expr_stmt><expr><name>isGUA</name> <operator>=</operator> <operator>(</operator><name><name>bytes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x70</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x20</literal></expr>;</expr_stmt>
			<comment type="line">// Unique Local Address   (fc00::/7, RFC 4193)</comment>
			<expr_stmt><expr><name>isULA</name> <operator>=</operator> <operator>(</operator><name><name>bytes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xfe</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xfc</literal></expr>;</expr_stmt>
			<comment type="line">// Link Local Address   (fe80::/10, RFC 4291)</comment>
			<expr_stmt><expr><name>isLL</name> <operator>=</operator> <operator>(</operator><name><name>bytes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xfe</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>bytes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x30</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<comment type="line">// Store IPv6 address only if we don't already have a GUA or ULA address</comment>
			<comment type="line">// This makes the preference:</comment>
			<comment type="line">//  1. ULA</comment>
			<comment type="line">//  2. GUA</comment>
			<comment type="line">//  3. Link-local</comment>
			<if_stmt><if>if<condition>(<expr><operator>(</operator><operator>!</operator><name>haveGUAv6</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>haveULAv6</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>haveGUAv6</name> <operator>&amp;&amp;</operator> <name>isULA</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>next_iface</name><operator>.</operator><name>haveIPv6</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="line">// Store IPv6 address</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>next_iface</name><operator>.</operator><name>addr6</name><operator>.</operator><name>addr6</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in6</name><operator>.</operator><name>sin6_addr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in6</name><operator>.</operator><name>sin6_addr</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if<condition>(<expr><name>isGUA</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>haveGUAv6</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if<condition>(<expr><name>isULA</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>haveULAv6</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<comment type="line">// Check if this address is different from 0.0.0.0</comment>
		<if type="elseif">else if<condition>(<expr><name>family</name> <operator>==</operator> <name>AF_INET</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>next_iface</name><operator>.</operator><name>addr4</name><operator>.</operator><name>addr4</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in</name><operator>.</operator><name>sin_addr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in</name><operator>.</operator><name>sin_addr</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>next_iface</name><operator>.</operator><name>haveIPv4</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="line">// Store IPv4 address</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>next_iface</name><operator>.</operator><name>addr4</name><operator>.</operator><name>addr4</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in</name><operator>.</operator><name>sin_addr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in</name><operator>.</operator><name>sin_addr</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Debug logging</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_NETWORKING</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>ADDRSTRLEN</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><name>family</name> <operator>==</operator> <name>AF_INET</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name>AF_INET</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in</name><operator>.</operator><name>sin_addr</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if<condition>(<expr><name>family</name> <operator>==</operator> <name>AF_INET6</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name>AF_INET6</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in6</name><operator>.</operator><name>sin6_addr</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><ternary><condition><expr><name>family</name> <operator>==</operator> <name>AF_INET6</name></expr> ?</condition><then> <expr><ternary><condition><expr><name>isGUA</name></expr> ?</condition><then> <expr><literal type="string">" (GUA)"</literal></expr> </then><else>: <expr><ternary><condition><expr><name>isULA</name></expr> ?</condition><then> <expr><literal type="string">" (ULA)"</literal></expr> </then><else>: <expr><ternary><condition><expr><name>isLL</name></expr> ?</condition><then> <expr><literal type="string">" (LL)"</literal></expr> </then><else>: <expr><literal type="string">" (other)"</literal></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"  -  OK  IPv%d interface %s: (%d,%d) is %s%s"</literal></expr></argument>,
			     <argument><expr><ternary><condition><expr><name>family</name> <operator>==</operator> <name>AF_INET</name></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">6</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>next_iface</name><operator>.</operator><name>name</name></name></expr></argument>,
			     <argument><expr><name><name>iface</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name><name>iface</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Exit loop early if we already have everything we need</comment>
		<comment type="line">// (a valid IPv4 address + a valid ULA IPv6 address)</comment>
		<if_stmt><if>if<condition>(<expr><name><name>next_iface</name><operator>.</operator><name>haveIPv4</name></name> <operator>&amp;&amp;</operator> <name>haveULAv6</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_NETWORKING</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Exiting interface analysis early (have IPv4 + ULAv6)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>check_pihole_PTR</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>domain</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Return early if Pi-hole PTR is not available</comment>
	<if_stmt><if>if<condition>(<expr><name>pihole_ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="line">// Convert PTR request into numeric form</comment>
	<decl_stmt><decl><type><name><name>union</name> <name>all_addr</name></name></type> <name>addr</name> <init>= <expr><block>{<expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>flags</name> <init>= <expr><call><name>in_arpa_name_2_addr</name><argument_list>(<argument><expr><name>domain</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Check if this is a valid in-addr.arpa (IPv4) or ip6.[int|arpa] (IPv6)</comment>
	<comment type="line">// specifier. If not, nothing is to be done here and we return early</comment>
	<if_stmt><if>if<condition>(<expr><name>flags</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="line">// We do not want to reply with "pi.hole" to loopback PTRs</comment>
	<if_stmt><if>if<condition>(<expr><operator>(</operator><name>flags</name> <operator>==</operator> <name>F_IPV4</name> <operator>&amp;&amp;</operator> <name><name>addr</name><operator>.</operator><name>addr4</name><operator>.</operator><name>s_addr</name></name> <operator>==</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>INADDR_LOOPBACK</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
	   <operator>(</operator><name>flags</name> <operator>==</operator> <name>F_IPV6</name> <operator>&amp;&amp;</operator> <call><name>IN6_IS_ADDR_LOOPBACK</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>addr</name><operator>.</operator><name>addr6</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="line">// If we reached this point, addr contains the address the client requested</comment>
	<comment type="line">// a name for. We compare this address against all addresses of the local</comment>
	<comment type="line">// interfaces to see if we should reply with "pi.hole"</comment>
	<for>for <control>(<init><decl><type><name><name>struct</name> <name>irec</name></name> <modifier>*</modifier><name>iface</name></type> <init>= <expr><name><name>daemon</name><operator>-&gt;</operator><name>interfaces</name></name></expr></init></decl>;</init> <condition><expr><name>iface</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>iface</name> <operator>=</operator> <name><name>iface</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>sa_family_t</name></type> <name>family</name> <init>= <expr><name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>sa</name><operator>.</operator><name>sa_family</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><operator>(</operator><name>family</name> <operator>==</operator> <name>AF_INET</name> <operator>&amp;&amp;</operator> <name>flags</name> <operator>==</operator> <name>F_IPV4</name> <operator>&amp;&amp;</operator> <name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in</name><operator>.</operator><name>sin_addr</name><operator>.</operator><name>s_addr</name></name> <operator>==</operator> <name><name>addr</name><operator>.</operator><name>addr4</name><operator>.</operator><name>s_addr</name></name><operator>)</operator> <operator>||</operator>
		   <operator>(</operator><name>family</name> <operator>==</operator> <name>AF_INET6</name> <operator>&amp;&amp;</operator> <name>flags</name> <operator>==</operator> <name>F_IPV6</name> <operator>&amp;&amp;</operator> <call><name>IN6_ARE_ADDR_EQUAL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in6</name><operator>.</operator><name>sin6_addr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>addr</name><operator>.</operator><name>addr6</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// The last PTR record in daemon-&gt;ptr is reserved for Pi-hole</comment>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pihole_ptr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pihole_ptr</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>domain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name>family</name> <operator>==</operator> <name>AF_INET</name></expr>)</condition>
			<block>{<block_content>
				<comment type="line">// IPv4 supports conditional domains</comment>
				<decl_stmt><decl><type><name><name>struct</name> <name>in_addr</name></name></type> <name>addrv4</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>addrv4</name><operator>.</operator><name>s_addr</name></name> <operator>=</operator> <name><name>iface</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in</name><operator>.</operator><name>sin_addr</name><operator>.</operator><name>s_addr</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pihole_ptr</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>get_ptrname</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addrv4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="line">// IPv6 does not support conditional domains</comment>
				<expr_stmt><expr><name><name>pihole_ptr</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>get_ptrname</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="line">// Debug logging</comment>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Generating PTR response: %s -&gt; %s"</literal></expr></argument>, <argument><expr><name><name>pihole_ptr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>pihole_ptr</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <specifier>static</specifier> <name>void</name></type> <name>set_dnscache_blockingstatus</name><parameter_list>(<parameter><decl><type><name>DNSCacheData</name> <modifier>*</modifier></type> <name>dns_cache</name></decl></parameter>, <parameter><decl><type><name>clientsData</name> <modifier>*</modifier></type><name>client</name></decl></parameter>,
                                               <parameter><decl><type><name><name>enum</name> <name>domain_client_status</name></name></type> <name>new_status</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>domain</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Memorize blocking status DNS cache for the domain/client combination</comment>
	<expr_stmt><expr><name><name>dns_cache</name><operator>-&gt;</operator><name>blocking_status</name></name> <operator>=</operator> <name>new_status</name></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>clientip</name> <init>= <expr><ternary><condition><expr><name>client</name></expr> ?</condition><then> <expr><call><name>getstr</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>ippos</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"N/A"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"DNS cache: %s/%s is %s"</literal></expr></argument>, <argument><expr><name>clientip</name></expr></argument>, <argument><expr><name>domain</name></expr></argument>, <argument><expr><name>blockingreason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>check_domain_blocked</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>domain</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>clientID</name></decl></parameter>,
                                 <parameter><decl><type><name>clientsData</name> <modifier>*</modifier></type><name>client</name></decl></parameter>, <parameter><decl><type><name>queriesData</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>DNSCacheData</name> <modifier>*</modifier></type><name>dns_cache</name></decl></parameter>,
                                 <parameter><decl><type><name><name>enum</name> <name>query_status</name></name> <modifier>*</modifier></type><name>new_status</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>db_okay</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Return early if this domain is explicitly allowed</comment>
	<if_stmt><if>if<condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>whitelisted</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// Check domains against exact blacklist</comment>
	<decl_stmt><decl><type><name><name>enum</name> <name>db_result</name></name></type> <name>blacklist</name> <init>= <expr><call><name>in_blacklist</name><argument_list>(<argument><expr><name>domain</name></expr></argument>, <argument><expr><name>dns_cache</name></expr></argument>, <argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>blacklist</name> <operator>==</operator> <name>FOUND</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Set new status</comment>
		<expr_stmt><expr><operator>*</operator><name>new_status</name> <operator>=</operator> <name>QUERY_BLACKLIST</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>blockingreason</name> <operator>=</operator> <literal type="string">"exactly blacklisted"</literal></expr>;</expr_stmt>

		<comment type="line">// Mark domain as exactly blacklisted for this client</comment>
		<expr_stmt><expr><call><name>set_dnscache_blockingstatus</name><argument_list>(<argument><expr><name>dns_cache</name></expr></argument>, <argument><expr><name>client</name></expr></argument>, <argument><expr><name>BLACKLIST_BLOCKED</name></expr></argument>, <argument><expr><name>domain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// We block this domain</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Check domains against gravity domains</comment>
	<decl_stmt><decl><type><name><name>enum</name> <name>db_result</name></name></type> <name>gravity</name> <init>= <expr><call><name>in_gravity</name><argument_list>(<argument><expr><name>domain</name></expr></argument>, <argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>gravity</name> <operator>==</operator> <name>FOUND</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Set new status</comment>
		<expr_stmt><expr><operator>*</operator><name>new_status</name> <operator>=</operator> <name>QUERY_GRAVITY</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>blockingreason</name> <operator>=</operator> <literal type="string">"gravity blocked"</literal></expr>;</expr_stmt>

		<comment type="line">// Mark domain as gravity blocked for this client</comment>
		<expr_stmt><expr><call><name>set_dnscache_blockingstatus</name><argument_list>(<argument><expr><name>dns_cache</name></expr></argument>, <argument><expr><name>client</name></expr></argument>, <argument><expr><name>GRAVITY_BLOCKED</name></expr></argument>, <argument><expr><name>domain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// We block this domain</comment>
		<return>return <expr><name>FOUND</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Check if one of the database lookups returned that the database is</comment>
	<comment type="line">// currently busy</comment>
	<if_stmt><if>if<condition>(<expr><name>blacklist</name> <operator>==</operator> <name>LIST_NOT_AVAILABLE</name> <operator>||</operator> <name>gravity</name> <operator>==</operator> <name>LIST_NOT_AVAILABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>db_okay</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<comment type="line">// Handle reply to this query as configured</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>reply_when_busy</name></name> <operator>==</operator> <name>BUSY_ALLOW</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Allowing query as gravity database is not available"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="line">// Permit this query</comment>
			<comment type="line">// As we set db_okay to false, this allowing here does not enter the</comment>
			<comment type="line">// DNS cache so this domain will be rechecked on the next query</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if<condition>(<expr><name><name>config</name><operator>.</operator><name>reply_when_busy</name></name> <operator>==</operator> <name>BUSY_REFUSE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>blockingreason</name> <operator>=</operator> <literal type="string">"to be refused (gravity database is not available)"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>force_next_DNS_reply</name> <operator>=</operator> <name>REPLY_REFUSED</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>new_status</name> <operator>=</operator> <name>QUERY_DBBUSY</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if<condition>(<expr><name><name>config</name><operator>.</operator><name>reply_when_busy</name></name> <operator>==</operator> <name>BUSY_DROP</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>blockingreason</name> <operator>=</operator> <literal type="string">"to be dropped (gravity database is not available)"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>force_next_DNS_reply</name> <operator>=</operator> <name>REPLY_NONE</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>new_status</name> <operator>=</operator> <name>QUERY_DBBUSY</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>blockingreason</name> <operator>=</operator> <literal type="string">"to be blocked (gravity database is not available)"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>new_status</name> <operator>=</operator> <name>QUERY_DBBUSY</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="line">// We block this query</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Check domain against blacklist regex filters</comment>
	<comment type="line">// Skipped when the domain is whitelisted or blocked by exact blacklist or gravity</comment>
	<if_stmt><if>if<condition>(<expr><call><name>in_regex</name><argument_list>(<argument><expr><name>domain</name></expr></argument>, <argument><expr><name>dns_cache</name></expr></argument>, <argument><expr><name><name>client</name><operator>-&gt;</operator> <name>id</name></name></expr></argument>, <argument><expr><name>REGEX_BLACKLIST</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Set new status</comment>
		<expr_stmt><expr><operator>*</operator><name>new_status</name> <operator>=</operator> <name>QUERY_REGEX</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>blockingreason</name> <operator>=</operator> <literal type="string">"regex blacklisted"</literal></expr>;</expr_stmt>

		<comment type="line">// Mark domain as regex matched for this client</comment>
		<expr_stmt><expr><call><name>set_dnscache_blockingstatus</name><argument_list>(<argument><expr><name>dns_cache</name></expr></argument>, <argument><expr><name>client</name></expr></argument>, <argument><expr><name>REGEX_BLOCKED</name></expr></argument>, <argument><expr><name>domain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Regex may be overwriting reply type for this domain</comment>
		<if_stmt><if>if<condition>(<expr><name><name>dns_cache</name><operator>-&gt;</operator><name>force_reply</name></name> <operator>!=</operator> <name>REPLY_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>force_next_DNS_reply</name> <operator>=</operator> <name><name>dns_cache</name><operator>-&gt;</operator><name>force_reply</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="line">// Store ID of this regex (fork-private)</comment>
		<expr_stmt><expr><name>last_regex_idx</name> <operator>=</operator> <name><name>dns_cache</name><operator>-&gt;</operator><name>domainlist_id</name></name></expr>;</expr_stmt>

		<comment type="line">// We block this domain</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Not blocked because not found on any list</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Special domain checking</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>special_domain</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>queriesData</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>domain</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Mozilla canary domain</comment>
	<comment type="line">// Network administrators may configure their networks as follows to signal</comment>
	<comment type="line">// that their local DNS resolver implemented special features that make the</comment>
	<comment type="line">// network unsuitable for DoH:</comment>
	<comment type="line">// DNS queries for the A and AAAA records for the domain</comment>
	<comment type="line">// use-application-dns.net must respond with either: a response code other</comment>
	<comment type="line">// than NOERROR, such as NXDOMAIN (non-existent domain) or SERVFAIL; or</comment>
	<comment type="line">// respond with NOERROR, but return no A or AAAA records.</comment>
	<comment type="line">// https://support.mozilla.org/en-US/kb/configuring-networks-disable-dns-over-https</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>special_domains</name><operator>.</operator><name>mozilla_canary</name></name> <operator>&amp;&amp;</operator>
	   <call><name>strcasecmp</name><argument_list>(<argument><expr><name>domain</name></expr></argument>, <argument><expr><literal type="string">"use-application-dns.net"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
	   <operator>(</operator><name><name>query</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>TYPE_A</name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>TYPE_AAAA</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>blockingreason</name> <operator>=</operator> <literal type="string">"Mozilla canary domain"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>force_next_DNS_reply</name> <operator>=</operator> <name>REPLY_NXDOMAIN</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Apple iCloud Private Relay</comment>
	<comment type="line">// Some enterprise or school networks might be required to audit all</comment>
	<comment type="line">// network traffic by policy, and your network can block access to</comment>
	<comment type="line">// Private Relay in these cases. The user will be alerted that they need</comment>
	<comment type="line">// to either disable Private Relay for your network or choose another</comment>
	<comment type="line">// network.</comment>
	<comment type="line">// The fastest and most reliable way to alert users is to return a</comment>
	<comment type="line">// negative answer from your networks DNS resolver, preventing DNS</comment>
	<comment type="line">// resolution for the following hostnames used by Private Relay traffic.</comment>
	<comment type="line">// Avoid causing DNS resolution timeouts or silently dropping IP packets</comment>
	<comment type="line">// sent to the Private Relay server, as this can lead to delays on</comment>
	<comment type="line">// client devices.</comment>
	<comment type="line">// &gt; mask.icloud.com</comment>
	<comment type="line">// &gt; mask-h2.icloud.com</comment>
	<comment type="line">// https://developer.apple.com/support/prepare-your-network-for-icloud-private-relay</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>special_domains</name><operator>.</operator><name>icloud_private_relay</name></name> <operator>&amp;&amp;</operator>
	   <operator>(</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>domain</name></expr></argument>, <argument><expr><literal type="string">"mask.icloud.com"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
	    <call><name>strcasecmp</name><argument_list>(<argument><expr><name>domain</name></expr></argument>, <argument><expr><literal type="string">"mask-h2.icloud.com"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>blockingreason</name> <operator>=</operator> <literal type="string">"Apple iCloud Private Relay domain"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>force_next_DNS_reply</name> <operator>=</operator> <name>REPLY_NXDOMAIN</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>_FTL_check_blocking</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>queryID</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>domainID</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>clientID</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Only check blocking conditions when global blocking is enabled</comment>
	<if_stmt><if>if<condition>(<expr><name>blockingstatus</name> <operator>==</operator> <name>BLOCKING_DISABLED</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Get query, domain and client pointers</comment>
	<decl_stmt><decl><type><name>queriesData</name> <modifier>*</modifier></type><name>query</name>  <init>= <expr><call><name>getQuery</name><argument_list>(<argument><expr><name>queryID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>domainsData</name> <modifier>*</modifier></type><name>domain</name> <init>= <expr><call><name>getDomain</name><argument_list>(<argument><expr><name>domainID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>clientsData</name> <modifier>*</modifier></type><name>client</name> <init>= <expr><call><name>getClient</name><argument_list>(<argument><expr><name>clientID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>query</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>domain</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>client</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Error: No memory available, skipping query analysis"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Get cache pointer</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>cacheID</name> <init>= <expr><call><name>findCacheID</name><argument_list>(<argument><expr><name>domainID</name></expr></argument>, <argument><expr><name>clientID</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DNSCacheData</name> <modifier>*</modifier></type><name>dns_cache</name> <init>= <expr><call><name>getDNSCache</name><argument_list>(<argument><expr><name>cacheID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>dns_cache</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"WARN: No memory available, skipping query analysis"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Skip the entire chain of tests if we already know the answer for this</comment>
	<comment type="line">// particular client</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>blockingStatus</name> <init>= <expr><name><name>dns_cache</name><operator>-&gt;</operator><name>blocking_status</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>domainstr</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>getstr</name><argument_list>(<argument><expr><name><name>domain</name><operator>-&gt;</operator><name>domainpos</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<switch>switch<condition>(<expr><name>blockingStatus</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>UNKNOWN_BLOCKED</name></expr>:</case>
			<comment type="line">// New domain/client combination.</comment>
			<comment type="line">// We have to go through all the tests below</comment>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"%s is not known"</literal></expr></argument>, <argument><expr><name>domainstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<break>break;</break>

		<case>case <expr><name>BLACKLIST_BLOCKED</name></expr>:</case>
			<comment type="line">// Known as exactly blacklistes, we</comment>
			<comment type="line">// return this result early, skipping</comment>
			<comment type="line">// all the lengthy tests below</comment>
			<expr_stmt><expr><name>blockingreason</name> <operator>=</operator> <literal type="string">"exactly blacklisted"</literal></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"%s is known as %s"</literal></expr></argument>, <argument><expr><name>domainstr</name></expr></argument>, <argument><expr><name>blockingreason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="line">// Do not block if the entire query is to be permitted</comment>
			<comment type="line">// as something along the CNAME path hit the whitelist</comment>
			<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>whitelisted</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>force_next_DNS_reply</name> <operator>=</operator> <name><name>dns_cache</name><operator>-&gt;</operator><name>force_reply</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>query_blocked</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>domain</name></expr></argument>, <argument><expr><name>client</name></expr></argument>, <argument><expr><name>QUERY_BLACKLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>GRAVITY_BLOCKED</name></expr>:</case>
			<comment type="line">// Known as gravity blocked, we</comment>
			<comment type="line">// return this result early, skipping</comment>
			<comment type="line">// all the lengthy tests below</comment>
			<expr_stmt><expr><name>blockingreason</name> <operator>=</operator> <literal type="string">"gravity blocked"</literal></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"%s is known as %s"</literal></expr></argument>, <argument><expr><name>domainstr</name></expr></argument>, <argument><expr><name>blockingreason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="line">// Do not block if the entire query is to be permitted</comment>
			<comment type="line">// as sometving along the CNAME path hit the whitelist</comment>
			<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>whitelisted</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>force_next_DNS_reply</name> <operator>=</operator> <name><name>dns_cache</name><operator>-&gt;</operator><name>force_reply</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>query_blocked</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>domain</name></expr></argument>, <argument><expr><name>client</name></expr></argument>, <argument><expr><name>QUERY_GRAVITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>REGEX_BLOCKED</name></expr>:</case>
			<comment type="line">// Known as regex blacklisted, we</comment>
			<comment type="line">// return this result early, skipping</comment>
			<comment type="line">// all the lengthy tests below</comment>
			<expr_stmt><expr><name>blockingreason</name> <operator>=</operator> <literal type="string">"regex blacklisted"</literal></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"%s is known as %s"</literal></expr></argument>, <argument><expr><name>domainstr</name></expr></argument>, <argument><expr><name>blockingreason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="line">// Do not block if the entire query is to be permitted</comment>
			<comment type="line">// as sometving along the CNAME path hit the whitelist</comment>
			<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>whitelisted</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>force_next_DNS_reply</name> <operator>=</operator> <name><name>dns_cache</name><operator>-&gt;</operator><name>force_reply</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>last_regex_idx</name> <operator>=</operator> <name><name>dns_cache</name><operator>-&gt;</operator><name>domainlist_id</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>query_blocked</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>domain</name></expr></argument>, <argument><expr><name>client</name></expr></argument>, <argument><expr><name>QUERY_REGEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>WHITELISTED</name></expr>:</case>
			<comment type="line">// Known as whitelisted, we</comment>
			<comment type="line">// return this result early, skipping</comment>
			<comment type="line">// all the lengthy tests below</comment>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"%s is known as not to be blocked (whitelisted)"</literal></expr></argument>, <argument><expr><name>domainstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>whitelisted</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<return>return <expr><name>false</name></expr>;</return>
			<break>break;</break>

		<case>case <expr><name>SPECIAL_DOMAIN</name></expr>:</case>
			<comment type="line">// Known as a special domain, we</comment>
			<comment type="line">// return this result early, skipping</comment>
			<comment type="line">// all the lengthy tests below</comment>
			<expr_stmt><expr><name>blockingreason</name> <operator>=</operator> <literal type="string">"special domain"</literal></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"%s is known as special domain"</literal></expr></argument>, <argument><expr><name>domainstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><empty_stmt>;</empty_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>force_next_DNS_reply</name> <operator>=</operator> <name><name>dns_cache</name><operator>-&gt;</operator><name>force_reply</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>query_blocked</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>domain</name></expr></argument>, <argument><expr><name>client</name></expr></argument>, <argument><expr><name>QUERY_SPECIAL_DOMAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
			<break>break;</break>

		<case>case <expr><name>NOT_BLOCKED</name></expr>:</case>
			<comment type="line">// Known as not blocked, we</comment>
			<comment type="line">// return this result early, skipping</comment>
			<comment type="line">// all the lengthy tests below</comment>
			<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"%s is known as not to be blocked"</literal></expr></argument>, <argument><expr><name>domainstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><name>false</name></expr>;</return>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="line">// Not in FTL's cache. Check if this is a special domain</comment>
	<if_stmt><if>if<condition>(<expr><call><name>special_domain</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>domainstr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Set DNS cache properties</comment>
		<expr_stmt><expr><name><name>dns_cache</name><operator>-&gt;</operator><name>blocking_status</name></name> <operator>=</operator> <name>SPECIAL_DOMAIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dns_cache</name><operator>-&gt;</operator><name>force_reply</name></name> <operator>=</operator> <name>force_next_DNS_reply</name></expr>;</expr_stmt>

		<comment type="line">// Adjust counters</comment>
		<expr_stmt><expr><call><name>query_blocked</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>domain</name></expr></argument>, <argument><expr><name>client</name></expr></argument>, <argument><expr><name>QUERY_SPECIAL_DOMAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Debug output</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Special domain: %s is %s"</literal></expr></argument>, <argument><expr><name>domainstr</name></expr></argument>, <argument><expr><name>blockingreason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Skip all checks and continue if we hit already at least one whitelist in the chain</comment>
	<if_stmt><if>if<condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>whitelisted</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Query is permitted as at least one whitelist entry matched"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Make a local copy of the domain string. The string memory may get</comment>
	<comment type="line">// reorganized in the following. We cannot expect domainstr to remain</comment>
	<comment type="line">// valid for all time.</comment>
	<expr_stmt><expr><name>domainstr</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>domainstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>blockedDomain</name> <init>= <expr><name>domainstr</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// Check exact whitelist for match</comment>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>whitelisted</name></name> <operator>=</operator> <call><name>in_whitelist</name><argument_list>(<argument><expr><name>domainstr</name></expr></argument>, <argument><expr><name>dns_cache</name></expr></argument>, <argument><expr><name>client</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FOUND</name></expr>;</expr_stmt>

	<comment type="line">// If not found: Check regex whitelist for match</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>whitelisted</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>whitelisted</name></name> <operator>=</operator> <call><name>in_regex</name><argument_list>(<argument><expr><name>domainstr</name></expr></argument>, <argument><expr><name>dns_cache</name></expr></argument>, <argument><expr><name><name>client</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>REGEX_WHITELIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Check blacklist (exact + regex) and gravity for queried domain</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>new_status</name> <init>= <expr><name>QUERY_UNKNOWN</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>db_okay</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>blockDomain</name> <init>= <expr><call><name>check_domain_blocked</name><argument_list>(<argument><expr><name>domainstr</name></expr></argument>, <argument><expr><name>clientID</name></expr></argument>, <argument><expr><name>client</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>dns_cache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_status</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>db_okay</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Check blacklist (exact + regex) and gravity for _esni.domain if enabled</comment>
	<comment type="line">// (defaulting to true)</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>block_esni</name></name> <operator>&amp;&amp;</operator>
	   <operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>whitelisted</name></name> <operator>&amp;&amp;</operator> <name>blockDomain</name> <operator>==</operator> <name>NOT_FOUND</name> <operator>&amp;&amp;</operator>
	    <call><name>strlen</name><argument_list>(<argument><expr><name>domainstr</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <call><name>strncasecmp</name><argument_list>(<argument><expr><name>domainstr</name></expr></argument>, <argument><expr><literal type="string">"_esni."</literal></expr></argument>, <argument><expr><literal type="number">6u</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>blockDomain</name> <operator>=</operator> <call><name>check_domain_blocked</name><argument_list>(<argument><expr><name>domainstr</name> <operator>+</operator> <literal type="number">6u</literal></expr></argument>, <argument><expr><name>clientID</name></expr></argument>, <argument><expr><name>client</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>dns_cache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_status</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>db_okay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><name>blockDomain</name></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// Truncate "_esni." from queried domain if the parenting domain was</comment>
			<comment type="line">// the reason for blocking this query</comment>
			<expr_stmt><expr><name>blockedDomain</name> <operator>=</operator> <name>domainstr</name> <operator>+</operator> <literal type="number">6u</literal></expr>;</expr_stmt>
			<comment type="line">// Force next DNS reply to be NXDOMAIN for _esni.* queries</comment>
			<expr_stmt><expr><name>force_next_DNS_reply</name> <operator>=</operator> <name>REPLY_NXDOMAIN</name></expr>;</expr_stmt>

			<comment type="line">// Store this in the DNS cache only if the database is available at</comment>
			<comment type="line">// this point</comment>
			<if_stmt><if>if<condition>(<expr><name>db_okay</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>dns_cache</name><operator>-&gt;</operator><name>force_reply</name></name> <operator>=</operator> <name>REPLY_NXDOMAIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Common actions regardless what the possible blocking reason is</comment>
	<if_stmt><if>if<condition>(<expr><name>blockDomain</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Adjust counters</comment>
		<expr_stmt><expr><call><name>query_blocked</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>domain</name></expr></argument>, <argument><expr><name>client</name></expr></argument>, <argument><expr><name>new_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Debug output</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Blocking %s as %s is %s"</literal></expr></argument>, <argument><expr><name>domainstr</name></expr></argument>, <argument><expr><name>blockedDomain</name></expr></argument>, <argument><expr><name>blockingreason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name>force_next_DNS_reply</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Forcing next reply to %s"</literal></expr></argument>, <argument><expr><call><name>get_query_reply_str</name><argument_list>(<argument><expr><name>force_next_DNS_reply</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name>db_okay</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Explicitly mark as not blocked to skip the entire gravity/blacklist</comment>
		<comment type="line">// chain when the same client asks for the same domain in the future.</comment>
		<comment type="line">// Store domain as whitelisted if this is the case</comment>
		<expr_stmt><expr><name><name>dns_cache</name><operator>-&gt;</operator><name>blocking_status</name></name> <operator>=</operator> <ternary><condition><expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>whitelisted</name></name></expr> ?</condition><then> <expr><name>WHITELISTED</name></expr> </then><else>: <expr><name>NOT_BLOCKED</name></expr></else></ternary></expr>;</expr_stmt>

		<comment type="line">// Debug output</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="line">// client is guaranteed to be non-NULL above</comment>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"DNS cache: %s/%s is %s"</literal></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>ippos</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>domainstr</name></expr></argument>,
			     <argument><expr><ternary><condition><expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>whitelisted</name></name></expr> ?</condition><then> <expr><literal type="string">"whitelisted"</literal></expr> </then><else>: <expr><literal type="string">"not blocked"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>domainstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>blockDomain</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>bool</name></type> <name>_FTL_CNAME</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"FTL_CNAME called with: src = %s, dst = %s, id = %d"</literal></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Does the user want to skip deep CNAME inspection?</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>config</name><operator>.</operator><name>cname_inspection</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Skipping analysis as cname inspection is disabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Lock shared memory</comment>
	<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Save status and upstreamID in corresponding query identified by dnsmasq's ID</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>queryID</name> <init>= <expr><call><name>findQueryID</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>queryID</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// This may happen e.g. if the original query was a PTR query</comment>
		<comment type="line">// or "pi.hole" and we ignored them altogether</comment>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Skipping analysis as parent query is not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Get query pointer so we can later extract the client requesting this domain for</comment>
	<comment type="line">// the per-client blocking evaluation</comment>
	<decl_stmt><decl><type><name>queriesData</name><modifier>*</modifier></type> <name>query</name> <init>= <expr><call><name>getQuery</name><argument_list>(<argument><expr><name>queryID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>query</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Nothing to be done here</comment>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Skipping analysis as parent query is not valid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Example to make the terminology used in here clear:</comment>
	<comment type="line">// CNAME abc -&gt; 123</comment>
	<comment type="line">// CNAME 123 -&gt; 456</comment>
	<comment type="line">// CNAME 456 -&gt; 789</comment>
	<comment type="line">// parent_domain: abc</comment>
	<comment type="line">// child_domains: [123, 456, 789]</comment>

	<comment type="line">// parent_domain = Domain at the top of the CNAME path</comment>
	<comment type="line">// This is the domain which was queried first in this chain</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>parent_domainID</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>domainID</name></name></expr></init></decl>;</decl_stmt>

	<comment type="line">// child_domain = Intermediate domain in CNAME path</comment>
	<comment type="line">// This is the domain which was queried later in this chain</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>child_domain</name> <init>= <expr><call><name>strdup</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// Convert to lowercase for matching</comment>
	<expr_stmt><expr><call><name>strtolower</name><argument_list>(<argument><expr><name>child_domain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>child_domainID</name> <init>= <expr><call><name>findDomainID</name><argument_list>(<argument><expr><name>child_domain</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Get client ID from the original query (the entire chain always</comment>
	<comment type="line">// belongs to the same client)</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>clientID</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>clientID</name></name></expr></init></decl>;</decl_stmt>

	<comment type="line">// Check per-client blocking for the child domain</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>block</name> <init>= <expr><call><name>FTL_check_blocking</name><argument_list>(<argument><expr><name>queryID</name></expr></argument>, <argument><expr><name>child_domainID</name></expr></argument>, <argument><expr><name>clientID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// If we find during a CNAME inspection that we want to block the entire chain,</comment>
	<comment type="line">// the originally queried domain itself was not counted as blocked. We have to</comment>
	<comment type="line">// correct this when we are going to short-circuit the entire query</comment>
	<if_stmt><if>if<condition>(<expr><name>block</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Increase blocked count of parent domain</comment>
		<decl_stmt><decl><type><name>domainsData</name><modifier>*</modifier></type> <name>parent_domain</name> <init>= <expr><call><name>getDomain</name><argument_list>(<argument><expr><name>parent_domainID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>parent_domain</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// Memory error, return</comment>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>child_domain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>parent_domain</name><operator>-&gt;</operator><name>blockedcount</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="line">// Store query response as CNAME type</comment>
		<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>response</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>response</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>query_set_reply</name><argument_list>(<argument><expr><name>F_CNAME</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Store domain that was the reason for blocking the entire chain</comment>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>CNAME_domainID</name></name> <operator>=</operator> <name>child_domainID</name></expr>;</expr_stmt>

		<comment type="line">// Change blocking reason into CNAME-caused blocking</comment>
		<if_stmt><if>if<condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>QUERY_GRAVITY</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>query_set_status</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>QUERY_GRAVITY_CNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if<condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>QUERY_REGEX</name></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// Get parent and child DNS cache entries</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>parent_cacheID</name> <init>= <expr><call><name>findCacheID</name><argument_list>(<argument><expr><name>parent_domainID</name></expr></argument>, <argument><expr><name>clientID</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>child_cacheID</name> <init>= <expr><call><name>findCacheID</name><argument_list>(<argument><expr><name>child_domainID</name></expr></argument>, <argument><expr><name>clientID</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="line">// Get cache pointers</comment>
			<decl_stmt><decl><type><name>DNSCacheData</name> <modifier>*</modifier></type><name>parent_cache</name> <init>= <expr><call><name>getDNSCache</name><argument_list>(<argument><expr><name>parent_cacheID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DNSCacheData</name> <modifier>*</modifier></type><name>child_cache</name> <init>= <expr><call><name>getDNSCache</name><argument_list>(<argument><expr><name>child_cacheID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="line">// Propagate ID of responsible regex up from the child to the parent domain</comment>
			<if_stmt><if>if<condition>(<expr><name>parent_cache</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>child_cache</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>child_cache</name><operator>-&gt;</operator><name>domainlist_id</name></name> <operator>=</operator> <name><name>parent_cache</name><operator>-&gt;</operator><name>domainlist_id</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="line">// Set status</comment>
			<expr_stmt><expr><call><name>query_set_status</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>QUERY_REGEX_CNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if<condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>QUERY_BLACKLIST</name></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// Only set status</comment>
			<expr_stmt><expr><call><name>query_set_status</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>QUERY_BLACKLIST_CNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Debug logging for deep CNAME inspection (if enabled)</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Query %d: CNAME %s ---&gt; %s"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Return result</comment>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>child_domain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>block</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>FTL_forwarded</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>union</name> <name>all_addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>,
                          <parameter><decl><type><name>unsigned</name> <name>short</name></type> <name>port</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Save that this query got forwarded to an upstream server</comment>

	<comment type="line">// Lock shared memory</comment>
	<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Get forward destination IP address and port</comment>
	<decl_stmt><decl><type><name>in_port_t</name></type> <name>upstreamPort</name> <init>= <expr><literal type="number">53</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>dest</name><index>[<expr><name>ADDRSTRLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<comment type="line">// If addr == NULL, we will only duplicate an empty string instead of uninitialized memory</comment>
	<expr_stmt><expr><name><name>dest</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>addr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_IPV4</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name>AF_INET</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="line">// Reverse-engineer port from underlying sockaddr_in structure</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>in_port_t</name> <modifier>*</modifier></type><name>rport</name> <init>= <expr><operator>(</operator><name>in_port_t</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>addr</name>
			                                     <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr>struct <name>sockaddr_in</name></expr></argument>, <argument><expr><name>sin_addr</name></expr></argument>)</argument_list></call>
			                                     <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr>struct <name>sockaddr_in</name></expr></argument>, <argument><expr><name>sin_port</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>upstreamPort</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><operator>*</operator><name>rport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name>upstreamPort</name> <operator>!=</operator> <name>port</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"ERR: Port mismatch for %s: we derived %d, dnsmasq told us %d"</literal></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>upstreamPort</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name>AF_INET6</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="line">// Reverse-engineer port from underlying sockaddr_in6 structure</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>in_port_t</name> <modifier>*</modifier></type><name>rport</name> <init>= <expr><operator>(</operator><name>in_port_t</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>addr</name>
			                                     <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr>struct <name>sockaddr_in6</name></expr></argument>, <argument><expr><name>sin6_addr</name></expr></argument>)</argument_list></call>
			                                     <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr>struct <name>sockaddr_in6</name></expr></argument>, <argument><expr><name>sin6_port</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>upstreamPort</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><operator>*</operator><name>rport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name>upstreamPort</name> <operator>!=</operator> <name>port</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"ERR: Port mismatch for %s: we derived %d, dnsmasq told us %d"</literal></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>upstreamPort</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Convert upstreamIP to lower case</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>upstreamIP</name> <init>= <expr><call><name>strdup</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>strtolower</name><argument_list>(<argument><expr><name>upstreamIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Debug logging</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"**** forwarded %s to %s#%u (ID %i, %s:%i)"</literal></expr></argument>,
		     <argument><expr><name>name</name></expr></argument>, <argument><expr><name>upstreamIP</name></expr></argument>, <argument><expr><name>upstreamPort</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Save status and upstreamID in corresponding query identified by dnsmasq's ID</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>queryID</name> <init>= <expr><call><name>findQueryID</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>queryID</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// This may happen e.g. if the original query was a PTR query or "pi.hole"</comment>
		<comment type="line">// as we ignore them altogether</comment>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>upstreamIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Get query pointer</comment>
	<decl_stmt><decl><type><name>queriesData</name><modifier>*</modifier></type> <name>query</name> <init>= <expr><call><name>getQuery</name><argument_list>(<argument><expr><name>queryID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>query</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>upstreamIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Get ID of upstream destination, create new upstream record</comment>
	<comment type="line">// if not found in current data structure</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>upstreamID</name> <init>= <expr><call><name>findUpstreamID</name><argument_list>(<argument><expr><name>upstreamIP</name></expr></argument>, <argument><expr><name>upstreamPort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>upstreamID</name></name> <operator>=</operator> <name>upstreamID</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>upstreamsData</name> <modifier>*</modifier></type><name>upstream</name> <init>= <expr><call><name>getUpstream</name><argument_list>(<argument><expr><name>upstreamID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>upstream</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Update overTime counts</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>timeidx</name> <init>= <expr><call><name>getOverTimeID</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>timestamp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>upstream</name><operator>-&gt;</operator><name>overTime</name><index>[<expr><name>timeidx</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
		<comment type="line">// Update lastQuery timestamp</comment>
		<expr_stmt><expr><name><name>upstream</name><operator>-&gt;</operator><name>lastQuery</name></name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Proceed only if</comment>
	<comment type="line">// - current query has not been marked as replied to so far</comment>
	<comment type="line">//   (it could be that answers from multiple forward</comment>
	<comment type="line">//    destinations are coming in for the same query)</comment>
	<comment type="line">// - the query was formally known as cached but had to be forwarded</comment>
	<comment type="line">//   (this is a special case further described below)</comment>
	<if_stmt><if>if<condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>complete</name></name> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>QUERY_CACHE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>upstreamIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>QUERY_CACHE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Detect if we cached the &lt;CNAME&gt; but need to ask the upstream</comment>
		<comment type="line">// servers for the actual IPs now, we remove this query from the</comment>
		<comment type="line">// counters for cache replied queries as we had to forward a</comment>
		<comment type="line">// request for it. Example:</comment>
		<comment type="line">// Assume a domain a.com is a CNAME which is cached and has a very</comment>
		<comment type="line">// long TTL. It point to another domain server.a.com which has an</comment>
		<comment type="line">// A record but this has a much lower TTL.</comment>
		<comment type="line">// If you now query a.com and then again after some time, you end</comment>
		<comment type="line">// up in a situation where dnsmasq can answer the first level of</comment>
		<comment type="line">// the DNS result (the CNAME) from cache, hence the status of this</comment>
		<comment type="line">// query is marked as "answered from cache" in FTLDNS. However, for</comment>
		<comment type="line">// server.a.com with the much shorter TTL, we still have to forward</comment>
		<comment type="line">// something and ask the upstream server for the final IP address.</comment>

		<comment type="line">// Correct reply timer if a response time has already been calculated</comment>
		<if_stmt><if>if<condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>response_calculated</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>response</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>response</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="line">// Reset timer to measure how long it takes until an answer arrives</comment>
			<comment type="line">// If a response time has already been calculated, we</comment>
			<comment type="line">// can go back in time to measure both the initial cache</comment>
			<comment type="line">// lookup and the (now starting) time it takes for the</comment>
			<comment type="line">// upstream to respond</comment>
			<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>response</name></name> <operator>=</operator> <call><name>converttimeval</name><argument_list>(<argument><expr><name>response</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>query</name><operator>-&gt;</operator><name>response</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>response_calculated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="line">// Normal forwarded query (status is set below)</comment>
		<comment type="line">// Hereby, this query is now fully determined</comment>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>complete</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="line">// Set query status to forwarded only after the</comment>
	<comment type="line">// if(query-&gt;status == QUERY_CACHE) { ... }</comment>
	<comment type="line">// from above as otherwise this check will always</comment>
	<comment type="line">// be negative</comment>
	<expr_stmt><expr><call><name>query_set_status</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>QUERY_FORWARDED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Release allocated memory</comment>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>upstreamIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Unlock shared memory</comment>
	<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>FTL_dnsmasq_reload</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// This function is called by the dnsmasq code on receive of SIGHUP</comment>
	<comment type="line">// *before* clearing the cache and rereading the lists</comment>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Reloading DNS cache"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Request reload the privacy level and blocking status</comment>
	<expr_stmt><expr><call><name>set_event</name><argument_list>(<argument><expr><name>RELOAD_PRIVACY_LEVEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_event</name><argument_list>(<argument><expr><name>RELOAD_BLOCKINGSTATUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Reread pihole-FTL.conf to see which blocking mode the user wants to use</comment>
	<comment type="line">// It is possible to change the blocking mode here as we anyhow clear the</comment>
	<comment type="line">// cache and reread all blocking lists</comment>
	<comment type="line">// Passing NULL to this function means it has to open the config file on</comment>
	<comment type="line">// its own behalf (on initial reading, the config file is already opened)</comment>
	<expr_stmt><expr><call><name>get_blocking_mode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Reread pihole-FTL.conf to see which debugging flags are set</comment>
	<expr_stmt><expr><call><name>read_debuging_settings</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Gravity database updates</comment>
	<comment type="line">// - (Re-)open gravity database connection</comment>
	<comment type="line">// - Get number of blocked domains</comment>
	<comment type="line">// - check adlist table for inaccessible adlists</comment>
	<comment type="line">// - Read and compile regex filters (incl. per-client)</comment>
	<comment type="line">// - Flush FTL's DNS cache</comment>
	<expr_stmt><expr><call><name>set_event</name><argument_list>(<argument><expr><name>RELOAD_GRAVITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Print current set of capabilities if requested via debug flag</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_CAPS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_capabilities</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Set resolver as ready</comment>
	<expr_stmt><expr><name>resolver_ready</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>alladdr_extract_ip</name><parameter_list>(<parameter><decl><type><name><name>union</name> <name>all_addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>sa_family_t</name></type> <name>family</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name><name>ip</name><index>[<expr><name>ADDRSTRLEN</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Extract IP address</comment>
	<expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name>family</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mysockaddr_extract_ip_port</name><parameter_list>(<parameter><decl><type><name><name>union</name> <name>mysockaddr</name></name> <modifier>*</modifier></type><name>server</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name><name>ip</name><index>[<expr><name>ADDRSTRLEN</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>in_port_t</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Extract IP address</comment>
	<expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name><name>server</name><operator>-&gt;</operator><name>sa</name><operator>.</operator><name>sa_family</name></name></expr></argument>,
	          <argument><expr><ternary><condition><expr><name><name>server</name><operator>-&gt;</operator><name>sa</name><operator>.</operator><name>sa_family</name></name> <operator>==</operator> <name>AF_INET</name></expr> ?</condition><then>
	            <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>server</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>sin_addr</name></name></expr> </then><else>:
	            <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>server</name><operator>-&gt;</operator><name>in6</name><operator>.</operator><name>sin6_addr</name></name></expr></else></ternary></expr></argument>,
	          <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Extract port (only if requested)</comment>
	<if_stmt><if>if<condition>(<expr><name>port</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>port</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>server</name><operator>-&gt;</operator><name>sa</name><operator>.</operator><name>sa_family</name></name> <operator>==</operator> <name>AF_INET</name></expr> ?</condition><then>
		                <expr><name><name>server</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>sin_port</name></name></expr> </then><else>:
		                <expr><name><name>server</name><operator>-&gt;</operator><name>in6</name><operator>.</operator><name>sin6_port</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// Compute cache/upstream response time</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>set_response_time</name><parameter_list>(<parameter><decl><type><name>queriesData</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>timeval</name></name></type> <name>response</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Do this only if this is the first time we set a reply</comment>
	<if_stmt><if>if<condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>response_calculated</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="line">// Convert absolute timestamp to relative timestamp</comment>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>response</name></name> <operator>=</operator> <call><name>converttimeval</name><argument_list>(<argument><expr><name>response</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>query</name><operator>-&gt;</operator><name>response</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>response_calculated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Changes upstream server (only relevant when multiple servers are defined)</comment>
<comment type="line">// If this is an upstream response and the answering upstream is known (may not</comment>
<comment type="line">// be the case for internally generated DNSSEC queries), we have to check if the</comment>
<comment type="line">// first answering upstream server is also the first one we sent the query to.</comment>
<comment type="line">// If not, we need to change the upstream server associated with this query to</comment>
<comment type="line">// get accurate statistics</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>update_upstream</name><parameter_list>(<parameter><decl><type><name>queriesData</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// We use query-&gt;flags.response_calculated to check if this is the first</comment>
	<comment type="line">// response received for this query and check the family of last server</comment>
	<comment type="line">// to see if it is available</comment>
	<if_stmt><if>if<condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>response_calculated</name></name> <operator>||</operator> <name><name>last_server</name><operator>.</operator><name>sa</name><operator>.</operator><name>sa_family</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name><name>ip</name><index>[<expr><name>ADDRSTRLEN</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>in_port_t</name></type> <name>port</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>mysockaddr_extract_ip_port</name><argument_list>(<argument><expr><operator>&amp;</operator><name>last_server</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>upstreamID</name> <init>= <expr><call><name>findUpstreamID</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>upstreamID</name> <operator>!=</operator> <name><name>query</name><operator>-&gt;</operator><name>upstreamID</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>upstreamsData</name> <modifier>*</modifier></type><name>upstream</name> <init>= <expr><call><name>getUpstream</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>upstreamID</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><name>upstream</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>oldaddr</name> <init>= <expr><call><name>getstr</name><argument_list>(<argument><expr><name><name>upstream</name><operator>-&gt;</operator><name>ippos</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>in_port_t</name></type> <name>oldport</name> <init>= <expr><name><name>upstream</name><operator>-&gt;</operator><name>port</name></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Query ID %d: Associated upstream changed (was %s#%d) as %s#%d replied earlier"</literal></expr></argument>,
					<argument><expr><name>id</name></expr></argument>, <argument><expr><name>oldaddr</name></expr></argument>, <argument><expr><name>oldport</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>upstreamID</name></name> <operator>=</operator> <name>upstreamID</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>FTL_reply</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>union</name> <name>all_addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// If domain is "pi.hole", we skip this query</comment>
	<comment type="line">// We compare case-insensitive here</comment>
	<comment type="line">// Hint: name can be NULL, e.g. for NODATA/NXDOMAIN replies</comment>
	<if_stmt><if>if<condition>(<expr><name>name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"pi.hole"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Get response time before lock because we want to measure upstream not</comment>
	<comment type="line">// the lock. The latter may artificially add some extra nanoseconds when</comment>
	<comment type="line">// the Pi-hole is currently busy</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>response</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>response</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Lock shared memory</comment>
	<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Save status in corresponding query identified by dnsmasq's ID</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>queryID</name> <init>= <expr><call><name>findQueryID</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>queryID</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// This may happen e.g. if the original query was "pi.hole"</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"FTL_reply(): Query %i has not been found"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Check if this reply came from our local cache</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>cached</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>F_UPSTREAM</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cached</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>F_HOSTS</name><operator>)</operator> <operator>||</operator> <comment type="line">// local.list, hostname.list, /etc/hosts and others</comment>
		   <operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>F_NAMEP</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>F_DHCP</name><operator>)</operator><operator>)</operator> <operator>||</operator> <comment type="line">// DHCP server reply</comment>
		   <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>F_FORWARD</name><operator>)</operator> <operator>||</operator> <comment type="line">// cached answer to previously forwarded request</comment>
		   <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>F_REVERSE</name><operator>)</operator> <operator>||</operator> <comment type="line">// cached answer to reverse request (PTR)</comment>
		   <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>F_RRNAME</name><operator>)</operator></expr>)</condition> <comment type="line">// cached answer to TXT query</comment>
		<block>{<block_content>
			<empty_stmt>;</empty_stmt> <comment type="line">// Okay</comment>
		</block_content>}</block></if>
		<if type="elseif">else if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_FLAGS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"***** Unknown cache query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Is this a stale reply?</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>stale</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>F_STALE</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// Possible debugging output</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Human-readable answer may be provided by arg</comment>
		<comment type="line">// (e.g. for non-cached queries such as SOA)</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>answer</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
		<comment type="line">// Determine returned address (if applicable)</comment>
		<decl_stmt><decl><type><name>char</name></type> <name><name>dest</name><index>[<expr><name>ADDRSTRLEN</name></expr>]</index></name></decl>;</decl_stmt> <expr_stmt><expr><name><name>dest</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>addr</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>F_IPV4</name><operator>)</operator></expr> ?</condition><then> <expr><name>AF_INET</name></expr> </then><else>: <expr><name>AF_INET6</name></expr></else></ternary></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>answer</name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt> <comment type="line">// Overwrite answer with human-readable IP address</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Extract answer (used e.g. for detecting if a local config is a user-defined</comment>
		<comment type="line">// wildcard blocking entry in form "server=/tobeblocked.com/")</comment>
		<if_stmt><if>if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_CNAME</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>answer</name> <operator>=</operator> <literal type="string">"(CNAME)"</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if<condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>F_NEG</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>F_NXDOMAIN</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>answer</name> <operator>=</operator> <literal type="string">"(NXDOMAIN)"</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_NEG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>answer</name> <operator>=</operator> <literal type="string">"(NODATA)"</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_RCODE</name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>rcode</name> <init>= <expr><name><name>addr</name><operator>-&gt;</operator><name>log</name><operator>.</operator><name>rcode</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><name>rcode</name> <operator>==</operator> <name>REFUSED</name></expr>)</condition>
			<block>{<block_content>
				<comment type="line">// This happens, e.g., in a "nowhere to forward to" situation</comment>
				<expr_stmt><expr><name>answer</name> <operator>=</operator> <literal type="string">"REFUSED (nowhere to forward to)"</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if<condition>(<expr><name>rcode</name> <operator>==</operator> <name>SERVFAIL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="line">// This happens on upstream destination errors</comment>
				<expr_stmt><expr><name>answer</name> <operator>=</operator> <literal type="string">"SERVFAIL"</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_NOEXTRA</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_KEYTAG</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>answer</name> <operator>=</operator> <literal type="string">"DNSKEY"</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>answer</name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="line">// e.g. "reply &lt;TLD&gt; is no DS"</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Substitute "." if we are querying the root domain (e.g. DNSKEY)</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dispname</name> <init>= <expr><name>name</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><name>name</name> <operator>||</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>dispname</name> <operator>=</operator> <literal type="string">"."</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if<condition>(<expr><name>cached</name> <operator>||</operator> <name><name>last_server</name><operator>.</operator><name>sa</name><operator>.</operator><name>sa_family</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<comment type="line">// Log cache or upstream reply from unknown source</comment>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"**** got %s%s reply: %s is %s (ID %i, %s:%i)"</literal></expr></argument>,
			     <argument><expr><ternary><condition><expr><name>stale</name></expr> ?</condition><then> <expr><literal type="string">"stale "</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><ternary><condition><expr><name>cached</name></expr> ?</condition><then> <expr><literal type="string">"cache"</literal></expr> </then><else>: <expr><literal type="string">"upstream"</literal></expr></else></ternary></expr></argument>,
			     <argument><expr><name>dispname</name></expr></argument>, <argument><expr><name>answer</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type> <name><name>ip</name><index>[<expr><name>ADDRSTRLEN</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>in_port_t</name></type> <name>port</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>mysockaddr_extract_ip_port</name><argument_list>(<argument><expr><operator>&amp;</operator><name>last_server</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="line">// Log server which replied to our request</comment>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"**** got %s%s reply from %s#%d: %s is %s (ID %i, %s:%i)"</literal></expr></argument>,
			     <argument><expr><ternary><condition><expr><name>stale</name></expr> ?</condition><then> <expr><literal type="string">"stale "</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><ternary><condition><expr><name>cached</name></expr> ?</condition><then> <expr><literal type="string">"cache"</literal></expr> </then><else>: <expr><literal type="string">"upstream"</literal></expr></else></ternary></expr></argument>,
			     <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>dispname</name></expr></argument>, <argument><expr><name>answer</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Get and check query pointer</comment>
	<decl_stmt><decl><type><name>queriesData</name><modifier>*</modifier></type> <name>query</name> <init>= <expr><call><name>getQuery</name><argument_list>(<argument><expr><name>queryID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>query</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Nothing to be done here</comment>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// EDE analysis</comment>
	<if_stmt><if>if<condition>(<expr><name>addr</name> <operator>&amp;&amp;</operator> <name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>F_RCODE</name> <operator>|</operator> <name>F_SECSTAT</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>addr</name><operator>-&gt;</operator><name>log</name><operator>.</operator><name>ede</name></name> <operator>!=</operator> <name>EDE_UNSET</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>ede</name></name> <operator>=</operator> <name><name>addr</name><operator>-&gt;</operator><name>log</name><operator>.</operator><name>ede</name></name></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     EDE: %s (%d)"</literal></expr></argument>, <argument><expr><call><name>edestr</name><argument_list>(<argument><expr><name><name>addr</name><operator>-&gt;</operator><name>log</name><operator>.</operator><name>ede</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>log</name><operator>.</operator><name>ede</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Update upstream server (if applicable)</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>cached</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>update_upstream</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Save response time</comment>
	<comment type="line">// Skipped internally if already computed</comment>
	<expr_stmt><expr><call><name>set_response_time</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// We only process the first reply further in here</comment>
	<comment type="line">// Check if reply type is still UNKNOWN</comment>
	<if_stmt><if>if<condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>reply</name></name> <operator>!=</operator> <name>REPLY_UNKNOWN</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Nothing to be done here</comment>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Determine if this reply is an exact match for the queried domain</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>domainID</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>domainID</name></name></expr></init></decl>;</decl_stmt>

	<comment type="line">// Get domain pointer</comment>
	<decl_stmt><decl><type><name>domainsData</name><modifier>*</modifier></type> <name>domain</name> <init>= <expr><call><name>getDomain</name><argument_list>(<argument><expr><name>domainID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>domain</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Memory error, skip reply</comment>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Determine query status (live or stale data?)</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>enum</name> <name>query_status</name></name></type> <name>qs</name> <init>= <expr><ternary><condition><expr><name>stale</name></expr> ?</condition><then> <expr><name>QUERY_CACHE_STALE</name></expr> </then><else>: <expr><name>QUERY_CACHE</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<comment type="line">// This is either a reply served from cache or a blocked query (which appear</comment>
	<comment type="line">// to be from cache because of flags containing F_HOSTS)</comment>
	<if_stmt><if>if<condition>(<expr><name>cached</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Set status of this query only if this is not a blocked query</comment>
		<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>is_blocked</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>query_set_status</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>qs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="line">// Detect if returned IP indicates that this query was blocked</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name><name>enum</name> <name>query_status</name></name></type> <name>new_status</name> <init>= <expr><call><name>detect_blocked_IP</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>domain</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// Update status of this query if detected as external blocking</comment>
		<if_stmt><if>if<condition>(<expr><name>new_status</name> <operator>!=</operator> <name><name>query</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>clientsData</name> <modifier>*</modifier></type><name>client</name> <init>= <expr><call><name>getClient</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>clientID</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><name>client</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>query_blocked</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>domain</name></expr></argument>, <argument><expr><name>client</name></expr></argument>, <argument><expr><name>new_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Save reply type and update individual reply counters</comment>
		<expr_stmt><expr><call><name>query_set_reply</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// We know from cache that this domain is either SECURE or</comment>
		<comment type="line">// INSECURE, bogus queries are not cached</comment>
		<if_stmt><if>if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_DNSSECOK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>query_set_dnssec</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>DNSSEC_SECURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>query_set_dnssec</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>DNSSEC_INSECURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="line">// Hereby, this query is now fully determined</comment>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>complete</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// else: This is a reply from upstream</comment>
	<comment type="line">// Check if this domain matches exactly</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>isExactMatch</name> <init>= <expr><call><name>strcmp_escaped</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name><name>domain</name><operator>-&gt;</operator><name>domainpos</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>F_CONFIG</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>isExactMatch</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>complete</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Answered from local configuration, might be a wildcard or user-provided</comment>

		<comment type="line">// Answered from a custom (user provided) cache file or because</comment>
		<comment type="line">// we're the authoritative DNS server (e.g. DHCP server and this</comment>
		<comment type="line">// is our own domain)</comment>
		<expr_stmt><expr><call><name>query_set_status</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>qs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Save reply type and update individual reply counters</comment>
		<expr_stmt><expr><call><name>query_set_reply</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Hereby, this query is now fully determined</comment>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>complete</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>F_FORWARD</name> <operator>|</operator> <name>F_UPSTREAM</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <name>isExactMatch</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Only proceed if query is not already known</comment>
		<comment type="line">// to have been blocked by Quad9</comment>
		<if_stmt><if>if<condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>QUERY_EXTERNAL_BLOCKED_IP</name> <operator>||</operator>
		   <name><name>query</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>QUERY_EXTERNAL_BLOCKED_NULL</name> <operator>||</operator>
		   <name><name>query</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>QUERY_EXTERNAL_BLOCKED_NXRA</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// DNSSEC query handling</comment>
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>reply_flags</name> <init>= <expr><name>flags</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_NOEXTRA</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>query</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>TYPE_DNSKEY</name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>TYPE_DS</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_KEYTAG</name></expr>)</condition>
			<block>{<block_content>
				<comment type="line">// We were able to validate this query, mark it</comment>
				<comment type="line">// as SECURE (reply &lt;domain&gt; is {DNSKEY,DS}</comment>
				<comment type="line">// keytag &lt;X&gt;, algo &lt;Y&gt;, digest &lt;Z&gt;)</comment>
				<expr_stmt><expr><call><name>query_set_dnssec</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>DNSSEC_SECURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if<condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"BOGUS"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="line">// BOGUS DS</comment>
				<expr_stmt><expr><call><name>query_set_dnssec</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>DNSSEC_BOGUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="line">// If is a negative reply to a DNSSEC query</comment>
				<comment type="line">// (reply &lt;domain&gt; is no DS), we overwrite flags</comment>
				<comment type="line">// to store NODATA for this query</comment>
				<expr_stmt><expr><name>reply_flags</name> <operator>=</operator> <name>F_NEG</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Save reply type and update individual reply counters</comment>
		<expr_stmt><expr><call><name>query_set_reply</name><argument_list>(<argument><expr><name>reply_flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Further checks if this is an IP address</comment>
		<if_stmt><if>if<condition>(<expr><name>addr</name></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// Detect if returned IP indicates that this query was blocked</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name><name>enum</name> <name>query_status</name></name></type> <name>new_status</name> <init>= <expr><call><name>detect_blocked_IP</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>domain</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="line">// Update status of this query if detected as external blocking</comment>
			<if_stmt><if>if<condition>(<expr><name>new_status</name> <operator>!=</operator> <name><name>query</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>clientsData</name> <modifier>*</modifier></type><name>client</name> <init>= <expr><call><name>getClient</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>clientID</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if<condition>(<expr><name>client</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>query_blocked</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>domain</name></expr></argument>, <argument><expr><name>client</name></expr></argument>, <argument><expr><name>new_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_REVERSE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// isExactMatch is not used here as the PTR is special.</comment>
		<comment type="line">// Example:</comment>
		<comment type="line">// Question: PTR 8.8.8.8</comment>
		<comment type="line">// will lead to:</comment>
		<comment type="line">//   domain-&gt;domain = 8.8.8.8.in-addr.arpa</comment>
		<comment type="line">// and will return</comment>
		<comment type="line">//   name = google-public-dns-a.google.com</comment>
		<comment type="line">// Hence, isExactMatch is always false</comment>

		<comment type="line">// Save reply type and update individual reply counters</comment>
		<expr_stmt><expr><call><name>query_set_reply</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name>isExactMatch</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>complete</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"*************************** unknown REPLY ***************************"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_FLAGS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"***** Unknown upstream REPLY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>enum</name> <name>query_status</name></name></type> <name>detect_blocked_IP</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>short</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>union</name> <name>all_addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>queriesData</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>domainsData</name> <modifier>*</modifier></type><name>domain</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Compare returned IP against list of known blocking splash pages</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addr</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name><name>query</name><operator>-&gt;</operator><name>status</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// First, we check if we want to skip this result even before comparing against the known IPs</comment>
	<if_stmt><if>if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_HOSTS</name> <operator>||</operator> <name>flags</name> <operator>&amp;</operator> <name>F_REVERSE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Skip replies which originated locally. Otherwise, we would</comment>
		<comment type="line">// count gravity.list blocked queries as externally blocked.</comment>
		<comment type="line">// Also: Do not mark responses of PTR requests as externally blocked.</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cause</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>F_HOSTS</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"origin is HOSTS"</literal></expr> </then><else>: <expr><literal type="string">"query is PTR"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Skipping detection of external blocking IP for ID %i as %s"</literal></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>cause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Return early, do not compare against known blocking page IP addresses below</comment>
		<return>return <expr><name><name>query</name><operator>-&gt;</operator><name>status</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// If received one of the following IPs as reply, OpenDNS</comment>
	<comment type="line">// (Cisco Umbrella) blocked this query</comment>
	<comment type="line">// See https://support.opendns.com/hc/en-us/articles/227986927-What-are-the-Cisco-Umbrella-Block-Page-IP-Addresses-</comment>
	<comment type="line">// for a full list of these IP addresses</comment>
	<decl_stmt><decl><type><name>in_addr_t</name></type> <name>ipv4Addr</name> <init>= <expr><call><name>ntohl</name><argument_list>(<argument><expr><name><name>addr</name><operator>-&gt;</operator><name>addr4</name><operator>.</operator><name>s_addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>in_addr_t</name></type> <name>ipv6Addr</name> <init>= <expr><call><name>ntohl</name><argument_list>(<argument><expr><name><name>addr</name><operator>-&gt;</operator><name>addr6</name><operator>.</operator><name>s6_addr32</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// Check for IP block 146.112.61.104 - 146.112.61.110</comment>
	<if_stmt><if>if<condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>F_IPV4</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>ipv4Addr</name> <operator>&gt;=</operator> <literal type="number">0x92703d68</literal> <operator>&amp;&amp;</operator> <name>ipv4Addr</name> <operator>&lt;=</operator> <literal type="number">0x92703d6e</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type> <name><name>answer</name><index>[<expr><name>ADDRSTRLEN</name></expr>]</index></name></decl>;</decl_stmt> <expr_stmt><expr><name><name>answer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name>AF_INET</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>answer</name></expr></argument>, <argument><expr><name>ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Upstream responded with known blocking page (IPv4), ID %i:\n\t\"%s\" -&gt; \"%s\""</literal></expr></argument>,
			     <argument><expr><name><name>query</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name><name>domain</name><operator>-&gt;</operator><name>domainpos</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>answer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Update status</comment>
		<return>return <expr><name>QUERY_EXTERNAL_BLOCKED_IP</name></expr>;</return>
	</block_content>}</block></if>
	<comment type="line">// Check for IP block :ffff:146.112.61.104 - :ffff:146.112.61.110</comment>
	<if type="elseif">else if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_IPV6</name> <operator>&amp;&amp;</operator>
	        <name><name>addr</name><operator>-&gt;</operator><name>addr6</name><operator>.</operator><name>s6_addr32</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
	        <name><name>addr</name><operator>-&gt;</operator><name>addr6</name><operator>.</operator><name>s6_addr32</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
	        <name><name>addr</name><operator>-&gt;</operator><name>addr6</name><operator>.</operator><name>s6_addr32</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xffff0000</literal> <operator>&amp;&amp;</operator>
	        <name>ipv6Addr</name> <operator>&gt;=</operator> <literal type="number">0x92703d68</literal> <operator>&amp;&amp;</operator> <name>ipv6Addr</name> <operator>&lt;=</operator> <literal type="number">0x92703d6e</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type> <name><name>answer</name><index>[<expr><name>ADDRSTRLEN</name></expr>]</index></name></decl>;</decl_stmt> <expr_stmt><expr><name><name>answer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name>AF_INET6</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>answer</name></expr></argument>, <argument><expr><name>ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Upstream responded with known blocking page (IPv6), ID %i:\n\t\"%s\" -&gt; \"%s\""</literal></expr></argument>,
			     <argument><expr><name><name>query</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name><name>domain</name><operator>-&gt;</operator><name>domainpos</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>answer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Update status</comment>
		<return>return <expr><name>QUERY_EXTERNAL_BLOCKED_IP</name></expr>;</return>
	</block_content>}</block></if>

	<comment type="line">// If upstream replied with 0.0.0.0 or ::,</comment>
	<comment type="line">// we assume that it filtered the reply as</comment>
	<comment type="line">// nothing is reachable under these addresses</comment>
	<if type="elseif">else if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_IPV4</name> <operator>&amp;&amp;</operator> <name>ipv4Addr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Upstream responded with 0.0.0.0, ID %i:\n\t\"%s\" -&gt; \"0.0.0.0\""</literal></expr></argument>,
			     <argument><expr><name><name>query</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name><name>domain</name><operator>-&gt;</operator><name>domainpos</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Update status</comment>
		<return>return <expr><name>QUERY_EXTERNAL_BLOCKED_NULL</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_IPV6</name> <operator>&amp;&amp;</operator>
	        <name><name>addr</name><operator>-&gt;</operator><name>addr6</name><operator>.</operator><name>s6_addr32</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
	        <name><name>addr</name><operator>-&gt;</operator><name>addr6</name><operator>.</operator><name>s6_addr32</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
	        <name><name>addr</name><operator>-&gt;</operator><name>addr6</name><operator>.</operator><name>s6_addr32</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
	        <name><name>addr</name><operator>-&gt;</operator><name>addr6</name><operator>.</operator><name>s6_addr32</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Upstream responded with ::, ID %i:\n\t\"%s\" -&gt; \"::\""</literal></expr></argument>,
			     <argument><expr><name><name>query</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name><name>domain</name><operator>-&gt;</operator><name>domainpos</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Update status</comment>
		<return>return <expr><name>QUERY_EXTERNAL_BLOCKED_NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Nothing happened here</comment>
	<return>return <expr><name><name>query</name><operator>-&gt;</operator><name>status</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>query_blocked</name><parameter_list>(<parameter><decl><type><name>queriesData</name><modifier>*</modifier></type> <name>query</name></decl></parameter>, <parameter><decl><type><name>domainsData</name><modifier>*</modifier></type> <name>domain</name></decl></parameter>, <parameter><decl><type><name>clientsData</name><modifier>*</modifier></type> <name>client</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>enum</name> <name>query_status</name></name></type> <name>new_status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Get response time</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>response</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>response</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Adjust counters if we recorded a non-blocking status</comment>
	<if_stmt><if>if<condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>QUERY_FORWARDED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Get forward pointer</comment>
		<decl_stmt><decl><type><name>upstreamsData</name><modifier>*</modifier></type> <name>upstream</name> <init>= <expr><call><name>getUpstream</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>upstreamID</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>upstream</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>timeidx</name> <init>= <expr><call><name>getOverTimeID</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>timestamp</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>upstream</name><operator>-&gt;</operator><name>overTime</name><index>[<expr><name>timeidx</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><call><name>is_blocked</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Already a blocked query, no need to change anything</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>is_blocked</name><argument_list>(<argument><expr><name>new_status</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Count as blocked query</comment>
		<if_stmt><if>if<condition>(<expr><name>domain</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>domain</name><operator>-&gt;</operator><name>blockedcount</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if<condition>(<expr><name>client</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>change_clientcount</name><argument_list>(<argument><expr><name>client</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>blocked</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Update status</comment>
	<expr_stmt><expr><call><name>query_set_status</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>new_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>FTL_dnssec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>union</name> <name>all_addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Process DNSSEC result for a domain</comment>

	<comment type="line">// Lock shared memory</comment>
	<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Search for corresponding query identified by ID</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>queryID</name> <init>= <expr><call><name>findQueryID</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>queryID</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// This may happen e.g. if the original query was an unhandled query type</comment>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Get query pointer</comment>
	<decl_stmt><decl><type><name>queriesData</name><modifier>*</modifier></type> <name>query</name> <init>= <expr><call><name>getQuery</name><argument_list>(<argument><expr><name>queryID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>query</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Memory error, skip this DNSSEC details</comment>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Debug logging</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Get domain pointer</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>domainsData</name><modifier>*</modifier></type> <name>domain</name> <init>= <expr><call><name>getDomain</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>domainID</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>domain</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"**** DNSSEC %s is %s (ID %i, %s:%i)"</literal></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name><name>domain</name><operator>-&gt;</operator><name>domainpos</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if<condition>(<expr><name>addr</name> <operator>&amp;&amp;</operator> <name><name>addr</name><operator>-&gt;</operator><name>log</name><operator>.</operator><name>ede</name></name> <operator>!=</operator> <name>EDE_UNSET</name></expr>)</condition><block type="pseudo"><block_content> <comment type="line">// This function is only called if (flags &amp; F_SECSTAT)</comment>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     EDE: %s (%d)"</literal></expr></argument>, <argument><expr><call><name>edestr</name><argument_list>(<argument><expr><name><name>addr</name><operator>-&gt;</operator><name>log</name><operator>.</operator><name>ede</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>log</name><operator>.</operator><name>ede</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Store EDE</comment>
	<if_stmt><if>if<condition>(<expr><name>addr</name> <operator>&amp;&amp;</operator> <name><name>addr</name><operator>-&gt;</operator><name>log</name><operator>.</operator><name>ede</name></name> <operator>!=</operator> <name>EDE_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>ede</name></name> <operator>=</operator> <name><name>addr</name><operator>-&gt;</operator><name>log</name><operator>.</operator><name>ede</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Iterate through possible values</comment>
	<if_stmt><if>if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"SECURE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>query_set_dnssec</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>DNSSEC_SECURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"INSECURE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>query_set_dnssec</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>DNSSEC_INSECURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"BOGUS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>query_set_dnssec</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>DNSSEC_BOGUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"ABANDONED"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>query_set_dnssec</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>DNSSEC_ABANDONED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"***** Ignored unknown DNSSEC status \"%s\""</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="line">// Unlock shared memory</comment>
	<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>FTL_upstream_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>union</name> <name>all_addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Process local and upstream errors</comment>
	<comment type="line">// Queries with error are those where the RCODE</comment>
	<comment type="line">// in the DNS header is neither NOERROR nor NXDOMAIN.</comment>

	<comment type="line">// Return early if there is nothing we can analyze here (shouldn't happen)</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>addr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="line">// Record response time before queuing for the lock</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>response</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>response</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Lock shared memory</comment>
	<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Search for corresponding query identified by ID</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>queryID</name> <init>= <expr><call><name>findQueryID</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>queryID</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// This may happen e.g. if the original query was an unhandled query type</comment>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Get query pointer</comment>
	<decl_stmt><decl><type><name>queriesData</name><modifier>*</modifier></type> <name>query</name> <init>= <expr><call><name>getQuery</name><argument_list>(<argument><expr><name>queryID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>query</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Memory error, skip this query</comment>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Update upstream server if necessary</comment>
	<expr_stmt><expr><call><name>update_upstream</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Translate dnsmasq's rcode into something we can use</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rcodestr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>enum</name> <name>reply_type</name></name></type> <name>reply</name></decl>;</decl_stmt>
	<switch>switch<condition>(<expr><name><name>addr</name><operator>-&gt;</operator><name>log</name><operator>.</operator><name>rcode</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SERVFAIL</name></expr>:</case>
			<expr_stmt><expr><name>rcodestr</name> <operator>=</operator> <literal type="string">"SERVFAIL"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>reply</name> <operator>=</operator> <name>REPLY_SERVFAIL</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>REFUSED</name></expr>:</case>
			<expr_stmt><expr><name>rcodestr</name> <operator>=</operator> <literal type="string">"REFUSED"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>reply</name> <operator>=</operator> <name>REPLY_REFUSED</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>NOTIMP</name></expr>:</case>
			<expr_stmt><expr><name>rcodestr</name> <operator>=</operator> <literal type="string">"NOT IMPLEMENTED"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>reply</name> <operator>=</operator> <name>REPLY_NOTIMP</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>rcodestr</name> <operator>=</operator> <literal type="string">"UNKNOWN"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>reply</name> <operator>=</operator> <name>REPLY_OTHER</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="line">// Debug logging</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Get domain pointer</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>domainsData</name><modifier>*</modifier></type> <name>domain</name> <init>= <expr><call><name>getDomain</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>domainID</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// Get domain name</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>domainname</name></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>domain</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>domainname</name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name><name>domain</name><operator>-&gt;</operator><name>domainpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>domainname</name> <operator>=</operator> <literal type="string">"&lt;cannot access domain struct&gt;"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_CONFIG</name></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// Log local error, typically "nowhere to forward to"</comment>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"**** local error (nowhere to forward to): %s is %s (ID %i, %s:%i)"</literal></expr></argument>,
			     <argument><expr><name>domainname</name></expr></argument>, <argument><expr><name>rcodestr</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if<condition>(<expr><name><name>last_server</name><operator>.</operator><name>sa</name><operator>.</operator><name>sa_family</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// Log error reply from unknown source</comment>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"**** got error reply: %s is %s (ID %i, %s:%i)"</literal></expr></argument>,
			     <argument><expr><name>domainname</name></expr></argument>, <argument><expr><name>rcodestr</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type> <name><name>ip</name><index>[<expr><name>ADDRSTRLEN</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>in_port_t</name></type> <name>port</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>mysockaddr_extract_ip_port</name><argument_list>(<argument><expr><operator>&amp;</operator><name>last_server</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="line">// Log server which replied to our request</comment>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"**** got error reply from %s#%d: %s is %s (ID %i, %s:%i)"</literal></expr></argument>,
			     <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>domainname</name></expr></argument>, <argument><expr><name>rcodestr</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if<condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>reply</name></name> <operator>==</operator> <name>REPLY_OTHER</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     Unknown rcode = %i"</literal></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>log</name><operator>.</operator><name>rcode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if<condition>(<expr><name><name>addr</name><operator>-&gt;</operator><name>log</name><operator>.</operator><name>ede</name></name> <operator>!=</operator> <name>EDE_UNSET</name></expr>)</condition><block type="pseudo"><block_content> <comment type="line">// This function is only called if (flags &amp; F_RCODE)</comment>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     EDE: %s (%d)"</literal></expr></argument>, <argument><expr><call><name>edestr</name><argument_list>(<argument><expr><name><name>addr</name><operator>-&gt;</operator><name>log</name><operator>.</operator><name>ede</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>log</name><operator>.</operator><name>ede</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Set query reply</comment>
	<expr_stmt><expr><call><name>query_set_reply</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>reply</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Unlock shared memory</comment>
	<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>FTL_mark_externally_blocked</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Lock shared memory</comment>
	<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Search for corresponding query identified by ID</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>queryID</name> <init>= <expr><call><name>findQueryID</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>queryID</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// This may happen e.g. if the original query was an unhandled query type</comment>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Get query pointer</comment>
	<decl_stmt><decl><type><name>queriesData</name><modifier>*</modifier></type> <name>query</name> <init>= <expr><call><name>getQuery</name><argument_list>(<argument><expr><name>queryID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>query</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Memory error, skip this query</comment>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Get domain pointer</comment>
	<decl_stmt><decl><type><name>domainsData</name> <modifier>*</modifier></type><name>domain</name> <init>= <expr><call><name>getDomain</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>domainID</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>domain</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Memory error, skip this query</comment>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Possible debugging information</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Get domain name (domain cannot be NULL here)</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>domainname</name> <init>= <expr><call><name>getstr</name><argument_list>(<argument><expr><name><name>domain</name><operator>-&gt;</operator><name>domainpos</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"**** %s externally blocked (ID %i, FTL %i, %s:%i)"</literal></expr></argument>, <argument><expr><name>domainname</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>queryID</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Get response time</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>response</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>response</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Store query as externally blocked</comment>
	<decl_stmt><decl><type><name>clientsData</name> <modifier>*</modifier></type><name>client</name> <init>= <expr><call><name>getClient</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>clientID</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>client</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>query_blocked</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>domain</name></expr></argument>, <argument><expr><name>client</name></expr></argument>, <argument><expr><name>QUERY_EXTERNAL_BLOCKED_NXRA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Store reply type as replied with NXDOMAIN</comment>
	<expr_stmt><expr><call><name>query_set_reply</name><argument_list>(<argument><expr><name>F_NEG</name> <operator>|</operator> <name>F_NXDOMAIN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Unlock shared memory</comment>
	<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>_FTL_header_analysis</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>header4</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>rcode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>server</name></name> <modifier>*</modifier></type><name>server</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Analyze DNS header bits</comment>

	<comment type="line">// Check if RA bit is unset in DNS header and rcode is NXDOMAIN</comment>
	<comment type="line">// If the response code (rcode) is NXDOMAIN, we may be seeing a response from</comment>
	<comment type="line">// an externally blocked query. As they are not always accompany a necessary</comment>
	<comment type="line">// SOA record, they are not getting added to our cache and, therefore,</comment>
	<comment type="line">// FTL_reply() is never getting called from within the cache routines.</comment>
	<comment type="line">// Hence, we have to store the necessary information about the NXDOMAIN</comment>
	<comment type="line">// reply already here.</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><name>header4</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>rcode</name> <operator>==</operator> <name>NXDOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="line">// RA bit is not set and rcode is NXDOMAIN</comment>
		<expr_stmt><expr><call><name>FTL_mark_externally_blocked</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Store server which sent this reply</comment>
	<if_stmt><if>if<condition>(<expr><name>server</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>last_server</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>server</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>last_server</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_EXTRA</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Got forward address: YES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>last_server</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>last_server</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_EXTRA</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Got forward address: NO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>print_flags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Debug function, listing resolver flags in clear text</comment>
	<comment type="line">// e.g. "Flags: F_FORWARD F_NEG F_IPV6"</comment>

	<comment type="line">// Only print flags if corresponding debugging flag is set</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_FLAGS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>flagstr</name> <init>= <expr><call><name>calloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>flagnames</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>flagnames</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>flagnames</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>i</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>flagstr</name></expr></argument>, <argument><expr><name><name>flagnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     Flags: %s"</literal></expr></argument>, <argument><expr><name>flagstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>flagstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_query_set_reply</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>enum</name> <name>reply_type</name></name></type> <name>reply</name></decl></parameter>,
                             <parameter><decl><type><specifier>const</specifier> <name><name>union</name> <name>all_addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>,
                             <parameter><decl><type><name>queriesData</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>timeval</name></name></type> <name>response</name></decl></parameter>,
                             <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>enum</name> <name>reply_type</name></name></type> <name>new_reply</name> <init>= <expr><name>REPLY_UNKNOWN</name></expr></init></decl>;</decl_stmt>
	<comment type="line">// If reply is set, we use it directly instead of interpreting the flags</comment>
	<if_stmt><if>if<condition>(<expr><name>reply</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>new_reply</name> <operator>=</operator> <name>reply</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="line">// else: Iterate through possible values by analyzing both the flags and the addr bits</comment>
	<if type="elseif">else if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_NEG</name> <operator>||</operator>
	        <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>F_NOERR</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>F_IPV4</name> <operator>|</operator> <name>F_IPV6</name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>||</operator> <comment type="line">// &lt;-- FTL_make_answer() when no A or AAAA is added</comment>
	        <name>force_next_DNS_reply</name> <operator>==</operator> <name>REPLY_NXDOMAIN</name> <operator>||</operator>
	        <name>force_next_DNS_reply</name> <operator>==</operator> <name>REPLY_NODATA</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_NXDOMAIN</name> <operator>||</operator> <name>force_next_DNS_reply</name> <operator>==</operator> <name>REPLY_NXDOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="line">// NXDOMAIN</comment>
			<expr_stmt><expr><name>new_reply</name> <operator>=</operator> <name>REPLY_NXDOMAIN</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<comment type="line">// NODATA(-IPv6)</comment>
			<expr_stmt><expr><name>new_reply</name> <operator>=</operator> <name>REPLY_NODATA</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_CNAME</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="line">// &lt;CNAME&gt;</comment>
		<expr_stmt><expr><name>new_reply</name> <operator>=</operator> <name>REPLY_CNAME</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_REVERSE</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="line">// reserve lookup</comment>
		<expr_stmt><expr><name>new_reply</name> <operator>=</operator> <name>REPLY_DOMAIN</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_RRNAME</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="line">// TXT query</comment>
		<expr_stmt><expr><name>new_reply</name> <operator>=</operator> <name>REPLY_RRNAME</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if<condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>F_RCODE</name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <name>force_next_DNS_reply</name> <operator>==</operator> <name>REPLY_REFUSED</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><operator>(</operator><name>addr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>addr</name><operator>-&gt;</operator><name>log</name><operator>.</operator><name>rcode</name></name> <operator>==</operator> <name>REFUSED</name><operator>)</operator>
		   <operator>||</operator> <name>force_next_DNS_reply</name> <operator>==</operator> <name>REPLY_REFUSED</name></expr> )</condition>
		<block>{<block_content>
			<comment type="line">// REFUSED query</comment>
			<expr_stmt><expr><name>new_reply</name> <operator>=</operator> <name>REPLY_REFUSED</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if<condition>(<expr><name>addr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>addr</name><operator>-&gt;</operator><name>log</name><operator>.</operator><name>rcode</name></name> <operator>==</operator> <name>SERVFAIL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// SERVFAIL query</comment>
			<expr_stmt><expr><name>new_reply</name> <operator>=</operator> <name>REPLY_SERVFAIL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>F_KEYTAG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>new_reply</name> <operator>=</operator> <name>REPLY_DNSSEC</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if<condition>(<expr><name>force_next_DNS_reply</name> <operator>==</operator> <name>REPLY_NONE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>new_reply</name> <operator>=</operator> <name>REPLY_NONE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>F_IPV4</name> <operator>|</operator> <name>F_IPV6</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// IP address</comment>
		<expr_stmt><expr><name>new_reply</name> <operator>=</operator> <name>REPLY_IP</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="line">// Other binary, possibly proprietry, data</comment>
		<expr_stmt><expr><name>new_reply</name> <operator>=</operator> <name>REPLY_BLOB</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>short_path</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Set reply to %s (%d) in %s:%d"</literal></expr></argument>, <argument><expr><call><name>get_query_reply_str</name><argument_list>(<argument><expr><name>new_reply</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>new_reply</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>reply</name></name> <operator>!=</operator> <name>REPLY_UNKNOWN</name> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>reply</name></name> <operator>!=</operator> <name>new_reply</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Reply of query %i was %s now changing to %s"</literal></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,
			     <argument><expr><call><name>get_query_reply_str</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>reply</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>get_query_reply_str</name><argument_list>(<argument><expr><name>new_reply</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Subtract from old reply counter</comment>
	<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>reply</name><index>[<expr><name><name>query</name><operator>-&gt;</operator><name>reply</name></name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
	<comment type="line">// Add to new reply counter</comment>
	<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>reply</name><index>[<expr><name>new_reply</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
	<comment type="line">// Store reply type</comment>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <name>new_reply</name></expr>;</expr_stmt>

	<comment type="line">// Save response time</comment>
	<comment type="line">// Skipped internally if already computed</comment>
	<expr_stmt><expr><call><name>set_response_time</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>FTL_fork_and_bind_sockets</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>passwd</name></name> <modifier>*</modifier></type><name>ent_pw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Going into daemon mode involves storing the</comment>
	<comment type="line">// PID of the generated child process. If FTL</comment>
	<comment type="line">// is asked to stay in foreground, we just save</comment>
	<comment type="line">// the PID of the current process in the PID file</comment>
	<if_stmt><if>if<condition>(<expr><name>daemonmode</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>go_daemon</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>savepid</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="line">// Handle real-time signals in this process (and its children)</comment>
	<comment type="line">// Helper processes are already split from the main instance</comment>
	<comment type="line">// so they will not listen to real-time signals</comment>
	<expr_stmt><expr><call><name>handle_realtime_signals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// We will use the attributes object later to start all threads in</comment>
	<comment type="line">// detached mode</comment>
	<decl_stmt><decl><type><name>pthread_attr_t</name></type> <name>attr</name></decl>;</decl_stmt>
	<comment type="line">// Initialize thread attributes object with default attribute values</comment>
	<expr_stmt><expr><call><name>pthread_attr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Start listening on telnet-like interface</comment>
	<expr_stmt><expr><call><name>listen_telnet</name><argument_list>(<argument><expr><name>TELNETv4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>listen_telnet</name><argument_list>(<argument><expr><name>TELNETv6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>listen_telnet</name><argument_list>(<argument><expr><name>TELNET_SOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Start database thread if database is used</comment>
	<if_stmt><if>if<condition>(<expr><call><name>pthread_create</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>threads</name><index>[<expr><name>DB</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>DB_thread</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Unable to open database thread. Exiting..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Start thread that will stay in the background until garbage</comment>
	<comment type="line">// collection needs to be done</comment>
	<if_stmt><if>if<condition>(<expr><call><name>pthread_create</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>threads</name><index>[<expr><name>GC</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>GC_thread</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Unable to open GC thread. Exiting..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Start thread that will stay in the background until host names needs to</comment>
	<comment type="line">// be resolved. If configuration does not ask for never resolving hostnames</comment>
	<comment type="line">// (e.g. on CI builds), the thread is never started)</comment>
	<if_stmt><if>if<condition>(<expr><call><name>resolve_names</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>pthread_create</name><argument_list>( <argument><expr><operator>&amp;</operator><name><name>threads</name><index>[<expr><name>DNSclient</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>DNSclient_thread</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> )</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Unable to open DNS client thread. Exiting..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Chown files if FTL started as user root but a dnsmasq config</comment>
	<comment type="line">// option states to run as a different user/group (e.g. "nobody")</comment>
	<if_stmt><if>if<condition>(<expr><call><name>getuid</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Only print this and change ownership of shmem objects when</comment>
		<comment type="line">// we're actually dropping root (user/group my be set to root)</comment>
		<if_stmt><if>if<condition>(<expr><name>ent_pw</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>ent_pw</name><operator>-&gt;</operator><name>pw_uid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"INFO: FTL is going to drop from root to user %s (UID %d)"</literal></expr></argument>,
			     <argument><expr><name><name>ent_pw</name><operator>-&gt;</operator><name>pw_name</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>ent_pw</name><operator>-&gt;</operator><name>pw_uid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><call><name>chown</name><argument_list>(<argument><expr><name><name>FTLfiles</name><operator>.</operator><name>log</name></name></expr></argument>, <argument><expr><name><name>ent_pw</name><operator>-&gt;</operator><name>pw_uid</name></name></expr></argument>, <argument><expr><name><name>ent_pw</name><operator>-&gt;</operator><name>pw_gid</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Setting ownership (%i:%i) of %s failed: %s (%i)"</literal></expr></argument>,
				<argument><expr><name><name>ent_pw</name><operator>-&gt;</operator><name>pw_uid</name></name></expr></argument>, <argument><expr><name><name>ent_pw</name><operator>-&gt;</operator><name>pw_gid</name></name></expr></argument>, <argument><expr><name><name>FTLfiles</name><operator>.</operator><name>log</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if<condition>(<expr><call><name>chown</name><argument_list>(<argument><expr><name><name>FTLfiles</name><operator>.</operator><name>FTL_db</name></name></expr></argument>, <argument><expr><name><name>ent_pw</name><operator>-&gt;</operator><name>pw_uid</name></name></expr></argument>, <argument><expr><name><name>ent_pw</name><operator>-&gt;</operator><name>pw_gid</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Setting ownership (%i:%i) of %s failed: %s (%i)"</literal></expr></argument>,
				<argument><expr><name><name>ent_pw</name><operator>-&gt;</operator><name>pw_uid</name></name></expr></argument>, <argument><expr><name><name>ent_pw</name><operator>-&gt;</operator><name>pw_gid</name></name></expr></argument>, <argument><expr><name><name>FTLfiles</name><operator>.</operator><name>FTL_db</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>chown_all_shmem</name><argument_list>(<argument><expr><name>ent_pw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"INFO: FTL is running as root"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>uid_t</name></type> <name>uid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name> <modifier>*</modifier></type><name>current_user</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>current_user</name> <operator>=</operator> <call><name>getpwuid</name><argument_list>(<argument><expr><name>uid</name> <operator>=</operator> <call><name>geteuid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"INFO: FTL is running as user %s (UID %d)"</literal></expr></argument>,
			     <argument><expr><name><name>current_user</name><operator>-&gt;</operator><name>pw_name</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>current_user</name><operator>-&gt;</operator><name>pw_uid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"INFO: Failed to obtain information about FTL user"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="line">// Obtain DNS port from dnsmasq daemon</comment>
	<expr_stmt><expr><name><name>config</name><operator>.</operator><name>dns_port</name></name> <operator>=</operator> <name><name>daemon</name><operator>-&gt;</operator><name>port</name></name></expr>;</expr_stmt>

	<comment type="line">// Obtain PTR record used for Pi-hole PTR injection (if enabled)</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>pihole_ptr</name></name> <operator>!=</operator> <name>PTR_NONE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Add PTR record for pi.hole, the address will be injected later</comment>
		<expr_stmt><expr><name>pihole_ptr</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>ptr_record</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pihole_ptr</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"x.x.x.x.in-addr.arpa"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pihole_ptr</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="string">""</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pihole_ptr</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<comment type="line">// Add our PTR record to the end of the linked list</comment>
		<if_stmt><if>if<condition>(<expr><name><name>daemon</name><operator>-&gt;</operator><name>ptr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// Iterate to the last PTR entry in dnsmasq's structure</comment>
			<decl_stmt><decl><type><name><name>struct</name> <name>ptr_record</name></name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
			<for>for<control>(<init><expr><name>ptr</name> <operator>=</operator> <name><name>daemon</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</init> <condition><expr><name>ptr</name> <operator>&amp;&amp;</operator> <name><name>ptr</name><operator>-&gt;</operator><name>next</name></name></expr>;</condition> <incr><expr><name>ptr</name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>

			<comment type="line">// Add our record after the last existing ptr-record</comment>
			<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>pihole_ptr</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="line">// Ours is the only record for daemon-&gt;ptr</comment>
			<expr_stmt><expr><name><name>daemon</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>pihole_ptr</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_ptrname</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>in_addr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>ptrname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<comment type="line">// Determine name that should be replied to with on Pi-hole PTRs</comment>
	<switch>switch <condition>(<expr><name><name>config</name><operator>.</operator><name>pihole_ptr</name></name></expr>)</condition>
	<block>{<block_content>
		<default>default:</default>
		<case>case <expr><name>PTR_NONE</name></expr>:</case>
		<case>case <expr><name>PTR_PIHOLE</name></expr>:</case>
			<expr_stmt><expr><name>ptrname</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="string">"pi.hole"</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PTR_HOSTNAME</name></expr>:</case>
			<expr_stmt><expr><name>ptrname</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>hostname</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PTR_HOSTNAMEFQDN</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>suffix</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>size_t</name></type> <name>ptrnamesize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<comment type="line">// get_domain() will also check conditional domains configured like</comment>
			<comment type="line">// domain=&lt;domain&gt;[,&lt;address range&gt;[,local]]</comment>
			<if_stmt><if>if<condition>(<expr><name>addr</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>suffix</name> <operator>=</operator> <call><name>get_domain</name><argument_list>(<argument><expr><operator>*</operator><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>suffix</name> <operator>=</operator> <name><name>daemon</name><operator>-&gt;</operator><name>domain_suffix</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<comment type="line">// If local suffix is not available, we substitute "no_fqdn_available"</comment>
			<comment type="line">// see the comment about PIHOLE_PTR=HOSTNAMEFQDN in the Pi-hole docs</comment>
			<comment type="line">// for further details on why this was chosen</comment>
			<if_stmt><if>if<condition>(<expr><operator>!</operator><name>suffix</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>suffix</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><literal type="string">"no_fqdn_available"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="line">// Get enough space for domain building</comment>
			<decl_stmt><decl><type><name>size_t</name></type> <name>needspace</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>hostname</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>suffix</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if<condition>(<expr><name>ptrnamesize</name> <operator>&lt;</operator> <name>needspace</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ptrname</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>ptrname</name></expr></argument>, <argument><expr><name>needspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ptrnamesize</name> <operator>=</operator> <name>needspace</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if<condition>(<expr><name>ptrname</name></expr>)</condition>
			<block>{<block_content>
				<comment type="line">// Build "&lt;hostname&gt;.&lt;local suffix&gt;" domain</comment>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>ptrname</name></expr></argument>, <argument><expr><call><name>hostname</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>ptrname</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>ptrname</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="line">// Fallback to "&lt;hostname&gt;" on memory error</comment>
				<expr_stmt><expr><name>ptrname</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>hostname</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block></switch>

	<return>return <expr><name>ptrname</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// int cache_inserted, cache_live_freed are defined in dnsmasq/cache.c</comment>
<function><type><name>void</name></type> <name>getCacheInformation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>sock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>cache_info</name></name></type> <name>ci</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>get_dnsmasq_cache_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ssend</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><literal type="string">"cache-size: %i\ncache-live-freed: %i\ncache-inserted: %i\nipv4: %i\nipv6: %i\nsrv: %i\ncname: %i\nds: %i\ndnskey: %i\nother: %i\nexpired: %i\nimmortal: %i\n"</literal></expr></argument>,
	            <argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>cachesize</name></name></expr></argument>,
	            <argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>metrics</name><index>[<expr><name>METRIC_DNS_CACHE_LIVE_FREED</name></expr>]</index></name></expr></argument>,
	            <argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>metrics</name><index>[<expr><name>METRIC_DNS_CACHE_INSERTED</name></expr>]</index></name></expr></argument>,
	            <argument><expr><name><name>ci</name><operator>.</operator><name>valid</name><operator>.</operator><name>ipv4</name></name></expr></argument>,
	            <argument><expr><name><name>ci</name><operator>.</operator><name>valid</name><operator>.</operator><name>ipv6</name></name></expr></argument>,
	            <argument><expr><name><name>ci</name><operator>.</operator><name>valid</name><operator>.</operator><name>srv</name></name></expr></argument>,
	            <argument><expr><name><name>ci</name><operator>.</operator><name>valid</name><operator>.</operator><name>cname</name></name></expr></argument>,
	            <argument><expr><name><name>ci</name><operator>.</operator><name>valid</name><operator>.</operator><name>ds</name></name></expr></argument>,
	            <argument><expr><name><name>ci</name><operator>.</operator><name>valid</name><operator>.</operator><name>dnskey</name></name></expr></argument>,
	            <argument><expr><name><name>ci</name><operator>.</operator><name>valid</name><operator>.</operator><name>other</name></name></expr></argument>,
	            <argument><expr><name><name>ci</name><operator>.</operator><name>expired</name></name></expr></argument>,
	            <argument><expr><name><name>ci</name><operator>.</operator><name>immortal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// &lt;cache-size&gt; is obvious</comment>
	<comment type="line">// It means the resolver handled &lt;cache-inserted&gt; names lookups that</comment>
	<comment type="line">// needed to be sent to upstream servers and that &lt;cache-live-freed&gt;</comment>
	<comment type="line">// was thrown out of the cache before reaching the end of its</comment>
	<comment type="line">// time-to-live, to make room for a newer name.</comment>
	<comment type="line">// For &lt;cache-live-freed&gt;, smaller is better. New queries are always</comment>
	<comment type="line">// cached. If the cache is full with entries which haven't reached</comment>
	<comment type="line">// the end of their time-to-live, then the entry which hasn't been</comment>
	<comment type="line">// looked up for the longest time is evicted.</comment>
	<comment type="line">// &lt;valid&gt; are cache entries with positive remaining TTL</comment>
	<comment type="line">// &lt;expired&gt; cache entries (to be removed when space is needed)</comment>
	<comment type="line">// &lt;immortal&gt; cache records never expire (e.g. from /etc/hosts)</comment>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>FTL_forwarding_retried</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>server</name></name> <modifier>*</modifier></type><name>serv</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>oldID</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>newID</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>dnssec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Forwarding to upstream server failed</comment>

	<if_stmt><if>if<condition>(<expr><name>oldID</name> <operator>==</operator> <name>newID</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"%d: Ignoring self-retry"</literal></expr></argument>, <argument><expr><name>oldID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Lock shared memory</comment>
	<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Try to obtain destination IP address if available</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>dest</name><index>[<expr><name>ADDRSTRLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>in_port_t</name></type> <name>upstreamPort</name> <init>= <expr><literal type="number">53</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>dest</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>serv</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>serv</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>sa</name><operator>.</operator><name>sa_family</name></name> <operator>==</operator> <name>AF_INET</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name>AF_INET</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>serv</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in</name><operator>.</operator><name>sin_addr</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>upstreamPort</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>serv</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in</name><operator>.</operator><name>sin_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name>AF_INET6</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>serv</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in6</name><operator>.</operator><name>sin6_addr</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>upstreamPort</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>serv</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>in6</name><operator>.</operator><name>sin6_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Convert upstream to lower case</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>upstreamIP</name> <init>= <expr><call><name>strdup</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>strtolower</name><argument_list>(<argument><expr><name>upstreamIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Get upstream ID</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>upstreamID</name> <init>= <expr><call><name>findUpstreamID</name><argument_list>(<argument><expr><name>upstreamIP</name></expr></argument>, <argument><expr><name>upstreamPort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Possible debugging information</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"**** RETRIED%s query %i as %i to %s#%d"</literal></expr></argument>,
		     <argument><expr><ternary><condition><expr><name>dnssec</name></expr> ?</condition><then> <expr><literal type="string">" DNSSEC"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>oldID</name></expr></argument>, <argument><expr><name>newID</name></expr></argument>,
		     <argument><expr><name>upstreamIP</name></expr></argument>, <argument><expr><name>upstreamPort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Get upstream pointer</comment>
	<decl_stmt><decl><type><name>upstreamsData</name><modifier>*</modifier></type> <name>upstream</name> <init>= <expr><call><name>getUpstream</name><argument_list>(<argument><expr><name>upstreamID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Update counter</comment>
	<if_stmt><if>if<condition>(<expr><name>upstream</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>upstream</name><operator>-&gt;</operator><name>failed</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Search for corresponding query identified by ID</comment>
	<comment type="line">// Retried DNSSEC queries are ignored, we have to flag themselves (newID)</comment>
	<comment type="line">// Retried normal queries take over, we have to flag the original query (oldID)</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>queryID</name> <init>= <expr><call><name>findQueryID</name><argument_list>(<argument><expr><ternary><condition><expr><name>dnssec</name></expr> ?</condition><then> <expr><name>newID</name></expr> </then><else>: <expr><name>oldID</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>queryID</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Get query pointer</comment>
		<decl_stmt><decl><type><name>queriesData</name><modifier>*</modifier></type> <name>query</name> <init>= <expr><call><name>getQuery</name><argument_list>(<argument><expr><name>queryID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// Set retried status</comment>
		<if_stmt><if>if<condition>(<expr><name>query</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name>dnssec</name></expr>)</condition>
			<block>{<block_content>
				<comment type="line">// There is no point in retrying the query when</comment>
				<comment type="line">// we've already got an answer to this query,</comment>
				<comment type="line">// but we're awaiting keys for DNSSEC</comment>
				<comment type="line">// validation. We're retrying the DNSSEC query</comment>
				<comment type="line">// instead</comment>
				<expr_stmt><expr><call><name>query_set_status</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>QUERY_RETRIED_DNSSEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="line">// Normal query retry due to answer not arriving</comment>
				<comment type="line">// soon enough at the requestor</comment>
				<expr_stmt><expr><call><name>query_set_status</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>QUERY_RETRIED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Clean up and unlock shared memory</comment>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>upstreamIP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier><operator>)</operator></expr></argument>)</argument_list> <name>converttimeval</name><argument_list>(<argument><expr><specifier>const</specifier> struct <name>timeval</name> <name>time</name></expr></argument>)</argument_list>
<block>{<block_content>
	<comment type="line">// Convert time from struct timeval into units</comment>
	<comment type="line">// of 10*milliseconds</comment>
	<return>return <expr><name><name>time</name><operator>.</operator><name>tv_sec</name></name><operator>*</operator><literal type="number">10000</literal> <operator>+</operator> <name><name>time</name><operator>.</operator><name>tv_usec</name></name><operator>/</operator><literal type="number">100</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name>unsigned</name> <name>int</name></type> <name>FTL_extract_question_flags</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dns_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>qlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Create working pointer</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>header</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16_t</name></type> <name>qtype</name></decl>, <decl><type ref="prev"/><name>qclass</name></decl>;</decl_stmt>

	<comment type="line">// Go through the questions</comment>
	<for>for <control>(<init><decl><type><name>uint16_t</name></type> <name>i</name> <init>= <expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>qdcount</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="line">// Prime dnsmasq flags</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><ternary><condition><expr><call><name>RCODE</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NXDOMAIN</name></expr> ?</condition><then> <expr><name>F_NXDOMAIN</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<comment type="line">// Extract name from this question</comment>
		<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><name>MAXDNAME</name></expr>]</index></name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>qlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt> <comment type="line">// bad packet, go to fallback solution</comment>

		<comment type="line">// Extract query type</comment>
		<expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>qtype</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>qclass</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Only further analyze IN questions here (not CHAOS, etc.)</comment>
		<if_stmt><if>if <condition>(<expr><name>qclass</name> <operator>!=</operator> <name>C_IN</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="line">// Very simple decision: If the question is AAAA, the reply</comment>
		<comment type="line">// should be IPv6. We use IPv4 in all other cases</comment>
		<if_stmt><if>if<condition>(<expr><name>qtype</name> <operator>==</operator> <name>T_AAAA</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>F_IPV6</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>F_IPV4</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="line">// Debug logging if enabled</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>qtype_str</name> <init>= <expr><call><name>querystr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>qtype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"CNAME header: Question was &lt;IN&gt; %s %s"</literal></expr></argument>, <argument><expr><name>qtype_str</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>flags</name></expr>;</return>
	</block_content>}</block></for>

	<comment type="line">// Fall back to IPv4 (type A) when for the unlikely event that we cannot</comment>
	<comment type="line">// find any questions in this header</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"CNAME header: No valid IN question found in header"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>F_IPV4</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Called when a (forked) TCP worker is terminated by receiving SIGALRM</comment>
<comment type="line">// We close the dedicated database connection this client had opened</comment>
<comment type="line">// to avoid dangling database locks</comment>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>atomic_flag</name></type> <name>worker_already_terminating</name> <init>= <expr><name>ATOMIC_FLAG_INIT</name></expr></init></decl>;</decl_stmt>
<function><type><name>void</name></type> <name>FTL_TCP_worker_terminating</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>finished</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>dnsmasq_debug</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Nothing to be done here, forking does not happen in debug mode</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>atomic_flag_test_and_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>worker_already_terminating</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"TCP worker already terminating!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Possible debug logging</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reason</name> <init>= <expr><ternary><condition><expr><name>finished</name></expr> ?</condition><then> <expr><literal type="string">"client disconnected"</literal></expr> </then><else>: <expr><literal type="string">"timeout"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"TCP worker terminating (%s)"</literal></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>main_pid</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// If this is not really a fork (e.g. in debug mode), we don't</comment>
		<comment type="line">// actually close gravity here</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// First check if we already locked before. This can happen when a fork</comment>
	<comment type="line">// is running into a timeout while it is still processing something and</comment>
	<comment type="line">// still holding a lock.</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>is_our_lock</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="line">// Close dedicated database connections of this fork</comment>
	<expr_stmt><expr><call><name>gravityDB_close</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Called when a (forked) TCP worker is created</comment>
<comment type="line">// FTL forked to handle TCP connections with dedicated (forked) workers</comment>
<comment type="line">// SQLite3's mentions that carrying an open database connection across a</comment>
<comment type="line">// fork() can lead to all kinds of locking problems as SQLite3 was not</comment>
<comment type="line">// intended to work under such circumstances. Doing so may easily lead</comment>
<comment type="line">// to ending up with a corrupted database.</comment>
<function><type><name>void</name></type> <name>FTL_TCP_worker_created</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>confd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>dnsmasq_debug</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Nothing to be done here, TCP worker forking does not happen</comment>
		<comment type="line">// in debug mode</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Print this if any debug setting is enabled</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Get peer IP address (client)</comment>
		<decl_stmt><decl><type><name>char</name></type> <name><name>peer_ip</name><index>[<expr><name>ADDRSTRLEN</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>union</name> <name>mysockaddr</name></name></type> <name>peer_sockaddr</name> <init>= <expr><block>{<expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>socklen_t</name></type> <name>peer_len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr>union <name>mysockaddr</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>getpeername</name><argument_list>(<argument><expr><name>confd</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>peer_sockaddr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>peer_len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>union</name> <name>all_addr</name></name></type> <name>peer_addr</name> <init>= <expr><block>{<expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr>}</block></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>peer_sockaddr</name><operator>.</operator><name>sa</name><operator>.</operator><name>sa_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>peer_addr</name><operator>.</operator><name>addr6</name></name> <operator>=</operator> <name><name>peer_sockaddr</name><operator>.</operator><name>in6</name><operator>.</operator><name>sin6_addr</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>peer_addr</name><operator>.</operator><name>addr4</name></name> <operator>=</operator> <name><name>peer_sockaddr</name><operator>.</operator><name>in</name><operator>.</operator><name>sin_addr</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name><name>peer_sockaddr</name><operator>.</operator><name>sa</name><operator>.</operator><name>sa_family</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>peer_addr</name></expr></argument>, <argument><expr><name>peer_ip</name></expr></argument>, <argument><expr><name>ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Get local IP address (interface)</comment>
		<decl_stmt><decl><type><name>char</name></type> <name><name>local_ip</name><index>[<expr><name>ADDRSTRLEN</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>union</name> <name>mysockaddr</name></name></type> <name>iface_sockaddr</name> <init>= <expr><block>{<expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>socklen_t</name></type> <name>iface_len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr>union <name>mysockaddr</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>getsockname</name><argument_list>(<argument><expr><name>confd</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>iface_sockaddr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iface_len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>union</name> <name>all_addr</name></name></type> <name>iface_addr</name> <init>= <expr><block>{<expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr>}</block></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>iface_sockaddr</name><operator>.</operator><name>sa</name><operator>.</operator><name>sa_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>iface_addr</name><operator>.</operator><name>addr6</name></name> <operator>=</operator> <name><name>iface_sockaddr</name><operator>.</operator><name>in6</name><operator>.</operator><name>sin6_addr</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>iface_addr</name><operator>.</operator><name>addr4</name></name> <operator>=</operator> <name><name>iface_sockaddr</name><operator>.</operator><name>in</name><operator>.</operator><name>sin_addr</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>inet_ntop</name><argument_list>(<argument><expr><name><name>iface_sockaddr</name><operator>.</operator><name>sa</name><operator>.</operator><name>sa_family</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iface_addr</name></expr></argument>, <argument><expr><name>local_ip</name></expr></argument>, <argument><expr><name>ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Print log</comment>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"TCP worker forked for client %s on interface %s with IP %s"</literal></expr></argument>, <argument><expr><name>peer_ip</name></expr></argument>, <argument><expr><name><name>next_iface</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>local_ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>main_pid</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// If this is not really a fork (e.g. in debug mode), we don't</comment>
		<comment type="line">// actually re-open gravity or close sockets here</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Reopen gravity database handle in this fork as the main process's</comment>
	<comment type="line">// handle isn't valid here</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Reopening Gravity database for this fork"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>gravityDB_forked</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>FTL_unlink_DHCP_lease</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ipaddr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>dhcp_lease</name></name> <modifier>*</modifier></type><name>lease</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>union</name> <name>all_addr</name></name></type> <name>addr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>time_t</name></type> <name>now</name> <init>= <expr><call><name>dnsmasq_time</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Try to extract IP address</comment>
	<if_stmt><if>if <condition>(<expr><call><name>inet_pton</name><argument_list>(<argument><expr><name>AF_INET</name></expr></argument>, <argument><expr><name>ipaddr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>addr</name><operator>.</operator><name>addr4</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>lease</name> <operator>=</operator> <call><name>lease_find_by_addr</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>addr4</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DHCP6</name></cpp:ifdef>
	<if type="elseif">else if <condition>(<expr><call><name>inet_pton</name><argument_list>(<argument><expr><name>AF_INET6</name></expr></argument>, <argument><expr><name>ipaddr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>addr</name><operator>.</operator><name>addr6</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>lease</name> <operator>=</operator> <call><name>lease6_find_by_addr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>addr</name><operator>.</operator><name>addr6</name></name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="line">// If a lease exists for this IP address, we unlink it and immediately</comment>
	<comment type="line">// update the lease file to reflect the removal of this lease</comment>
	<if_stmt><if>if <condition>(<expr><name>lease</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Unlink the lease for dnsmasq's database</comment>
		<expr_stmt><expr><call><name>lease_prune</name><argument_list>(<argument><expr><name>lease</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// Update the lease file</comment>
		<expr_stmt><expr><call><name>lease_update_file</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="line">// Argument force == 0 ensures the DNS records are only updated</comment>
		<comment type="line">// when unlinking the lease above actually changed something</comment>
		<comment type="line">// (variable lease.c:dns_dirty is used here)</comment>
		<expr_stmt><expr><call><name>lease_update_dns</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Return success</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>FTL_query_in_progress</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Query (possibly from new source), but the same query may be in</comment>
	<comment type="line">// progress from another source.</comment>

	<comment type="line">// Lock shared memory</comment>
	<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Search for corresponding query identified by ID</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>queryID</name> <init>= <expr><call><name>findQueryID</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>queryID</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// This may happen e.g. if the original query was an unhandled query type</comment>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Get query pointer</comment>
	<decl_stmt><decl><type><name>queriesData</name><modifier>*</modifier></type> <name>query</name> <init>= <expr><call><name>getQuery</name><argument_list>(<argument><expr><name>queryID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>query</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Memory error, skip this DNSSEC details</comment>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Debug logging</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Get domain pointer</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>domainsData</name><modifier>*</modifier></type> <name>domain</name> <init>= <expr><call><name>getDomain</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>domainID</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>domain</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"**** query for %s is already in progress (ID %i)"</literal></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name><name>domain</name><operator>-&gt;</operator><name>domainpos</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Store status</comment>
	<expr_stmt><expr><call><name>query_set_status</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>QUERY_IN_PROGRESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Unlock shared memory</comment>
	<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>FTL_multiple_replies</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>firstID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// We are in the loop that iterates over all aggregated queries for the same</comment>
	<comment type="line">// type + domain. Every query will receive the reply here so we need to</comment>
	<comment type="line">// update the original queries to set their status</comment>

	<comment type="line">// Don't process self-duplicates</comment>
	<if_stmt><if>if<condition>(<expr><operator>*</operator><name>firstID</name> <operator>==</operator> <name>id</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="line">// Skip if the original query was not found in FTL's memory</comment>
	<if_stmt><if>if<condition>(<expr><operator>*</operator><name>firstID</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="line">// Lock shared memory</comment>
	<expr_stmt><expr><call><name>lock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Search for corresponding query identified by ID</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>queryID</name> <init>= <expr><call><name>findQueryID</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>queryID</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// This may happen e.g. if the original query was an unhandled query type</comment>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>firstID</name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><operator>*</operator><name>firstID</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// This is not yet a duplicate, we just store the ID</comment>
		<comment type="line">// of the successful reply here so we can get it quicker</comment>
		<comment type="line">// during the next loop iterations</comment>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>firstID</name> <operator>=</operator> <name>queryID</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Get (read-only) pointer of the query that contains all relevant</comment>
	<comment type="line">// information (all others are mere duplicates and were only added to the</comment>
	<comment type="line">// list of duplicates rather than havong been forwarded on their own)</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>queriesData</name><modifier>*</modifier></type> <name>source_query</name> <init>= <expr><call><name>getQuery</name><argument_list>(<argument><expr><operator>*</operator><name>firstID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// Get query pointer of duplicated reply</comment>
	<decl_stmt><decl><type><name>queriesData</name><modifier>*</modifier></type> <name>duplicated_query</name> <init>= <expr><call><name>getQuery</name><argument_list>(<argument><expr><name>queryID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>duplicated_query</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>source_query</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Memory error, skip this duplicate</comment>
		<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Debug logging</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_QUERIES</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"**** sending reply %d also to %d"</literal></expr></argument>, <argument><expr><operator>*</operator><name>firstID</name></expr></argument>, <argument><expr><name>queryID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Copy relevant information over</comment>
	<expr_stmt><expr><name><name>duplicated_query</name><operator>-&gt;</operator><name>reply</name></name> <operator>=</operator> <name><name>source_query</name><operator>-&gt;</operator><name>reply</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>duplicated_query</name><operator>-&gt;</operator><name>dnssec</name></name> <operator>=</operator> <name><name>source_query</name><operator>-&gt;</operator><name>dnssec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>duplicated_query</name><operator>-&gt;</operator><name>flags</name><operator>.</operator><name>complete</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>duplicated_query</name><operator>-&gt;</operator><name>CNAME_domainID</name></name> <operator>=</operator> <name><name>source_query</name><operator>-&gt;</operator><name>CNAME_domainID</name></name></expr>;</expr_stmt>

	<comment type="line">// The original query may have been blocked during CNAME inspection,</comment>
	<comment type="line">// correct status in this case</comment>
	<if_stmt><if>if<condition>(<expr><name><name>source_query</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>QUERY_FORWARDED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>query_set_status</name><argument_list>(<argument><expr><name>duplicated_query</name></expr></argument>, <argument><expr><name><name>source_query</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Unlock shared memory</comment>
	<expr_stmt><expr><call><name>unlock_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_edestr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>ede</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>edestr</name><argument_list>(<argument><expr><name>ede</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>_query_set_dnssec</name><parameter_list>(<parameter><decl><type><name>queriesData</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>enum</name> <name>dnssec_status</name></name></type> <name>dnssec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Return early if DNSSEC validation is disabled</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>option_bool</name><argument_list>(<argument><expr><name>OPT_DNSSEC_VALID</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_DNSSEC</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>status</name> <init>= <expr><literal type="string">"unknown"</literal></expr></init></decl>;</decl_stmt>
		<switch>switch<condition>(<expr><name>dnssec</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DNSSEC_UNSPECIFIED</name></expr>:</case>
				<expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="string">"unspecified"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DNSSEC_SECURE</name></expr>:</case>
				<expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="string">"SECURE"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DNSSEC_INSECURE</name></expr>:</case>
				<expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="string">"INSECURE"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DNSSEC_BOGUS</name></expr>:</case>
				<expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="string">"BOGUS"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DNSSEC_ABANDONED</name></expr>:</case>
				<expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="string">"ABANDONED"</literal></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>short_path</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Setting DNSSEC status to %s in %s:%d"</literal></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Set DNSSEC status</comment>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>dnssec</name></name> <operator>=</operator> <name>dnssec</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Check sizes of all important in-memory objects. This routine returns the number of</comment>
<comment type="line">// errors found (i.e., a return value of 0 is what we want and expect)</comment>
<function><type><name>int</name></type> <name>check_struct_sizes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>check_one_struct</name><argument_list>(<argument><expr><literal type="string">"ConfigStruct"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConfigStruct</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">112</literal></expr></argument>, <argument><expr><literal type="number">104</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>check_one_struct</name><argument_list>(<argument><expr><literal type="string">"queriesData"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>queriesData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">56</literal></expr></argument>, <argument><expr><literal type="number">44</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>check_one_struct</name><argument_list>(<argument><expr><literal type="string">"upstreamsData"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>upstreamsData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">616</literal></expr></argument>, <argument><expr><literal type="number">604</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>check_one_struct</name><argument_list>(<argument><expr><literal type="string">"clientsData"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>clientsData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">672</literal></expr></argument>, <argument><expr><literal type="number">648</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>check_one_struct</name><argument_list>(<argument><expr><literal type="string">"domainsData"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>domainsData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>check_one_struct</name><argument_list>(<argument><expr><literal type="string">"DNSCacheData"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DNSCacheData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>check_one_struct</name><argument_list>(<argument><expr><literal type="string">"ednsData"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ednsData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">72</literal></expr></argument>, <argument><expr><literal type="number">72</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>check_one_struct</name><argument_list>(<argument><expr><literal type="string">"overTimeData"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>overTimeData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>check_one_struct</name><argument_list>(<argument><expr><literal type="string">"regexData"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>regexData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">56</literal></expr></argument>, <argument><expr><literal type="number">44</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>check_one_struct</name><argument_list>(<argument><expr><literal type="string">"SharedMemory"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SharedMemory</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>check_one_struct</name><argument_list>(<argument><expr><literal type="string">"ShmSettings"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmSettings</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>check_one_struct</name><argument_list>(<argument><expr><literal type="string">"countersStruct"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>countersStruct</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">248</literal></expr></argument>, <argument><expr><literal type="number">248</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>+=</operator> <call><name>check_one_struct</name><argument_list>(<argument><expr><literal type="string">"sqlite3_stmt_vec"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sqlite3_stmt_vec</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"All okay\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>check_dnsmasq_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Special domain name handling</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="line">// 1. Substitute "(NULL)" if no name is available (should not happen)</comment>
		<return>return <expr><literal type="string">"(NULL)"</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if<condition>(<expr><operator>!</operator><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="line">// 2. Substitute "." if we are querying the root domain (e.g. DNSKEY)</comment>
		<return>return <expr><literal type="string">"."</literal></expr>;</return></block_content></block></if></if_stmt>
	<comment type="line">// else</comment>
	<return>return <expr><name>name</name></expr>;</return>
</block_content>}</block></function>
</unit>
