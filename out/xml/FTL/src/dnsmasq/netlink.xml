<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/dnsmasq/netlink.c"><comment type="block">/* dnsmasq is Copyright (c) 2000-2022 Simon Kelley

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; version 2 dated June, 1991, or
   (at your option) version 3 dated 29 June, 2007.
 
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
     
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dnsmasq.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LINUX_NETWORK</name></cpp:ifdef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;linux/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;linux/netlink.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;linux/rtnetlink.h&gt;</cpp:file></cpp:include>

<comment type="block">/* Blergh. Radv does this, so that's our excuse. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SOL_NETLINK</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SOL_NETLINK</name></cpp:macro> <cpp:value>270</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NETLINK_NO_ENOBUFS</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NETLINK_NO_ENOBUFS</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* linux 2.6.19 buggers up the headers, patch it up here. */</comment> 
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>IFA_RTA</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>IFA_RTA</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro>  \
       <cpp:value>((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct ifaddrmsg))))</cpp:value></cpp:define>

<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;linux/if_addr.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDA_RTA</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>NDA_RTA</name><parameter_list>(<parameter><type><name>r</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct ndmsg))))</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Used to request refresh of addresses or routes just once,
 * when multiple changes might be announced. */</comment>
<enum>enum <name>async_states</name> <block>{
  <decl><name>STATE_NEWADDR</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>,
  <decl><name>STATE_NEWROUTE</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>,
}</block>;</enum>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>iovec</name></name></type> <name>iov</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>u32</name></type> <name>netlink_pid</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>unsigned</name></type> <name>nl_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nlmsghdr</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>nl_multicast_state</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>char</name> <modifier>*</modifier></type><name>netlink_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_nl</name></name></type> <name>addr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>socklen_t</name></type> <name>slen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>nl_family</name></name> <operator>=</operator> <name>AF_NETLINK</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>nl_pad</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>nl_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* autobind */</comment>
  <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>nl_groups</name></name> <operator>=</operator> <name>RTMGRP_IPV4_ROUTE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>nl_groups</name></name> <operator>|=</operator> <name>RTMGRP_IPV4_IFADDR</name></expr>;</expr_stmt>  
  <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>nl_groups</name></name> <operator>|=</operator> <name>RTMGRP_IPV6_ROUTE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>nl_groups</name></name> <operator>|=</operator> <name>RTMGRP_IPV6_IFADDR</name></expr>;</expr_stmt>

  <comment type="block">/* May not be able to have permission to set multicast groups don't die in that case */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>daemon</name><operator>-&gt;</operator><name>netlinkfd</name></name> <operator>=</operator> <call><name>socket</name><argument_list>(<argument><expr><name>AF_NETLINK</name></expr></argument>, <argument><expr><name>SOCK_RAW</name></expr></argument>, <argument><expr><name>NETLINK_ROUTE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>bind</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>netlinkfd</name></name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>nl_groups</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EPERM</name> <operator>||</operator> <call><name>bind</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>netlinkfd</name></name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name><name>daemon</name><operator>-&gt;</operator><name>netlinkfd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  
  <if_stmt><if>if <condition>(<expr><name><name>daemon</name><operator>-&gt;</operator><name>netlinkfd</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> 
      <call><name>getsockname</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>netlinkfd</name></name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>slen</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot create netlink socket: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>EC_MISC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  
  
  <comment type="block">/* save pid assigned by bind() and retrieved by getsockname() */</comment> 
  <expr_stmt><expr><name>netlink_pid</name> <operator>=</operator> <name><name>addr</name><operator>.</operator><name>nl_pid</name></name></expr>;</expr_stmt>
  
  <expr_stmt><expr><name><name>iov</name><operator>.</operator><name>iov_len</name></name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>iov</name><operator>.</operator><name>iov_base</name></name> <operator>=</operator> <call><name>safe_malloc</name><argument_list>(<argument><expr><name><name>iov</name><operator>.</operator><name>iov_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ssize_t</name></type> <name>netlink_recv</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>msghdr</name></name></type> <name>msg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_nl</name></name></type> <name>nladdr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ssize_t</name></type> <name>rc</name></decl>;</decl_stmt>

  <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_control</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_controllen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_name</name></name> <operator>=</operator> <operator>&amp;</operator><name>nladdr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_namelen</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>nladdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_iov</name></name> <operator>=</operator> <operator>&amp;</operator><name>iov</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_iovlen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      
      <while>while <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>recvmsg</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>netlinkfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>flags</name> <operator>|</operator> <name>MSG_PEEK</name> <operator>|</operator> <name>MSG_TRUNC</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
	     <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>
      
      <comment type="block">/* make buffer big enough */</comment>
      <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>msg</name><operator>.</operator><name>msg_flags</name></name> <operator>&amp;</operator> <name>MSG_TRUNC</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
	  <comment type="block">/* Very new Linux kernels return the actual size needed, older ones always return truncated size */</comment>
	  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator><name>rc</name> <operator>==</operator> <name><name>iov</name><operator>.</operator><name>iov_len</name></name></expr>)</condition>
	    <block>{<block_content>
	      <if_stmt><if>if <condition>(<expr><call><name>expand_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iov</name></expr></argument>, <argument><expr><name>rc</name> <operator>+</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<continue>continue;</continue></block_content></block></if></if_stmt>
	    </block_content>}</block></if>
	  <else>else<block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>expand_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iov</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

      <comment type="block">/* read it for real */</comment>
      <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <while>while <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>recvmsg</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>netlinkfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>
      
      <comment type="block">/* Make sure this is from the kernel */</comment>
      <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name><name>nladdr</name><operator>.</operator><name>nl_pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>
      
  <comment type="block">/* discard stuff which is truncated at this point (expand_buf() may fail) */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>msg</name><operator>.</operator><name>msg_flags</name></name> <operator>&amp;</operator> <name>MSG_TRUNC</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOMEM</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
  <return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
  

<comment type="block">/* family = AF_UNSPEC finds ARP table entries.
   family = AF_LOCAL finds MAC addresses.
   returns 0 on failure, 1 on success, -1 when restart is required
*/</comment>
<function><type><name>int</name></type> <name>iface_enumerate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>family</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>parm</name></decl></parameter>, <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>callback</name>)<parameter_list>()</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_nl</name></name></type> <name>addr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>nlmsghdr</name></name> <modifier>*</modifier></type><name>h</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>seq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>callback_ok</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>state</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <struct>struct <block>{
    <decl_stmt><decl><type><name><name>struct</name> <name>nlmsghdr</name></name></type> <name>nlh</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>rtgenmsg</name></name></type> <name>g</name></decl>;</decl_stmt> 
  }</block> <decl><name>req</name></decl>;</struct>

  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>req</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>nl_family</name></name> <operator>=</operator> <name>AF_NETLINK</name></expr>;</expr_stmt>
 
  <if_stmt><if>if <condition>(<expr><name>family</name> <operator>==</operator> <name>AF_UNSPEC</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>req</name><operator>.</operator><name>nlh</name><operator>.</operator><name>nlmsg_type</name></name> <operator>=</operator> <name>RTM_GETNEIGH</name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>family</name> <operator>==</operator> <name>AF_LOCAL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>req</name><operator>.</operator><name>nlh</name><operator>.</operator><name>nlmsg_type</name></name> <operator>=</operator> <name>RTM_GETLINK</name></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>req</name><operator>.</operator><name>nlh</name><operator>.</operator><name>nlmsg_type</name></name> <operator>=</operator> <name>RTM_GETADDR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

  <expr_stmt><expr><name><name>req</name><operator>.</operator><name>nlh</name><operator>.</operator><name>nlmsg_len</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>req</name><operator>.</operator><name>nlh</name><operator>.</operator><name>nlmsg_flags</name></name> <operator>=</operator> <name>NLM_F_ROOT</name> <operator>|</operator> <name>NLM_F_MATCH</name> <operator>|</operator> <name>NLM_F_REQUEST</name> <operator>|</operator> <name>NLM_F_ACK</name></expr>;</expr_stmt> 
  <expr_stmt><expr><name><name>req</name><operator>.</operator><name>nlh</name><operator>.</operator><name>nlmsg_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>req</name><operator>.</operator><name>nlh</name><operator>.</operator><name>nlmsg_seq</name></name> <operator>=</operator> <operator>++</operator><name>seq</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>req</name><operator>.</operator><name>g</name><operator>.</operator><name>rtgen_family</name></name> <operator>=</operator> <name>family</name></expr>;</expr_stmt> 

  <comment type="block">/* Don't block in recvfrom if send fails */</comment>
  <while>while<condition>(<expr><call><name>retry_send</name><argument_list>(<argument><expr><call><name>sendto</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>netlinkfd</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>req</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, 
			  <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>

  <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    
  <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <call><name>netlink_recv</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOBUFS</name></expr>)</condition>
	    <block>{<block_content>
	      <expr_stmt><expr><call><name>nl_multicast_state</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	    </block_content>}</block></if></if_stmt>
	  <return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

      <for>for <control>(<init><expr><name>h</name> <operator>=</operator> <operator>(</operator>struct <name>nlmsghdr</name> <operator>*</operator><operator>)</operator><name><name>iov</name><operator>.</operator><name>iov_base</name></name></expr>;</init> <condition><expr><call><name>NLMSG_OK</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>h</name> <operator>=</operator> <call><name>NLMSG_NEXT</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>
	<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>nlmsg_pid</name></name> <operator>!=</operator> <name>netlink_pid</name> <operator>||</operator> <name><name>h</name><operator>-&gt;</operator><name>nlmsg_type</name></name> <operator>==</operator> <name>NLMSG_ERROR</name></expr>)</condition>
	  <block>{<block_content>
	    <comment type="block">/* May be multicast arriving async */</comment>
	    <expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>nl_async</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  </block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>nlmsg_seq</name></name> <operator>!=</operator> <name>seq</name></expr>)</condition>
	  <block>{<block_content>
	    <comment type="block">/* May be part of incomplete response to previous request after
	       ENOBUFS. Drop it. */</comment>
	    <continue>continue;</continue>
	  </block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>nlmsg_type</name></name> <operator>==</operator> <name>NLMSG_DONE</name></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><name>callback_ok</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>nlmsg_type</name></name> <operator>==</operator> <name>RTM_NEWADDR</name> <operator>&amp;&amp;</operator> <name>family</name> <operator>!=</operator> <name>AF_UNSPEC</name> <operator>&amp;&amp;</operator> <name>family</name> <operator>!=</operator> <name>AF_LOCAL</name></expr>)</condition>
	  <block>{<block_content>
	    <decl_stmt><decl><type><name><name>struct</name> <name>ifaddrmsg</name></name> <modifier>*</modifier></type><name>ifa</name> <init>= <expr><call><name>NLMSG_DATA</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  
	    <decl_stmt><decl><type><name><name>struct</name> <name>rtattr</name></name> <modifier>*</modifier></type><name>rta</name> <init>= <expr><call><name>IFA_RTA</name><argument_list>(<argument><expr><name>ifa</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>len1</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>nlmsg_len</name></name> <operator>-</operator> <call><name>NLMSG_LENGTH</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ifa</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    
	    <if_stmt><if>if <condition>(<expr><name><name>ifa</name><operator>-&gt;</operator><name>ifa_family</name></name> <operator>==</operator> <name>family</name></expr>)</condition>
	      <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>ifa</name><operator>-&gt;</operator><name>ifa_family</name></name> <operator>==</operator> <name>AF_INET</name></expr>)</condition>
		  <block>{<block_content>
		    <decl_stmt><decl><type><name><name>struct</name> <name>in_addr</name></name></type> <name>netmask</name></decl>, <decl><type ref="prev"/><name>addr</name></decl>, <decl><type ref="prev"/><name>broadcast</name></decl>;</decl_stmt>
		    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>label</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		    <expr_stmt><expr><name><name>netmask</name><operator>.</operator><name>s_addr</name></name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><operator>~</operator><operator>(</operator><name>in_addr_t</name><operator>)</operator><literal type="number">0</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">32</literal> <operator>-</operator> <name><name>ifa</name><operator>-&gt;</operator><name>ifa_prefixlen</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		    <expr_stmt><expr><name><name>addr</name><operator>.</operator><name>s_addr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		    <expr_stmt><expr><name><name>broadcast</name><operator>.</operator><name>s_addr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		    
		    <while>while <condition>(<expr><call><name>RTA_OK</name><argument_list>(<argument><expr><name>rta</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>)</condition>
		      <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>rta</name><operator>-&gt;</operator><name>rta_type</name></name> <operator>==</operator> <name>IFA_LOCAL</name></expr>)</condition><block type="pseudo"><block_content>
			  <expr_stmt><expr><name>addr</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator>struct <name>in_addr</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>rta</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>rta</name><operator>-&gt;</operator><name>rta_type</name></name> <operator>==</operator> <name>IFA_BROADCAST</name></expr>)</condition><block type="pseudo"><block_content>
			  <expr_stmt><expr><name>broadcast</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator>struct <name>in_addr</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>rta</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>rta</name><operator>-&gt;</operator><name>rta_type</name></name> <operator>==</operator> <name>IFA_LABEL</name></expr>)</condition><block type="pseudo"><block_content>
			  <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>RTA_DATA</name><argument_list>(<argument><expr><name>rta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			
			<expr_stmt><expr><name>rta</name> <operator>=</operator> <call><name>RTA_NEXT</name><argument_list>(<argument><expr><name>rta</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      </block_content>}</block></while>
		    
		    <if_stmt><if>if <condition>(<expr><name><name>addr</name><operator>.</operator><name>s_addr</name></name> <operator>&amp;&amp;</operator> <name>callback_ok</name></expr>)</condition><block type="pseudo"><block_content>
		      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call>(<modifier>*</modifier><name>callback</name>)<argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>ifa</name><operator>-&gt;</operator><name>ifa_index</name></name></expr></argument>, <argument><expr><name>label</name></expr></argument>,  <argument><expr><name>netmask</name></expr></argument>, <argument><expr><name>broadcast</name></expr></argument>, <argument><expr><name>parm</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>callback_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
		  </block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>ifa</name><operator>-&gt;</operator><name>ifa_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr>)</condition>
		  <block>{<block_content>
		    <decl_stmt><decl><type><name><name>struct</name> <name>in6_addr</name></name> <modifier>*</modifier></type><name>addrp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		    <decl_stmt><decl><type><name>u32</name></type> <name>valid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>preferred</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		    <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		    
		    <while>while <condition>(<expr><call><name>RTA_OK</name><argument_list>(<argument><expr><name>rta</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>)</condition>
		      <block>{<block_content>
			<comment type="block">/*
			 * Important comment: (from if_addr.h)
			 * IFA_ADDRESS is prefix address, rather than local interface address.
			 * It makes no difference for normally configured broadcast interfaces,
			 * but for point-to-point IFA_ADDRESS is DESTINATION address,
			 * local address is supplied in IFA_LOCAL attribute.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rta</name><operator>-&gt;</operator><name>rta_type</name></name> <operator>==</operator> <name>IFA_LOCAL</name></expr>)</condition><block type="pseudo"><block_content>
			  <expr_stmt><expr><name>addrp</name> <operator>=</operator> <operator>(</operator><operator>(</operator>struct <name>in6_addr</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>rta</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>rta</name><operator>-&gt;</operator><name>rta_type</name></name> <operator>==</operator> <name>IFA_ADDRESS</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>addrp</name></expr>)</condition><block type="pseudo"><block_content>
			  <expr_stmt><expr><name>addrp</name> <operator>=</operator> <operator>(</operator><operator>(</operator>struct <name>in6_addr</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>rta</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></if> 
			<if type="elseif">else if <condition>(<expr><name><name>rta</name><operator>-&gt;</operator><name>rta_type</name></name> <operator>==</operator> <name>IFA_CACHEINFO</name></expr>)</condition>
			  <block>{<block_content>
			    <decl_stmt><decl><type><name><name>struct</name> <name>ifa_cacheinfo</name></name> <modifier>*</modifier></type><name>ifc</name> <init>= <expr><operator>(</operator>struct <name>ifa_cacheinfo</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>rta</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
			    <expr_stmt><expr><name>preferred</name> <operator>=</operator> <name><name>ifc</name><operator>-&gt;</operator><name>ifa_prefered</name></name></expr>;</expr_stmt>
			    <expr_stmt><expr><name>valid</name> <operator>=</operator> <name><name>ifc</name><operator>-&gt;</operator><name>ifa_valid</name></name></expr>;</expr_stmt>
			  </block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>rta</name> <operator>=</operator> <call><name>RTA_NEXT</name><argument_list>(<argument><expr><name>rta</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      </block_content>}</block></while>
		    
		    <if_stmt><if>if <condition>(<expr><name><name>ifa</name><operator>-&gt;</operator><name>ifa_flags</name></name> <operator>&amp;</operator> <name>IFA_F_TENTATIVE</name></expr>)</condition><block type="pseudo"><block_content>
		      <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>IFACE_TENTATIVE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		    
		    <if_stmt><if>if <condition>(<expr><name><name>ifa</name><operator>-&gt;</operator><name>ifa_flags</name></name> <operator>&amp;</operator> <name>IFA_F_DEPRECATED</name></expr>)</condition><block type="pseudo"><block_content>
		      <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>IFACE_DEPRECATED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		    
		    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ifa</name><operator>-&gt;</operator><name>ifa_flags</name></name> <operator>&amp;</operator> <name>IFA_F_TEMPORARY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		      <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>IFACE_PERMANENT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    		    
		    <if_stmt><if>if <condition>(<expr><name>addrp</name> <operator>&amp;&amp;</operator> <name>callback_ok</name></expr>)</condition><block type="pseudo"><block_content>
		      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call>(<modifier>*</modifier><name>callback</name>)<argument_list>(<argument><expr><name>addrp</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>ifa</name><operator>-&gt;</operator><name>ifa_prefixlen</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>ifa</name><operator>-&gt;</operator><name>ifa_scope</name></name><operator>)</operator></expr></argument>, 
					<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>ifa</name><operator>-&gt;</operator><name>ifa_index</name></name><operator>)</operator></expr></argument>, <argument><expr><name>flags</name></expr></argument>, 
					<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>preferred</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>valid</name></expr></argument>, <argument><expr><name>parm</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>callback_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
		  </block_content>}</block></if></if_stmt>
	      </block_content>}</block></if></if_stmt>
	  </block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>nlmsg_type</name></name> <operator>==</operator> <name>RTM_NEWNEIGH</name> <operator>&amp;&amp;</operator> <name>family</name> <operator>==</operator> <name>AF_UNSPEC</name></expr>)</condition>
	  <block>{<block_content>
	    <decl_stmt><decl><type><name><name>struct</name> <name>ndmsg</name></name> <modifier>*</modifier></type><name>neigh</name> <init>= <expr><call><name>NLMSG_DATA</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  
	    <decl_stmt><decl><type><name><name>struct</name> <name>rtattr</name></name> <modifier>*</modifier></type><name>rta</name> <init>= <expr><call><name>NDA_RTA</name><argument_list>(<argument><expr><name>neigh</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>len1</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>nlmsg_len</name></name> <operator>-</operator> <call><name>NLMSG_LENGTH</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>neigh</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>size_t</name></type> <name>maclen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>inaddr</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>mac</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	    
	    <while>while <condition>(<expr><call><name>RTA_OK</name><argument_list>(<argument><expr><name>rta</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>)</condition>
	      <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rta</name><operator>-&gt;</operator><name>rta_type</name></name> <operator>==</operator> <name>NDA_DST</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><name>inaddr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>rta</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rta</name><operator>-&gt;</operator><name>rta_type</name></name> <operator>==</operator> <name>NDA_LLADDR</name></expr>)</condition>
		  <block>{<block_content>
		    <expr_stmt><expr><name>maclen</name> <operator>=</operator> <name><name>rta</name><operator>-&gt;</operator><name>rta_len</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>rtattr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		    <expr_stmt><expr><name>mac</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>rta</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		  </block_content>}</block></if></if_stmt>
		
		<expr_stmt><expr><name>rta</name> <operator>=</operator> <call><name>RTA_NEXT</name><argument_list>(<argument><expr><name>rta</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      </block_content>}</block></while>

	    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>neigh</name><operator>-&gt;</operator><name>ndm_state</name></name> <operator>&amp;</operator> <operator>(</operator><name>NUD_NOARP</name> <operator>|</operator> <name>NUD_INCOMPLETE</name> <operator>|</operator> <name>NUD_FAILED</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>inaddr</name> <operator>&amp;&amp;</operator> <name>mac</name> <operator>&amp;&amp;</operator> <name>callback_ok</name></expr>)</condition><block type="pseudo"><block_content>
	      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call>(<modifier>*</modifier><name>callback</name>)<argument_list>(<argument><expr><name><name>neigh</name><operator>-&gt;</operator><name>ndm_family</name></name></expr></argument>, <argument><expr><name>inaddr</name></expr></argument>, <argument><expr><name>mac</name></expr></argument>, <argument><expr><name>maclen</name></expr></argument>, <argument><expr><name>parm</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>callback_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
	  </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DHCP6</name></cpp:ifdef>
	<if type="elseif">else if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>nlmsg_type</name></name> <operator>==</operator> <name>RTM_NEWLINK</name> <operator>&amp;&amp;</operator> <name>family</name> <operator>==</operator> <name>AF_LOCAL</name></expr>)</condition>
	  <block>{<block_content>
	    <decl_stmt><decl><type><name><name>struct</name> <name>ifinfomsg</name></name> <modifier>*</modifier></type><name>link</name> <init>=  <expr><call><name>NLMSG_DATA</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name><name>struct</name> <name>rtattr</name></name> <modifier>*</modifier></type><name>rta</name> <init>= <expr><call><name>IFLA_RTA</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>len1</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>nlmsg_len</name></name> <operator>-</operator> <call><name>NLMSG_LENGTH</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>link</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>mac</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>size_t</name></type> <name>maclen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	    <while>while <condition>(<expr><call><name>RTA_OK</name><argument_list>(<argument><expr><name>rta</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>)</condition>
	      <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rta</name><operator>-&gt;</operator><name>rta_type</name></name> <operator>==</operator> <name>IFLA_ADDRESS</name></expr>)</condition>
		  <block>{<block_content>
		    <expr_stmt><expr><name>maclen</name> <operator>=</operator> <name><name>rta</name><operator>-&gt;</operator><name>rta_len</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>rtattr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		    <expr_stmt><expr><name>mac</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>rta</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		  </block_content>}</block></if></if_stmt>
		
		<expr_stmt><expr><name>rta</name> <operator>=</operator> <call><name>RTA_NEXT</name><argument_list>(<argument><expr><name>rta</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      </block_content>}</block></while>

	    <if_stmt><if>if <condition>(<expr><name>mac</name> <operator>&amp;&amp;</operator> <name>callback_ok</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><operator>(</operator><name><name>link</name><operator>-&gt;</operator><name>ifi_flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>IFF_LOOPBACK</name> <operator>|</operator> <name>IFF_POINTOPOINT</name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> 
		<operator>!</operator><operator>(</operator><call>(<modifier>*</modifier><name>callback</name>)<argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>link</name><operator>-&gt;</operator><name>ifi_index</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name><name>link</name><operator>-&gt;</operator><name>ifi_type</name></name></expr></argument>, <argument><expr><name>mac</name></expr></argument>, <argument><expr><name>maclen</name></expr></argument>, <argument><expr><name>parm</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><name>callback_ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  </block_content>}</block></if></if_stmt></block_content></block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>nl_multicast_state</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>nlmsghdr</name></name> <modifier>*</modifier></type><name>h</name></decl>;</decl_stmt>

  <do>do <block>{<block_content>
    <comment type="block">/* don't risk blocking reading netlink messages here. */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <call><name>netlink_recv</name><argument_list>(<argument><expr><name>MSG_DONTWAIT</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
  
      <for>for <control>(<init><expr><name>h</name> <operator>=</operator> <operator>(</operator>struct <name>nlmsghdr</name> <operator>*</operator><operator>)</operator><name><name>iov</name><operator>.</operator><name>iov_base</name></name></expr>;</init> <condition><expr><call><name>NLMSG_OK</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>h</name> <operator>=</operator> <call><name>NLMSG_NEXT</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>
	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>nl_async</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></while>
  </block_content>}</block> while <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOBUFS</name></expr>)</condition>;</do>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>netlink_multicast</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>state</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>nl_multicast_state</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>nl_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>nlmsghdr</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>nlmsg_type</name></name> <operator>==</operator> <name>NLMSG_ERROR</name></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>nlmsgerr</name></name> <modifier>*</modifier></type><name>err</name> <init>= <expr><call><name>NLMSG_DATA</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>err</name><operator>-&gt;</operator><name>error</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>my_syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"netlink returns error: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><operator>-</operator><operator>(</operator><name><name>err</name><operator>-&gt;</operator><name>error</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>nlmsg_pid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>h</name><operator>-&gt;</operator><name>nlmsg_type</name></name> <operator>==</operator> <name>RTM_NEWROUTE</name> <operator>&amp;&amp;</operator>
	   <operator>(</operator><name>state</name> <operator>&amp;</operator> <name>STATE_NEWROUTE</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* We arrange to receive netlink multicast messages whenever the network route is added.
	 If this happens and we still have a DNS packet in the buffer, we re-send it.
	 This helps on DoD links, where frequently the packet which triggers dialling is
	 a DNS query, which then gets lost. By re-sending, we can avoid the lookup
	 failing. */</comment> 
      <decl_stmt><decl><type><name><name>struct</name> <name>rtmsg</name></name> <modifier>*</modifier></type><name>rtm</name> <init>= <expr><call><name>NLMSG_DATA</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      
      <if_stmt><if>if <condition>(<expr><name><name>rtm</name><operator>-&gt;</operator><name>rtm_type</name></name> <operator>==</operator> <name>RTN_UNICAST</name> <operator>&amp;&amp;</operator> <name><name>rtm</name><operator>-&gt;</operator><name>rtm_scope</name></name> <operator>==</operator> <name>RT_SCOPE_LINK</name> <operator>&amp;&amp;</operator>
	  <operator>(</operator><name><name>rtm</name><operator>-&gt;</operator><name>rtm_table</name></name> <operator>==</operator> <name>RT_TABLE_MAIN</name> <operator>||</operator>
	   <name><name>rtm</name><operator>-&gt;</operator><name>rtm_table</name></name> <operator>==</operator> <name>RT_TABLE_LOCAL</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><call><name>queue_event</name><argument_list>(<argument><expr><name>EVENT_NEWROUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>state</name> <operator>|=</operator> <name>STATE_NEWROUTE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>h</name><operator>-&gt;</operator><name>nlmsg_type</name></name> <operator>==</operator> <name>RTM_NEWADDR</name> <operator>||</operator> <name><name>h</name><operator>-&gt;</operator><name>nlmsg_type</name></name> <operator>==</operator> <name>RTM_DELADDR</name><operator>)</operator> <operator>&amp;&amp;</operator>
	   <operator>(</operator><name>state</name> <operator>&amp;</operator> <name>STATE_NEWADDR</name><operator>)</operator><operator>==</operator><literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>queue_event</name><argument_list>(<argument><expr><name>EVENT_NEWADDR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>state</name> <operator>|=</operator> <name>STATE_NEWADDR</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  <return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_LINUX_NETWORK */</comment>
</unit>
