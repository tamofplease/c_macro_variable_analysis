<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/dnsmasq/dnssec.c"><comment type="block">/* dnssec.c is Copyright (c) 2012 Giovanni Bajo &lt;rasky@develer.com&gt;
           and Copyright (c) 2012-2020 Simon Kelley

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; version 2 dated June, 1991, or
   (at your option) version 3 dated 29 June, 2007.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dnsmasq.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DNSSEC</name></cpp:ifdef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SERIAL_UNDEF</name></cpp:macro>  <cpp:value>-100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SERIAL_EQ</name></cpp:macro>        <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SERIAL_LT</name></cpp:macro>       <cpp:value>-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SERIAL_GT</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>

<comment type="block">/* Convert from presentation format to wire format, in place.
   Also map UC -&gt; LC.
   Note that using extract_name to get presentation format
   then calling to_wire() removes compression and maps case,
   thus generating names in canonical form.
   Calling to_wire followed by from_wire is almost an identity,
   except that the UC remains mapped to LC. 

   Note that both /000 and '.' are allowed within labels. These get
   represented in presentation format using NAME_ESCAPE as an escape
   character. In theory, if all the characters in a name were /000 or
   '.' or NAME_ESCAPE then all would have to be escaped, so the 
   presentation format would be twice as long as the spec (1024). 
   The buffers are all declared as 2049 (allowing for the trailing zero) 
   for this reason.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>to_wire</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>l</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>q</name></decl>, <decl><type ref="prev"/><name>term</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>name</name></expr>;</init> <condition><expr><operator>*</operator><name>l</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>l</name> <operator>=</operator> <name>p</name></expr></incr>)</control>
    <block>{<block_content>
      <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>l</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <operator>*</operator><name>p</name> <operator>-</operator> <literal type="char">'A'</literal> <operator>+</operator> <literal type="char">'a'</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>NAME_ESCAPE</name></expr>)</condition>
	  <block>{<block_content>
	    <for>for <control>(<init><expr><name>q</name> <operator>=</operator> <name>p</name></expr>;</init> <condition><expr><operator>*</operator><name>q</name></expr>;</condition> <incr><expr><name>q</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	      <expr_stmt><expr><operator>*</operator><name>q</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>q</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
	    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>
	  </block_content>}</block></if></if_stmt></block_content></block></for>
      <expr_stmt><expr><name>term</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
      
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>l</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>l</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>l</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
      
      <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
      
      <if_stmt><if>if <condition>(<expr><name>term</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  
  <return>return <expr><name>l</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Note: no compression  allowed in input. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>from_wire</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>l</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>last</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
  
  <for>for <control>(<init><expr><name>last</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr>;</init> <condition><expr><operator>*</operator><name>last</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>last</name> <operator>+=</operator> <operator>*</operator><name>last</name><operator>+</operator><literal type="number">1</literal></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
  
  <for>for <control>(<init><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr>;</init> <condition><expr><operator>*</operator><name>l</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>l</name> <operator>+=</operator> <name>len</name><operator>+</operator><literal type="number">1</literal></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>*</operator><name>l</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>l</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>l</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>l</name> <operator>+</operator> <name>len</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'.'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <name>NAME_ESCAPE</name></expr>)</condition>
	  <block>{<block_content>
	    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>last</name> <operator>-</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
	    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>NAME_ESCAPE</name></expr>;</expr_stmt> 
	    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
	  </block_content>}</block></if></if_stmt></block_content></block></for>
	
      <expr_stmt><expr><name><name>l</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
    </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>l</name> <operator>!=</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><name>l</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Input in presentation format */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>count_labels</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>name</name></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

  <comment type="block">/* Don't count empty first label. */</comment>
  <return>return <expr><ternary><condition><expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'.'</literal></expr> ?</condition><then> <expr><name>i</name></expr> </then><else>: <expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Implement RFC1982 wrapped compare for 32-bit numbers */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>serial_compare_32</name><parameter_list>(<parameter><decl><type><name>u32</name></type> <name>s1</name></decl></parameter>, <parameter><decl><type><name>u32</name></type> <name>s2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>s1</name> <operator>==</operator> <name>s2</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>SERIAL_EQ</name></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>s1</name> <operator>&lt;</operator> <name>s2</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>s2</name> <operator>-</operator> <name>s1</name><operator>)</operator> <operator>&lt;</operator> <operator>(</operator><literal type="number">1UL</literal><operator>&lt;&lt;</operator><literal type="number">31</literal><operator>)</operator><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name>s1</name> <operator>&gt;</operator> <name>s2</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>s1</name> <operator>-</operator> <name>s2</name><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><literal type="number">1UL</literal><operator>&lt;&lt;</operator><literal type="number">31</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>SERIAL_LT</name></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name><name>s1</name> <argument_list type="generic">&lt; <argument><expr><name>s2</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>s2</name> <operator>-</operator> <name>s1</name><operator>)</operator></expr></argument> &gt;</argument_list></name> <argument_list>(<argument><expr><literal type="number">1UL</literal><operator>&lt;&lt;</operator><literal type="number">31</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
      <operator>(</operator><name>s1</name> <operator>&gt;</operator> <name>s2</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>s1</name> <operator>-</operator> <name>s2</name><operator>)</operator> <operator>&lt;</operator> <operator>(</operator><literal type="number">1UL</literal><operator>&lt;&lt;</operator><literal type="number">31</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>SERIAL_GT</name></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><name>SERIAL_UNDEF</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Called at startup. If the timestamp file is configured and exists, put its mtime on
   timestamp_time. If it doesn't exist, create it, and set the mtime to 1-1-2015.
   return -1 -&gt; Cannot create file.
           0 -&gt; not using timestamp, or timestamp exists and is in past.
           1 -&gt; timestamp exists and is in future.
*/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>time_t</name></type> <name>timestamp_time</name></decl>;</decl_stmt>

<function><type><name>int</name></type> <name>setup_timestamp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><name><name>daemon</name><operator>-&gt;</operator><name>back_to_the_future</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>daemon</name><operator>-&gt;</operator><name>timestamp_file</name></name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  
  <if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>timestamp_file</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>timestamp_time</name> <operator>=</operator> <name><name>statbuf</name><operator>.</operator><name>st_mtime</name></name></expr>;</expr_stmt>
    <label><name>check_and_exit</name>:</label>
      <if_stmt><if>if <condition>(<expr><call><name>difftime</name><argument_list>(<argument><expr><name>timestamp_time</name></expr></argument>, <argument><expr><call><name>time</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;=</operator>  <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
	  <comment type="block">/* time already OK, update timestamp, and do key checking from the start. */</comment>
	  <if_stmt><if>if <condition>(<expr><call><name>utimes</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>timestamp_file</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>my_syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to update mtime on %s: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>timestamp_file</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <expr_stmt><expr><name><name>daemon</name><operator>-&gt;</operator><name>back_to_the_future</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	  <return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
  
  <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* NB. for explanation of O_EXCL flag, see comment on pidfile in dnsmasq.c */</comment> 
      <decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>open</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>timestamp_file</name></name></expr></argument>, <argument><expr><name>O_WRONLY</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_NONBLOCK</name> <operator>|</operator> <name>O_EXCL</name></expr></argument>, <argument><expr><literal type="number">0666</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
	  <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name><name>tv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	  <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  
	  <expr_stmt><expr><name>timestamp_time</name> <operator>=</operator> <literal type="number">1420070400</literal></expr>;</expr_stmt> <comment type="block">/* 1-1-2015 */</comment>
	  <expr_stmt><expr><name><name>tv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tv_sec</name> <operator>=</operator> <name><name>tv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>tv_sec</name> <operator>=</operator> <name>timestamp_time</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>tv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tv_usec</name> <operator>=</operator> <name><name>tv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>tv_usec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><call><name>utimes</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>timestamp_file</name></name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	    <goto>goto <name>check_and_exit</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check whether today/now is between date_start and date_end */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>is_check_date</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>curtime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Checking timestamps may be temporarily disabled */</comment>
    
  <comment type="block">/* If the current time if _before_ the timestamp
     on our persistent timestamp file, then assume the
     time if not yet correct, and don't check the
     key timestamps. As soon as the current time is
     later then the timestamp, update the timestamp
     and start checking keys */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>daemon</name><operator>-&gt;</operator><name>timestamp_file</name></name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name><name>daemon</name><operator>-&gt;</operator><name>back_to_the_future</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>difftime</name><argument_list>(<argument><expr><name>timestamp_time</name></expr></argument>, <argument><expr><name>curtime</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><call><name>utimes</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>timestamp_file</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>my_syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to update mtime on %s: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>timestamp_file</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  
	  <expr_stmt><expr><call><name>my_syslog</name><argument_list>(<argument><expr><name>LOG_INFO</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"system time considered valid, now checking DNSSEC signature timestamps."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>daemon</name><operator>-&gt;</operator><name>back_to_the_future</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>daemon</name><operator>-&gt;</operator><name>dnssec_no_time_check</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>queue_event</name><argument_list>(<argument><expr><name>EVENT_RELOAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* purge cache */</comment>
	</block_content>}</block></if></if_stmt> 

      <return>return <expr><name><name>daemon</name><operator>-&gt;</operator><name>back_to_the_future</name></name></expr>;</return>
    </block_content>}</block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><operator>!</operator><name><name>daemon</name><operator>-&gt;</operator><name>dnssec_no_time_check</name></name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Return bytes of canonicalised rrdata one by one.
   Init state-&gt;ip with the RR, and state-&gt;end with the end of same.
   Init state-&gt;op to NULL.
   Init state-&gt;desc to RR descriptor.
   Init state-&gt;buff with a MAXDNAME * 2 buffer.
   
   After each call which returns 1, state-&gt;op points to the next byte of data.
   On returning 0, the end has been reached.
*/</comment>
<struct>struct <name>rdata_state</name> <block>{
  <decl_stmt><decl><type><name>u16</name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ip</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buff</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_rdata</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dns_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>plen</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>rdata_state</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>d</name></decl>;</decl_stmt>
  
  <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>op</name></name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>c</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>op</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>c</name></name><operator>--</operator></expr>;</expr_stmt>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>d</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>desc</name></name><operator>)</operator></expr>;</expr_stmt>
      
      <if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
	  <comment type="block">/* all the bytes to the end. */</comment>
	  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>c</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>ip</name></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	    <block>{<block_content>
	      <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>ip</name></name></expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ip</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>end</name></name></expr>;</expr_stmt><empty_stmt>;</empty_stmt>
	    </block_content>}</block></if>
	  <else>else<block type="pseudo"><block_content>
	    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if>
      <else>else
	<block>{<block_content>
	  <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>desc</name></name><operator>++</operator></expr>;</expr_stmt>
	  
	  <if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <operator>(</operator><name>u16</name><operator>)</operator><literal type="number">0</literal></expr>)</condition>
	    <block>{<block_content>
	      <comment type="block">/* domain-name, canonicalise */</comment>
	      <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
	      
	      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator>
		  <operator>(</operator><name>len</name> <operator>=</operator> <call><name>to_wire</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<continue>continue;</continue></block_content></block></if></if_stmt>
	      
	      <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>c</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>state</name><operator>-&gt;</operator><name>buff</name></name></expr>;</expr_stmt>
	    </block_content>}</block></if>
	  <else>else
	    <block>{<block_content>
	      <comment type="block">/* plain data preceding a domain-name, don't run off the end of the data */</comment>
	      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>ip</name></name><operator>)</operator> <operator>&lt;</operator> <name>d</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>d</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>end</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>ip</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	      
	      <if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<continue>continue;</continue></block_content></block></if></if_stmt>
		  
	      <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>ip</name></name></expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>c</name></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ip</name></name> <operator>+=</operator> <name>d</name></expr>;</expr_stmt>
	    </block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
      
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* Bubble sort the RRset into the canonical order. */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sort_rrset</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dns_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>plen</name></decl></parameter>, <parameter><decl><type><name>u16</name> <modifier>*</modifier></type><name>rr_desc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rrsetidx</name></decl></parameter>, 
		      <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>rrset</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buff1</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buff2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>swap</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  
  <do>do
    <block>{<block_content>
      <for>for <control>(<init><expr><name>swap</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>rrsetidx</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
	  <decl_stmt><decl><type><name>int</name></type> <name>rdlen1</name></decl>, <decl><type ref="prev"/><name>rdlen2</name></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name><name>struct</name> <name>rdata_state</name></name></type> <name>state1</name></decl>, <decl><type ref="prev"/><name>state2</name></decl>;</decl_stmt>
	  
	  <comment type="block">/* Note that these have been determined to be OK previously,
	     so we don't need to check for NULL return here. */</comment>
	  <expr_stmt><expr><name><name>state1</name><operator>.</operator><name>ip</name></name> <operator>=</operator> <call><name>skip_name</name><argument_list>(<argument><expr><name><name>rrset</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>state2</name><operator>.</operator><name>ip</name></name> <operator>=</operator> <call><name>skip_name</name><argument_list>(<argument><expr><name><name>rrset</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>state1</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name><name>state2</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>state1</name><operator>.</operator><name>buff</name></name> <operator>=</operator> <name>buff1</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>state2</name><operator>.</operator><name>buff</name></name> <operator>=</operator> <name>buff2</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>state1</name><operator>.</operator><name>desc</name></name> <operator>=</operator> <name><name>state2</name><operator>.</operator><name>desc</name></name> <operator>=</operator> <name>rr_desc</name></expr>;</expr_stmt>
	  
	  <expr_stmt><expr><name><name>state1</name><operator>.</operator><name>ip</name></name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt> <comment type="block">/* skip class, type, ttl */</comment>
	  <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>rdlen1</name></expr></argument>, <argument><expr><name><name>state1</name><operator>.</operator><name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHECK_LEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name><name>state1</name><operator>.</operator><name>ip</name></name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>rdlen1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>rrsetidx</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* short packet */</comment>
	  <expr_stmt><expr><name><name>state1</name><operator>.</operator><name>end</name></name> <operator>=</operator> <name><name>state1</name><operator>.</operator><name>ip</name></name> <operator>+</operator> <name>rdlen1</name></expr>;</expr_stmt>
	  
	  <expr_stmt><expr><name><name>state2</name><operator>.</operator><name>ip</name></name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt> <comment type="block">/* skip class, type, ttl */</comment>
	  <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>rdlen2</name></expr></argument>, <argument><expr><name><name>state2</name><operator>.</operator><name>ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHECK_LEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name><name>state2</name><operator>.</operator><name>ip</name></name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>rdlen2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>rrsetidx</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* short packet */</comment>
	  <expr_stmt><expr><name><name>state2</name><operator>.</operator><name>end</name></name> <operator>=</operator> <name><name>state2</name><operator>.</operator><name>ip</name></name> <operator>+</operator> <name>rdlen2</name></expr>;</expr_stmt> 

	  <comment type="block">/* If the RR has no names in it then canonicalisation
	     is the identity function and we can compare
	     the RRs directly. If not we compare the 
	     canonicalised RRs one byte at a time. */</comment>
	  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>rr_desc</name> <operator>==</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition>	  
	    <block>{<block_content>
	      <decl_stmt><decl><type><name>int</name></type> <name>rdmin</name> <init>= <expr><ternary><condition><expr><name>rdlen1</name> <operator>&gt;</operator> <name>rdlen2</name></expr> ?</condition><then> <expr><name>rdlen2</name></expr> </then><else>: <expr><name>rdlen1</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
	      <decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>state1</name><operator>.</operator><name>ip</name></name></expr></argument>, <argument><expr><name><name>state2</name><operator>.</operator><name>ip</name></name></expr></argument>, <argument><expr><name>rdmin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	      
	      <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>cmp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rdlen1</name> <operator>&gt;</operator> <name>rdmin</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
		  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name><name>rrset</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		  <expr_stmt><expr><name><name>rrset</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>rrset</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>rrset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name>swap</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
	      <if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>rdlen1</name> <operator>==</operator> <name>rdlen2</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
		  <comment type="block">/* Two RRs are equal, remove one copy. RFC 4034, para 6.3 */</comment>
		  <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>rrsetidx</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		    <expr_stmt><expr><name><name>rrset</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>rrset</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
		  <expr_stmt><expr><name>rrsetidx</name><operator>--</operator></expr>;</expr_stmt>
		  <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	    </block_content>}</block></if>
	  <else>else<block type="pseudo"><block_content>
	    <comment type="block">/* Comparing canonicalised RRs, byte-at-a-time. */</comment>
	    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
	      <block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>ok1</name></decl>, <decl><type ref="prev"/><name>ok2</name></decl>;</decl_stmt>
		
		<expr_stmt><expr><name>ok1</name> <operator>=</operator> <call><name>get_rdata</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ok2</name> <operator>=</operator> <call><name>get_rdata</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ok1</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>ok2</name></expr>)</condition>
		  <block>{<block_content>
		    <comment type="block">/* Two RRs are equal, remove one copy. RFC 4034, para 6.3 */</comment>
		    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>rrsetidx</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		      <expr_stmt><expr><name><name>rrset</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>rrset</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
		    <expr_stmt><expr><name>rrsetidx</name><operator>--</operator></expr>;</expr_stmt>
		    <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
		    <break>break;</break>
		  </block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>ok1</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>ok2</name> <operator>||</operator> <operator>*</operator><name><name>state1</name><operator>.</operator><name>op</name></name> <operator>&gt;</operator> <operator>*</operator><name><name>state2</name><operator>.</operator><name>op</name></name><operator>)</operator></expr>)</condition> 
		  <block>{<block_content>
		    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name><name>rrset</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		    <expr_stmt><expr><name><name>rrset</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>rrset</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		    <expr_stmt><expr><name><name>rrset</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>swap</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		    <break>break;</break>
		  </block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>ok2</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>ok1</name> <operator>||</operator> <operator>*</operator><name><name>state2</name><operator>.</operator><name>op</name></name> <operator>&gt;</operator> <operator>*</operator><name><name>state1</name><operator>.</operator><name>op</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		  <break>break;</break></block_content></block></if></if_stmt>
		
		<comment type="block">/* arrive here when bytes are equal, go round the loop again
		   and compare the next ones. */</comment>
	      </block_content>}</block></while></block_content></block></else></if_stmt>
	</block_content>}</block></for>
    </block_content>}</block> while <condition>(<expr><name>swap</name></expr>)</condition>;</do>

  <return>return <expr><name>rrsetidx</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>rrset</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>sigs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Get pointers to RRset members and signature(s) for same.
   Check signatures, and return keyname associated in keyname. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>explore_rrset</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dns_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>plen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>class</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, 
			 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>keyname</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sigcnt</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>rrcnt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>rrset_sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>sig_sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rrsetidx</name></decl>, <decl><type ref="prev"/><name>sigidx</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>rdlen</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>gotkey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>p</name> <operator>=</operator> <call><name>skip_questions</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

   <comment type="block">/* look for RRSIGs for this RRset and get pointers to each RR in the set. */</comment>
  <for>for <control>(<init><expr><name>rrsetidx</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>sigidx</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>ancount</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>nscount</name></name></expr></argument>)</argument_list></call></expr>;</init> 
       <condition><expr><name>j</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control> 
    <block>{<block_content>
      <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pstart</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pdata</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>stype</name></decl>, <decl><type ref="prev"/><name>sclass</name></decl>, <decl><type ref="prev"/><name>type_covered</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>pstart</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>res</name> <operator>=</operator> <call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment>
      
      <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>stype</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>sclass</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
           
      <expr_stmt><expr><name>pdata</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

      <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <comment type="block">/* TTL */</comment>
      <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>rdlen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHECK_LEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>rdlen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> 
      
      <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>sclass</name> <operator>==</operator> <name>class</name></expr>)</condition>
	<block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>stype</name> <operator>==</operator> <name>type</name></expr>)</condition>
	    <block>{<block_content>
	      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>expand_workspace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rrset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rrset_sz</name></expr></argument>, <argument><expr><name>rrsetidx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> 
	      
	      <expr_stmt><expr><name><name>rrset</name><index>[<expr><name>rrsetidx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pstart</name></expr>;</expr_stmt>
	    </block_content>}</block></if></if_stmt>
	  
	  <if_stmt><if>if <condition>(<expr><name>stype</name> <operator>==</operator> <name>T_RRSIG</name></expr>)</condition>
	    <block>{<block_content>
	      <if_stmt><if>if <condition>(<expr><name>rdlen</name> <operator>&lt;</operator> <literal type="number">18</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment> 
	      
	      <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>type_covered</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">16</literal></expr>;</expr_stmt> <comment type="block">/* algo, labels, orig_ttl, sig_expiration, sig_inception, key_tag */</comment>
	      
	      <if_stmt><if>if <condition>(<expr><name>gotkey</name></expr>)</condition>
		<block>{<block_content>
		  <comment type="block">/* If there's more than one SIG, ensure they all have same keyname */</comment>
		  <if_stmt><if>if <condition>(<expr><call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
	      <else>else
		<block>{<block_content>
		  <expr_stmt><expr><name>gotkey</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		  
		  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		  
		  <comment type="block">/* RFC 4035 5.3.1 says that the Signer's Name field MUST equal
		     the name of the zone containing the RRset. We can't tell that
		     for certain, but we can check that  the RRset name is equal to
		     or encloses the signers name, which should be enough to stop 
		     an attacker using signatures made with the key of an unrelated 
		     zone he controls. Note that the root key is always allowed. */</comment>
		  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>keyname</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		    <block>{<block_content>
		      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name_start</name></decl>;</decl_stmt>
		      <for>for <control>(<init><expr><name>name_start</name> <operator>=</operator> <name>name</name></expr>;</init> <condition><expr><operator>!</operator><call><name>hostname_isequal</name><argument_list>(<argument><expr><name>name_start</name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>)</argument_list></call></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>name_start</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>name_start</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			  <expr_stmt><expr><name>name_start</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* chop a label off and try again */</comment>
			<else>else<block type="pseudo"><block_content>
			  <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt></block_content></block></for>
		    </block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		  
	      
	      <if_stmt><if>if <condition>(<expr><name>type_covered</name> <operator>==</operator> <name>type</name></expr>)</condition>
		<block>{<block_content>
		  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>expand_workspace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sigs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sig_sz</name></expr></argument>, <argument><expr><name>sigidx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> 
		  
		  <expr_stmt><expr><name><name>sigs</name><index>[<expr><name>sigidx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pdata</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt> 
	      
	      <expr_stmt><expr><name>p</name> <operator>=</operator> <name>pdata</name> <operator>+</operator> <literal type="number">6</literal></expr>;</expr_stmt> <comment type="block">/* restore for ADD_RDLEN */</comment>
	    </block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
      
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ADD_RDLEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>rdlen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  
  <expr_stmt><expr><operator>*</operator><name>sigcnt</name> <operator>=</operator> <name>sigidx</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>rrcnt</name> <operator>=</operator> <name>rrsetidx</name></expr>;</expr_stmt>

  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Validate a single RRset (class, type, name) in the supplied DNS reply 
   Return code:
   STAT_SECURE   if it validates.
   STAT_SECURE_WILDCARD if it validates and is the result of wildcard expansion.
   (In this case *wildcard_out points to the "body" of the wildcard within name.) 
   STAT_BOGUS    signature is wrong, bad packet.
   STAT_NEED_KEY need DNSKEY to complete validation (name is returned in keyname)
   STAT_NEED_DS  need DS to complete validation (name is returned in keyname)

   If key is non-NULL, use that key, which has the algo and tag given in the params of those names,
   otherwise find the key in the cache.

   Name is unchanged on exit. keyname is used as workspace and trashed.

   Call explore_rrset first to find and count RRs and sigs.

   ttl_out is the floor on TTL, based on TTL and orig_ttl and expiration of sig used to validate.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>validate_rrset</name><parameter_list>(<parameter><decl><type><name>time_t</name></type> <name>now</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>dns_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>plen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>class</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sigidx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rrsetidx</name></decl></parameter>, 
			  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>keyname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>wildcard_out</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>blockdata</name></name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keylen</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>algo_in</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keytag_in</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>ttl_out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rdlen</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>name_labels</name></decl>, <decl><type ref="prev"/><name>algo</name></decl>, <decl><type ref="prev"/><name>labels</name></decl>, <decl><type ref="prev"/><name>key_tag</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>crec</name></name> <modifier>*</modifier></type><name>crecp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u16</name> <modifier>*</modifier></type><name>rr_desc</name> <init>= <expr><call><name>rrfilter_desc</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>u32</name></type> <name>sig_expiration</name></decl>, <decl><type ref="prev"/><name>sig_inception</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>failflags</name> <init>= <expr><name>DNSSEC_FAIL_NOSIG</name> <operator>|</operator> <name>DNSSEC_FAIL_NYV</name> <operator>|</operator> <name>DNSSEC_FAIL_EXP</name> <operator>|</operator> <name>DNSSEC_FAIL_NOKEYSUP</name></expr></init></decl>;</decl_stmt>
  
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>curtime</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>time_check</name> <init>= <expr><call><name>is_check_date</name><argument_list>(<argument><expr><name>curtime</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  
  <if_stmt><if>if <condition>(<expr><name>wildcard_out</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>wildcard_out</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
  
  <expr_stmt><expr><name>name_labels</name> <operator>=</operator> <call><name>count_labels</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* For 4035 5.3.2 check */</comment>

  <comment type="block">/* Sort RRset records into canonical order. 
     Note that at this point keyname and daemon-&gt;workspacename buffs are
     unused, and used as workspace by the sort. */</comment>
  <expr_stmt><expr><name>rrsetidx</name> <operator>=</operator> <call><name>sort_rrset</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>rr_desc</name></expr></argument>, <argument><expr><name>rrsetidx</name></expr></argument>, <argument><expr><name>rrset</name></expr></argument>, <argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>workspacename</name></name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         
  <comment type="block">/* Now try all the sigs to try and find one which validates */</comment>
  <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator><name>sigidx</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>psav</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sig</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>digest</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>wire_len</name></decl>, <decl><type ref="prev"/><name>sig_len</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>nettle_hash</name></name> <modifier>*</modifier></type><name>hash</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name_start</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>u32</name></type> <name>nsigttl</name></decl>, <decl><type ref="prev"/><name>ttl</name></decl>, <decl><type ref="prev"/><name>orig_ttl</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>failflags</name> <operator>&amp;=</operator> <operator>~</operator><name>DNSSEC_FAIL_NOSIG</name></expr>;</expr_stmt>
      
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>sigs</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETLONG</name><argument_list>(<argument><expr><name>ttl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>rdlen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* rdlen &gt;= 18 checked previously */</comment>
      <expr_stmt><expr><name>psav</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <comment type="block">/* type_covered - already checked */</comment>
      <expr_stmt><expr><name>algo</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>labels</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETLONG</name><argument_list>(<argument><expr><name>orig_ttl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETLONG</name><argument_list>(<argument><expr><name>sig_expiration</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETLONG</name><argument_list>(<argument><expr><name>sig_inception</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>key_tag</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>time_check</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>failflags</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>DNSSEC_FAIL_NYV</name> <operator>|</operator> <name>DNSSEC_FAIL_EXP</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
      <else>else
	<block>{<block_content>
	  <comment type="block">/* We must explicitly check against wanted values, because of SERIAL_UNDEF */</comment>
	  <if_stmt><if>if <condition>(<expr><call><name>serial_compare_32</name><argument_list>(<argument><expr><name>curtime</name></expr></argument>, <argument><expr><name>sig_inception</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SERIAL_LT</name></expr>)</condition><block type="pseudo"><block_content>
	    <continue>continue;</continue></block_content></block></if>
	  <else>else<block type="pseudo"><block_content>
	    <expr_stmt><expr><name>failflags</name> <operator>&amp;=</operator> <operator>~</operator><name>DNSSEC_FAIL_NYV</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	  
	  <if_stmt><if>if <condition>(<expr><call><name>serial_compare_32</name><argument_list>(<argument><expr><name>curtime</name></expr></argument>, <argument><expr><name>sig_expiration</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SERIAL_GT</name></expr>)</condition><block type="pseudo"><block_content>
	    <continue>continue;</continue></block_content></block></if>
	  <else>else<block type="pseudo"><block_content>
	    <expr_stmt><expr><name>failflags</name> <operator>&amp;=</operator> <operator>~</operator><name>DNSSEC_FAIL_EXP</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>hash</name> <operator>=</operator> <call><name>hash_find</name><argument_list>(<argument><expr><call><name>algo_digest_name</name><argument_list>(<argument><expr><name>algo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<continue>continue;</continue></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><name>failflags</name> <operator>&amp;=</operator> <operator>~</operator><name>DNSSEC_FAIL_NOKEYSUP</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
      
      <if_stmt><if>if <condition>(<expr><name>labels</name> <operator>&gt;</operator> <name>name_labels</name> <operator>||</operator>
	  <operator>!</operator><call><name>hash_init</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>digest</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<continue>continue;</continue></block_content></block></if></if_stmt>
      
      <comment type="block">/* OK, we have the signature record, see if the relevant DNSKEY is in the cache. */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>key</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>crecp</name> <operator>=</operator> <call><name>cache_find_by_name</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>F_DNSKEY</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>STAT_NEED_KEY</name></expr>;</return></block_content></block></if></if_stmt>

       <if_stmt><if>if <condition>(<expr><name>ttl_out</name></expr>)</condition>
	 <block>{<block_content>
	   <comment type="block">/* 4035 5.3.3 rules on TTLs */</comment>
	   <if_stmt><if>if <condition>(<expr><name>orig_ttl</name> <operator>&lt;</operator> <name>ttl</name></expr>)</condition><block type="pseudo"><block_content>
	     <expr_stmt><expr><name>ttl</name> <operator>=</operator> <name>orig_ttl</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	   
	   <if_stmt><if>if <condition>(<expr><name>time_check</name> <operator>&amp;&amp;</operator> <call><name>difftime</name><argument_list>(<argument><expr><name>sig_expiration</name></expr></argument>, <argument><expr><name>curtime</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>ttl</name></expr>)</condition><block type="pseudo"><block_content>
	     <expr_stmt><expr><name>ttl</name> <operator>=</operator> <call><name>difftime</name><argument_list>(<argument><expr><name>sig_expiration</name></expr></argument>, <argument><expr><name>curtime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	   <expr_stmt><expr><operator>*</operator><name>ttl_out</name> <operator>=</operator> <name>ttl</name></expr>;</expr_stmt>
	 </block_content>}</block></if></if_stmt>
       
      <expr_stmt><expr><name>sig</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>sig_len</name> <operator>=</operator> <name>rdlen</name> <operator>-</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>psav</name><operator>)</operator></expr>;</expr_stmt>
              
      <expr_stmt><expr><name>nsigttl</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>orig_ttl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <expr_stmt><expr><call><name><name>hash</name><operator>-&gt;</operator><name>update</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>, <argument><expr><name>psav</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>wire_len</name> <operator>=</operator> <call><name>to_wire</name><argument_list>(<argument><expr><name>keyname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>hash</name><operator>-&gt;</operator><name>update</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>wire_len</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>keyname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>from_wire</name><argument_list>(<argument><expr><name>keyname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RRBUFLEN</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define> <comment type="block">/* Most RRs are smaller than this. */</comment>
      
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>rrsetidx</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
	  <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name><name>struct</name> <name>rdata_state</name></name></type> <name>state</name></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>u16</name></type> <name>len</name></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>rrbuf</name><index>[<expr><name>RRBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
	  
	  <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>rrset</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	  
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> 
	    <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt>

	  <expr_stmt><expr><name>name_start</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
	  
	  <comment type="block">/* if more labels than in RRsig name, hash *.&lt;no labels in rrsig labels field&gt;  4035 5.3.2 */</comment>
	  <if_stmt><if>if <condition>(<expr><name>labels</name> <operator>&lt;</operator> <name>name_labels</name></expr>)</condition>
	    <block>{<block_content>
	      <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>name_labels</name> <operator>-</operator> <name>labels</name></expr>;</init> <condition><expr><name>j</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
		<block>{<block_content>
		  <while>while <condition>(<expr><operator>*</operator><name>name_start</name> <operator>!=</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>name_start</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		    <expr_stmt><expr><name>name_start</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		  <if_stmt><if>if <condition>(<expr><name>j</name> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>name_start</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
		    <expr_stmt><expr><name>name_start</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	      
	      <if_stmt><if>if <condition>(<expr><name>wildcard_out</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>wildcard_out</name> <operator>=</operator> <name>name_start</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	      <expr_stmt><expr><name>name_start</name><operator>--</operator></expr>;</expr_stmt>
	      <expr_stmt><expr><operator>*</operator><name>name_start</name> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt>
	    </block_content>}</block></if></if_stmt>
	  
	  <expr_stmt><expr><name>wire_len</name> <operator>=</operator> <call><name>to_wire</name><argument_list>(<argument><expr><name>name_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name><name>hash</name><operator>-&gt;</operator><name>update</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>wire_len</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>name_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name><name>hash</name><operator>-&gt;</operator><name>update</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* class and type */</comment>
	  <expr_stmt><expr><call><name><name>hash</name><operator>-&gt;</operator><name>update</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>nsigttl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	  <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt> <comment type="block">/* skip type, class, ttl */</comment>
	  <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>rdlen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHECK_LEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>rdlen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt> 

	  <comment type="block">/* Optimisation for RR types which need no cannonicalisation.
	     This includes DNSKEY DS NSEC and NSEC3, which are also long, so
	     it saves lots of calls to get_rdata, and avoids the pessimal
	     segmented insertion, even with a small rrbuf[].
	     
	     If canonicalisation is not needed, a simple insertion into the hash works.
	  */</comment>
	  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>rr_desc</name> <operator>==</operator> <operator>(</operator><name>u16</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition>
	    <block>{<block_content>
	      <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>rdlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name><name>hash</name><operator>-&gt;</operator><name>update</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name><name>hash</name><operator>-&gt;</operator><name>update</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>rdlen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    </block_content>}</block></if>
	  <else>else
	    <block>{<block_content>
	      <comment type="block">/* canonicalise rdata and calculate length of same, use 
		 name buffer as workspace for get_rdata. */</comment>
	      <expr_stmt><expr><name><name>state</name><operator>.</operator><name>ip</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>state</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>state</name><operator>.</operator><name>desc</name></name> <operator>=</operator> <name>rr_desc</name></expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>state</name><operator>.</operator><name>buff</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
	      <expr_stmt><expr><name><name>state</name><operator>.</operator><name>end</name></name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>rdlen</name></expr>;</expr_stmt>
	      
	      <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><call><name>get_rdata</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>RRBUFLEN</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><name><name>rrbuf</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name><name>state</name><operator>.</operator><name>op</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
	      
	      <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><operator>(</operator><name>u16</name><operator>)</operator><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name><name>hash</name><operator>-&gt;</operator><name>update</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	      
	      <comment type="block">/* If the RR is shorter than RRBUFLEN (most of them, in practice)
		 then we can just digest it now. If it exceeds RRBUFLEN we have to
		 go back to the start and do it in chunks. */</comment>
	      <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;=</operator> <name>RRBUFLEN</name></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><name><name>state</name><operator>.</operator><name>ip</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>state</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>state</name><operator>.</operator><name>desc</name></name> <operator>=</operator> <name>rr_desc</name></expr>;</expr_stmt>
		  
		  <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><call><name>get_rdata</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		    <block>{<block_content>
		      <expr_stmt><expr><name><name>rrbuf</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name><name>state</name><operator>.</operator><name>op</name></name></expr>;</expr_stmt>
		      
		      <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>RRBUFLEN</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
			  <expr_stmt><expr><call><name><name>hash</name><operator>-&gt;</operator><name>update</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>RRBUFLEN</name></expr></argument>, <argument><expr><name>rrbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			  <expr_stmt><expr><name>j</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		    </block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	      
	      <if_stmt><if>if <condition>(<expr><name>j</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>hash</name><operator>-&gt;</operator><name>update</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>rrbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	    </block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
     
      <expr_stmt><expr><call><name><name>hash</name><operator>-&gt;</operator><name>digest</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>hash</name><operator>-&gt;</operator><name>digest_size</name></name></expr></argument>, <argument><expr><name>digest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* namebuff used for workspace above, restore to leave unchanged on exit */</comment>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>rrset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>key</name></expr>)</condition>
	<block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>algo_in</name> <operator>==</operator> <name>algo</name> <operator>&amp;&amp;</operator> <name>keytag_in</name> <operator>==</operator> <name>key_tag</name> <operator>&amp;&amp;</operator>
	      <call><name>verify</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><name>sig_len</name></expr></argument>, <argument><expr><name>digest</name></expr></argument>, <argument><expr><name><name>hash</name><operator>-&gt;</operator><name>digest_size</name></name></expr></argument>, <argument><expr><name>algo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>STAT_SECURE</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
      <else>else
	<block>{<block_content>
	  <comment type="block">/* iterate through all possible keys 4035 5.3.1 */</comment>
	  <for>for <control>(<init>;</init> <condition><expr><name>crecp</name></expr>;</condition> <incr><expr><name>crecp</name> <operator>=</operator> <call><name>cache_find_by_name</name><argument_list>(<argument><expr><name>crecp</name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>F_DNSKEY</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>
	    <if_stmt><if>if <condition>(<expr><name><name>crecp</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>key</name><operator>.</operator><name>algo</name></name> <operator>==</operator> <name>algo</name> <operator>&amp;&amp;</operator> 
		<name><name>crecp</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>key</name><operator>.</operator><name>keytag</name></name> <operator>==</operator> <name>key_tag</name> <operator>&amp;&amp;</operator>
		<name><name>crecp</name><operator>-&gt;</operator><name>uid</name></name> <operator>==</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>class</name> <operator>&amp;&amp;</operator>
		<call><name>verify</name><argument_list>(<argument><expr><name><name>crecp</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>key</name><operator>.</operator><name>keydata</name></name></expr></argument>, <argument><expr><name><name>crecp</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>key</name><operator>.</operator><name>keylen</name></name></expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr><name>sig_len</name></expr></argument>, <argument><expr><name>digest</name></expr></argument>, <argument><expr><name><name>hash</name><operator>-&gt;</operator><name>digest_size</name></name></expr></argument>, <argument><expr><name>algo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	      <return>return <expr><ternary><condition><expr><operator>(</operator><name>labels</name> <operator>&lt;</operator> <name>name_labels</name><operator>)</operator></expr> ?</condition><then> <expr><name>STAT_SECURE_WILDCARD</name></expr> </then><else>: <expr><name>STAT_SECURE</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
	</block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

  <comment type="block">/* If we reach this point, no verifying key was found */</comment>
  <return>return <expr><name>STAT_BOGUS</name> <operator>|</operator> <name>failflags</name> <operator>|</operator> <name>DNSSEC_FAIL_NOKEY</name></expr>;</return>
</block_content>}</block></function>
 

<comment type="block">/* The DNS packet is expected to contain the answer to a DNSKEY query.
   Put all DNSKEYs in the answer which are valid into the cache.
   return codes:
         STAT_OK        Done, key(s) in cache.
	 STAT_BOGUS     No DNSKEYs found, which  can be validated with DS,
	                or self-sign for DNSKEY RRset is not valid, bad packet.
	 STAT_NEED_DS   DS records to validate a key not found, name in keyname 
	 STAT_NEED_KEY  DNSKEY records to validate a key not found, name in keyname 
*/</comment>
<function><type><name>int</name></type> <name>dnssec_validate_by_ds</name><parameter_list>(<parameter><decl><type><name>time_t</name></type> <name>now</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>dns_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>plen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>keyname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>class</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>psave</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>header</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>crec</name></name> <modifier>*</modifier></type><name>crecp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>recp1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>qtype</name></decl>, <decl><type ref="prev"/><name>qclass</name></decl>, <decl><type ref="prev"/><name>rdlen</name></decl>, <decl><type ref="prev"/><name>flags</name></decl>, <decl><type ref="prev"/><name>algo</name></decl>, <decl><type ref="prev"/><name>valid</name></decl>, <decl><type ref="prev"/><name>keytag</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>ttl</name></decl>, <decl><type ref="prev"/><name>sig_ttl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>blockdata</name></name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>union</name> <name>all_addr</name></name></type> <name>a</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>failflags</name> <init>= <expr><name>DNSSEC_FAIL_NOSIG</name> <operator>|</operator> <name>DNSSEC_FAIL_NODSSUP</name> <operator>|</operator> <name>DNSSEC_FAIL_NOZONE</name> <operator>|</operator> <name>DNSSEC_FAIL_NOKEY</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>qdcount</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
      <call><name>RCODE</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SERVFAIL</name> <operator>||</operator> <call><name>RCODE</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>REFUSED</name> <operator>||</operator>
      <operator>!</operator><call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>STAT_BOGUS</name> <operator>|</operator> <name>DNSSEC_FAIL_NOKEY</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>qtype</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>qclass</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if <condition>(<expr><name>qtype</name> <operator>!=</operator> <name>T_DNSKEY</name> <operator>||</operator> <name>qclass</name> <operator>!=</operator> <name>class</name> <operator>||</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>ancount</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>STAT_BOGUS</name> <operator>|</operator> <name>DNSSEC_FAIL_NOKEY</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* See if we have cached a DS record which validates this key */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>crecp</name> <operator>=</operator> <call><name>cache_find_by_name</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>F_DS</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>keyname</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>STAT_NEED_DS</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  
  <comment type="block">/* NOTE, we need to find ONE DNSKEY which matches the DS */</comment>
  <for>for <control>(<init><expr><name>valid</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>ancount</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>j</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>valid</name></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control> 
    <block>{<block_content>
      <comment type="block">/* Ensure we have type, class  TTL and length */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment>
  
      <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>qtype</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>qclass</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETLONG</name><argument_list>(<argument><expr><name>ttl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>rdlen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHECK_LEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>rdlen</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>rdlen</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment>
      
      <if_stmt><if>if <condition>(<expr><name>qclass</name> <operator>!=</operator> <name>class</name> <operator>||</operator> <name>qtype</name> <operator>!=</operator> <name>T_DNSKEY</name> <operator>||</operator> <name>rc</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>rdlen</name></expr>;</expr_stmt>
	  <continue>continue;</continue>
	</block_content>}</block></if></if_stmt>
            
      <expr_stmt><expr><name>psave</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      
      <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>STAT_BOGUS</name> <operator>|</operator> <name>DNSSEC_FAIL_NOKEY</name></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>algo</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>keytag</name> <operator>=</operator> <call><name>dnskey_keytag</name><argument_list>(<argument><expr><name>algo</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>rdlen</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>key</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      
      <comment type="block">/* key must have zone key flag set */</comment>
      <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <literal type="number">0x100</literal></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>blockdata_alloc</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>, <argument><expr><name>rdlen</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>failflags</name> <operator>&amp;=</operator> <operator>~</operator><name>DNSSEC_FAIL_NOZONE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
      
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name>psave</name></expr>;</expr_stmt>
      
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ADD_RDLEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>rdlen</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>key</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>blockdata_free</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <return>return <expr><name>STAT_BOGUS</name></expr>;</return> <comment type="block">/* bad packet */</comment>
	</block_content>}</block></if></if_stmt>

      <comment type="block">/* No zone key flag or malloc failure */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>key</name></expr>)</condition><block type="pseudo"><block_content>
	<continue>continue;</continue></block_content></block></if></if_stmt>
      
      <for>for <control>(<init><expr><name>recp1</name> <operator>=</operator> <name>crecp</name></expr>;</init> <condition><expr><name>recp1</name></expr>;</condition> <incr><expr><name>recp1</name> <operator>=</operator> <call><name>cache_find_by_name</name><argument_list>(<argument><expr><name>recp1</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>F_DS</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
	  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>digest</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ds_digest</name></decl>;</decl_stmt>
	  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>nettle_hash</name></name> <modifier>*</modifier></type><name>hash</name></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>int</name></type> <name>sigcnt</name></decl>, <decl><type ref="prev"/><name>rrcnt</name></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>int</name></type> <name>wire_len</name></decl>;</decl_stmt>
	  
	  <if_stmt><if>if <condition>(<expr><name><name>recp1</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>ds</name><operator>.</operator><name>algo</name></name> <operator>==</operator> <name>algo</name> <operator>&amp;&amp;</operator> 
	      <name><name>recp1</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>ds</name><operator>.</operator><name>keytag</name></name> <operator>==</operator> <name>keytag</name> <operator>&amp;&amp;</operator>
	      <name><name>recp1</name><operator>-&gt;</operator><name>uid</name></name> <operator>==</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>class</name></expr>)</condition>
	    <block>{<block_content>
	      <expr_stmt><expr><name>failflags</name> <operator>&amp;=</operator> <operator>~</operator><name>DNSSEC_FAIL_NOKEY</name></expr>;</expr_stmt>
	      
	      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>hash</name> <operator>=</operator> <call><name>hash_find</name><argument_list>(<argument><expr><call><name>ds_digest_name</name><argument_list>(<argument><expr><name><name>recp1</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>ds</name><operator>.</operator><name>digest</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<continue>continue;</continue></block_content></block></if>
	      <else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>failflags</name> <operator>&amp;=</operator> <operator>~</operator><name>DNSSEC_FAIL_NODSSUP</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hash_init</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>digest</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<continue>continue;</continue></block_content></block></if></if_stmt>
	      
	      <expr_stmt><expr><name>wire_len</name> <operator>=</operator> <call><name>to_wire</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      
	      <comment type="block">/* Note that digest may be different between DSs, so 
		 we can't move this outside the loop. */</comment>
	      <expr_stmt><expr><call><name><name>hash</name><operator>-&gt;</operator><name>update</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>wire_len</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name><name>hash</name><operator>-&gt;</operator><name>update</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>rdlen</name></expr></argument>, <argument><expr><name>psave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name><name>hash</name><operator>-&gt;</operator><name>digest</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>hash</name><operator>-&gt;</operator><name>digest_size</name></name></expr></argument>, <argument><expr><name>digest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      
	      <expr_stmt><expr><call><name>from_wire</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      
	      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>recp1</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>F_NEG</name><operator>)</operator> <operator>&amp;&amp;</operator>
		  <name><name>recp1</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>ds</name><operator>.</operator><name>keylen</name></name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>hash</name><operator>-&gt;</operator><name>digest_size</name></name> <operator>&amp;&amp;</operator>
		  <operator>(</operator><name>ds_digest</name> <operator>=</operator> <call><name>blockdata_retrieve</name><argument_list>(<argument><expr><name><name>recp1</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>ds</name><operator>.</operator><name>keydata</name></name></expr></argument>, <argument><expr><name><name>recp1</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>ds</name><operator>.</operator><name>keylen</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
		  <call><name>memcmp</name><argument_list>(<argument><expr><name>ds_digest</name></expr></argument>, <argument><expr><name>digest</name></expr></argument>, <argument><expr><name><name>recp1</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>ds</name><operator>.</operator><name>keylen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		  <call><name>explore_rrset</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>class</name></expr></argument>, <argument><expr><name>T_DNSKEY</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sigcnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rrcnt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		  <name>rrcnt</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
		  <if_stmt><if>if <condition>(<expr><name>sigcnt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		    <continue>continue;</continue></block_content></block></if>
		  <else>else<block type="pseudo"><block_content>
		    <expr_stmt><expr><name>failflags</name> <operator>&amp;=</operator> <operator>~</operator><name>DNSSEC_FAIL_NOSIG</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		  
		  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>validate_rrset</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>class</name></expr></argument>, <argument><expr><name>T_DNSKEY</name></expr></argument>, <argument><expr><name>sigcnt</name></expr></argument>, <argument><expr><name>rrcnt</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>, 
				      <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>rdlen</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>algo</name></expr></argument>, <argument><expr><name>keytag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sig_ttl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		  <expr_stmt><expr><name>failflags</name> <operator>&amp;=</operator> <name>rc</name></expr>;</expr_stmt>
		  
		  <if_stmt><if>if <condition>(<expr><call><name>STAT_ISEQUAL</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>STAT_SECURE</name></expr></argument>)</argument_list></call></expr>)</condition>
		    <block>{<block_content>
		      <expr_stmt><expr><name>valid</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		      <break>break;</break>
		    </block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	    </block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
      <expr_stmt><expr><call><name>blockdata_free</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><name>valid</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* DNSKEY RRset determined to be OK, now cache it. */</comment>
      <expr_stmt><expr><call><name>cache_start_insert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      
      <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skip_questions</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>ancount</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>j</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control> 
	<block>{<block_content>
	  <comment type="block">/* Ensure we have type, class  TTL and length */</comment>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment>
	  
	  <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>qtype</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	  <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>qclass</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>GETLONG</name><argument_list>(<argument><expr><name>ttl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>rdlen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	  <comment type="block">/* TTL may be limited by sig. */</comment>
	  <if_stmt><if>if <condition>(<expr><name>sig_ttl</name> <operator>&lt;</operator> <name>ttl</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>ttl</name> <operator>=</operator> <name>sig_ttl</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	    
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHECK_LEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>rdlen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment>
	  
	  <if_stmt><if>if <condition>(<expr><name>qclass</name> <operator>==</operator> <name>class</name> <operator>&amp;&amp;</operator> <name>rc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	    <block>{<block_content>
	      <expr_stmt><expr><name>psave</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
	      
	      <if_stmt><if>if <condition>(<expr><name>qtype</name> <operator>==</operator> <name>T_DNSKEY</name></expr>)</condition>
		<block>{<block_content>
		  <if_stmt><if>if <condition>(<expr><name>rdlen</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment>
		  
		  <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt>
		  <expr_stmt><expr><name>algo</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
		  <expr_stmt><expr><name>keytag</name> <operator>=</operator> <call><name>dnskey_keytag</name><argument_list>(<argument><expr><name>algo</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>rdlen</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  
		  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>key</name> <operator>=</operator> <call><name>blockdata_alloc</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>, <argument><expr><name>rdlen</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		    <block>{<block_content>
		      <expr_stmt><expr><name><name>a</name><operator>.</operator><name>key</name><operator>.</operator><name>keylen</name></name> <operator>=</operator> <name>rdlen</name> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		      <expr_stmt><expr><name><name>a</name><operator>.</operator><name>key</name><operator>.</operator><name>keydata</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
		      <expr_stmt><expr><name><name>a</name><operator>.</operator><name>key</name><operator>.</operator><name>algo</name></name> <operator>=</operator> <name>algo</name></expr>;</expr_stmt>
		      <expr_stmt><expr><name><name>a</name><operator>.</operator><name>key</name><operator>.</operator><name>keytag</name></name> <operator>=</operator> <name>keytag</name></expr>;</expr_stmt>
		      <expr_stmt><expr><name><name>a</name><operator>.</operator><name>key</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
		      
		      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cache_insert</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><name>class</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>ttl</name></expr></argument>, <argument><expr><name>F_FORWARD</name> <operator>|</operator> <name>F_DNSKEY</name> <operator>|</operator> <name>F_DNSSECOK</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
			  <expr_stmt><expr><call><name>blockdata_free</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			  <return>return <expr><name>STAT_BOGUS</name></expr>;</return>
			</block_content>}</block></if>
		      <else>else
			<block>{<block_content>
			  <expr_stmt><expr><name><name>a</name><operator>.</operator><name>log</name><operator>.</operator><name>keytag</name></name> <operator>=</operator> <name>keytag</name></expr>;</expr_stmt>
			  <expr_stmt><expr><name><name>a</name><operator>.</operator><name>log</name><operator>.</operator><name>algo</name></name> <operator>=</operator> <name>algo</name></expr>;</expr_stmt>
			  <if_stmt><if>if <condition>(<expr><call><name>algo_digest_name</name><argument_list>(<argument><expr><name>algo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			    <expr_stmt><expr><call><name>log_query</name><argument_list>(<argument><expr><name>F_NOEXTRA</name> <operator>|</operator> <name>F_KEYTAG</name> <operator>|</operator> <name>F_UPSTREAM</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><literal type="string">"DNSKEY keytag %hu, algo %hu"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			  <else>else<block type="pseudo"><block_content>
			    <expr_stmt><expr><call><name>log_query</name><argument_list>(<argument><expr><name>F_NOEXTRA</name> <operator>|</operator> <name>F_KEYTAG</name> <operator>|</operator> <name>F_UPSTREAM</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><literal type="string">"DNSKEY keytag %hu, algo %hu (not supported)"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		    </block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	      	      
	      <expr_stmt><expr><name>p</name> <operator>=</operator> <name>psave</name></expr>;</expr_stmt>
	    </block_content>}</block></if></if_stmt>

	  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ADD_RDLEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>rdlen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment>
	</block_content>}</block></for>
      
      <comment type="block">/* commit cache insert. */</comment>
      <expr_stmt><expr><call><name>cache_end_insert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>STAT_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>log_query</name><argument_list>(<argument><expr><name>F_NOEXTRA</name> <operator>|</operator> <name>F_UPSTREAM</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"BOGUS DNSKEY"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>STAT_BOGUS</name> <operator>|</operator> <name>failflags</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The DNS packet is expected to contain the answer to a DS query
   Put all DSs in the answer which are valid and have hash and signature algos
   we support into the cache.
   Also handles replies which prove that there's no DS at this location, 
   either because the zone is unsigned or this isn't a zone cut. These are
   cached too.
   If none of the DS's are for supported algos, treat the answer as if 
   it's a proof of no DS at this location. RFC4035 para 5.2.
   return codes:
   STAT_OK          At least one valid DS found and in cache.
   STAT_BOGUS       no DS in reply or not signed, fails validation, bad packet.
   STAT_NEED_KEY    DNSKEY records to validate a DS not found, name in keyname
   STAT_NEED_DS     DS record needed.
*/</comment>

<function><type><name>int</name></type> <name>dnssec_validate_ds</name><parameter_list>(<parameter><decl><type><name>time_t</name></type> <name>now</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>dns_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>plen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>keyname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>class</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>header</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>qtype</name></decl>, <decl><type ref="prev"/><name>qclass</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>neganswer</name></decl>, <decl><type ref="prev"/><name>nons</name></decl>, <decl><type ref="prev"/><name>neg_ttl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>found_supported</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>aclass</name></decl>, <decl><type ref="prev"/><name>atype</name></decl>, <decl><type ref="prev"/><name>rdlen</name></decl>, <decl><type ref="prev"/><name>flags</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>ttl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>union</name> <name>all_addr</name></name></type> <name>a</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>qdcount</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
      <operator>!</operator><operator>(</operator><name>p</name> <operator>=</operator> <call><name>skip_name</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt>
  
  <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>qtype</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>qclass</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>qtype</name> <operator>!=</operator> <name>T_DS</name> <operator>||</operator> <name>qclass</name> <operator>!=</operator> <name>class</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>STAT_BOGUS</name></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>dnssec_validate_reply</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>neganswer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nons</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>neg_ttl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
  
  <if_stmt><if>if <condition>(<expr><call><name>STAT_ISEQUAL</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>STAT_INSECURE</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>my_syslog</name><argument_list>(<argument><expr><name>LOG_WARNING</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Insecure DS reply received for %s, check domain configuration and upstream DNS server DNSSEC support"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>log_query</name><argument_list>(<argument><expr><name>F_NOEXTRA</name> <operator>|</operator> <name>F_UPSTREAM</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"BOGUS DS - not secure"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>STAT_BOGUS</name> <operator>|</operator> <name>DNSSEC_FAIL_INDET</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>header</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <comment type="block">/* qtype, qclass */</comment>
  
  <comment type="block">/* If the key needed to validate the DS is on the same domain as the DS, we'll
     loop getting nowhere. Stop that now. This can happen of the DS answer comes
     from the DS's zone, and not the parent zone. */</comment>
  <if_stmt><if>if <condition>(<expr><call><name>STAT_ISEQUAL</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>STAT_NEED_KEY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>hostname_isequal</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>log_query</name><argument_list>(<argument><expr><name>F_NOEXTRA</name> <operator>|</operator> <name>F_UPSTREAM</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"BOGUS DS"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>STAT_BOGUS</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STAT_ISEQUAL</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>STAT_SECURE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
   
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>neganswer</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>cache_start_insert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>ancount</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment>
	  
	  <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>atype</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>aclass</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>GETLONG</name><argument_list>(<argument><expr><name>ttl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>rdlen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHECK_LEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>rdlen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment>
	  
	  <if_stmt><if>if <condition>(<expr><name>aclass</name> <operator>==</operator> <name>class</name> <operator>&amp;&amp;</operator> <name>atype</name> <operator>==</operator> <name>T_DS</name> <operator>&amp;&amp;</operator> <name>rc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	    <block>{<block_content> 
	      <decl_stmt><decl><type><name>int</name></type> <name>algo</name></decl>, <decl><type ref="prev"/><name>digest</name></decl>, <decl><type ref="prev"/><name>keytag</name></decl>;</decl_stmt>
	      <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>psave</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
	      <decl_stmt><decl><type><name><name>struct</name> <name>blockdata</name></name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>
	   
	      <if_stmt><if>if <condition>(<expr><name>rdlen</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment>
	      
	      <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>keytag</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><name>algo</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
	      <expr_stmt><expr><name>digest</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
	      
	      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ds_digest_name</name><argument_list>(<argument><expr><name>digest</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>ds_digest_name</name><argument_list>(<argument><expr><name>digest</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><name><name>a</name><operator>.</operator><name>log</name><operator>.</operator><name>keytag</name></name> <operator>=</operator> <name>keytag</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>a</name><operator>.</operator><name>log</name><operator>.</operator><name>algo</name></name> <operator>=</operator> <name>algo</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>a</name><operator>.</operator><name>log</name><operator>.</operator><name>digest</name></name> <operator>=</operator> <name>digest</name></expr>;</expr_stmt>
		  <expr_stmt><expr><call><name>log_query</name><argument_list>(<argument><expr><name>F_NOEXTRA</name> <operator>|</operator> <name>F_KEYTAG</name> <operator>|</operator> <name>F_UPSTREAM</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><literal type="string">"DS keytag %hu, algo %hu, digest %hu (not supported)"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><name>neg_ttl</name> <operator>=</operator> <name>ttl</name></expr>;</expr_stmt>
		</block_content>}</block></if> 
	      <if type="elseif">else if <condition>(<expr><operator>(</operator><name>key</name> <operator>=</operator> <call><name>blockdata_alloc</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>, <argument><expr><name>rdlen</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><name><name>a</name><operator>.</operator><name>ds</name><operator>.</operator><name>digest</name></name> <operator>=</operator> <name>digest</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>a</name><operator>.</operator><name>ds</name><operator>.</operator><name>keydata</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>a</name><operator>.</operator><name>ds</name><operator>.</operator><name>algo</name></name> <operator>=</operator> <name>algo</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>a</name><operator>.</operator><name>ds</name><operator>.</operator><name>keytag</name></name> <operator>=</operator> <name>keytag</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name><name>a</name><operator>.</operator><name>ds</name><operator>.</operator><name>keylen</name></name> <operator>=</operator> <name>rdlen</name> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		  
		  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cache_insert</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><name>class</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>ttl</name></expr></argument>, <argument><expr><name>F_FORWARD</name> <operator>|</operator> <name>F_DS</name> <operator>|</operator> <name>F_DNSSECOK</name></expr></argument>)</argument_list></call></expr>)</condition>
		    <block>{<block_content>
		      <expr_stmt><expr><call><name>blockdata_free</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <return>return <expr><name>STAT_BOGUS</name></expr>;</return>
		    </block_content>}</block></if>
		  <else>else
		    <block>{<block_content>
		      <expr_stmt><expr><name><name>a</name><operator>.</operator><name>log</name><operator>.</operator><name>keytag</name></name> <operator>=</operator> <name>keytag</name></expr>;</expr_stmt>
		      <expr_stmt><expr><name><name>a</name><operator>.</operator><name>log</name><operator>.</operator><name>algo</name></name> <operator>=</operator> <name>algo</name></expr>;</expr_stmt>
		      <expr_stmt><expr><name><name>a</name><operator>.</operator><name>log</name><operator>.</operator><name>digest</name></name> <operator>=</operator> <name>digest</name></expr>;</expr_stmt>
		      <expr_stmt><expr><call><name>log_query</name><argument_list>(<argument><expr><name>F_NOEXTRA</name> <operator>|</operator> <name>F_KEYTAG</name> <operator>|</operator> <name>F_UPSTREAM</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><literal type="string">"DS keytag %hu, algo %hu, digest %hu"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <expr_stmt><expr><name>found_supported</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		    </block_content>}</block></else></if_stmt> 
		</block_content>}</block></if></if_stmt>
	      
	      <expr_stmt><expr><name>p</name> <operator>=</operator> <name>psave</name></expr>;</expr_stmt>
	    </block_content>}</block></if></if_stmt>

	  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ADD_RDLEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>rdlen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment>
	</block_content>}</block></for>

      <expr_stmt><expr><call><name>cache_end_insert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Fall through if no supported algo DS found. */</comment>
      <if_stmt><if>if <condition>(<expr><name>found_supported</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>STAT_OK</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  
  <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>F_FORWARD</name> <operator>|</operator> <name>F_DS</name> <operator>|</operator> <name>F_NEG</name> <operator>|</operator> <name>F_DNSSECOK</name></expr>;</expr_stmt>
  
  <if_stmt><if>if <condition>(<expr><name>neganswer</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>RCODE</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NXDOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>F_NXDOMAIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
      
      <comment type="block">/* We only cache validated DS records, DNSSECOK flag hijacked 
	 to store presence/absence of NS. */</comment>
      <if_stmt><if>if <condition>(<expr><name>nons</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>F_DNSSECOK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  
  <expr_stmt><expr><call><name>cache_start_insert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Use TTL from NSEC for negative cache entries */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cache_insert</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>class</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>neg_ttl</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt>
  
  <expr_stmt><expr><call><name>cache_end_insert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>  
  
  <if_stmt><if>if <condition>(<expr><name>neganswer</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>log_query</name><argument_list>(<argument><expr><name>F_NOEXTRA</name> <operator>|</operator> <name>F_UPSTREAM</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><ternary><condition><expr><name>nons</name></expr> ?</condition><then> <expr><literal type="string">"no DS/cut"</literal></expr> </then><else>: <expr><literal type="string">"no DS"</literal></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      
  <return>return <expr><name>STAT_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* 4034 6.1 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hostname_cmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sa</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ea</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ca</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sb</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>eb</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>ac</name></decl>, <decl><type ref="prev"/><name>bc</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><name>sa</name> <operator>=</operator> <name>ea</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>a</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>sb</name> <operator>=</operator> <name>eb</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>b</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 
  <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
      <while>while <condition>(<expr><name>sa</name> <operator>!=</operator> <name>a</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>sa</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>sa</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
      
      <while>while <condition>(<expr><name>sb</name> <operator>!=</operator> <name>b</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>sb</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>sb</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

      <expr_stmt><expr><name>ca</name> <operator>=</operator> <name>sa</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cb</name> <operator>=</operator> <name>sb</name></expr>;</expr_stmt>

      <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> 
	<block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>ca</name> <operator>==</operator> <name>ea</name></expr>)</condition>
	    <block>{<block_content>
	      <if_stmt><if>if <condition>(<expr><name>cb</name> <operator>==</operator> <name>eb</name></expr>)</condition><block type="pseudo"><block_content>
		<break>break;</break></block_content></block></if></if_stmt>
	      
	      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	    </block_content>}</block></if></if_stmt>
	  
	  <if_stmt><if>if <condition>(<expr><name>cb</name> <operator>==</operator> <name>eb</name></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	  
	  <expr_stmt><expr><name>ac</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>ca</name><operator>++</operator></expr>;</expr_stmt>
	  <expr_stmt><expr><name>bc</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>cb</name><operator>++</operator></expr>;</expr_stmt>
	  
	  <if_stmt><if>if <condition>(<expr><name>ac</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>ac</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>ac</name> <operator>+=</operator> <literal type="char">'a'</literal> <operator>-</operator> <literal type="char">'A'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <if_stmt><if>if <condition>(<expr><name>bc</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>bc</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>bc</name> <operator>+=</operator> <literal type="char">'a'</literal> <operator>-</operator> <literal type="char">'A'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  
	  <if_stmt><if>if <condition>(<expr><name>ac</name> <operator>&lt;</operator> <name>bc</name></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	  <if type="elseif">else if <condition>(<expr><name>ac</name> <operator>!=</operator> <name>bc</name></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>

     
      <if_stmt><if>if <condition>(<expr><name>sa</name> <operator>==</operator> <name>a</name></expr>)</condition>
	<block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>sb</name> <operator>==</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	  
	  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
      
      <if_stmt><if>if <condition>(<expr><name>sb</name> <operator>==</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
      
      <expr_stmt><expr><name>ea</name> <operator>=</operator> <operator>--</operator><name>sa</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>eb</name> <operator>=</operator> <operator>--</operator><name>sb</name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>prove_non_existence_nsec</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dns_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>plen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nsecs</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>labels</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nsec_count</name></decl></parameter>,
				    <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>workspace1_in</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>workspace2</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nons</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>, <decl><type ref="prev"/><name>rdlen</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>psave</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><operator>(</operator><name>type</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>mask</name> <init>= <expr><literal type="number">0x80</literal> <operator>&gt;&gt;</operator> <operator>(</operator><name>type</name> <operator>&amp;</operator> <literal type="number">0x07</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>nons</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>nons</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  
  <comment type="block">/* Find NSEC record that proves name doesn't exist */</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsec_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>workspace1</name> <init>= <expr><name>workspace1_in</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>sig_labels</name></decl>, <decl><type ref="prev"/><name>name_labels</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>nsecs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>workspace1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt> <comment type="block">/* class, type, TTL */</comment>
      <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>rdlen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>psave</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>workspace2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

      <comment type="block">/* If NSEC comes from wildcard expansion, use original wildcard
	 as name for computation. */</comment>
      <expr_stmt><expr><name>sig_labels</name> <operator>=</operator> <operator>*</operator><name><name>labels</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>name_labels</name> <operator>=</operator> <call><name>count_labels</name><argument_list>(<argument><expr><name>workspace1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>sig_labels</name> <operator>&lt;</operator> <name>name_labels</name></expr>)</condition>
	<block>{<block_content>
	  <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
	  <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name>name_labels</name> <operator>-</operator> <name>sig_labels</name></expr>;</init> <condition><expr><name>k</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>k</name><operator>--</operator></expr></incr>)</control>
	    <block>{<block_content>
	      <while>while <condition>(<expr><operator>*</operator><name>workspace1</name> <operator>!=</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>workspace1</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>workspace1</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	      <if_stmt><if>if <condition>(<expr><name>k</name> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>workspace1</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>workspace1</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	    </block_content>}</block></for>
	  
	  <expr_stmt><expr><name>workspace1</name><operator>--</operator></expr>;</expr_stmt>
	  <expr_stmt><expr><operator>*</operator><name>workspace1</name> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	  
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>hostname_cmp</name><argument_list>(<argument><expr><name>workspace1</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
	  <comment type="block">/* 4035 para 5.4. Last sentence */</comment>
	  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>T_NSEC</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>T_RRSIG</name></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	  <comment type="block">/* NSEC with the same name as the RR we're testing, check
	     that the type in question doesn't appear in the type map */</comment>
	  <expr_stmt><expr><name>rdlen</name> <operator>-=</operator> <name>p</name> <operator>-</operator> <name>psave</name></expr>;</expr_stmt>
	  <comment type="block">/* rdlen is now length of type map, and p points to it */</comment>
	  
	  <comment type="block">/* If we can prove that there's no NS record, return that information. */</comment>
	  <if_stmt><if>if <condition>(<expr><name>nons</name> <operator>&amp;&amp;</operator> <name>rdlen</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">0x80</literal> <operator>&gt;&gt;</operator> <name>T_NS</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><operator>*</operator><name>nons</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  
	  <if_stmt><if>if <condition>(<expr><name>rdlen</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	    <block>{<block_content>
	      <comment type="block">/* A CNAME answer would also be valid, so if there's a CNAME is should 
		 have been returned. */</comment>
	      <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">0x80</literal> <operator>&gt;&gt;</operator> <name>T_CNAME</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	      
	      <comment type="block">/* If the SOA bit is set for a DS record, then we have the
		 DS from the wrong side of the delegation. For the root DS, 
		 this is expected. */</comment>
	      <if_stmt><if>if <condition>(<expr><name>name_labels</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>T_DS</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">0x80</literal> <operator>&gt;&gt;</operator> <name>T_SOA</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	    </block_content>}</block></if></if_stmt>

	  <while>while <condition>(<expr><name>rdlen</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition>
	    <block>{<block_content>
	      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHECK_LEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>rdlen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	      
	      <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>type</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>)</condition>
		<block>{<block_content>
		  <comment type="block">/* Does the NSEC say our type exists? */</comment>
		  <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><index>[<expr><name>offset</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		  
		  <break>break;</break> <comment type="block">/* finished checking */</comment>
		</block_content>}</block></if></if_stmt>
	      
	      <expr_stmt><expr><name>rdlen</name> <operator>-=</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	      <expr_stmt><expr><name>p</name> <operator>+=</operator>  <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	    </block_content>}</block></while>
	  
	  <return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>rc</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
	  <comment type="block">/* Normal case, name falls between NSEC name and next domain name,
	     wrap around case, name falls between NSEC name (rc == -1) and end */</comment>
	  <if_stmt><if>if <condition>(<expr><call><name>hostname_cmp</name><argument_list>(<argument><expr><name>workspace2</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>hostname_cmp</name><argument_list>(<argument><expr><name>workspace1</name></expr></argument>, <argument><expr><name>workspace2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
      <else>else 
	<block>{<block_content>
	  <comment type="block">/* wrap around case, name falls between start and next domain name */</comment>
	  <if_stmt><if>if <condition>(<expr><call><name>hostname_cmp</name><argument_list>(<argument><expr><name>workspace1</name></expr></argument>, <argument><expr><name>workspace2</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>hostname_cmp</name><argument_list>(<argument><expr><name>workspace2</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator><literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
	    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
  
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* return digest length, or zero on error */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hash_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>nettle_hash</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>hash</name></decl></parameter>, 
		     <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>salt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>salt_len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iterations</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>digest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hash_init</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>digest</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
 
  <expr_stmt><expr><call><name><name>hash</name><operator>-&gt;</operator><name>update</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><call><name>to_wire</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>hash</name><operator>-&gt;</operator><name>update</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>salt_len</name></expr></argument>, <argument><expr><name>salt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>hash</name><operator>-&gt;</operator><name>digest</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>hash</name><operator>-&gt;</operator><name>digest_size</name></name></expr></argument>, <argument><expr><name>digest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>iterations</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <expr_stmt><expr><call><name><name>hash</name><operator>-&gt;</operator><name>update</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>hash</name><operator>-&gt;</operator><name>digest_size</name></name></expr></argument>, <argument><expr><name>digest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>hash</name><operator>-&gt;</operator><name>update</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>salt_len</name></expr></argument>, <argument><expr><name>salt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>hash</name><operator>-&gt;</operator><name>digest</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>hash</name><operator>-&gt;</operator><name>digest_size</name></name></expr></argument>, <argument><expr><name>digest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
   
  <expr_stmt><expr><call><name>from_wire</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <name>digest</name></expr>;</expr_stmt>
  <return>return <expr><name><name>hash</name><operator>-&gt;</operator><name>digest_size</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Decode base32 to first "." or end of string */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>base32_decode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>oc</name></decl>, <decl><type ref="prev"/><name>on</name></decl>, <decl><type ref="prev"/><name>c</name></decl>, <decl><type ref="prev"/><name>mask</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>out</name></expr></init></decl>;</decl_stmt>
 
  <for>for <control>(<init><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>in</name></expr><operator>,</operator> <expr><name>oc</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>on</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">'.'</literal></expr>;</condition> <incr><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>in</name></expr></incr>)</control> 
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>c</name> <operator>-=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'v'</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>c</name> <operator>-=</operator> <literal type="char">'a'</literal></expr><operator>,</operator> <expr><name>c</name> <operator>+=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'V'</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>c</name> <operator>-=</operator> <literal type="char">'A'</literal></expr><operator>,</operator> <expr><name>c</name> <operator>+=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
      
      <for>for <control>(<init><expr><name>mask</name> <operator>=</operator> <literal type="number">0x10</literal></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>c</name> <operator>&amp;</operator> <name>mask</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>oc</name> <operator>|=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <expr_stmt><expr><name>mask</name> <operator>=</operator> <name>mask</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>++</operator><name>on</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">7</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>oc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <expr_stmt><expr><name>oc</name> <operator>=</operator> <name>oc</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
    </block_content>}</block></for>
  
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>on</name> <operator>&amp;</operator> <literal type="number">7</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><name>p</name> <operator>-</operator> <name>out</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>check_nsec3_coverage</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dns_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>plen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>digest_len</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>digest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>,
				<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>workspace1</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>workspace2</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nsecs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nsec_count</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nons</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>name_labels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>hash_len</name></decl>, <decl><type ref="prev"/><name>salt_len</name></decl>, <decl><type ref="prev"/><name>base32_len</name></decl>, <decl><type ref="prev"/><name>rdlen</name></decl>, <decl><type ref="prev"/><name>flags</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>psave</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsec_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <name><name>nsecs</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
       	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>workspace1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator>
	    <operator>!</operator><operator>(</operator><name>base32_len</name> <operator>=</operator> <call><name>base32_decode</name><argument_list>(<argument><expr><name>workspace1</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>workspace2</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt> <comment type="block">/* class, type, TTL */</comment>
	<expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>rdlen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>psave</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* algo */</comment>
	<expr_stmt><expr><name>flags</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* flags */</comment>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <comment type="block">/* iterations */</comment>
	<expr_stmt><expr><name>salt_len</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* salt_len */</comment>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>salt_len</name></expr>;</expr_stmt> <comment type="block">/* salt */</comment>
	<expr_stmt><expr><name>hash_len</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* p now points to next hashed name */</comment>
	
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHECK_LEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>hash_len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>digest_len</name> <operator>==</operator> <name>base32_len</name> <operator>&amp;&amp;</operator> <name>hash_len</name> <operator>==</operator> <name>base32_len</name></expr>)</condition>
	  <block>{<block_content>
	    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>workspace2</name></expr></argument>, <argument><expr><name>digest</name></expr></argument>, <argument><expr><name>digest_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	    <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	      <block>{<block_content>
		<comment type="block">/* We found an NSEC3 whose hashed name exactly matches the query, so
		   we just need to check the type map. p points to the RR data for the record. */</comment>
		
		<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><operator>(</operator><name>type</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>mask</name> <init>= <expr><literal type="number">0x80</literal> <operator>&gt;&gt;</operator> <operator>(</operator><name>type</name> <operator>&amp;</operator> <literal type="number">0x07</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
		
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>hash_len</name></expr>;</expr_stmt> <comment type="block">/* skip next-domain hash */</comment>
		<expr_stmt><expr><name>rdlen</name> <operator>-=</operator> <name>p</name> <operator>-</operator> <name>psave</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHECK_LEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>rdlen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		  <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		
		<if_stmt><if>if <condition>(<expr><name>rdlen</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		  <block>{<block_content>
		    <comment type="block">/* If we can prove that there's no NS record, return that information. */</comment>
		    <if_stmt><if>if <condition>(<expr><name>nons</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">0x80</literal> <operator>&gt;&gt;</operator> <name>T_NS</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		      <expr_stmt><expr><operator>*</operator><name>nons</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		
		    <comment type="block">/* A CNAME answer would also be valid, so if there's a CNAME is should 
		       have been returned. */</comment>
		    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">0x80</literal> <operator>&gt;&gt;</operator> <name>T_CNAME</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		      <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		    
		    <comment type="block">/* If the SOA bit is set for a DS record, then we have the
		       DS from the wrong side of the delegation. For the root DS, 
		       this is expected.  */</comment>
		    <if_stmt><if>if <condition>(<expr><name>name_labels</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>T_DS</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">0x80</literal> <operator>&gt;&gt;</operator> <name>T_SOA</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		      <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		  </block_content>}</block></if></if_stmt>

		<while>while <condition>(<expr><name>rdlen</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition>
		  <block>{<block_content>
		    <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>type</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr>)</condition>
		      <block>{<block_content>
			<comment type="block">/* Does the NSEC3 say our type exists? */</comment>
			<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><index>[<expr><name>offset</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			  <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
			
			<break>break;</break> <comment type="block">/* finished checking */</comment>
		      </block_content>}</block></if></if_stmt>
		    
		    <expr_stmt><expr><name>rdlen</name> <operator>-=</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		    <expr_stmt><expr><name>p</name> <operator>+=</operator>  <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		  </block_content>}</block></while>
		
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	      </block_content>}</block></if>
	    <if type="elseif">else if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	      <block>{<block_content>
		<comment type="block">/* Normal case, hash falls between NSEC3 name-hash and next domain name-hash,
		   wrap around case, name-hash falls between NSEC3 name-hash and end */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>digest</name></expr></argument>, <argument><expr><name>digest_len</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>workspace2</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>digest_len</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		  <block>{<block_content>
		    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <literal type="number">0x01</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>nons</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* opt out */</comment>
		      <expr_stmt><expr><operator>*</operator><name>nons</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		    <return>return <expr><literal type="number">1</literal></expr>;</return>
		  </block_content>}</block></if></if_stmt>
	      </block_content>}</block></if>
	    <else>else 
	      <block>{<block_content>
		<comment type="block">/* wrap around case, name falls between start and next domain name */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>workspace2</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>digest_len</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>digest</name></expr></argument>, <argument><expr><name>digest_len</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		  <block>{<block_content>
		    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <literal type="number">0x01</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>nons</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* opt out */</comment>
		      <expr_stmt><expr><operator>*</operator><name>nons</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		    <return>return <expr><literal type="number">1</literal></expr>;</return>
		  </block_content>}</block></if></if_stmt>
	      </block_content>}</block></else></if_stmt>
	  </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt></block_content></block></for>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>prove_non_existence_nsec3</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dns_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>plen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nsecs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nsec_count</name></decl></parameter>,
				     <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>workspace1</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>workspace2</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>wildname</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nons</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>salt</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>digest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>digest_len</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>iterations</name></decl>, <decl><type ref="prev"/><name>salt_len</name></decl>, <decl><type ref="prev"/><name>base32_len</name></decl>, <decl><type ref="prev"/><name>algo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>nettle_hash</name></name> <specifier>const</specifier> <modifier>*</modifier></type><name>hash</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>closest_encloser</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next_closest</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>wildcard</name></decl>;</decl_stmt>
  
  <if_stmt><if>if <condition>(<expr><name>nons</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>nons</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  
  <comment type="block">/* Look though the NSEC3 records to find the first one with 
     an algorithm we support.

     Take the algo, iterations, and salt of that record
     as the ones we're going to use, and prune any 
     that don't match. */</comment>
  
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsec_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>p</name> <operator>=</operator> <call><name>skip_name</name><argument_list>(<argument><expr><name><name>nsecs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment>
      
     <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">10</literal></expr>;</expr_stmt> <comment type="block">/* type, class, TTL, rdlen */</comment>
      <expr_stmt><expr><name>algo</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
      
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>hash</name> <operator>=</operator> <call><name>hash_find</name><argument_list>(<argument><expr><call><name>nsec3_digest_name</name><argument_list>(<argument><expr><name>algo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* known algo */</comment>
    </block_content>}</block></for>

  <comment type="block">/* No usable NSEC3s */</comment>
  <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>nsec_count</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* flags */</comment>

  <expr_stmt><expr><call><name>GETSHORT</name> <argument_list>(<argument><expr><name>iterations</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Upper-bound iterations, to avoid DoS.
     Strictly, there are lower bounds for small keys, but
     since we don't have key size info here, at least limit
     to the largest bound, for 4096-bit keys. RFC 5155 10.3 */</comment>
  <if_stmt><if>if <condition>(<expr><name>iterations</name> <operator>&gt;</operator> <literal type="number">2500</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  
  <expr_stmt><expr><name>salt_len</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>salt</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHECK_LEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>salt</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>salt_len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment>
    
  <comment type="block">/* Now prune so we only have NSEC3 records with same iterations, salt and algo */</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsec_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>nsec3p</name> <init>= <expr><name><name>nsecs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>this_iter</name></decl>, <decl><type ref="prev"/><name>flags</name></decl>;</decl_stmt>

      <expr_stmt><expr><name><name>nsecs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* Speculative, will be restored if OK. */</comment>
      
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>p</name> <operator>=</operator> <call><name>skip_name</name><argument_list>(<argument><expr><name>nsec3p</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment>
      
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">10</literal></expr>;</expr_stmt> <comment type="block">/* type, class, TTL, rdlen */</comment>
      
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator> <operator>!=</operator> <name>algo</name></expr>)</condition><block type="pseudo"><block_content>
	<continue>continue;</continue></block_content></block></if></if_stmt>
 
      <expr_stmt><expr><name>flags</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* flags */</comment>
      
      <comment type="block">/* 5155 8.2 */</comment>
      <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>flags</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
	<continue>continue;</continue></block_content></block></if></if_stmt>

      <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>this_iter</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>this_iter</name> <operator>!=</operator> <name>iterations</name></expr>)</condition><block type="pseudo"><block_content>
	<continue>continue;</continue></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>salt_len</name> <operator>!=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>)</condition><block type="pseudo"><block_content>
	<continue>continue;</continue></block_content></block></if></if_stmt>
      
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHECK_LEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>salt_len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment>

      <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>salt</name></expr></argument>, <argument><expr><name>salt_len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<continue>continue;</continue></block_content></block></if></if_stmt>

      <comment type="block">/* All match, put the pointer back */</comment>
      <expr_stmt><expr><name><name>nsecs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>nsec3p</name></expr>;</expr_stmt>
    </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>digest_len</name> <operator>=</operator> <call><name>hash_name</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>digest</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>salt</name></expr></argument>, <argument><expr><name>salt_len</name></expr></argument>, <argument><expr><name>iterations</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  
  <if_stmt><if>if <condition>(<expr><call><name>check_nsec3_coverage</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>digest_len</name></expr></argument>, <argument><expr><name>digest</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>workspace1</name></expr></argument>, <argument><expr><name>workspace2</name></expr></argument>, <argument><expr><name>nsecs</name></expr></argument>, <argument><expr><name>nsec_count</name></expr></argument>, <argument><expr><name>nons</name></expr></argument>, <argument><expr><call><name>count_labels</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Can't find an NSEC3 which covers the name directly, we need the "closest encloser NSEC3" 
     or an answer inferred from a wildcard record. */</comment>
  <expr_stmt><expr><name>closest_encloser</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>next_closest</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <do>do
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>closest_encloser</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>closest_encloser</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>wildname</name> <operator>&amp;&amp;</operator> <call><name>hostname_isequal</name><argument_list>(<argument><expr><name>closest_encloser</name></expr></argument>, <argument><expr><name>wildname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<break>break;</break></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>digest_len</name> <operator>=</operator> <call><name>hash_name</name><argument_list>(<argument><expr><name>closest_encloser</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>digest</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>salt</name></expr></argument>, <argument><expr><name>salt_len</name></expr></argument>, <argument><expr><name>iterations</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      
      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsec_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <name><name>nsecs</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>)</condition>
	  <block>{<block_content>
	    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>workspace1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><operator>(</operator><name>base32_len</name> <operator>=</operator> <call><name>base32_decode</name><argument_list>(<argument><expr><name>workspace1</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>workspace2</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	      <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	  
	    <if_stmt><if>if <condition>(<expr><name>digest_len</name> <operator>==</operator> <name>base32_len</name> <operator>&amp;&amp;</operator>
		<call><name>memcmp</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>workspace2</name></expr></argument>, <argument><expr><name>digest_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	      <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* Gotit */</comment>
	  </block_content>}</block></if></if_stmt></block_content></block></for>
      
      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>nsec_count</name></expr>)</condition><block type="pseudo"><block_content>
	<break>break;</break></block_content></block></if></if_stmt>
      
      <expr_stmt><expr><name>next_closest</name> <operator>=</operator> <name>closest_encloser</name></expr>;</expr_stmt>
    </block_content>}</block>
  while <condition>(<expr><operator>(</operator><name>closest_encloser</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>closest_encloser</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>;</do>
  
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>closest_encloser</name> <operator>||</operator> <operator>!</operator><name>next_closest</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  
  <comment type="block">/* Look for NSEC3 that proves the non-existence of the next-closest encloser */</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>digest_len</name> <operator>=</operator> <call><name>hash_name</name><argument_list>(<argument><expr><name>next_closest</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>digest</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>salt</name></expr></argument>, <argument><expr><name>salt_len</name></expr></argument>, <argument><expr><name>iterations</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_nsec3_coverage</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>digest_len</name></expr></argument>, <argument><expr><name>digest</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>workspace1</name></expr></argument>, <argument><expr><name>workspace2</name></expr></argument>, <argument><expr><name>nsecs</name></expr></argument>, <argument><expr><name>nsec_count</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
  
  <comment type="block">/* Finally, check that there's no seat of wildcard synthesis */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>wildname</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>wildcard</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>next_closest</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <name>wildcard</name> <operator>==</operator> <name>next_closest</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      
      <expr_stmt><expr><name>wildcard</name><operator>--</operator></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>wildcard</name> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt>
      
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>digest_len</name> <operator>=</operator> <call><name>hash_name</name><argument_list>(<argument><expr><name>wildcard</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>digest</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>salt</name></expr></argument>, <argument><expr><name>salt_len</name></expr></argument>, <argument><expr><name>iterations</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
      
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_nsec3_coverage</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>digest_len</name></expr></argument>, <argument><expr><name>digest</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>workspace1</name></expr></argument>, <argument><expr><name>workspace2</name></expr></argument>, <argument><expr><name>nsecs</name></expr></argument>, <argument><expr><name>nsec_count</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  
  <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>prove_non_existence</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dns_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>plen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>keyname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>qtype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>qclass</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>wildname</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nons</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nsec_ttl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nsecset</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>rrsig_labels</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>nsecset_sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>rrsig_labels_sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  
  <decl_stmt><decl><type><name>int</name></type> <name>type_found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>auth_start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>skip_questions</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>, <decl><type ref="prev"/><name>class</name></decl>, <decl><type ref="prev"/><name>rdlen</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>nsecs_found</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>ttl</name></decl>;</decl_stmt>
  
  <comment type="block">/* Move to NS section */</comment>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name>p</name> <operator>=</operator> <call><name>skip_section</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>ancount</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>auth_start</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  
  <for>for <control>(<init><expr><name>nsecs_found</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>nscount</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pstart</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
      
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>workspacename</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	  
      <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>class</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETLONG</name><argument_list>(<argument><expr><name>ttl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>rdlen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><name>class</name> <operator>==</operator> <name>qclass</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>type</name> <operator>==</operator> <name>T_NSEC</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>T_NSEC3</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>nsec_ttl</name></expr>)</condition>
	    <block>{<block_content>
	      <comment type="block">/* Limit TTL with sig TTL */</comment>
	      <if_stmt><if>if <condition>(<expr><name><name>daemon</name><operator>-&gt;</operator><name>rr_status</name><index>[<expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>ancount</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>&lt;</operator> <name>ttl</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ttl</name> <operator>=</operator> <name><name>daemon</name><operator>-&gt;</operator><name>rr_status</name><index>[<expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>ancount</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	      <expr_stmt><expr><operator>*</operator><name>nsec_ttl</name> <operator>=</operator> <name>ttl</name></expr>;</expr_stmt>
	    </block_content>}</block></if></if_stmt>
	  
	  <comment type="block">/* No mixed NSECing 'round here, thankyouverymuch */</comment>
	  <if_stmt><if>if <condition>(<expr><name>type_found</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>type_found</name> <operator>!=</operator> <name>type</name></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	  <expr_stmt><expr><name>type_found</name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

	  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>expand_workspace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nsecset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nsecset_sz</name></expr></argument>, <argument><expr><name>nsecs_found</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> 
	  
	  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>T_NSEC</name></expr>)</condition>
	    <block>{<block_content>
	      <comment type="block">/* If we're looking for NSECs, find the corresponding SIGs, to 
		 extract the labels value, which we need in case the NSECs
		 are the result of wildcard expansion.
		 Note that the NSEC may not have been validated yet
		 so if there are multiple SIGs, make sure the label value
		 is the same in all, to avoid be duped by a rogue one.
		 If there are no SIGs, that's an error */</comment>
	      <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><name>auth_start</name></expr></init></decl>;</decl_stmt>
	      <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>rdlen1</name></decl>, <decl><type ref="prev"/><name>type1</name></decl>, <decl><type ref="prev"/><name>class1</name></decl>;</decl_stmt>
	      
	      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>expand_workspace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rrsig_labels</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rrsig_labels_sz</name></expr></argument>, <argument><expr><name>nsecs_found</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	      
	      <expr_stmt><expr><name><name>rrsig_labels</name><index>[<expr><name>nsecs_found</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	      
	      <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>nscount</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>j</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
		<block>{<block_content>
		  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>res</name> <operator>=</operator> <call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>workspacename</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

		   <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>type1</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
		   <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>class1</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		   <expr_stmt><expr><name>p1</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <comment type="block">/* TTL */</comment>
		   <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>rdlen1</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		   <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CHECK_LEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>rdlen1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		     <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		   
		   <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>class1</name> <operator>==</operator> <name>qclass</name> <operator>&amp;&amp;</operator> <name>type1</name> <operator>==</operator> <name>T_RRSIG</name></expr>)</condition>
		     <block>{<block_content>
		       <decl_stmt><decl><type><name>int</name></type> <name>type_covered</name></decl>;</decl_stmt>
		       <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>psav</name> <init>= <expr><name>p1</name></expr></init></decl>;</decl_stmt>
		       
		       <if_stmt><if>if <condition>(<expr><name>rdlen1</name> <operator>&lt;</operator> <literal type="number">18</literal></expr>)</condition><block type="pseudo"><block_content>
			 <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment>

		       <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>type_covered</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		       <if_stmt><if>if <condition>(<expr><name>type_covered</name> <operator>==</operator> <name>T_NSEC</name></expr>)</condition>
			 <block>{<block_content>
			   <expr_stmt><expr><name>p1</name><operator>++</operator></expr>;</expr_stmt> <comment type="block">/* algo */</comment>
			   
			   <comment type="block">/* labels field must be the same in every SIG we find. */</comment>
			   <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rrsig_labels</name><index>[<expr><name>nsecs_found</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			     <expr_stmt><expr><name><name>rrsig_labels</name><index>[<expr><name>nsecs_found</name></expr>]</index></name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt></block_content></block></if>
			   <if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>rrsig_labels</name><index>[<expr><name>nsecs_found</name></expr>]</index></name> <operator>!=</operator> <operator>*</operator><name>p1</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* algo */</comment>
			     <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
			   </block_content>}</block></if></if_stmt>
		       <expr_stmt><expr><name>p1</name> <operator>=</operator> <name>psav</name></expr>;</expr_stmt>
		     </block_content>}</block></if></if_stmt>
		   
		   <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ADD_RDLEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>rdlen1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		     <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>

	      <comment type="block">/* Must have found at least one sig. */</comment>
	      <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rrsig_labels</name><index>[<expr><name>nsecs_found</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	    </block_content>}</block></if></if_stmt>

	  <expr_stmt><expr><name><name>nsecset</name><index>[<expr><name>nsecs_found</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pstart</name></expr>;</expr_stmt>   
	</block_content>}</block></if></if_stmt>
      
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ADD_RDLEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>rdlen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>
  
  <if_stmt><if>if <condition>(<expr><name>type_found</name> <operator>==</operator> <name>T_NSEC</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>prove_non_existence_nsec</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>nsecset</name></expr></argument>, <argument><expr><name>rrsig_labels</name></expr></argument>, <argument><expr><name>nsecs_found</name></expr></argument>, <argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>workspacename</name></name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>qtype</name></expr></argument>, <argument><expr><name>nons</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>type_found</name> <operator>==</operator> <name>T_NSEC3</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>prove_non_existence_nsec3</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>nsecset</name></expr></argument>, <argument><expr><name>nsecs_found</name></expr></argument>, <argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>workspacename</name></name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>qtype</name></expr></argument>, <argument><expr><name>wildname</name></expr></argument>, <argument><expr><name>nons</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Check signing status of name.
   returns:
   STAT_SECURE   zone is signed.
   STAT_INSECURE zone proved unsigned.
   STAT_NEED_DS  require DS record of name returned in keyname.
   STAT_NEED_KEY require DNSKEY record of name returned in keyname.
   name returned unaltered.
*/</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zone_status</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>class</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>keyname</name></decl></parameter>, <parameter><decl><type><name>time_t</name></type> <name>now</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>name_start</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* for when TA is root */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>crec</name></name> <modifier>*</modifier></type><name>crecp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

  <comment type="block">/* First, work towards the root, looking for a trust anchor.
     This can either be one configured, or one previously cached.
     We can assume, if we don't find one first, that there is
     a trust anchor at the root. */</comment>
  <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>name</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr></incr>)</control>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><call><name>cache_find_by_name</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>F_DS</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><name>name_start</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>name</name></expr>;</expr_stmt>
	  <break>break;</break>
	</block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

  <comment type="block">/* Now work away from the trust anchor */</comment>
  <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>keyname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>name</name><index>[<expr><name>name_start</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>crecp</name> <operator>=</operator> <call><name>cache_find_by_name</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>F_DS</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>STAT_NEED_DS</name></expr>;</return></block_content></block></if></if_stmt>
      
       <comment type="block">/* F_DNSSECOK misused in DS cache records to non-existence of NS record.
	  F_NEG &amp;&amp; !F_DNSSECOK implies that we've proved there's no DS record here,
	  but that's because there's no NS record either, ie this isn't the start
	  of a zone. We only prove that the DNS tree below a node is unsigned when
	  we prove that we're at a zone cut AND there's no DS record. */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>crecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>F_NEG</name></expr>)</condition>
	<block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name><name>crecp</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>F_DNSSECOK</name></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>STAT_INSECURE</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* proved no DS here */</comment>
	</block_content>}</block></if>
      <else>else
	<block>{<block_content>
	  <comment type="block">/* If all the DS records have digest and/or sig algos we don't support,
	     then the zone is insecure. Note that if an algo
	     appears in the DS, then RRSIGs for that algo MUST
	     exist for each RRset: 4035 para 2.2  So if we find
	     a DS here with digest and sig we can do, we're entitled
	     to assume we can validate the zone and if we can't later,
	     because an RRSIG is missing we return BOGUS.
	  */</comment>
	  <do>do 
	    <block>{<block_content>
	      <if_stmt><if>if <condition>(<expr><name><name>crecp</name><operator>-&gt;</operator><name>uid</name></name> <operator>==</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>class</name> <operator>&amp;&amp;</operator>
		  <call><name>ds_digest_name</name><argument_list>(<argument><expr><name><name>crecp</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>ds</name><operator>.</operator><name>digest</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		  <call><name>algo_digest_name</name><argument_list>(<argument><expr><name><name>crecp</name><operator>-&gt;</operator><name>addr</name><operator>.</operator><name>ds</name><operator>.</operator><name>algo</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<break>break;</break></block_content></block></if></if_stmt>
	    </block_content>}</block>
	  while <condition>(<expr><operator>(</operator><name>crecp</name> <operator>=</operator> <call><name>cache_find_by_name</name><argument_list>(<argument><expr><name>crecp</name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>F_DS</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>;</do>

	  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>crecp</name></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>STAT_INSECURE</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>name_start</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<break>break;</break></block_content></block></if></if_stmt>

      <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>name</name><index>[<expr><name>name_start</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr>;</init> <condition><expr><operator>(</operator><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'.'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>p</name> <operator>!=</operator> <name>name</name><operator>)</operator></expr>;</condition> <incr><expr><name>p</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
      
      <if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>name</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
      
      <expr_stmt><expr><name>name_start</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>name</name></expr>;</expr_stmt>
    </block_content>}</block></while> 

  <return>return <expr><name>STAT_SECURE</name></expr>;</return>
</block_content>}</block></function>
       
<comment type="block">/* Validate all the RRsets in the answer and authority sections of the reply (4035:3.2.3) 
   Return code:
   STAT_SECURE   if it validates.
   STAT_INSECURE at least one RRset not validated, because in unsigned zone.
   STAT_BOGUS    signature is wrong, bad packet, no validation where there should be.
   STAT_NEED_KEY need DNSKEY to complete validation (name is returned in keyname, class in *class)
   STAT_NEED_DS  need DS to complete validation (name is returned in keyname)

   daemon-&gt;rr_status points to a char array which corressponds to the RRs in the 
   answer and auth sections. This is set to &gt;1 for each RR which is validated, and 0 for any which aren't.

   When validating replies to DS records, we're only interested in the NSEC{3} RRs in the auth section.
   Other RRs in that section missing sigs will not cause am INSECURE reply. We determine this mode
   is the nons argument is non-NULL.
*/</comment>
<function><type><name>int</name></type> <name>dnssec_validate_reply</name><parameter_list>(<parameter><decl><type><name>time_t</name></type> <name>now</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>dns_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>plen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>keyname</name></decl></parameter>, 
			  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>class</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>check_unsigned</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>neganswer</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nons</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nsec_ttl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>targets</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>target_sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ans_start</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>type1</name></decl>, <decl><type ref="prev"/><name>class1</name></decl>, <decl><type ref="prev"/><name>rdlen1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>type2</name></decl>, <decl><type ref="prev"/><name>class2</name></decl>, <decl><type ref="prev"/><name>rdlen2</name></decl>, <decl><type ref="prev"/><name>qclass</name></decl>, <decl><type ref="prev"/><name>qtype</name></decl>, <decl><type ref="prev"/><name>targetidx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>rc</name> <init>= <expr><name>STAT_INSECURE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>secure</name> <init>= <expr><name>STAT_SECURE</name></expr></init></decl>;</decl_stmt>
   
  <comment type="block">/* extend rr_status if necessary */</comment>
  <if_stmt><if>if <condition>(<expr><name><name>daemon</name><operator>-&gt;</operator><name>rr_status_sz</name></name> <operator>&lt;</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>ancount</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>nscount</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>new</name> <init>= <expr><call><name>whine_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>daemon</name><operator>-&gt;</operator><name>rr_status</name></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>ancount</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>nscount</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">64</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>new</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt>

      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>rr_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>daemon</name><operator>-&gt;</operator><name>rr_status</name></name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>daemon</name><operator>-&gt;</operator><name>rr_status_sz</name></name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>ancount</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>nscount</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">64</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>rr_status</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name><name>daemon</name><operator>-&gt;</operator><name>rr_status</name></name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>daemon</name><operator>-&gt;</operator><name>rr_status_sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if <condition>(<expr><name>neganswer</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>neganswer</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
  
  <if_stmt><if>if <condition>(<expr><call><name>RCODE</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>SERVFAIL</name> <operator>||</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>qdcount</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt>
  
  <if_stmt><if>if <condition>(<expr><call><name>RCODE</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NXDOMAIN</name> <operator>&amp;&amp;</operator> <call><name>RCODE</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NOERROR</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>STAT_INSECURE</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>p1</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>header</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
  
   <comment type="block">/* Find all the targets we're looking for answers to.
     The zeroth array element is for the query, subsequent ones
     for CNAME targets, unless the query is for a CNAME or ANY. */</comment>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>expand_workspace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targets</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target_sz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt>
  
  <expr_stmt><expr><name><name>targets</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>targetidx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
   
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt>
  
  <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>qtype</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>qclass</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ans_start</name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
 
  <comment type="block">/* Can't validate an RRSIG query */</comment>
  <if_stmt><if>if <condition>(<expr><name>qtype</name> <operator>==</operator> <name>T_RRSIG</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>STAT_INSECURE</name></expr>;</return></block_content></block></if></if_stmt>
  
  <if_stmt><if>if <condition>(<expr><name>qtype</name> <operator>!=</operator> <name>T_CNAME</name> <operator>&amp;&amp;</operator> <name>qtype</name> <operator>!=</operator> <name>T_ANY</name></expr>)</condition><block type="pseudo"><block_content>
    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>ancount</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>j</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control> 
      <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>p1</name> <operator>=</operator> <call><name>skip_name</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment>
	
	<expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>type2</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	<expr_stmt><expr><name>p1</name> <operator>+=</operator> <literal type="number">6</literal></expr>;</expr_stmt> <comment type="block">/* class, TTL */</comment>
	<expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>rdlen2</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
	
	<if_stmt><if>if <condition>(<expr><name>type2</name> <operator>==</operator> <name>T_CNAME</name></expr>)</condition>
	  <block>{<block_content>
	    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>expand_workspace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targets</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target_sz</name></expr></argument>, <argument><expr><name>targetidx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	      <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt>
	    
	    <expr_stmt><expr><name><name>targets</name><index>[<expr><name>targetidx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt> <comment type="block">/* pointer to target name */</comment>
	  </block_content>}</block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ADD_RDLEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>rdlen2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt>
      </block_content>}</block></for></block_content></block></if></if_stmt>
  
  <for>for <control>(<init><expr><name>p1</name> <operator>=</operator> <name>ans_start</name></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>ancount</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>nscount</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ADD_RDLEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>rdlen1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt>
      
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment>
      
      <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>type1</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>class1</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p1</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <comment type="block">/* TTL */</comment>
      <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>rdlen1</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* Don't try and validate RRSIGs! */</comment>
      <if_stmt><if>if <condition>(<expr><name>type1</name> <operator>==</operator> <name>T_RRSIG</name></expr>)</condition><block type="pseudo"><block_content>
	<continue>continue;</continue></block_content></block></if></if_stmt>
      
      <comment type="block">/* Check if we've done this RRset already */</comment>
      <for>for <control>(<init><expr><name>p2</name> <operator>=</operator> <name>ans_start</name></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment>
	  
	  <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>type2</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>class2</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>p2</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <comment type="block">/* TTL */</comment>
	  <expr_stmt><expr><call><name>GETSHORT</name><argument_list>(<argument><expr><name>rdlen2</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  
	  <if_stmt><if>if <condition>(<expr><name>type2</name> <operator>==</operator> <name>type1</name> <operator>&amp;&amp;</operator> <name>class2</name> <operator>==</operator> <name>class1</name> <operator>&amp;&amp;</operator> <name>rc</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
	    <break>break;</break></block_content></block></if></if_stmt> <comment type="block">/* Done it before: name, type, class all match. */</comment>
	  
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ADD_RDLEN</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>rdlen2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
      
      <comment type="block">/* Done already: copy the validation status */</comment>
      <if_stmt><if>if <condition>(<expr><name>j</name> <operator>!=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>daemon</name><operator>-&gt;</operator><name>rr_status</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>daemon</name><operator>-&gt;</operator><name>rr_status</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
      <else>else
	<block>{<block_content>
	  <comment type="block">/* Not done, validate now */</comment>
	  <decl_stmt><decl><type><name>int</name></type> <name>sigcnt</name></decl>, <decl><type ref="prev"/><name>rrcnt</name></decl>;</decl_stmt>
	  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>wildname</name></decl>;</decl_stmt>
	  
	  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>explore_rrset</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>class1</name></expr></argument>, <argument><expr><name>type1</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sigcnt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rrcnt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt>
	  
	  <comment type="block">/* No signatures for RRset. We can be configured to assume this is OK and return an INSECURE result. */</comment>
	  <if_stmt><if>if <condition>(<expr><name>sigcnt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	    <block>{<block_content>
	      <comment type="block">/* NSEC and NSEC3 records must be signed. We make this assumption elsewhere. */</comment>
	      <if_stmt><if>if <condition>(<expr><name>type1</name> <operator>==</operator> <name>T_NSEC</name> <operator>||</operator> <name>type1</name> <operator>==</operator> <name>T_NSEC3</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STAT_BOGUS</name> <operator>|</operator> <name>DNSSEC_FAIL_NOSIG</name></expr>;</return></block_content></block></if>
	      <if type="elseif">else if <condition>(<expr><name>nons</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>ancount</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* If we're validating a DS reply, rather than looking for the value of AD bit,
		   we only care that NSEC and NSEC3 RRs in the auth section are signed. 
		   Return SECURE even if others (SOA....) are not. */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>STAT_SECURE</name></expr>;</expr_stmt></block_content></block></if>
	      <else>else
		<block>{<block_content>
		  <comment type="block">/* unsigned RRsets in auth section are not BOGUS, but do make reply insecure. */</comment>
		  <if_stmt><if>if <condition>(<expr><name>check_unsigned</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name><name>header</name><operator>-&gt;</operator><name>ancount</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		    <block>{<block_content>
		      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zone_status</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>class1</name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		      <if_stmt><if>if <condition>(<expr><call><name>STAT_ISEQUAL</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>STAT_SECURE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>STAT_BOGUS</name> <operator>|</operator> <name>DNSSEC_FAIL_NOSIG</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		      
		      <if_stmt><if>if <condition>(<expr><name>class</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>class</name> <operator>=</operator> <name>class1</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* Class for NEED_DS or NEED_KEY */</comment>
		    </block_content>}</block></if>
		  <else>else<block type="pseudo"><block_content> 
		    <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>STAT_INSECURE</name></expr>;</expr_stmt></block_content></block></else></if_stmt> 
		  
		  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STAT_ISEQUAL</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>STAT_INSECURE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><name>rc</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	    </block_content>}</block></if>
	  <else>else
	    <block>{<block_content>
	      <comment type="block">/* explore_rrset() gives us key name from sigs in keyname.
		 Can't overwrite name here. */</comment>
	      <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>workspacename</name></name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>zone_status</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>workspacename</name></name></expr></argument>, <argument><expr><name>class1</name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      
	      <if_stmt><if>if <condition>(<expr><call><name>STAT_ISEQUAL</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>STAT_BOGUS</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>STAT_ISEQUAL</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>STAT_NEED_KEY</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>STAT_ISEQUAL</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>STAT_NEED_DS</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
		  <if_stmt><if>if <condition>(<expr><name>class</name></expr>)</condition><block type="pseudo"><block_content>
		    <expr_stmt><expr><operator>*</operator><name>class</name> <operator>=</operator> <name>class1</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* Class for NEED_DS or NEED_KEY */</comment>
		  <return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	      
	      <comment type="block">/* Zone is insecure, don't need to validate RRset */</comment>
	      <if_stmt><if>if <condition>(<expr><call><name>STAT_ISEQUAL</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>STAT_SECURE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
		  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>sig_ttl</name></decl>;</decl_stmt>
		  <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>validate_rrset</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>class1</name></expr></argument>, <argument><expr><name>type1</name></expr></argument>, <argument><expr><name>sigcnt</name></expr></argument>,
				      <argument><expr><name>rrcnt</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wildname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sig_ttl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  
		  <if_stmt><if>if <condition>(<expr><call><name>STAT_ISEQUAL</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>STAT_BOGUS</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>STAT_ISEQUAL</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>STAT_NEED_KEY</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>STAT_ISEQUAL</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>STAT_NEED_DS</name></expr></argument>)</argument_list></call></expr>)</condition>
		    <block>{<block_content>
		      <if_stmt><if>if <condition>(<expr><name>class</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>class</name> <operator>=</operator> <name>class1</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* Class for DS or DNSKEY */</comment>
		      <return>return <expr><name>rc</name></expr>;</return>
		    </block_content>}</block></if></if_stmt> 
		  
		  <comment type="block">/* rc is now STAT_SECURE or STAT_SECURE_WILDCARD */</comment>
		  
		  <comment type="block">/* Note that RR is validated */</comment>
		  <expr_stmt><expr><name><name>daemon</name><operator>-&gt;</operator><name>rr_status</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>sig_ttl</name></expr>;</expr_stmt>
		   
		  <comment type="block">/* Note if we've validated either the answer to the question
		     or the target of a CNAME. Any not noted will need NSEC or
		     to be in unsigned space. */</comment>
		  <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator><name>targetidx</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>p2</name> <operator>=</operator> <name><name>targets</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr>)</condition>
		      <block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>rc1</name></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>rc1</name> <operator>=</operator> <call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			  <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment>
			
			<if_stmt><if>if <condition>(<expr><name>class1</name> <operator>==</operator> <name>qclass</name> <operator>&amp;&amp;</operator> <name>rc1</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>type1</name> <operator>==</operator> <name>T_CNAME</name> <operator>||</operator> <name>type1</name> <operator>==</operator> <name>qtype</name> <operator>||</operator> <name>qtype</name> <operator>==</operator> <name>T_ANY</name> <operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			  <expr_stmt><expr><name><name>targets</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		      </block_content>}</block></if></if_stmt></block_content></block></for>
		  
		  <comment type="block">/* An attacker replay a wildcard answer with a different
		     answer and overlay a genuine RR. To prove this
		     hasn't happened, the answer must prove that
		     the genuine record doesn't exist. Check that here. 
		     Note that we may not yet have validated the NSEC/NSEC3 RRsets. 
		     That's not a problem since if the RRsets later fail
		     we'll return BOGUS then. */</comment>
		  <if_stmt><if>if <condition>(<expr><call><name>STAT_ISEQUAL</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>STAT_SECURE_WILDCARD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		      <operator>!</operator><call><name>prove_non_existence</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>type1</name></expr></argument>, <argument><expr><name>class1</name></expr></argument>, <argument><expr><name>wildname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		    <return>return <expr><name>STAT_BOGUS</name> <operator>|</operator> <name>DNSSEC_FAIL_NONSEC</name></expr>;</return></block_content></block></if></if_stmt>

		  <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>STAT_SECURE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	    </block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

      <if_stmt><if>if <condition>(<expr><call><name>STAT_ISEQUAL</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>STAT_INSECURE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>secure</name> <operator>=</operator> <name>STAT_INSECURE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

  <comment type="block">/* OK, all the RRsets validate, now see if we have a missing answer or CNAME target. */</comment>
  <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator><name>targetidx</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>p2</name> <operator>=</operator> <name><name>targets</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr>)</condition>
      <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>neganswer</name></expr>)</condition><block type="pseudo"><block_content>
	  <expr_stmt><expr><operator>*</operator><name>neganswer</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>extract_name</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	  <return>return <expr><name>STAT_BOGUS</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* bad packet */</comment>
	
	<comment type="block">/* NXDOMAIN or NODATA reply, unanswered question is (name, qclass, qtype) */</comment>
	
	<comment type="block">/* For anything other than a DS record, this situation is OK if either
	   the answer is in an unsigned zone, or there's a NSEC records. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>prove_non_existence</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>qtype</name></expr></argument>, <argument><expr><name>qclass</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nons</name></expr></argument>, <argument><expr><name>nsec_ttl</name></expr></argument>)</argument_list></call></expr>)</condition>
	  <block>{<block_content>
	    <comment type="block">/* Empty DS without NSECS */</comment>
	    <if_stmt><if>if <condition>(<expr><name>qtype</name> <operator>==</operator> <name>T_DS</name></expr>)</condition><block type="pseudo"><block_content>
	      <return>return <expr><name>STAT_BOGUS</name> <operator>|</operator> <name>DNSSEC_FAIL_NONSEC</name></expr>;</return></block_content></block></if></if_stmt>
	    
	    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>STAT_ISEQUAL</name><argument_list>(<argument><expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>zone_status</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>qclass</name></expr></argument>, <argument><expr><name>keyname</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>, <argument><expr><name>STAT_SECURE</name></expr></argument>)</argument_list></call></expr>)</condition>
	      <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>class</name></expr>)</condition><block type="pseudo"><block_content>
		  <expr_stmt><expr><operator>*</operator><name>class</name> <operator>=</operator> <name>qclass</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* Class for NEED_DS or NEED_KEY */</comment>
		<return>return <expr><name>rc</name></expr>;</return>
	      </block_content>}</block></if></if_stmt> 
	    
	    <return>return <expr><name>STAT_BOGUS</name> <operator>|</operator> <name>DNSSEC_FAIL_NONSEC</name></expr>;</return> <comment type="block">/* signed zone, no NSECs */</comment>
	  </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt></block_content></block></for>
  
  <return>return <expr><name>secure</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Compute keytag (checksum to quickly index a key). See RFC4034 */</comment>
<function><type><name>int</name></type> <name>dnskey_keytag</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>alg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keylen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>alg</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* Algorithm 1 (RSAMD5) has a different (older) keytag calculation algorithm.
         See RFC4034, Appendix B.1 */</comment>
      <return>return <expr><name><name>key</name><index>[<expr><name>keylen</name><operator>-</operator><literal type="number">4</literal></expr>]</index></name> <operator>*</operator> <literal type="number">256</literal> <operator>+</operator> <name><name>key</name><index>[<expr><name>keylen</name><operator>-</operator><literal type="number">3</literal></expr>]</index></name></expr>;</return>
    </block_content>}</block></if>
  <else>else
    <block>{<block_content>
      <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>ac</name> <init>= <expr><name>flags</name> <operator>+</operator> <literal type="number">0x300</literal> <operator>+</operator> <name>alg</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

      <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>keylen</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ac</name> <operator>+=</operator> <ternary><condition><expr><operator>(</operator><name>i</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>key</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name><name>key</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></for>

      <expr_stmt><expr><name>ac</name> <operator>+=</operator> <operator>(</operator><name>ac</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr>;</expr_stmt>
      <return>return <expr><name>ac</name> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>dnssec_generate_query</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dns_header</name></name> <modifier>*</modifier></type><name>header</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>class</name></decl></parameter>, 
			     <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>edns_pktsz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>ret</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>qdcount</name></name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>ancount</name></name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>nscount</name></name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>arcount</name></name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>hb3</name></name> <operator>=</operator> <name>HB3_RD</name></expr>;</expr_stmt> 
  <expr_stmt><expr><call><name>SET_OPCODE</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>QUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* For debugging, set Checking Disabled, otherwise, have the upstream check too,
     this allows it to select auth servers when one is returning bad data. */</comment>
  <expr_stmt><expr><name><name>header</name><operator>-&gt;</operator><name>hb4</name></name> <operator>=</operator> <ternary><condition><expr><call><name>option_bool</name><argument_list>(<argument><expr><name>OPT_DNSSEC_DEBUG</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>HB4_CD</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

  <comment type="block">/* ID filled in later */</comment>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>header</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>do_rfc1035_name</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PUTSHORT</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>PUTSHORT</name><argument_list>(<argument><expr><name>class</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>add_do_bit</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>header</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>find_pseudoheader</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>PUTSHORT</name><argument_list>(<argument><expr><name>edns_pktsz</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>errflags_to_ede</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* We can end up with more than one flag set for some errors,
     so this encodes a rough priority so the (eg) No sig is reported
     before no-unexpired-sig. */</comment>

  <if_stmt><if>if <condition>(<expr><name>status</name> <operator>&amp;</operator> <name>DNSSEC_FAIL_NYV</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>EDE_SIG_NYV</name></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>status</name> <operator>&amp;</operator> <name>DNSSEC_FAIL_EXP</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>EDE_SIG_EXP</name></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>status</name> <operator>&amp;</operator> <name>DNSSEC_FAIL_NOKEYSUP</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>EDE_USUPDNSKEY</name></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>status</name> <operator>&amp;</operator> <name>DNSSEC_FAIL_NOZONE</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>EDE_NO_ZONEKEY</name></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>status</name> <operator>&amp;</operator> <name>DNSSEC_FAIL_NOKEY</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>EDE_NO_DNSKEY</name></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>status</name> <operator>&amp;</operator> <name>DNSSEC_FAIL_NODSSUP</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>EDE_USUPDS</name></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>status</name> <operator>&amp;</operator> <name>DNSSEC_FAIL_NONSEC</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>EDE_NO_NSEC</name></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>status</name> <operator>&amp;</operator> <name>DNSSEC_FAIL_INDET</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>EDE_DNSSEC_IND</name></expr>;</return></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>status</name> <operator>&amp;</operator> <name>DNSSEC_FAIL_NOSIG</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>EDE_NO_RRSIG</name></expr>;</return></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <return>return <expr><name>EDE_UNSET</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_DNSSEC */</comment>
</unit>
