<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/dnsmasq/inotify.c"><comment type="block">/* dnsmasq is Copyright (c) 2000-2022 Simon Kelley
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; version 2 dated June, 1991, or
   (at your option) version 3 dated 29 June, 2007.
 
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
     
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dnsmasq.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INOTIFY</name></cpp:ifdef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/inotify.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include> <comment type="block">/* For MAXSYMLINKS */</comment>

<comment type="block">/* the strategy is to set an inotify on the directories containing
   resolv files, for any files in the directory which are close-write 
   or moved into the directory.
   
   When either of those happen, we look to see if the file involved
   is actually a resolv-file, and if so, call poll-resolv with
   the "force" argument, to ensure it's read.

   This adds one new error condition: the directories containing
   all specified resolv-files must exist at start-up, even if the actual
   files don't. 
*/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>inotify_buffer</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INOTIFY_SZ</name></cpp:macro> <cpp:value>(sizeof(struct inotify_event) + NAME_MAX + 1)</cpp:value></cpp:define>

<comment type="block">/* If path is a symbolic link, return the path it
   points to, made absolute if relative.
   If path doesn't exist or is not a symlink, return NULL.
   Return value is malloc'ed */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>my_readlink</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ssize_t</name></type> <name>rc</name></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><literal type="number">64</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

  <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>safe_malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>readlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
	  <comment type="block">/* Not link or doesn't exist. */</comment>
	  <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINVAL</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
	    <block>{<block_content>
	      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <return>return <expr><name>NULL</name></expr>;</return>
	    </block_content>}</block></if>
	  <else>else<block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot access path %s: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>EC_MISC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
      <if type="elseif">else if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <name>size</name><operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
	  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>
	  
	  <expr_stmt><expr><name><name>buf</name><index>[<expr><name>rc</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>d</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>
	    <block>{<block_content>
	      <comment type="block">/* Add path to relative link */</comment>
	      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_buf</name> <init>= <expr><call><name>safe_malloc</name><argument_list>(<argument><expr><operator>(</operator><name>d</name> <operator>-</operator> <name>path</name><operator>)</operator> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>d</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>new_buf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>new_buf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      <expr_stmt><expr><name>buf</name> <operator>=</operator> <name>new_buf</name></expr>;</expr_stmt>
	    </block_content>}</block></if></if_stmt>
	  <return>return <expr><name>buf</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

      <comment type="block">/* Buffer too small, increase and retry */</comment>
      <expr_stmt><expr><name>size</name> <operator>+=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>inotify_dnsmasq_init</name><parameter_list>()</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>resolvc</name></name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>inotify_buffer</name> <operator>=</operator> <call><name>safe_malloc</name><argument_list>(<argument><expr><name>INOTIFY_SZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>daemon</name><operator>-&gt;</operator><name>inotifyfd</name></name> <operator>=</operator> <call><name>inotify_init1</name><argument_list>(<argument><expr><name>IN_NONBLOCK</name> <operator>|</operator> <name>IN_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <if_stmt><if>if <condition>(<expr><name><name>daemon</name><operator>-&gt;</operator><name>inotifyfd</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to create inotify: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>EC_MISC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>option_bool</name><argument_list>(<argument><expr><name>OPT_NO_RESOLV</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>
  
  <for>for <control>(<init><expr><name>res</name> <operator>=</operator> <name><name>daemon</name><operator>-&gt;</operator><name>resolv_files</name></name></expr>;</init> <condition><expr><name>res</name></expr>;</condition> <incr><expr><name>res</name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>d</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>new_path</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>safe_malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>links</name> <init>= <expr><name>MAXSYMLINKS</name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Follow symlinks until we reach a non-symlink, or a non-existent file. */</comment>
      <while>while <condition>(<expr><operator>(</operator><name>new_path</name> <operator>=</operator> <call><name>my_readlink</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
	  <if_stmt><if>if <condition>(<expr><name>links</name><operator>--</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"too many symlinks following %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>EC_MISC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>path</name> <operator>=</operator> <name>new_path</name></expr>;</expr_stmt>
	</block_content>}</block></while>

      <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>wd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>d</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* make path just directory */</comment>
	  <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>wd</name></name> <operator>=</operator> <call><name>inotify_add_watch</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>inotifyfd</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>IN_CLOSE_WRITE</name> <operator>|</operator> <name>IN_MOVED_TO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	  <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <name>d</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* pointer to filename */</comment>
	  <expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
	  
	  <if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>wd</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"directory %s for resolv-file is missing, cannot poll"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>EC_MISC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>	  
	 
      <if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>wd</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>die</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to create inotify for %s: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>EC_MISC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>hostsfile</name></name> <modifier>*</modifier></type><name>dyndir_addhosts</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dyndir</name></name> <modifier>*</modifier></type><name>dd</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* Check if this file is already known in dd-&gt;files */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>hostsfile</name></name> <modifier>*</modifier></type><name>ah</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <for>for<control>(<init><expr><name>ah</name> <operator>=</operator> <name><name>dd</name><operator>-&gt;</operator><name>files</name></name></expr>;</init> <condition><expr><name>ah</name></expr>;</condition> <incr><expr><name>ah</name> <operator>=</operator> <name><name>ah</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if<condition>(<expr><name>ah</name> <operator>&amp;&amp;</operator> <name><name>ah</name><operator>-&gt;</operator><name>fname</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>ah</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>ah</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

  <comment type="block">/* Not known, create new hostsfile record for this dyndir */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>hostsfile</name></name> <modifier>*</modifier></type><name>newah</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><name>newah</name> <operator>=</operator> <call><name>whine_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>hostsfile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* Add this file to the tip of the linked list */</comment>
  <expr_stmt><expr><name><name>newah</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>dd</name><operator>-&gt;</operator><name>files</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dd</name><operator>-&gt;</operator><name>files</name></name> <operator>=</operator> <name>newah</name></expr>;</expr_stmt>

  <comment type="block">/* Copy flags, set index and the full file path */</comment>
  <expr_stmt><expr><name><name>newah</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>dd</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>newah</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name><name>daemon</name><operator>-&gt;</operator><name>host_index</name></name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>newah</name><operator>-&gt;</operator><name>fname</name></name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>

  <return>return <expr><name>newah</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* initialisation for dynamic-dir. Set inotify watch for each directory, and read pre-existing files */</comment>
<function><type><name>void</name></type> <name>set_dynamic_inotify</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>total_size</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>crec</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>rhash</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>revhashsz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>dyndir</name></name> <modifier>*</modifier></type><name>dd</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>dd</name> <operator>=</operator> <name><name>daemon</name><operator>-&gt;</operator><name>dynamic_dirs</name></name></expr>;</init> <condition><expr><name>dd</name></expr>;</condition> <incr><expr><name>dd</name> <operator>=</operator> <name><name>dd</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
      <decl_stmt><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dir_stream</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>buf</name></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>dd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>flag</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<continue>continue;</continue></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name><name>dd</name><operator>-&gt;</operator><name>dname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><call><name>my_syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"bad dynamic directory %s: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, 
		    <argument><expr><name><name>dd</name><operator>-&gt;</operator><name>dname</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <continue>continue;</continue>
	</block_content>}</block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><call><name>my_syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"bad dynamic directory %s: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, 
		    <argument><expr><name><name>dd</name><operator>-&gt;</operator><name>dname</name></name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"not a directory"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <continue>continue;</continue>
	</block_content>}</block></if></if_stmt>

       <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>dd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AH_WD_DONE</name><operator>)</operator></expr>)</condition>
	 <block>{<block_content>
	   <expr_stmt><expr><name><name>dd</name><operator>-&gt;</operator><name>wd</name></name> <operator>=</operator> <call><name>inotify_add_watch</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>inotifyfd</name></name></expr></argument>, <argument><expr><name><name>dd</name><operator>-&gt;</operator><name>dname</name></name></expr></argument>, <argument><expr><name>IN_CLOSE_WRITE</name> <operator>|</operator> <name>IN_MOVED_TO</name> <operator>|</operator> <name>IN_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	   <expr_stmt><expr><name><name>dd</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>AH_WD_DONE</name></expr>;</expr_stmt>
	 </block_content>}</block></if></if_stmt>

       <comment type="block">/* Read contents of dir _after_ calling add_watch, in the hope of avoiding
	  a race which misses files being added as we start */</comment>
       <if_stmt><if>if <condition>(<expr><name><name>dd</name><operator>-&gt;</operator><name>wd</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <operator>!</operator><operator>(</operator><name>dir_stream</name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name><name>dd</name><operator>-&gt;</operator><name>dname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	 <block>{<block_content>
	   <expr_stmt><expr><call><name>my_syslog</name><argument_list>(<argument><expr><name>LOG_ERR</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"failed to create inotify for %s: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
		     <argument><expr><name><name>dd</name><operator>-&gt;</operator><name>dname</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	   <continue>continue;</continue>
	 </block_content>}</block></if></if_stmt>

       <while>while <condition>(<expr><operator>(</operator><name>ent</name> <operator>=</operator> <call><name>readdir</name><argument_list>(<argument><expr><name>dir_stream</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	 <block>{<block_content>
	   <decl_stmt><decl><type><name>size_t</name></type> <name>lendir</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>dd</name><operator>-&gt;</operator><name>dname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	   <decl_stmt><decl><type><name>size_t</name></type> <name>lenfile</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	   <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

	   <comment type="block">/* ignore emacs backups and dotfiles */</comment>
	   <if_stmt><if>if <condition>(<expr><name>lenfile</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> 
	       <name><name>ent</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><name>lenfile</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'~'</literal> <operator>||</operator>
	       <operator>(</operator><name><name>ent</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal> <operator>&amp;&amp;</operator> <name><name>ent</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><name>lenfile</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal><operator>)</operator> <operator>||</operator>
	       <name><name>ent</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
	     <continue>continue;</continue></block_content></block></if></if_stmt>

	   <if_stmt><if>if <condition>(<expr><operator>(</operator><name>path</name> <operator>=</operator> <call><name>whine_malloc</name><argument_list>(<argument><expr><name>lendir</name> <operator>+</operator> <name>lenfile</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	     <block>{<block_content>
	       <decl_stmt><decl><type><name><name>struct</name> <name>hostsfile</name></name> <modifier>*</modifier></type><name>ah</name></decl>;</decl_stmt>

	       <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>dd</name><operator>-&gt;</operator><name>dname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	       <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	       <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	       <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>ah</name> <operator>=</operator> <call><name>dyndir_addhosts</name><argument_list>(<argument><expr><name>dd</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		 <block>{<block_content>
		   <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		   <continue>continue;</continue>
		 </block_content>}</block></if></if_stmt>
	       
	       <comment type="block">/* ignore non-regular files */</comment>
	       <if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		 <block>{<block_content>
		   <if_stmt><if>if <condition>(<expr><name><name>dd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AH_HOSTS</name></expr>)</condition><block type="pseudo"><block_content>
		     <expr_stmt><expr><name>total_size</name> <operator>=</operator> <call><name>read_hostsfile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>ah</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><name>total_size</name></expr></argument>, <argument><expr><name>rhash</name></expr></argument>, <argument><expr><name>revhashsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DHCP</name></cpp:ifdef>
		   <if type="elseif">else if <condition>(<expr><name><name>dd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>AH_DHCP_HST</name> <operator>|</operator> <name>AH_DHCP_OPT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		     <expr_stmt><expr><call><name>option_read_dynfile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>dd</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>		   
		 </block_content>}</block></if></if_stmt>
	     </block_content>}</block></if></if_stmt>
	 </block_content>}</block></while>

       <expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dir_stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>inotify_check</name><parameter_list>(<parameter><decl><type><name>time_t</name></type> <name>now</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>hit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>dyndir</name></name> <modifier>*</modifier></type><name>dd</name></decl>;</decl_stmt>

  <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>struct</name> <name>resolvc</name></name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name><name>struct</name> <name>inotify_event</name></name> <modifier>*</modifier></type><name>in</name></decl>;</decl_stmt>

      <while>while <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>inotifyfd</name></name></expr></argument>, <argument><expr><name>inotify_buffer</name></expr></argument>, <argument><expr><name>INOTIFY_SZ</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>
      
      <if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<break>break;</break></block_content></block></if></if_stmt>
      
      <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>inotify_buffer</name></expr>;</init> <condition><expr><name>rc</name> <operator>-</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>inotify_buffer</name><operator>)</operator> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>inotify_event</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>inotify_event</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>in</name><operator>-&gt;</operator><name>len</name></name></expr></incr>)</control> 
	<block>{<block_content>
	  <decl_stmt><decl><type><name>size_t</name></type> <name>namelen</name></decl>;</decl_stmt>

	  <expr_stmt><expr><name>in</name> <operator>=</operator> <operator>(</operator>struct <name>inotify_event</name><operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
	  
	  <comment type="block">/* ignore emacs backups and dotfiles */</comment>
	  <if_stmt><if>if <condition>(<expr><name><name>in</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>namelen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
	      <name><name>in</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>namelen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'~'</literal> <operator>||</operator>
	      <operator>(</operator><name><name>in</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal> <operator>&amp;&amp;</operator> <name><name>in</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>namelen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal><operator>)</operator> <operator>||</operator>
	      <name><name>in</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
	    <continue>continue;</continue></block_content></block></if></if_stmt>

	  <for>for <control>(<init><expr><name>res</name> <operator>=</operator> <name><name>daemon</name><operator>-&gt;</operator><name>resolv_files</name></name></expr>;</init> <condition><expr><name>res</name></expr>;</condition> <incr><expr><name>res</name> <operator>=</operator> <name><name>res</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
	    <if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>wd</name></name> <operator>==</operator> <name><name>in</name><operator>-&gt;</operator><name>wd</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><name><name>in</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	      <expr_stmt><expr><name>hit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

	  <for>for <control>(<init><expr><name>dd</name> <operator>=</operator> <name><name>daemon</name><operator>-&gt;</operator><name>dynamic_dirs</name></name></expr>;</init> <condition><expr><name>dd</name></expr>;</condition> <incr><expr><name>dd</name> <operator>=</operator> <name><name>dd</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
	    <if_stmt><if>if <condition>(<expr><name><name>dd</name><operator>-&gt;</operator><name>wd</name></name> <operator>==</operator> <name><name>in</name><operator>-&gt;</operator><name>wd</name></name></expr>)</condition>
	      <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>lendir</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>dd</name><operator>-&gt;</operator><name>dname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
				
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>path</name> <operator>=</operator> <call><name>whine_malloc</name><argument_list>(<argument><expr><name>lendir</name> <operator>+</operator> <name><name>in</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		  <block>{<block_content>
		    <decl_stmt><decl><type><name><name>struct</name> <name>hostsfile</name></name> <modifier>*</modifier></type><name>ah</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>dd</name><operator>-&gt;</operator><name>dname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		    <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>in</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		    <comment type="block">/* Is this is a deletion event? */</comment>
		    <if_stmt><if>if <condition>(<expr><name><name>in</name><operator>-&gt;</operator><name>mask</name></name> <operator>&amp;</operator> <name>IN_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
		      <expr_stmt><expr><call><name>my_syslog</name><argument_list>(<argument><expr><name>LOG_INFO</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"inotify: %s removed"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		    <else>else<block type="pseudo"><block_content> 
		      <expr_stmt><expr><call><name>my_syslog</name><argument_list>(<argument><expr><name>LOG_INFO</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"inotify: %s new or modified"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		    <if_stmt><if>if <condition>(<expr><name><name>dd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AH_HOSTS</name></expr>)</condition>
		      <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ah</name> <operator>=</operator> <call><name>dyndir_addhosts</name><argument_list>(<argument><expr><name>dd</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
			  <block>{<block_content>
			    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>removed</name> <init>= <expr><call><name>cache_remove_uid</name><argument_list>(<argument><expr><name><name>ah</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			    <if_stmt><if>if <condition>(<expr><name>removed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			      <expr_stmt><expr><call><name>my_syslog</name><argument_list>(<argument><expr><name>LOG_INFO</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"inotify: flushed %u names read from %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>removed</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			    <comment type="block">/* (Re-)load hostsfile only if this event isn't triggered by deletion */</comment>
			    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>in</name><operator>-&gt;</operator><name>mask</name></name> <operator>&amp;</operator> <name>IN_DELETE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			      <expr_stmt><expr><call><name>read_hostsfile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>ah</name><operator>-&gt;</operator><name>index</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DHCP</name></cpp:ifdef>
			    <if_stmt><if>if <condition>(<expr><name><name>daemon</name><operator>-&gt;</operator><name>dhcp</name></name> <operator>||</operator> <name><name>daemon</name><operator>-&gt;</operator><name>doing_dhcp6</name></name></expr>)</condition> 
			      <block>{<block_content>
				<comment type="block">/* Propagate the consequences of loading a new dhcp-host */</comment>
				<expr_stmt><expr><call><name>dhcp_update_configs</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>dhcp_conf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>lease_update_from_configs</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
				<expr_stmt><expr><call><name>lease_update_file</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
				<expr_stmt><expr><call><name>lease_update_dns</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			      </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			  </block_content>}</block></if></if_stmt>
		      </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_DHCP</name></cpp:ifdef>
		    <if type="elseif">else if <condition>(<expr><name><name>dd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AH_DHCP_HST</name></expr>)</condition>
		      <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>option_read_dynfile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>AH_DHCP_HST</name></expr></argument>)</argument_list></call></expr>)</condition>
			  <block>{<block_content>
			    <comment type="block">/* Propagate the consequences of loading a new dhcp-host */</comment>
			    <expr_stmt><expr><call><name>dhcp_update_configs</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>dhcp_conf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <expr_stmt><expr><call><name>lease_update_from_configs</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
			    <expr_stmt><expr><call><name>lease_update_file</name><argument_list>(<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
			    <expr_stmt><expr><call><name>lease_update_dns</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			  </block_content>}</block></if></if_stmt>
		      </block_content>}</block></if>
		    <if type="elseif">else if <condition>(<expr><name><name>dd</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>AH_DHCP_OPT</name></expr>)</condition><block type="pseudo"><block_content>
		      <expr_stmt><expr><call><name>option_read_dynfile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>AH_DHCP_OPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		    
		    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ah</name></expr>)</condition><block type="pseudo"><block_content>
		      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		  </block_content>}</block></if></if_stmt>
	      </block_content>}</block></if></if_stmt></block_content></block></for>
	</block_content>}</block></for>
    </block_content>}</block></while>
  <return>return <expr><name>hit</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* INOTIFY */</comment>
</unit>
