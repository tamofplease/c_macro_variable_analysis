<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/dnsmasq/log.c"><comment type="block">/* dnsmasq is Copyright (c) 2000-2022 Simon Kelley

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; version 2 dated June, 1991, or
   (at your option) version 3 dated 29 June, 2007.
 
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
     
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dnsmasq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../log.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__ANDROID__</name></cpp:ifdef>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;android/log.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Implement logging to /dev/log asynchronously. If syslogd is 
   making DNS lookups through dnsmasq, and dnsmasq blocks awaiting
   syslogd, then the two daemons can deadlock. We get around this
   by not blocking when talking to syslog, instead we queue up to 
   MAX_LOGS messages. If more are queued, they will be dropped,
   and the drop event itself logged. */</comment>

<comment type="block">/* The "wire" protocol for logging is defined in RFC 3164 */</comment>

<comment type="block">/* From RFC 3164 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_MESSAGE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>

<comment type="block">/* defaults in case we die() before we log_start() */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>log_fac</name> <init>= <expr><name>LOG_DAEMON</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>log_stderr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>echo_stderr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>log_fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>log_to_file</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>entries_alloced</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>entries_lost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>connection_good</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>max_logs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>connection_type</name> <init>= <expr><name>SOCK_DGRAM</name></expr></init></decl>;</decl_stmt>

<struct>struct <name>log_entry</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>length</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt> <comment type="block">/* to avoid duplicates over a fork */</comment>
  <decl_stmt><decl><type><name><name>struct</name> <name>log_entry</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>payload</name><index>[<expr><name>MAX_MESSAGE</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>log_entry</name></name> <modifier>*</modifier></type><name>entries</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>log_entry</name></name> <modifier>*</modifier></type><name>free_entries</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<function><type><name>int</name></type> <name>log_start</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>passwd</name></name> <modifier>*</modifier></type><name>ent_pw</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>echo_stderr</name> <operator>=</operator> <call><name>option_bool</name><argument_list>(<argument><expr><name>OPT_DEBUG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>daemon</name><operator>-&gt;</operator><name>log_fac</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>log_fac</name> <operator>=</operator> <name><name>daemon</name><operator>-&gt;</operator><name>log_fac</name></name></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOG_LOCAL0</name></cpp:ifdef>
  <if type="elseif">else if <condition>(<expr><call><name>option_bool</name><argument_list>(<argument><expr><name>OPT_DEBUG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>log_fac</name> <operator>=</operator> <name>LOG_LOCAL0</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if <condition>(<expr><name><name>daemon</name><operator>-&gt;</operator><name>log_file</name></name></expr>)</condition>
    <block>{<block_content> 
      <expr_stmt><expr><name>log_to_file</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>daemon</name><operator>-&gt;</operator><name>max_logs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>log_file</name></name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><name>log_stderr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	  <expr_stmt><expr><name>echo_stderr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	  <expr_stmt><expr><name>log_fd</name> <operator>=</operator> <call><name>dup</name><argument_list>(<argument><expr><name>STDERR_FILENO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
  
  <expr_stmt><expr><name>max_logs</name> <operator>=</operator> <name><name>daemon</name><operator>-&gt;</operator><name>max_logs</name></name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>log_reopen</name><argument_list>(<argument><expr><name><name>daemon</name><operator>-&gt;</operator><name>log_file</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><call><name>send_event</name><argument_list>(<argument><expr><name>errfd</name></expr></argument>, <argument><expr><name>EVENT_LOG_ERR</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>daemon</name><operator>-&gt;</operator><name>log_file</name></name></expr> ?</condition><then> <expr><name><name>daemon</name><operator>-&gt;</operator><name>log_file</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* if queuing is inhibited, make sure we allocate
     the one required buffer now. */</comment>
  <if_stmt><if>if <condition>(<expr><name>max_logs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>  
      <expr_stmt><expr><name>free_entries</name> <operator>=</operator> <call><name>safe_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>log_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>free_entries</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>entries_alloced</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* If we're running as root and going to change uid later,
     change the ownership here so that the file is always owned by
     the dnsmasq user. Then logrotate can just copy the owner.
     Failure of the chown call is OK, (for instance when started as non-root).
     
     If we've created a file with group-id root, we also make
     the file group-writable. This gives processes in the root group
     write access to the file and avoids the problem that on some systems,
     once the file is owned by the dnsmasq user, it can't be written
     whilst dnsmasq is running as root during startup.
 */</comment>
  <if_stmt><if>if <condition>(<expr><name>log_to_file</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>log_stderr</name> <operator>&amp;&amp;</operator> <name>ent_pw</name> <operator>&amp;&amp;</operator> <name><name>ent_pw</name><operator>-&gt;</operator><name>pw_uid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>ls</name></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>getgid</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>fstat</name><argument_list>(<argument><expr><name>log_fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ls</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>ls</name><operator>.</operator><name>st_gid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
	  <operator>(</operator><name><name>ls</name><operator>.</operator><name>st_mode</name></name> <operator>&amp;</operator> <name>S_IWGRP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fchmod</name><argument_list>(<argument><expr><name>log_fd</name></expr></argument>, <argument><expr><name>S_IRUSR</name><operator>|</operator><name>S_IWUSR</name><operator>|</operator><name>S_IRGRP</name><operator>|</operator><name>S_IWGRP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>fchown</name><argument_list>(<argument><expr><name>log_fd</name></expr></argument>, <argument><expr><name><name>ent_pw</name><operator>-&gt;</operator><name>pw_uid</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>log_reopen</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>log_file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>log_stderr</name></expr>)</condition>
    <block>{<block_content>      
      <if_stmt><if>if <condition>(<expr><name>log_fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>log_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      
      <comment type="block">/* NOTE: umask is set to 022 by the time this gets called */</comment>
      
      <if_stmt><if>if <condition>(<expr><name>log_file</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>log_fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>, <argument><expr><name>O_WRONLY</name><operator>|</operator><name>O_CREAT</name><operator>|</operator><name>O_APPEND</name></expr></argument>, <argument><expr><name>S_IRUSR</name><operator>|</operator><name>S_IWUSR</name><operator>|</operator><name>S_IRGRP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
      <else>else
	<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SOLARIS_NETWORK</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__ANDROID__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	  <comment type="block">/* Solaris logging is "different", /dev/log is not unix-domain socket.
	     Just leave log_fd == -1 and use the vsyslog call for everything.... */</comment>
<cpp:define>#   <cpp:directive>define</cpp:directive> <cpp:macro><name>_PATH_LOG</name></cpp:macro> <cpp:value>""</cpp:value></cpp:define>  <comment type="block">/* dummy */</comment>
	  <return>return <expr><literal type="number">1</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	  <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
	  <expr_stmt><expr><name>log_fd</name> <operator>=</operator> <call><name>socket</name><argument_list>(<argument><expr><name>AF_UNIX</name></expr></argument>, <argument><expr><name>connection_type</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  
	  <comment type="block">/* if max_logs is zero, leave the socket blocking */</comment>
	  <if_stmt><if>if <condition>(<expr><name>log_fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>max_logs</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>=</operator> <call><name>fcntl</name><argument_list>(<argument><expr><name>log_fd</name></expr></argument>, <argument><expr><name>F_GETFL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name>log_fd</name></expr></argument>, <argument><expr><name>F_SETFL</name></expr></argument>, <argument><expr><name>flags</name> <operator>|</operator> <name>O_NONBLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
  
  <return>return <expr><name>log_fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_entry</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>log_entry</name></name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>entries</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>entries</name> <operator>=</operator> <name><name>tmp</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>free_entries</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>free_entries</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></function>      

<function><type><specifier>static</specifier> <name>void</name></type> <name>log_write</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>ssize_t</name></type> <name>rc</name></decl>;</decl_stmt>
   
  <while>while <condition>(<expr><name>entries</name></expr>)</condition>
    <block>{<block_content>
      <comment type="block">/* The data in the payload is written with a terminating zero character 
	 and the length reflects this. For a stream connection we need to 
	 send the zero as a record terminator, but this isn't done for a 
	 datagram connection, so treat the length as one less than reality 
	 to elide the zero. If we're logging to a file, turn the zero into 
	 a newline, and leave the length alone. */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>len_adjust</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name>log_to_file</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name><name>entries</name><operator>-&gt;</operator><name>payload</name><index>[<expr><name><name>entries</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name><name>entries</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name>connection_type</name> <operator>==</operator> <name>SOCK_DGRAM</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>len_adjust</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <comment type="block">/* Avoid duplicates over a fork() */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>entries</name><operator>-&gt;</operator><name>pid</name></name> <operator>!=</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><call><name>free_entry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	  <continue>continue;</continue>
	</block_content>}</block></if></if_stmt>

      <expr_stmt><expr><name>connection_good</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>rc</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>log_fd</name></expr></argument>, <argument><expr><name><name>entries</name><operator>-&gt;</operator><name>payload</name></name> <operator>+</operator> <name><name>entries</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>entries</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name>len_adjust</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><name><name>entries</name><operator>-&gt;</operator><name>length</name></name> <operator>-=</operator> <name>rc</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>entries</name><operator>-&gt;</operator><name>offset</name></name> <operator>+=</operator> <name>rc</name></expr>;</expr_stmt>
	  <if_stmt><if>if <condition>(<expr><name><name>entries</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <name>len_adjust</name></expr>)</condition>
	    <block>{<block_content>
	      <expr_stmt><expr><call><name>free_entry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	      <if_stmt><if>if <condition>(<expr><name>entries_lost</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
		  <decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><name>entries_lost</name></expr></init></decl>;</decl_stmt>
		  <expr_stmt><expr><name>entries_lost</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* avoid wild recursion */</comment>
		  <expr_stmt><expr><call><name>my_syslog</name><argument_list>(<argument><expr><name>LOG_WARNING</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"overflow: %d log entries lost"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>	  
	    </block_content>}</block></if></if_stmt>
	  <continue>continue;</continue>
	</block_content>}</block></if></if_stmt>
      
      <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
	<continue>continue;</continue></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition><block type="pseudo"><block_content>
	<return>return;</return></block_content></block></if></if_stmt> <comment type="block">/* syslogd busy, go again when select() or poll() says so */</comment>
      
      <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOBUFS</name></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><name>connection_good</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	  <return>return;</return>
	</block_content>}</block></if></if_stmt>

      <comment type="block">/* errors handling after this assumes sockets */</comment> 
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>log_to_file</name></expr>)</condition>
	<block>{<block_content>
	  <comment type="block">/* Once a stream socket hits EPIPE, we have to close and re-open
	     (we ignore SIGPIPE) */</comment>
	  <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EPIPE</name></expr>)</condition>
	    <block>{<block_content>
	      <if_stmt><if>if <condition>(<expr><call><name>log_reopen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<continue>continue;</continue></block_content></block></if></if_stmt>
	    </block_content>}</block></if>
	  <if type="elseif">else if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ECONNREFUSED</name> <operator>||</operator> 
		   <name>errno</name> <operator>==</operator> <name>ENOTCONN</name> <operator>||</operator> 
		   <name>errno</name> <operator>==</operator> <name>EDESTADDRREQ</name> <operator>||</operator> 
		   <name>errno</name> <operator>==</operator> <name>ECONNRESET</name></expr>)</condition>
	    <block>{<block_content>
	      <comment type="block">/* socket went (syslogd down?), try and reconnect. If we fail,
		 stop trying until the next call to my_syslog() 
		 ECONNREFUSED -&gt; connection went down
		 ENOTCONN -&gt; nobody listening
		 (ECONNRESET, EDESTADDRREQ are *BSD equivalents) */</comment>
	      
	      <decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_un</name></name></type> <name>logaddr</name></decl>;</decl_stmt>
	      
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SOCKADDR_SA_LEN</name></cpp:ifdef>
	      <expr_stmt><expr><name><name>logaddr</name><operator>.</operator><name>sun_len</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>logaddr</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>logaddr</name><operator>.</operator><name>sun_path</name></name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>_PATH_LOG</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	      <expr_stmt><expr><name><name>logaddr</name><operator>.</operator><name>sun_family</name></name> <operator>=</operator> <name>AF_UNIX</name></expr>;</expr_stmt>
	      <expr_stmt><expr><call><name>safe_strncpy</name><argument_list>(<argument><expr><name><name>logaddr</name><operator>.</operator><name>sun_path</name></name></expr></argument>, <argument><expr><name>_PATH_LOG</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>logaddr</name><operator>.</operator><name>sun_path</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	      
	      <comment type="block">/* Got connection back? try again. */</comment>
	      <if_stmt><if>if <condition>(<expr><call><name>connect</name><argument_list>(<argument><expr><name>log_fd</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>logaddr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>logaddr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<continue>continue;</continue></block_content></block></if></if_stmt>
	      
	      <comment type="block">/* errors from connect which mean we should keep trying */</comment>
	      <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name> <operator>||</operator> 
		  <name>errno</name> <operator>==</operator> <name>EALREADY</name> <operator>||</operator> 
		  <name>errno</name> <operator>==</operator> <name>ECONNREFUSED</name> <operator>||</operator>
		  <name>errno</name> <operator>==</operator> <name>EISCONN</name> <operator>||</operator> 
		  <name>errno</name> <operator>==</operator> <name>EINTR</name> <operator>||</operator>
		  <name>errno</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator> 
		  <name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition>
		<block>{<block_content>
		  <comment type="block">/* try again on next syslog() call */</comment>
		  <expr_stmt><expr><name>connection_good</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		  <return>return;</return>
		</block_content>}</block></if></if_stmt>
	      
	      <comment type="block">/* try the other sort of socket... */</comment>
	      <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EPROTOTYPE</name></expr>)</condition>
		<block>{<block_content>
		  <expr_stmt><expr><name>connection_type</name> <operator>=</operator> <ternary><condition><expr><name>connection_type</name> <operator>==</operator> <name>SOCK_DGRAM</name></expr> ?</condition><then> <expr><name>SOCK_STREAM</name></expr> </then><else>: <expr><name>SOCK_DGRAM</name></expr></else></ternary></expr>;</expr_stmt>
		  <if_stmt><if>if <condition>(<expr><call><name>log_reopen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		    <continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	    </block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

      <comment type="block">/* give up - fall back to syslog() - this handles out-of-space
	 when logging to a file, for instance. */</comment>
      <expr_stmt><expr><name>log_fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>my_syslog</name><argument_list>(<argument><expr><name>LOG_CRIT</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"log failed: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* priority is one of LOG_DEBUG, LOG_INFO, LOG_NOTICE, etc. See sys/syslog.h.
   OR'd to priority can be MS_TFTP, MS_DHCP, ... to be able to do log separation between
   DNS, DHCP and TFTP services.
   If OR'd with MS_DEBUG, the messages are suppressed unless --log-debug is set. */</comment>
<function><type><name>void</name></type> <name>my_syslog</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>priority</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>log_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>time_t</name></type> <name>time_now</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name> <init>= <expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>LOG_FACMASK</name> <operator>&amp;</operator> <name>priority</name><operator>)</operator> <operator>==</operator> <name>MS_TFTP</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>func</name> <operator>=</operator> <literal type="string">"-tftp"</literal></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name>LOG_FACMASK</name> <operator>&amp;</operator> <name>priority</name><operator>)</operator> <operator>==</operator> <name>MS_DHCP</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>func</name> <operator>=</operator> <literal type="string">"-dhcp"</literal></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name>LOG_FACMASK</name> <operator>&amp;</operator> <name>priority</name><operator>)</operator> <operator>==</operator> <name>MS_SCRIPT</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>func</name> <operator>=</operator> <literal type="string">"-script"</literal></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><operator>(</operator><name>LOG_FACMASK</name> <operator>&amp;</operator> <name>priority</name><operator>)</operator> <operator>==</operator> <name>MS_DEBUG</name></expr>)</condition>
    <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>option_bool</name><argument_list>(<argument><expr><name>OPT_LOG_DEBUG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<return>return;</return></block_content></block></if></if_stmt>
      <expr_stmt><expr><name>func</name> <operator>=</operator> <literal type="string">"-debug"</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOG_PRI</name></cpp:ifdef>
  <expr_stmt><expr><name>priority</name> <operator>=</operator> <call><name>LOG_PRI</name><argument_list>(<argument><expr><name>priority</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* Solaris doesn't have LOG_PRI */</comment>
  <expr_stmt><expr><name>priority</name> <operator>&amp;=</operator> <name>LOG_PRIMASK</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if <condition>(<expr><name>echo_stderr</name></expr>)</condition> 
    <block>{<block_content>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"dnsmasq%s: "</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <comment type="block">/* Pi-hole diagnosis system */</comment>
  <if_stmt><if>if<condition>(<expr><name>priority</name> <operator>==</operator> <name>LOG_WARNING</name></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>message</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if<condition>(<expr><call><name>vasprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>message</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
          <expr_stmt><expr><call><name>dnsmasq_diagnosis_warning</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>log_fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__ANDROID__</name></cpp:ifdef>
      <comment type="block">/* do android-specific logging. 
	 log_fd is always -1 on Android except when logging to a file. */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>alog_lvl</name></decl>;</decl_stmt>
      
      <if_stmt><if>if <condition>(<expr><name>priority</name> <operator>&lt;=</operator> <name>LOG_ERR</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>alog_lvl</name> <operator>=</operator> <name>ANDROID_LOG_ERROR</name></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name>priority</name> <operator>==</operator> <name>LOG_WARNING</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>alog_lvl</name> <operator>=</operator> <name>ANDROID_LOG_WARN</name></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name>priority</name> <operator>&lt;=</operator> <name>LOG_INFO</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>alog_lvl</name> <operator>=</operator> <name>ANDROID_LOG_INFO</name></expr>;</expr_stmt></block_content></block></if>
      <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><name>alog_lvl</name> <operator>=</operator> <name>ANDROID_LOG_DEBUG</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

      <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>__android_log_vprint</name><argument_list>(<argument><expr><name>alog_lvl</name></expr></argument>, <argument><expr><literal type="string">"dnsmasq"</literal></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* fall-back to syslog if we die during startup or 
	 fail during running (always on Solaris). */</comment>
      <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>isopen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isopen</name></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><call><name>openlog</name><argument_list>(<argument><expr><literal type="string">"dnsmasq"</literal></expr></argument>, <argument><expr><name>LOG_PID</name></expr></argument>, <argument><expr><name>log_fac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>isopen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
      <expr_stmt><expr><call><name>vsyslog</name><argument_list>(<argument><expr><name>priority</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <return>return;</return>
    </block_content>}</block></if></if_stmt>
  
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <name>free_entries</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>free_entries</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>entries_alloced</name> <operator>&lt;</operator> <name>max_logs</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>entry</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>log_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>entries_alloced</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
  
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>entries_lost</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
  <else>else
    <block>{<block_content>
      <comment type="block">/* add to end of list, consumed from the start */</comment>
      <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>entries</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>entries</name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt></block_content></block></if>
      <else>else
	<block>{<block_content>
	  <decl_stmt><decl><type><name><name>struct</name> <name>log_entry</name></name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
	  <for>for <control>(<init><expr><name>tmp</name> <operator>=</operator> <name>entries</name></expr>;</init> <condition><expr><name><name>tmp</name><operator>-&gt;</operator><name>next</name></name></expr>;</condition> <incr><expr><name>tmp</name> <operator>=</operator> <name><name>tmp</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
	  <expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
      
      <expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>time_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>payload</name></name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>log_to_file</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"&lt;%d&gt;"</literal></expr></argument>, <argument><expr><name>priority</name> <operator>|</operator> <name>log_fac</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <comment type="block">/* Omit timestamp for default daemontools situation */</comment>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>log_stderr</name> <operator>||</operator> <operator>!</operator><call><name>option_bool</name><argument_list>(<argument><expr><name>OPT_NO_FORK</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> 
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%.15s "</literal></expr></argument>, <argument><expr><call><name>ctime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>time_now</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"dnsmasq%s[%d]: "</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
      <expr_stmt><expr><name>len</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name><name>entry</name><operator>-&gt;</operator><name>payload</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
      <expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>vsnprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>MAX_MESSAGE</name> <operator>-</operator> <name>len</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* include zero-terminator */</comment>
      <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <ternary><condition><expr><name>len</name> <operator>&gt;</operator> <name>MAX_MESSAGE</name></expr> ?</condition><then> <expr><name>MAX_MESSAGE</name></expr> </then><else>: <expr><name>len</name></expr></else></ternary></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name>pid</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  
  <comment type="block">/* almost always, logging won't block, so try and write this now,
     to save collecting too many log messages during a select loop. */</comment>
  <expr_stmt><expr><call><name>log_write</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Since we're doing things asynchronously, a cache-dump, for instance,
     can now generate log lines very fast. With a small buffer (desirable),
     that means it can overflow the log-buffer very quickly,
     so that the cache dump becomes mainly a count of how many lines 
     overflowed. To avoid this, we delay here, the delay is controlled 
     by queue-occupancy, and grows exponentially. The delay is limited to (2^8)ms.
     The scaling stuff ensures that when the queue is bigger than 8, the delay
     only occurs for the last 8 entries. Once the queue is full, we stop delaying
     to preserve performance.
  */</comment>

  <if_stmt><if>if <condition>(<expr><name>entries</name> <operator>&amp;&amp;</operator> <name>max_logs</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>d</name></decl>;</decl_stmt>
      
      <for>for <control>(<init><expr><name>d</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator><expr><name>entry</name> <operator>=</operator> <name>entries</name></expr>;</init> <condition><expr><name>entry</name></expr>;</condition> <incr><expr><name>entry</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>next</name></name></expr><operator>,</operator> <expr><name>d</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
      
      <if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <name>max_logs</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
      <if type="elseif">else if <condition>(<expr><name>max_logs</name> <operator>&gt;</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>d</name> <operator>-=</operator> <name>max_logs</name> <operator>-</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

      <if_stmt><if>if <condition>(<expr><name>d</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
	  <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>waiter</name></decl>;</decl_stmt>
	  <expr_stmt><expr><name><name>waiter</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>waiter</name><operator>.</operator><name>tv_nsec</name></name> <operator>=</operator> <literal type="number">1000000</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>d</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt> <comment type="block">/* 1 ms */</comment>
	  <expr_stmt><expr><call><name>nanosleep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>waiter</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
	  <comment type="block">/* Have another go now */</comment>
	  <expr_stmt><expr><call><name>log_write</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt> 
</block_content>}</block></function>

<function><type><name>void</name></type> <name>set_log_writer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>entries</name> <operator>&amp;&amp;</operator> <name>log_fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>connection_good</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>poll_listen</name><argument_list>(<argument><expr><name>log_fd</name></expr></argument>, <argument><expr><name>POLLOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>check_log_writer</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>log_fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>force</name> <operator>||</operator> <call><name>poll_check</name><argument_list>(<argument><expr><name>log_fd</name></expr></argument>, <argument><expr><name>POLLOUT</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>log_write</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>flush_log</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
  <comment type="block">/* write until queue empty, but don't loop forever if there's
   no connection to the syslog in existence */</comment>
  <while>while <condition>(<expr><name>log_fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
      <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>waiter</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>log_write</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>entries</name> <operator>||</operator> <operator>!</operator><name>connection_good</name></expr>)</condition>
	<block>{<block_content>
	  <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>log_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
	  <break>break;</break>
	</block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>waiter</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>waiter</name><operator>.</operator><name>tv_nsec</name></name> <operator>=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt> <comment type="block">/* 1 ms */</comment>
      <expr_stmt><expr><call><name>nanosleep</name><argument_list>(<argument><expr><operator>&amp;</operator><name>waiter</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>die</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>exit_code</name></decl></parameter>)</parameter_list>
<block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>errmess</name> <init>= <expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg1</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>arg1</name> <operator>=</operator> <name>errmess</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>log_stderr</name></expr>)</condition>
    <block>{<block_content>
      <expr_stmt><expr><name>echo_stderr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* print as well as log when we die.... */</comment>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* prettyfy  startup-script message */</comment>
    </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>my_syslog</name><argument_list>(<argument><expr><name>LOG_CRIT</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>errmess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>echo_stderr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>my_syslog</name><argument_list>(<argument><expr><name>LOG_CRIT</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"FAILED to start up"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>flush_log</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block" format="doxygen">/********** Pi-hole modification *************/</comment>
  <expr_stmt><expr><call><name>FTL_log_dnsmasq_fatal</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>errmess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block" format="doxygen">/*********************************************/</comment>
  
  <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>exit_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
