<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/signals.c"><comment type="block">/* Pi-hole: A black hole for Internet advertisements
*  (c) 2017 Pi-hole, LLC (https://pi-hole.net)
*  Network-wide ad blocking via your own hardware.
*
*  FTL Engine
*  Signal processing routines
*
*  This file is copyright under the latest version of the EUPL.
*  Please see LICENSE file for your rights under this license. */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"FTL.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GLIBC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;execinfo.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"signals.h"</cpp:file></cpp:include>
<comment type="line">// logg()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"log.h"</cpp:file></cpp:include>
<comment type="line">// ls_dir()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"files.h"</cpp:file></cpp:include>
<comment type="line">// gettid()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"daemon.h"</cpp:file></cpp:include>
<comment type="line">// Eventqueue routines</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"events.h"</cpp:file></cpp:include>
<comment type="line">// sleepms()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"timers.h"</cpp:file></cpp:include>
<comment type="line">// struct config</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BINARY_NAME</name></cpp:macro> <cpp:value>"pihole-FTL"</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>killed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>pid_t</name></type> <name>mpid</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>time_t</name></type> <name>FTLstarttime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>exit_code</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name><name>thread_cancellable</name><index>[<expr><name>THREADS_MAX</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>thread_names</name><index>[<expr><name>THREADS_MAX</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="string">""</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<comment type="line">// Return the (null-terminated) name of the calling thread</comment>
<comment type="line">// The name is stored in the buffer as well as returned for convenience</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name>__attribute__</name> <argument_list>(<argument><expr><operator>(</operator><call><name>nonnull</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list> <name>getthread_name</name><argument_list>(<argument><expr><name>char</name> <name><name>buffer</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>prctl</name><argument_list>(<argument><expr><name>PR_GET_NAME</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>buffer</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GLIBC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>print_addr2line</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>symbol</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>address</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>j</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Only do this analysis for our own binary (skip trying to analyse libc.so, etc.)</comment>
	<if_stmt><if>if<condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>symbol</name></expr></argument>, <argument><expr><name>BINARY_NAME</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="line">// Find first occurrence of '(' or ' ' in the obtaned symbol string and</comment>
	<comment type="line">// assume everything before that is the file name. (Don't go beyond the</comment>
	<comment type="line">// string terminator \0)</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<while>while<condition>(<expr><name><name>symbol</name><index>[<expr><name>p</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'('</literal> <operator>&amp;&amp;</operator> <name><name>symbol</name><index>[<expr><name>p</name></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <name><name>symbol</name><index>[<expr><name>p</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<comment type="line">// Compute address cleaned by binary offset</comment>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>addr</name> <init>= <expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><name>address</name><operator>-</operator><name>offset</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<comment type="line">// Invoke addr2line command and get result through pipe</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>addr2line_cmd</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>addr2line_cmd</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr2line_cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"addr2line %p -e %.*s"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>symbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>addr2line</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>linebuffer</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>addr2line</name></name> <operator>&amp;&amp;</operator>
	   <operator>(</operator><name>addr2line</name> <operator>=</operator> <call><name>popen</name><argument_list>(<argument><expr><name>addr2line_cmd</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
	   <call><name>fgets</name><argument_list>(<argument><expr><name>linebuffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>linebuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>addr2line</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>
		<comment type="line">// Strip possible newline at the end of the addr2line output</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pos</name><operator>=</operator><call><name>strchr</name><argument_list>(<argument><expr><name>linebuffer</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>pos</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>linebuffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>linebuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"N/A (%p -&gt; %s)"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>addr2line_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="line">// Log result</comment>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"L[%04i]: %s"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>linebuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Close pipe</comment>
	<if_stmt><if>if<condition>(<expr><name>addr2line</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pclose</name><argument_list>(<argument><expr><name>addr2line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// Log backtrace</comment>
<function><type><name>void</name></type> <name>generate_backtrace</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="line">// Check GLIBC availability as MUSL does not support live backtrace generation</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GLIBC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<comment type="line">// Try to obtain backtrace. This may not always be helpful, but it is better than nothing</comment>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name><name>buffer</name><index>[<expr><literal type="number">255</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>calls</name> <init>= <expr><call><name>backtrace</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Backtrace:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type> <name>bcktrace</name> <init>= <expr><call><name>backtrace_symbols</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>calls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>bcktrace</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Unable to obtain backtrace symbols!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Try to compute binary offset from backtrace_symbols result</comment>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>offset</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>calls</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pend</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><operator>(</operator><name>pend</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name><name>bcktrace</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		   <call><name>strstr</name><argument_list>(<argument><expr><name><name>bcktrace</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>BINARY_NAME</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		   <call><name>sscanf</name><argument_list>(<argument><expr><name>pend</name></expr></argument>, <argument><expr><literal type="string">"(+%p) [%p]"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>p1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		   <expr_stmt><expr><name>offset</name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><operator>(</operator><name>p2</name><operator>-</operator><name>p1</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<for>for<control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>calls</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"B[%04i]: %s"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>,
		     <argument><expr><ternary><condition><expr><name>bcktrace</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>bcktrace</name><index>[<expr><name>j</name></expr>]</index></name></expr> </then><else>: <expr><literal type="string">"---"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if<condition>(<expr><name>bcktrace</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>print_addr2line</name><argument_list>(<argument><expr><name><name>bcktrace</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>buffer</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bcktrace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"!!! INFO: pihole-FTL has not been compiled with glibc/backtrace support, not generating one !!!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>noreturn</name><operator>)</operator></expr></argument>)</argument_list> <name>signal_handler</name><argument_list>(<argument><expr><name>int</name> <name>sig</name></expr></argument>, <argument><expr><name>siginfo_t</name> <operator>*</operator><name>si</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>unused</name></expr></argument>)</argument_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"----------------------------&gt;  FTL crashed!  &lt;----------------------------"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Please report a bug at https://github.com/pi-hole/FTL/issues"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"and include in your report already the following details:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>FTLstarttime</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"FTL has been running for %lli seconds"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>FTLstarttime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>log_FTL_version</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>namebuf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Process details: MID: %i"</literal></expr></argument>, <argument><expr><name>mpid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"                 PID: %i"</literal></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"                 TID: %i"</literal></expr></argument>, <argument><expr><call><name>gettid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"                 Name: %s"</literal></expr></argument>, <argument><expr><call><name>getthread_name</name><argument_list>(<argument><expr><name>namebuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Received signal: %s"</literal></expr></argument>, <argument><expr><call><name>strsignal</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     at address: %p"</literal></expr></argument>, <argument><expr><name><name>si</name><operator>-&gt;</operator><name>si_addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Segmentation fault - program crashed</comment>
	<if_stmt><if>if<condition>(<expr><name>sig</name> <operator>==</operator> <name>SIGSEGV</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>si_code</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>SEGV_MAPERR</name></expr>:</case>  <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  SEGV_MAPERR (Address not mapped to object)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
			<case>case <expr><name>SEGV_ACCERR</name></expr>:</case>  <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  SEGV_ACCERR (Invalid permissions for mapped object)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SEGV_BNDERR</name></cpp:ifdef>
			<case>case <expr><name>SEGV_BNDERR</name></expr>:</case>  <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  SEGV_BNDERR (Failed address bound checks)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SEGV_PKUERR</name></cpp:ifdef>
			<case>case <expr><name>SEGV_PKUERR</name></expr>:</case>  <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  SEGV_PKUERR (Protection key checking failure)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SEGV_ACCADI</name></cpp:ifdef>
			<case>case <expr><name>SEGV_ACCADI</name></expr>:</case>  <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  SEGV_ACCADI (ADI not enabled for mapped object)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SEGV_ADIDERR</name></cpp:ifdef>
			<case>case <expr><name>SEGV_ADIDERR</name></expr>:</case> <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  SEGV_ADIDERR (Disrupting MCD error)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SEGV_ADIPERR</name></cpp:ifdef>
			<case>case <expr><name>SEGV_ADIPERR</name></expr>:</case> <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  SEGV_ADIPERR (Precise MCD exception)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<default>default:</default>           <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  Unknown (%i)"</literal></expr></argument>, <argument><expr><name><name>si</name><operator>-&gt;</operator><name>si_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if>

	<comment type="line">// Bus error - memory manager problem</comment>
	<if type="elseif">else if<condition>(<expr><name>sig</name> <operator>==</operator> <name>SIGBUS</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>si_code</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>BUS_ADRALN</name></expr>:</case>    <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  BUS_ADRALN (Invalid address alignment)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
			<case>case <expr><name>BUS_ADRERR</name></expr>:</case>    <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  BUS_ADRERR (Non-existent physical address)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
			<case>case <expr><name>BUS_OBJERR</name></expr>:</case>    <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  BUS_OBJERR (Object specific hardware error)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
			<case>case <expr><name>BUS_MCEERR_AR</name></expr>:</case> <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  BUS_MCEERR_AR (Hardware memory error: action required)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
			<case>case <expr><name>BUS_MCEERR_AO</name></expr>:</case> <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  BUS_MCEERR_AO (Hardware memory error: action optional)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
			<default>default:</default>            <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  Unknown (%i)"</literal></expr></argument>, <argument><expr><name><name>si</name><operator>-&gt;</operator><name>si_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if>

	<comment type="line">// Illegal error - Illegal instruction detected</comment>
	<if type="elseif">else if<condition>(<expr><name>sig</name> <operator>==</operator> <name>SIGILL</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>si_code</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>ILL_ILLOPC</name></expr>:</case>   <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  ILL_ILLOPC (Illegal opcode)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
			<case>case <expr><name>ILL_ILLOPN</name></expr>:</case>   <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  ILL_ILLOPN (Illegal operand)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
			<case>case <expr><name>ILL_ILLADR</name></expr>:</case>   <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  ILL_ILLADR (Illegal addressing mode)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
			<case>case <expr><name>ILL_ILLTRP</name></expr>:</case>   <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  ILL_ILLTRP (Illegal trap)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
			<case>case <expr><name>ILL_PRVOPC</name></expr>:</case>   <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  ILL_PRVOPC (Privileged opcode)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
			<case>case <expr><name>ILL_PRVREG</name></expr>:</case>   <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  ILL_PRVREG (Privileged register)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
			<case>case <expr><name>ILL_COPROC</name></expr>:</case>   <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  ILL_COPROC (Coprocessor error)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
			<case>case <expr><name>ILL_BADSTK</name></expr>:</case>   <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  ILL_BADSTK (Internal stack error)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ILL_BADIADDR</name></cpp:ifdef>
			<case>case <expr><name>ILL_BADIADDR</name></expr>:</case> <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  ILL_BADIADDR (Unimplemented instruction address)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<default>default:</default>           <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  Unknown (%i)"</literal></expr></argument>, <argument><expr><name><name>si</name><operator>-&gt;</operator><name>si_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if>

	<comment type="line">// Floating point exception error</comment>
	<if type="elseif">else if<condition>(<expr><name>sig</name> <operator>==</operator> <name>SIGFPE</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>si_code</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>FPE_INTDIV</name></expr>:</case>   <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  FPE_INTDIV (Integer divide by zero)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
			<case>case <expr><name>FPE_INTOVF</name></expr>:</case>   <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  FPE_INTOVF (Integer overflow)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
			<case>case <expr><name>FPE_FLTDIV</name></expr>:</case>   <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  FPE_FLTDIV (Floating point divide by zero)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
			<case>case <expr><name>FPE_FLTOVF</name></expr>:</case>   <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  FPE_FLTOVF (Floating point overflow)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
			<case>case <expr><name>FPE_FLTUND</name></expr>:</case>   <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  FPE_FLTUND (Floating point underflow)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
			<case>case <expr><name>FPE_FLTRES</name></expr>:</case>   <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  FPE_FLTRES (Floating point inexact result)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
			<case>case <expr><name>FPE_FLTINV</name></expr>:</case>   <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  FPE_FLTINV (Floating point invalid operation)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
			<case>case <expr><name>FPE_FLTSUB</name></expr>:</case>   <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  FPE_FLTSUB (Subscript out of range)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FPE_FLTUNK</name></cpp:ifdef>
			<case>case <expr><name>FPE_FLTUNK</name></expr>:</case>   <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  FPE_FLTUNK (Undiagnosed floating-point exception)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FPE_CONDTRAP</name></cpp:ifdef>
			<case>case <expr><name>FPE_CONDTRAP</name></expr>:</case> <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  FPE_CONDTRAP (Trap on condition)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<default>default:</default>           <expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"     with code:  Unknown (%i)"</literal></expr></argument>, <argument><expr><name><name>si</name><operator>-&gt;</operator><name>si_code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>generate_backtrace</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Print content of /dev/shm</comment>
	<expr_stmt><expr><call><name>ls_dir</name><argument_list>(<argument><expr><literal type="string">"/dev/shm"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Please also include some lines from above the !!!!!!!!! header."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Thank you for helping us to improve our FTL engine!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Terminate main process if crash happened in a TCP worker</comment>
	<if_stmt><if>if<condition>(<expr><name>mpid</name> <operator>!=</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// This is a forked process</comment>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Asking parent pihole-FTL (PID %i) to shut down"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>mpid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>mpid</name></expr></argument>, <argument><expr><name>SIGRTMIN</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"FTL fork terminated!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="line">// This is the main process</comment>
		<expr_stmt><expr><call><name>cleanup</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="line">// Terminate process indicating failure</comment>
	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>SIGRT_handler</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signum</name></decl></parameter>, <parameter><decl><type><name>siginfo_t</name> <modifier>*</modifier></type><name>si</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>unused</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Backup errno</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// Ignore real-time signals outside of the main process (TCP forks)</comment>
	<if_stmt><if>if<condition>(<expr><name>mpid</name> <operator>!=</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Restore errno before returning</comment>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>_errno</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>rtsig</name> <init>= <expr><name>signum</name> <operator>-</operator> <name>SIGRTMIN</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Received: %s (%d -&gt; %d)"</literal></expr></argument>, <argument><expr><call><name>strsignal</name><argument_list>(<argument><expr><name>signum</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>signum</name></expr></argument>, <argument><expr><name>rtsig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>rtsig</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Reload</comment>
		<comment type="line">// - gravity</comment>
		<comment type="line">// - exact whitelist</comment>
		<comment type="line">// - regex whitelist</comment>
		<comment type="line">// - exact blacklist</comment>
		<comment type="line">// - exact blacklist</comment>
		<comment type="line">// WITHOUT wiping the DNS cache itself</comment>
		<expr_stmt><expr><call><name>set_event</name><argument_list>(<argument><expr><name>RELOAD_GRAVITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Reload the privacy level in case the user changed it</comment>
		<expr_stmt><expr><call><name>set_event</name><argument_list>(<argument><expr><name>RELOAD_PRIVACY_LEVEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Reload blocking status</comment>
		<expr_stmt><expr><call><name>set_event</name><argument_list>(<argument><expr><name>RELOAD_BLOCKINGSTATUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name>rtsig</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Terminate FTL indicating failure</comment>
		<expr_stmt><expr><name>exit_code</name> <operator>=</operator> <name>EXIT_FAILURE</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name>rtsig</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Reimport alias-clients from database</comment>
		<expr_stmt><expr><call><name>set_event</name><argument_list>(<argument><expr><name>REIMPORT_ALIASCLIENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name>rtsig</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Re-resolve all clients and forward destinations</comment>
		<comment type="line">// Force refreshing hostnames according to</comment>
		<comment type="line">// REFRESH_HOSTNAMES config option</comment>
		<expr_stmt><expr><call><name>set_event</name><argument_list>(<argument><expr><name>RERESOLVE_HOSTNAMES_FORCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name>rtsig</name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Parse neighbor cache</comment>
		<expr_stmt><expr><call><name>set_event</name><argument_list>(<argument><expr><name>PARSE_NEIGHBOR_CACHE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Restore errno before returning back to previous context</comment>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Register ordinary signals handler</comment>
<function><type><name>void</name></type> <name>handle_signals</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type> <name>old_action</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>signals</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>SIGSEGV</name></expr>, <expr><name>SIGBUS</name></expr>, <expr><name>SIGILL</name></expr>, <expr><name>SIGFPE</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<for>for<control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>signals</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>signals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="line">// Catch this signal</comment>
		<expr_stmt><expr><call><name>sigaction</name> <argument_list>(<argument><expr><name><name>signals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name><name>old_action</name><operator>.</operator><name>sa_handler</name></name> <operator>!=</operator> <name>SIG_IGN</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type> <name>SIGaction</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SIGaction</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sigaction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>SIGaction</name><operator>.</operator><name>sa_flags</name></name> <operator>=</operator> <name>SA_SIGINFO</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SIGaction</name><operator>.</operator><name>sa_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>SIGaction</name><operator>.</operator><name>sa_sigaction</name></name> <operator>=</operator> <operator>&amp;</operator><name>signal_handler</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sigaction</name><argument_list>(<argument><expr><name><name>signals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SIGaction</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="line">// Log start time of FTL</comment>
	<expr_stmt><expr><name>FTLstarttime</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Register real-time signal handler</comment>
<function><type><name>void</name></type> <name>handle_realtime_signals</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// This function is only called once (after forking), store the PID of</comment>
	<comment type="line">// the main process</comment>
	<expr_stmt><expr><name>mpid</name> <operator>=</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Catch all real-time signals</comment>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>signum</name> <init>= <expr><name>SIGRTMIN</name></expr></init></decl>;</init> <condition><expr><name>signum</name> <operator>&lt;=</operator> <name>SIGRTMAX</name></expr>;</condition> <incr><expr><name>signum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type> <name>SIGACTION</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SIGACTION</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sigaction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>SIGACTION</name><operator>.</operator><name>sa_flags</name></name> <operator>=</operator> <name>SA_SIGINFO</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SIGACTION</name><operator>.</operator><name>sa_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>SIGACTION</name><operator>.</operator><name>sa_sigaction</name></name> <operator>=</operator> <operator>&amp;</operator><name>SIGRT_handler</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sigaction</name><argument_list>(<argument><expr><name>signum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SIGACTION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="line">// Return PID of the main FTL process</comment>
<function><type><name>pid_t</name></type> <name>main_pid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>mpid</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<comment type="line">// Has already been set</comment>
		<return>return <expr><name>mpid</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<comment type="line">// Has not been set so far</comment>
		<return>return <expr><call><name>getpid</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>thread_sleepms</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>enum</name> <name>thread_types</name></name></type> <name>thread</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>milliseconds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>killed</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>thread_cancellable</name><index>[<expr><name>thread</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sleepms</name><argument_list>(<argument><expr><name>milliseconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>thread_cancellable</name><index>[<expr><name>thread</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
