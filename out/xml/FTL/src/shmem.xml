<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/FTL/src/shmem.c"><comment type="block">/* Pi-hole: A black hole for Internet advertisements
*  (c) 2018 Pi-hole, LLC (https://pi-hole.net)
*  Network-wide ad blocking via your own hardware.
*
*  FTL Engine
*  Shared memory subroutines
*
*  This file is copyright under the latest version of the EUPL.
*  Please see LICENSE file for your rights under this license. */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"FTL.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHMEM_PRIVATE</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"overTime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<comment type="line">// data getter functions</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"datastructure.h"</cpp:file></cpp:include>
<comment type="line">// get_num_regex()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regex_r.h"</cpp:file></cpp:include>
<comment type="line">// NAME_MAX</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<comment type="line">// gettid</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"daemon.h"</cpp:file></cpp:include>
<comment type="line">// generate_backtrace()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"signals.h"</cpp:file></cpp:include>
<comment type="line">// get_path_usage()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"files.h"</cpp:file></cpp:include>
<comment type="line">// log_resource_shortage()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"database/message-table.h"</cpp:file></cpp:include>
<comment type="line">// check_running_FTL()</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"procps.h"</cpp:file></cpp:include>

<comment type="line" format="doxygen">/// The version of shared memory used</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARED_MEMORY_VERSION</name></cpp:macro> <cpp:value>14</cpp:value></cpp:define>

<comment type="line" format="doxygen">/// The name of the shared memory. Use this when connecting to the shared memory.</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHMEM_PATH</name></cpp:macro> <cpp:value>"/dev/shm"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARED_LOCK_NAME</name></cpp:macro> <cpp:value>"FTL-lock"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARED_STRINGS_NAME</name></cpp:macro> <cpp:value>"FTL-strings"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARED_COUNTERS_NAME</name></cpp:macro> <cpp:value>"FTL-counters"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARED_DOMAINS_NAME</name></cpp:macro> <cpp:value>"FTL-domains"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARED_CLIENTS_NAME</name></cpp:macro> <cpp:value>"FTL-clients"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARED_QUERIES_NAME</name></cpp:macro> <cpp:value>"FTL-queries"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARED_UPSTREAMS_NAME</name></cpp:macro> <cpp:value>"FTL-upstreams"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARED_OVERTIME_NAME</name></cpp:macro> <cpp:value>"FTL-overTime"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARED_SETTINGS_NAME</name></cpp:macro> <cpp:value>"FTL-settings"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARED_DNS_CACHE</name></cpp:macro> <cpp:value>"FTL-dns-cache"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARED_PER_CLIENT_REGEX</name></cpp:macro> <cpp:value>"FTL-per-client-regex"</cpp:value></cpp:define>

<comment type="line">// Allocation step for FTL-strings bucket. This is somewhat special as we use</comment>
<comment type="line">// this as a general-purpose storage which should always be large enough. If,</comment>
<comment type="line">// for some reason, more data than this step has to be stored (highly unlikely,</comment>
<comment type="line">// close to impossible), the data will be properly truncated and we try again in</comment>
<comment type="line">// the next lock round</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGS_ALLOC_STEP</name></cpp:macro> <cpp:value>(10*pagesize)</cpp:value></cpp:define>

<comment type="line">// Global counters struct</comment>
<decl_stmt><decl><type><name>countersStruct</name> <modifier>*</modifier></type><name>counters</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="line" format="doxygen">/// The pointer in shared memory to the shared string buffer</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SharedMemory</name></type> <name>shm_lock</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SharedMemory</name></type> <name>shm_strings</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SharedMemory</name></type> <name>shm_counters</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SharedMemory</name></type> <name>shm_domains</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SharedMemory</name></type> <name>shm_clients</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SharedMemory</name></type> <name>shm_queries</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SharedMemory</name></type> <name>shm_upstreams</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SharedMemory</name></type> <name>shm_overTime</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SharedMemory</name></type> <name>shm_settings</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SharedMemory</name></type> <name>shm_dns_cache</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SharedMemory</name></type> <name>shm_per_client_regex</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>SharedMemory</name> <modifier>*</modifier></type><name><name>sharedMemories</name><index>[]</index></name> <init>= <expr><block>{ <expr><operator>&amp;</operator><name>shm_lock</name></expr>,
                                          <expr><operator>&amp;</operator><name>shm_strings</name></expr>,
                                          <expr><operator>&amp;</operator><name>shm_counters</name></expr>,
                                          <expr><operator>&amp;</operator><name>shm_domains</name></expr>,
                                          <expr><operator>&amp;</operator><name>shm_clients</name></expr>,
                                          <expr><operator>&amp;</operator><name>shm_queries</name></expr>,
                                          <expr><operator>&amp;</operator><name>shm_upstreams</name></expr>,
                                          <expr><operator>&amp;</operator><name>shm_overTime</name></expr>,
                                          <expr><operator>&amp;</operator><name>shm_settings</name></expr>,
                                          <expr><operator>&amp;</operator><name>shm_dns_cache</name></expr>,
                                          <expr><operator>&amp;</operator><name>shm_per_client_regex</name></expr> }</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_SHMEM</name></cpp:macro> <cpp:value>(sizeof(sharedMemories)/sizeof(SharedMemory*))</cpp:value></cpp:define>

<comment type="line">// Variable size array structs</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>queriesData</name> <modifier>*</modifier></type><name>queries</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>clientsData</name> <modifier>*</modifier></type><name>clients</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>domainsData</name> <modifier>*</modifier></type><name>domains</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>upstreamsData</name> <modifier>*</modifier></type><name>upstreams</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>DNSCacheData</name> <modifier>*</modifier></type><name>dns_cache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <block>{
	<struct>struct <block>{
		<decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name>outer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name>inner</name></decl>;</decl_stmt>
	}</block> <decl><name>lock</name></decl>;</struct>
	<struct>struct <block>{
		<decl_stmt><decl><type><specifier>volatile</specifier> <name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>volatile</specifier> <name>pid_t</name></type> <name>tid</name></decl>;</decl_stmt>
	}</block> <decl><name>owner</name></decl>;</struct>
}</block></struct></type> <name>ShmLock</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>ShmLock</name> <modifier>*</modifier></type><name>shmLock</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ShmSettings</name> <modifier>*</modifier></type><name>shmSettings</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>pagesize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>local_shm_counter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>shmem_pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>used_shmem</name> <init>= <expr><literal type="number">0u</literal></expr></init></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>size_t</name></type> <name>get_optimal_object_size</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>objsize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>minsize</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="line">// Private prototypes</comment>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>enlarge_shmem_struct</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_dev_shm_usage</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buffer2</name><index>[<expr><literal type="number">64</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>percentage</name> <init>= <expr><call><name>get_path_usage</name><argument_list>(<argument><expr><name>SHMEM_PATH</name></expr></argument>, <argument><expr><name>buffer2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Generate human-readable "used by FTL" size</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>prefix_FTL</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>formatted_FTL</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>format_memory_size</name><argument_list>(<argument><expr><name>prefix_FTL</name></expr></argument>, <argument><expr><name>used_shmem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>formatted_FTL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Print result into buffer passed to this subroutine</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"%s, FTL uses %.1f%sB"</literal></expr></argument>,
	         <argument><expr><name>buffer2</name></expr></argument>, <argument><expr><name>formatted_FTL</name></expr></argument>, <argument><expr><name>prefix_FTL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Return percentage</comment>
	<return>return <expr><name>percentage</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Verify the PID stored during shared memory initialization is the same as ours</comment>
<comment type="line">// (while we initialized the shared memory objects)</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>verify_shmem_pid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Open shared memory settings object</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>settingsfd</name> <init>= <expr><call><name>shm_open</name><argument_list>(<argument><expr><name>SHARED_SETTINGS_NAME</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>settingsfd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"FATAL: verify_shmem_pid(): Failed to open shared memory object \"%s\": %s"</literal></expr></argument>,
			<argument><expr><name>SHARED_SETTINGS_NAME</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>ShmSettings</name></type> <name>shms</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>settingsfd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shms</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>shms</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>shms</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"FATAL: verify_shmem_pid(): Failed to read %zu bytes from shared memory object \"%s\": %s"</literal></expr></argument>,
			<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>shms</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>SHARED_SETTINGS_NAME</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>settingsfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Compare the SHM's PID to the one we had when creating the SHM objects</comment>
	<if_stmt><if>if<condition>(<expr><name><name>shms</name><operator>.</operator><name>pid</name></name> <operator>==</operator> <name>shmem_pid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="line">// If we reach here, we are in serious trouble. Terminating with error</comment>
	<comment type="line">// code is the most sensible thing we can do at this point</comment>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"FATAL: Shared memory is owned by a different process (PID %d)"</literal></expr></argument>, <argument><expr><name><name>shms</name><operator>.</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_running_FTL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Exiting now!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// chown_shmem() changes the file ownership of a given shared memory object</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>chown_shmem</name><parameter_list>(<parameter><decl><type><name>SharedMemory</name> <modifier>*</modifier></type><name>sharedMemory</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>passwd</name></name> <modifier>*</modifier></type><name>ent_pw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Open shared memory object</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>fd</name> <init>= <expr><call><name>shm_open</name><argument_list>(<argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>O_RDWR</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"FATAL: chown_shmem(): Failed to open shared memory object \"%s\": %s"</literal></expr></argument>,
			<argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>fchown</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>ent_pw</name><operator>-&gt;</operator><name>pw_uid</name></name></expr></argument>, <argument><expr><name><name>ent_pw</name><operator>-&gt;</operator><name>pw_gid</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"WARNING: chown_shmem(%d, %d, %d): failed for %s: %s (%d)"</literal></expr></argument>,
		     <argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>ent_pw</name><operator>-&gt;</operator><name>pw_uid</name></name></expr></argument>, <argument><expr><name><name>ent_pw</name><operator>-&gt;</operator><name>pw_gid</name></name></expr></argument>, <argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
		     <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Changing %s (%d) to %d:%d"</literal></expr></argument>, <argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>ent_pw</name><operator>-&gt;</operator><name>pw_uid</name></name></expr></argument>, <argument><expr><name><name>ent_pw</name><operator>-&gt;</operator><name>pw_gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// Close shared memory object file descriptor as it is no longer</comment>
	<comment type="line">// needed after having called ftruncate()</comment>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// A function that duplicates a string and replaces all characters "s" by "r"</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>__attribute__</name> <argument_list>(<argument><expr><operator>(</operator><name>malloc</name><operator>)</operator></expr></argument>)</argument_list> <name>str_replace</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>input</name></expr></argument>,
                                                  <argument><expr><specifier>const</specifier> <name>char</name> <name>s</name></expr></argument>,
                                                  <argument><expr><specifier>const</specifier> <name>char</name> <name>r</name></expr></argument>,
                                                  <argument><expr><name>unsigned</name> <name>int</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list>
<block>{<block_content>
	<comment type="line">// Duplicate string</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>copy</name> <init>= <expr><call><name>strdup</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>copy</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// Woring pointer</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ix</name> <init>= <expr><name>copy</name></expr></init></decl>;</decl_stmt>
	<comment type="line">// Loop over string until there are no further "s" chars in the string</comment>
	<while>while<condition>(<expr><operator>(</operator><name>ix</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>ix</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>ix</name><operator>++</operator> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>N</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>copy</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>__attribute__</name> <argument_list>(<argument><expr><operator>(</operator><name>malloc</name><operator>)</operator></expr></argument>)</argument_list> <name>str_escape</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>input</name></expr></argument>, <argument><expr><name>unsigned</name> <name>int</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list>
<block>{<block_content>
	<comment type="line">// If no escaping is done, this routine returns the original pointer</comment>
	<comment type="line">// and N stays 0</comment>
	<expr_stmt><expr><operator>*</operator><name>N</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Replace any spaces by ~ if we find them in the domain name</comment>
		<comment type="line">// This is necessary as our telnet API uses space delimiters</comment>
		<return>return <expr><call><name>str_replace</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><literal type="char">'~'</literal></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name>bool</name></type> <name>strcmp_escaped</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>Na</name></decl>, <decl><type ref="prev"/><name>Nb</name></decl>;</decl_stmt>

	<comment type="line">// Input check</comment>
	<if_stmt><if>if<condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>b</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// Escape both inputs</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aa</name> <init>= <expr><call><name>str_escape</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Na</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>bb</name> <init>= <expr><call><name>str_escape</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Nb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Check for memory errors</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>aa</name> <operator>||</operator> <operator>!</operator><name>bb</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name>aa</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if<condition>(<expr><name>bb</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>result</name> <init>= <expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>aa</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>aa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>addstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>input</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"WARN: Called addstr() with NULL pointer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Get string length, add terminating character</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>avail_mem</name> <init>= <expr><name><name>shm_strings</name><operator>.</operator><name>size</name></name> <operator>-</operator> <name><name>shmSettings</name><operator>-&gt;</operator><name>next_str_pos</name></name></expr></init></decl>;</decl_stmt>

	<comment type="line">// If this is an empty string (only the terminating character is present),</comment>
	<comment type="line">// use the shared memory string at position zero instead of creating a new</comment>
	<comment type="line">// entry here. We also ensure that the given string is not too long to</comment>
	<comment type="line">// prevent possible memory corruption caused by strncpy() further down</comment>
	<if_stmt><if>if<condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name>len</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>pagesize</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"WARN: Shortening too long string (len %zu &gt; pagesize %i)"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>pagesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <name>pagesize</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if<condition>(<expr><name>len</name> <operator>&gt;</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>avail_mem</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"WARN: Shortening too long string (len %zu &gt; available memory %zu)"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>avail_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <name>avail_mem</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>N</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>str_escape</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>N</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>N</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"INFO: FTL replaced %u invalid characters with ~ in the query \"%s\""</literal></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Debugging output</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_SHMEM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Adding \"%s\" (len %zu) to buffer. next_str_pos is %u"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>shmSettings</name><operator>-&gt;</operator><name>next_str_pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Copy the C string pointed by str into the shared string buffer</comment>
	<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>shm_strings</name><operator>.</operator><name>ptr</name></name><operator>)</operator><index>[<expr><name><name>shmSettings</name><operator>-&gt;</operator><name>next_str_pos</name></name></expr>]</index></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Increment string length counter</comment>
	<expr_stmt><expr><name><name>shmSettings</name><operator>-&gt;</operator><name>next_str_pos</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

	<comment type="line">// Return start of stored string</comment>
	<return>return <expr><operator>(</operator><name><name>shmSettings</name><operator>-&gt;</operator><name>next_str_pos</name></name> <operator>-</operator> <name>len</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>_getstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Only access the string memory if this memory region has already been set</comment>
	<if_stmt><if>if<condition>(<expr><name>pos</name> <operator>&lt;</operator> <name><name>shmSettings</name><operator>-&gt;</operator><name>next_str_pos</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name><name>shm_strings</name><operator>.</operator><name>ptr</name></name><operator>)</operator><index>[<expr><name>pos</name></expr>]</index></expr>;</return></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"WARN: Tried to access %zu in %s() (%s:%i) but next_str_pos is %u"</literal></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name><name>shmSettings</name><operator>-&gt;</operator><name>next_str_pos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="string">""</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="line" format="doxygen">/// Create a mutex for shared memory</comment>
<function><type><specifier>static</specifier> <name>pthread_mutex_t</name></type> <name>create_mutex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
	<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Creating mutex"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>pthread_mutexattr_t</name></type> <name>lock_attr</name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name>lock</name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>

	<comment type="line">// Initialize the lock attributes</comment>
	<expr_stmt><expr><call><name>pthread_mutexattr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Allow the lock to be used by other processes</comment>
	<expr_stmt><expr><call><name>pthread_mutexattr_setpshared</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock_attr</name></expr></argument>, <argument><expr><name>PTHREAD_PROCESS_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Make the lock robust against process death</comment>
	<expr_stmt><expr><call><name>pthread_mutexattr_setrobust</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock_attr</name></expr></argument>, <argument><expr><name>PTHREAD_MUTEX_ROBUST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Initialize the lock</comment>
	<expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lock_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Destroy the lock attributes since we're done with it</comment>
	<expr_stmt><expr><call><name>pthread_mutexattr_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lock_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>lock</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>remap_shm</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Remap shared object pointers which might have changed</comment>
	<expr_stmt><expr><call><name>realloc_shm</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shm_queries</name></expr></argument>, <argument><expr><name><name>counters</name><operator>-&gt;</operator><name>queries_MAX</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>queriesData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>queries</name> <operator>=</operator> <operator>(</operator><name>queriesData</name><operator>*</operator><operator>)</operator><name><name>shm_queries</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>realloc_shm</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shm_domains</name></expr></argument>, <argument><expr><name><name>counters</name><operator>-&gt;</operator><name>domains_MAX</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>domainsData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>domains</name> <operator>=</operator> <operator>(</operator><name>domainsData</name><operator>*</operator><operator>)</operator><name><name>shm_domains</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>realloc_shm</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shm_clients</name></expr></argument>, <argument><expr><name><name>counters</name><operator>-&gt;</operator><name>clients_MAX</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>clientsData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>clients</name> <operator>=</operator> <operator>(</operator><name>clientsData</name><operator>*</operator><operator>)</operator><name><name>shm_clients</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>realloc_shm</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shm_upstreams</name></expr></argument>, <argument><expr><name><name>counters</name><operator>-&gt;</operator><name>upstreams_MAX</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>upstreamsData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>upstreams</name> <operator>=</operator> <operator>(</operator><name>upstreamsData</name><operator>*</operator><operator>)</operator><name><name>shm_upstreams</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>realloc_shm</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shm_dns_cache</name></expr></argument>, <argument><expr><name><name>counters</name><operator>-&gt;</operator><name>dns_cache_MAX</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DNSCacheData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dns_cache</name> <operator>=</operator> <operator>(</operator><name>DNSCacheData</name><operator>*</operator><operator>)</operator><name><name>shm_dns_cache</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>realloc_shm</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shm_per_client_regex</name></expr></argument>, <argument><expr><name><name>counters</name><operator>-&gt;</operator><name>per_client_regex_MAX</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// per-client-regex bools are not exposed by a global pointer</comment>

	<expr_stmt><expr><call><name>realloc_shm</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shm_strings</name></expr></argument>, <argument><expr><name><name>counters</name><operator>-&gt;</operator><name>strings_MAX</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// strings are not exposed by a global pointer</comment>

	<comment type="line">// Update local counter to reflect that we absorbed this change</comment>
	<expr_stmt><expr><name>local_shm_counter</name> <operator>=</operator> <name><name>shmSettings</name><operator>-&gt;</operator><name>global_shm_counter</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Obtain SHMEM lock</comment>
<function><type><name>void</name></type> <name>_lock_shm</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_LOCKS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Waiting for SHM lock in %s() (%s:%i)"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shmLock</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>outer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Error when obtaining outer SHM lock: %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>result</name> <operator>==</operator> <name>EOWNERDEAD</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Try to make the lock consistent if the other process died while</comment>
		<comment type="line">// holding the lock</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_LOCKS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Owner of outer SHM lock died, making lock consistent"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pthread_mutex_consistent</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shmLock</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>outer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Failed to make outer SHM lock consistent: %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Store lock owner after lock has been acquired and was made consistent (if required)</comment>
	<expr_stmt><expr><name><name>shmLock</name><operator>-&gt;</operator><name>owner</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shmLock</name><operator>-&gt;</operator><name>owner</name><operator>.</operator><name>tid</name></name> <operator>=</operator> <call><name>gettid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Check if this process needs to remap the shared memory objects</comment>
	<if_stmt><if>if<condition>(<expr><name>shmSettings</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
	   <name>local_shm_counter</name> <operator>!=</operator> <name><name>shmSettings</name><operator>-&gt;</operator><name>global_shm_counter</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_SHMEM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Remapping shared memory for current process %u %u"</literal></expr></argument>,
		             <argument><expr><name>local_shm_counter</name></expr></argument>, <argument><expr><name><name>shmSettings</name><operator>-&gt;</operator><name>global_shm_counter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>remap_shm</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Ensure we have enough shared memory available for new data</comment>
	<expr_stmt><expr><call><name>shm_ensure_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shmLock</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>inner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_LOCKS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Obtained SHM lock for %s() (%s:%i)"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Error when obtaining inner SHM lock: %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>result</name> <operator>==</operator> <name>EOWNERDEAD</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Try to make the lock consistent if the other process died while</comment>
		<comment type="line">// holding the lock</comment>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_LOCKS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Owner of inner SHM lock died, making lock consistent"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pthread_mutex_consistent</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shmLock</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>inner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Failed to make inner SHM lock consistent: %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// Release SHM lock</comment>
<function><type><name>void</name></type> <name>_unlock_shm</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>func</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_LOCKS</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_our_lock</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"ERROR: Tried to unlock but lock is owned by %li/%li"</literal></expr></argument>,
		     <argument><expr><operator>(</operator><name>long</name> <name>int</name><operator>)</operator><name><name>shmLock</name><operator>-&gt;</operator><name>owner</name><operator>.</operator><name>pid</name></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>int</name><operator>)</operator><name><name>shmLock</name><operator>-&gt;</operator><name>owner</name><operator>.</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Unlock mutex</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shmLock</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>inner</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>shmLock</name><operator>-&gt;</operator><name>owner</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shmLock</name><operator>-&gt;</operator><name>owner</name><operator>.</operator><name>tid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_LOCKS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Removed lock in %s() (%s:%i)"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Failed to unlock inner SHM lock: %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shmLock</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>outer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Failed to unlock outer SHM lock: %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// Return if we locked this mutex (PID and TID match)</comment>
<function><type><name>bool</name></type> <name>is_our_lock</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name><name>shmLock</name><operator>-&gt;</operator><name>owner</name><operator>.</operator><name>pid</name></name> <operator>==</operator> <call><name>getpid</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
	   <name><name>shmLock</name><operator>-&gt;</operator><name>owner</name><operator>.</operator><name>tid</name></name> <operator>==</operator> <call><name>gettid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>init_shmem</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<comment type="line">// Get kernel's page size</comment>
	<expr_stmt><expr><name>pagesize</name> <operator>=</operator> <call><name>getpagesize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/****************************** shared memory lock ******************************/</comment>
	<comment type="line">// Try to create shared memory object</comment>
	<expr_stmt><expr><name>shm_lock</name> <operator>=</operator> <call><name>create_shm</name><argument_list>(<argument><expr><name>SHARED_LOCK_NAME</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmLock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>shm_lock</name><operator>.</operator><name>ptr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>shmLock</name> <operator>=</operator> <operator>(</operator><name>ShmLock</name><operator>*</operator><operator>)</operator><name><name>shm_lock</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shmLock</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>outer</name></name> <operator>=</operator> <call><name>create_mutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shmLock</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>inner</name></name> <operator>=</operator> <call><name>create_mutex</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/****************************** shared counters struct ******************************/</comment>
	<comment type="line">// Try to create shared memory object</comment>
	<expr_stmt><expr><name>shm_counters</name> <operator>=</operator> <call><name>create_shm</name><argument_list>(<argument><expr><name>SHARED_COUNTERS_NAME</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>countersStruct</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>shm_counters</name><operator>.</operator><name>ptr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>counters</name> <operator>=</operator> <operator>(</operator><name>countersStruct</name><operator>*</operator><operator>)</operator><name><name>shm_counters</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/****************************** shared settings struct ******************************/</comment>
	<comment type="line">// Try to create shared memory object</comment>
	<expr_stmt><expr><name>shm_settings</name> <operator>=</operator> <call><name>create_shm</name><argument_list>(<argument><expr><name>SHARED_SETTINGS_NAME</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmSettings</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>shm_settings</name><operator>.</operator><name>ptr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>shmSettings</name> <operator>=</operator> <operator>(</operator><name>ShmSettings</name><operator>*</operator><operator>)</operator><name><name>shm_settings</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shmSettings</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <name>SHARED_MEMORY_VERSION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shmSettings</name><operator>-&gt;</operator><name>global_shm_counter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shmSettings</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name>shmem_pid</name> <operator>=</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/****************************** shared strings buffer ******************************/</comment>
	<comment type="line">// Try to create shared memory object</comment>
	<expr_stmt><expr><name>shm_strings</name> <operator>=</operator> <call><name>create_shm</name><argument_list>(<argument><expr><name>SHARED_STRINGS_NAME</name></expr></argument>, <argument><expr><name>STRINGS_ALLOC_STEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>shm_strings</name><operator>.</operator><name>ptr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>strings_MAX</name></name> <operator>=</operator> <name><name>shm_strings</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

	<comment type="line">// Initialize shared string object with an empty string at position zero</comment>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>shm_strings</name><operator>.</operator><name>ptr</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>shmSettings</name><operator>-&gt;</operator><name>next_str_pos</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/****************************** shared domains struct ******************************/</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>get_optimal_object_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>domainsData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="line">// Try to create shared memory object</comment>
	<expr_stmt><expr><name>shm_domains</name> <operator>=</operator> <call><name>create_shm</name><argument_list>(<argument><expr><name>SHARED_DOMAINS_NAME</name></expr></argument>, <argument><expr><name>size</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>domainsData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>shm_domains</name><operator>.</operator><name>ptr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>domains</name> <operator>=</operator> <operator>(</operator><name>domainsData</name><operator>*</operator><operator>)</operator><name><name>shm_domains</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>domains_MAX</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/****************************** shared clients struct ******************************/</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>get_optimal_object_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>clientsData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// Try to create shared memory object</comment>
	<expr_stmt><expr><name>shm_clients</name> <operator>=</operator> <call><name>create_shm</name><argument_list>(<argument><expr><name>SHARED_CLIENTS_NAME</name></expr></argument>, <argument><expr><name>size</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>clientsData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>shm_clients</name><operator>.</operator><name>ptr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>clients</name> <operator>=</operator> <operator>(</operator><name>clientsData</name><operator>*</operator><operator>)</operator><name><name>shm_clients</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>clients_MAX</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/****************************** shared upstreams struct ******************************/</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>get_optimal_object_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>upstreamsData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// Try to create shared memory object</comment>
	<expr_stmt><expr><name>shm_upstreams</name> <operator>=</operator> <call><name>create_shm</name><argument_list>(<argument><expr><name>SHARED_UPSTREAMS_NAME</name></expr></argument>, <argument><expr><name>size</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>upstreamsData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>shm_upstreams</name><operator>.</operator><name>ptr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>upstreams</name> <operator>=</operator> <operator>(</operator><name>upstreamsData</name><operator>*</operator><operator>)</operator><name><name>shm_upstreams</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>upstreams_MAX</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/****************************** shared queries struct ******************************/</comment>
	<comment type="line">// Try to create shared memory object</comment>
	<expr_stmt><expr><name>shm_queries</name> <operator>=</operator> <call><name>create_shm</name><argument_list>(<argument><expr><name>SHARED_QUERIES_NAME</name></expr></argument>, <argument><expr><name>pagesize</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>queriesData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>shm_queries</name><operator>.</operator><name>ptr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>queries</name> <operator>=</operator> <operator>(</operator><name>queriesData</name><operator>*</operator><operator>)</operator><name><name>shm_queries</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>queries_MAX</name></name> <operator>=</operator> <name>pagesize</name></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/****************************** shared overTime struct ******************************/</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>get_optimal_object_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>overTimeData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>OVERTIME_SLOTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// Try to create shared memory object</comment>
	<expr_stmt><expr><name>shm_overTime</name> <operator>=</operator> <call><name>create_shm</name><argument_list>(<argument><expr><name>SHARED_OVERTIME_NAME</name></expr></argument>, <argument><expr><name>size</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>overTimeData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>shm_overTime</name><operator>.</operator><name>ptr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// set global pointer in overTime.c</comment>
	<expr_stmt><expr><name>overTime</name> <operator>=</operator> <operator>(</operator><name>overTimeData</name><operator>*</operator><operator>)</operator><name><name>shm_overTime</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/****************************** shared DNS cache struct ******************************/</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>get_optimal_object_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DNSCacheData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="line">// Try to create shared memory object</comment>
	<expr_stmt><expr><name>shm_dns_cache</name> <operator>=</operator> <call><name>create_shm</name><argument_list>(<argument><expr><name>SHARED_DNS_CACHE</name></expr></argument>, <argument><expr><name>size</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>DNSCacheData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>shm_dns_cache</name><operator>.</operator><name>ptr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>dns_cache</name> <operator>=</operator> <operator>(</operator><name>DNSCacheData</name><operator>*</operator><operator>)</operator><name><name>shm_dns_cache</name><operator>.</operator><name>ptr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>dns_cache_MAX</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/****************************** shared per-client regex buffer ******************************/</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <name>pagesize</name></expr>;</expr_stmt> <comment type="line">// Allocate one pagesize initially. This may be expanded later on</comment>
	<comment type="line">// Try to create shared memory object</comment>
	<expr_stmt><expr><name>shm_per_client_regex</name> <operator>=</operator> <call><name>create_shm</name><argument_list>(<argument><expr><name>SHARED_PER_CLIENT_REGEX</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>shm_per_client_regex</name><operator>.</operator><name>ptr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>per_client_regex_MAX</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// CHOWN all shared memory objects to supplied user/group</comment>
<function><type><name>void</name></type> <name>chown_all_shmem</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>passwd</name></name> <modifier>*</modifier></type><name>ent_pw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for<control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_SHMEM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>chown_shmem</name><argument_list>(<argument><expr><name><name>sharedMemories</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>ent_pw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="line">// Destroy mutex and, subsequently, delete all shared memory objects</comment>
<function><type><name>void</name></type> <name>destroy_shmem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// First, we destroy the mutex</comment>
	<if_stmt><if>if<condition>(<expr><name>shmLock</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pthread_mutex_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shmLock</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>inner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_mutex_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shmLock</name><operator>-&gt;</operator><name>lock</name><operator>.</operator><name>outer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>shmLock</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="line">// Then, we delete the shared memory objects</comment>
	<for>for<control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_SHMEM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>delete_shm</name><argument_list>(<argument><expr><name><name>sharedMemories</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="line" format="doxygen">/// Create shared memory</comment>
<comment type="line" format="doxygen">///</comment>
<comment type="line" format="doxygen">/// \param name the name of the shared memory</comment>
<comment type="line" format="doxygen">/// \param size the size to allocate</comment>
<comment type="line" format="doxygen">/// \return a structure with a pointer to the mounted shared memory. The pointer</comment>
<comment type="line" format="doxygen">/// will always be valid, because if it failed FTL will have exited.</comment>
<function><type><specifier>static</specifier> <name>SharedMemory</name></type> <name>create_shm</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>df</name><index>[<expr><literal type="number">64</literal></expr>]</index></name> <init>=  <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>percentage</name> <init>= <expr><call><name>get_dev_shm_usage</name><argument_list>(<argument><expr><name>df</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_SHMEM</name> <operator>||</operator> <operator>(</operator><name><name>config</name><operator>.</operator><name>check</name><operator>.</operator><name>shmem</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>percentage</name> <operator>&gt;</operator> <name><name>config</name><operator>.</operator><name>check</name><operator>.</operator><name>shmem</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Creating shared memory with name \"%s\" and size %zu (%s)"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>df</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>check</name><operator>.</operator><name>shmem</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>percentage</name> <operator>&gt;</operator> <name><name>config</name><operator>.</operator><name>check</name><operator>.</operator><name>shmem</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>log_resource_shortage</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>percentage</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SHMEM_PATH</name></expr></argument>, <argument><expr><name>df</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>SharedMemory</name></type> <name>sharedMemory</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>name</name> <operator>=</operator> <name>name</name></expr>,
		<expr><operator>.</operator><name>size</name> <operator>=</operator> <name>size</name></expr>,
		<expr><operator>.</operator><name>ptr</name> <operator>=</operator> <name>NULL</name></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<comment type="line">// Create the shared memory file in read/write mode with 600 (u+rw) permissions</comment>
	<comment type="line">// and the following open flags:</comment>
	<comment type="line">// - O_RDWR: Open the object for read-write access (we need to be able to modify the locks)</comment>
	<comment type="line">// - O_CREAT: Create the shared memory object if it does not exist.</comment>
	<comment type="line">// - O_EXCL: Return an error if a shared memory object with the given name already exists.</comment>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>fd</name> <init>= <expr><call><name>shm_open</name><argument_list>(<argument><expr><name><name>sharedMemory</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_EXCL</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Check for `shm_open` error</comment>
	<if_stmt><if>if<condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"FATAL: create_shm(): Failed to create shared memory object \"%s\": %s"</literal></expr></argument>,
		     <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>sharedMemory</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Allocate shared memory object to specified size</comment>
	<comment type="line">// Using f[tl]allocate() will ensure that there's actually space for</comment>
	<comment type="line">// this file. Otherwise we end up with a sparse file that can give</comment>
	<comment type="line">// SIGBUS if we run out of space while writing to it.</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ret</name> <init>= <expr><call><name>ftlallocate</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0U</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"FATAL: create_shm(): Failed to resize \"%s\" (%i) to %zu: %s (%i)"</literal></expr></argument>,
		     <argument><expr><name><name>sharedMemory</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Update how much memory FTL uses</comment>
	<comment type="line">// We only add here as this is a new file</comment>
	<expr_stmt><expr><name>used_shmem</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>

	<comment type="line">// Create shared memory mapping</comment>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>shm</name> <init>= <expr><call><name>mmap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>PROT_READ</name> <operator>|</operator> <name>PROT_WRITE</name></expr></argument>, <argument><expr><name>MAP_SHARED</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Check for `mmap` error</comment>
	<if_stmt><if>if<condition>(<expr><name>shm</name> <operator>==</operator> <name>MAP_FAILED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"FATAL: create_shm(): Failed to map shared memory object \"%s\" (%i): %s"</literal></expr></argument>,
		     <argument><expr><name><name>sharedMemory</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>sharedMemory</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Close shared memory object file descriptor as it is no longer</comment>
	<comment type="line">// needed after having called mmap()</comment>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sharedMemory</name><operator>.</operator><name>ptr</name></name> <operator>=</operator> <name>shm</name></expr>;</expr_stmt>
	<return>return <expr><name>sharedMemory</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>enlarge_shmem_struct</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SharedMemory</name> <modifier>*</modifier></type><name>sharedMemory</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>sizeofobj</name></decl>, <decl><type ref="prev"/><name>allocation_step</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>counter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// Select type of struct that should be enlarged</comment>
	<switch>switch<condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>QUERIES</name></expr>:</case>
			<expr_stmt><expr><name>sharedMemory</name> <operator>=</operator> <operator>&amp;</operator><name>shm_queries</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>allocation_step</name> <operator>=</operator> <name>pagesize</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>sizeofobj</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>queriesData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><name>counter</name> <operator>=</operator> <operator>&amp;</operator><name><name>counters</name><operator>-&gt;</operator><name>queries_MAX</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CLIENTS</name></expr>:</case>
			<expr_stmt><expr><name>sharedMemory</name> <operator>=</operator> <operator>&amp;</operator><name>shm_clients</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>allocation_step</name> <operator>=</operator> <call><name>get_optimal_object_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>clientsData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sizeofobj</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>clientsData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><name>counter</name> <operator>=</operator> <operator>&amp;</operator><name><name>counters</name><operator>-&gt;</operator><name>clients_MAX</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DOMAINS</name></expr>:</case>
			<expr_stmt><expr><name>sharedMemory</name> <operator>=</operator> <operator>&amp;</operator><name>shm_domains</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>allocation_step</name> <operator>=</operator> <call><name>get_optimal_object_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>domainsData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sizeofobj</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>domainsData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><name>counter</name> <operator>=</operator> <operator>&amp;</operator><name><name>counters</name><operator>-&gt;</operator><name>domains_MAX</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>UPSTREAMS</name></expr>:</case>
			<expr_stmt><expr><name>sharedMemory</name> <operator>=</operator> <operator>&amp;</operator><name>shm_upstreams</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>allocation_step</name> <operator>=</operator> <call><name>get_optimal_object_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>upstreamsData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sizeofobj</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>upstreamsData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><name>counter</name> <operator>=</operator> <operator>&amp;</operator><name><name>counters</name><operator>-&gt;</operator><name>upstreams_MAX</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DNS_CACHE</name></expr>:</case>
			<expr_stmt><expr><name>sharedMemory</name> <operator>=</operator> <operator>&amp;</operator><name>shm_dns_cache</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>allocation_step</name> <operator>=</operator> <call><name>get_optimal_object_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DNSCacheData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sizeofobj</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DNSCacheData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><name>counter</name> <operator>=</operator> <operator>&amp;</operator><name><name>counters</name><operator>-&gt;</operator><name>dns_cache_MAX</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>STRINGS</name></expr>:</case>
			<expr_stmt><expr><name>sharedMemory</name> <operator>=</operator> <operator>&amp;</operator><name>shm_strings</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>allocation_step</name> <operator>=</operator> <name>STRINGS_ALLOC_STEP</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>sizeofobj</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>counter</name> <operator>=</operator> <operator>&amp;</operator><name><name>counters</name><operator>-&gt;</operator><name>strings_MAX</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Invalid argument in enlarge_shmem_struct(%i)"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></switch>

	<comment type="line">// Reallocate enough space for requested object</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>current</name> <init>= <expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>size</name></name><operator>/</operator><name>sizeofobj</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>realloc_shm</name><argument_list>(<argument><expr><name>sharedMemory</name></expr></argument>, <argument><expr><name>current</name> <operator>+</operator> <name>allocation_step</name></expr></argument>, <argument><expr><name>sizeofobj</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Add allocated memory to corresponding counter</comment>
	<expr_stmt><expr><operator>*</operator><name>counter</name> <operator>+=</operator> <name>allocation_step</name></expr>;</expr_stmt>

	<return>return <expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>realloc_shm</name><parameter_list>(<parameter><decl><type><name>SharedMemory</name> <modifier>*</modifier></type><name>sharedMemory</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>resize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Absolute target size</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name> <init>= <expr><name>size1</name> <operator>*</operator> <name>size2</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// Log that we are doing something here</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>df</name><index>[<expr><literal type="number">64</literal></expr>]</index></name> <init>=  <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>percentage</name> <init>= <expr><call><name>get_dev_shm_usage</name><argument_list>(<argument><expr><name>df</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="line">// Log output</comment>
	<if_stmt><if>if<condition>(<expr><name>resize</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Resizing \"%s\" from %zu to (%zu * %zu) == %zu (%s)"</literal></expr></argument>,
		     <argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>size1</name></expr></argument>, <argument><expr><name>size2</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>df</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"Remapping \"%s\" from %zu to (%zu * %zu) == %zu"</literal></expr></argument>,
		     <argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>size1</name></expr></argument>, <argument><expr><name>size2</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>check</name><operator>.</operator><name>shmem</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>percentage</name> <operator>&gt;</operator> <name><name>config</name><operator>.</operator><name>check</name><operator>.</operator><name>shmem</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>log_resource_shortage</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>percentage</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SHMEM_PATH</name></expr></argument>, <argument><expr><name>df</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="line">// Resize shard memory object if requested</comment>
	<comment type="line">// If not, we only remap a shared memory object which might have changed</comment>
	<comment type="line">// in another process. This happens when pihole-FTL forks due to incoming</comment>
	<comment type="line">// TCP requests.</comment>
	<if_stmt><if>if<condition>(<expr><name>resize</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Verify shared memory ownership</comment>
		<expr_stmt><expr><call><name>verify_shmem_pid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Open shared memory object</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>fd</name> <init>= <expr><call><name>shm_open</name><argument_list>(<argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>O_RDWR</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"FATAL: realloc_shm(): Failed to open shared memory object \"%s\": %s"</literal></expr></argument>,
			     <argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Allocate shared memory object to specified size</comment>
		<comment type="line">// Using f[tl]allocate() will ensure that there's actually space for</comment>
		<comment type="line">// this file. Otherwise we end up with a sparse file that can give</comment>
		<comment type="line">// SIGBUS if we run out of space while writing to it.</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ret</name> <init>= <expr><call><name>ftlallocate</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0U</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"FATAL: realloc_shm(): Failed to resize \"%s\" (%i) to %zu: %s (%i)"</literal></expr></argument>,
			     <argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Close shared memory object file descriptor as it is no longer</comment>
		<comment type="line">// needed after having called f[tl]allocate()</comment>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="line">// Update shm counters to indicate that at least one shared memory object changed</comment>
		<expr_stmt><expr><name><name>shmSettings</name><operator>-&gt;</operator><name>global_shm_counter</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>local_shm_counter</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>new_ptr</name> <init>= <expr><call><name>mremap</name><argument_list>(<argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>MREMAP_MAYMOVE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>new_ptr</name> <operator>==</operator> <name>MAP_FAILED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"FATAL: realloc_shm(): mremap(%p, %zu, %zu, MREMAP_MAYMOVE): Failed to reallocate \"%s\": %s"</literal></expr></argument>,
		     <argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
		     <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Update how much memory FTL uses</comment>
	<comment type="line">// We add the difference between updated and previous size</comment>
	<expr_stmt><expr><name>used_shmem</name> <operator>+=</operator> <operator>(</operator><name>size</name> <operator>-</operator> <name><name>sharedMemory</name><operator>-&gt;</operator><name>size</name></name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_SHMEM</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>ptr</name></name> <operator>==</operator> <name>new_ptr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"SHMEM pointer not updated: %p (%zu %zu)"</literal></expr></argument>,
			     <argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"SHMEM pointer updated: %p -&gt; %p (%zu %zu)"</literal></expr></argument>,
			     <argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>new_ptr</name></expr></argument>, <argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>new_ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>delete_shm</name><parameter_list>(<parameter><decl><type><name>SharedMemory</name> <modifier>*</modifier></type><name>sharedMemory</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Unmap shared memory (if mmapped)</comment>
	<if_stmt><if>if<condition>(<expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>ptr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><call><name>munmap</name><argument_list>(<argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"delete_shm(): munmap(%p, %zu) failed: %s"</literal></expr></argument>, <argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Now you can no longer `shm_open` the memory, and once all others</comment>
	<comment type="line">// unlink, it will be destroyed.</comment>
	<if_stmt><if>if<condition>(<expr><call><name>shm_unlink</name><argument_list>(<argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"delete_shm(): shm_unlink(%s) failed: %s"</literal></expr></argument>, <argument><expr><name><name>sharedMemory</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// Euclidean algorithm to return greatest common divisor of the numbers</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier><operator>)</operator></expr></argument>)</argument_list> <name>gcd</name><argument_list>(<argument><expr><name>size_t</name> <name>a</name></expr></argument>, <argument><expr><name>size_t</name> <name>b</name></expr></argument>)</argument_list>
<block>{<block_content>
	<while>while<condition>(<expr><name>b</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>temp</name> <init>= <expr><name>b</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>b</name> <operator>=</operator> <name>a</name> <operator>%</operator> <name>b</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>a</name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<comment type="line">// Function to return the optimal (minimum) size for page-aligned</comment>
<comment type="line">// shared memory objects. This routine works by computing the LCM</comment>
<comment type="line">// of two numbers, the pagesize and the size of a single element</comment>
<comment type="line">// in the shared memory object</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>get_optimal_object_size</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>objsize</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>minsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// optsize and minsize are in units of objsize</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>optsize</name> <init>= <expr><name>pagesize</name> <operator>/</operator> <call><name>gcd</name><argument_list>(<argument><expr><name>pagesize</name></expr></argument>, <argument><expr><name>objsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>optsize</name> <operator>&lt;</operator> <name>minsize</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_SHMEM</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"DEBUG: LCM(%i, %zu) == %zu &lt; %zu"</literal></expr></argument>,
			     <argument><expr><name>pagesize</name></expr></argument>, <argument><expr><name>objsize</name></expr></argument>,
			     <argument><expr><name>optsize</name><operator>*</operator><name>objsize</name></expr></argument>,
			     <argument><expr><name>minsize</name><operator>*</operator><name>objsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Upscale optimal size by a certain factor</comment>
		<comment type="line">// Logic of this computation:</comment>
		<comment type="line">// First part: Integer division, may cause clipping, e.g., 5/3 = 1</comment>
		<comment type="line">// Second part: Catch a possibly happened clipping event by adding</comment>
		<comment type="line">//              one to the number: (5 % 3 != 0) is 1</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>multiplier</name> <init>= <expr><operator>(</operator><name>minsize</name><operator>/</operator><name>optsize</name><operator>)</operator> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>minsize</name> <operator>%</operator> <name>optsize</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1u</literal></expr> </then><else>: <expr><literal type="number">0u</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_SHMEM</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"DEBUG: Using %zu*%zu == %zu &gt;= %zu"</literal></expr></argument>,
			     <argument><expr><name>multiplier</name></expr></argument>, <argument><expr><name>optsize</name><operator>*</operator><name>objsize</name></expr></argument>,
			     <argument><expr><name>multiplier</name><operator>*</operator><name>optsize</name><operator>*</operator><name>objsize</name></expr></argument>,
			     <argument><expr><name>minsize</name><operator>*</operator><name>objsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="line">// As optsize ensures perfect page-alignment,</comment>
		<comment type="line">// any multiple of it will be aligned as well</comment>
		<return>return <expr><name>multiplier</name><operator>*</operator><name>optsize</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_SHMEM</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"DEBUG: LCM(%i, %zu) == %zu &gt;= %zu"</literal></expr></argument>,
			     <argument><expr><name>pagesize</name></expr></argument>, <argument><expr><name>objsize</name></expr></argument>,
			     <argument><expr><name>optsize</name><operator>*</operator><name>objsize</name></expr></argument>,
			     <argument><expr><name>minsize</name><operator>*</operator><name>objsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="line">// Return computed optimal size</comment>
		<return>return <expr><name>optsize</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">// Enlarge shared memory to be able to hold at least one new record</comment>
<function><type><name>void</name></type> <name>shm_ensure_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name><name>counters</name><operator>-&gt;</operator><name>queries</name></name> <operator>&gt;=</operator> <name><name>counters</name><operator>-&gt;</operator><name>queries_MAX</name></name><operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Have to reallocate shared memory</comment>
		<expr_stmt><expr><name>queries</name> <operator>=</operator> <call><name>enlarge_shmem_struct</name><argument_list>(<argument><expr><name>QUERIES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>queries</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"FATAL: Memory allocation failed! Exiting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>counters</name><operator>-&gt;</operator><name>upstreams</name></name> <operator>&gt;=</operator> <name><name>counters</name><operator>-&gt;</operator><name>upstreams_MAX</name></name><operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Have to reallocate shared memory</comment>
		<expr_stmt><expr><name>upstreams</name> <operator>=</operator> <call><name>enlarge_shmem_struct</name><argument_list>(<argument><expr><name>UPSTREAMS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>upstreams</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"FATAL: Memory allocation failed! Exiting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>counters</name><operator>-&gt;</operator><name>clients</name></name> <operator>&gt;=</operator> <name><name>counters</name><operator>-&gt;</operator><name>clients_MAX</name></name><operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Have to reallocate shared memory</comment>
		<expr_stmt><expr><name>clients</name> <operator>=</operator> <call><name>enlarge_shmem_struct</name><argument_list>(<argument><expr><name>CLIENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>clients</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"FATAL: Memory allocation failed! Exiting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>counters</name><operator>-&gt;</operator><name>domains</name></name> <operator>&gt;=</operator> <name><name>counters</name><operator>-&gt;</operator><name>domains_MAX</name></name><operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Have to reallocate shared memory</comment>
		<expr_stmt><expr><name>domains</name> <operator>=</operator> <call><name>enlarge_shmem_struct</name><argument_list>(<argument><expr><name>DOMAINS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>domains</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"FATAL: Memory allocation failed! Exiting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>counters</name><operator>-&gt;</operator><name>dns_cache_size</name></name> <operator>&gt;=</operator> <name><name>counters</name><operator>-&gt;</operator><name>dns_cache_MAX</name></name><operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Have to reallocate shared memory</comment>
		<expr_stmt><expr><name>dns_cache</name> <operator>=</operator> <call><name>enlarge_shmem_struct</name><argument_list>(<argument><expr><name>DNS_CACHE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if<condition>(<expr><name>dns_cache</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"FATAL: Memory allocation failed! Exiting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if<condition>(<expr><name><name>shmSettings</name><operator>-&gt;</operator><name>next_str_pos</name></name> <operator>+</operator> <name>STRINGS_ALLOC_STEP</name> <operator>&gt;=</operator> <name><name>shm_strings</name><operator>.</operator><name>size</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// Have to reallocate shared memory</comment>
		<if_stmt><if>if<condition>(<expr><call><name>enlarge_shmem_struct</name><argument_list>(<argument><expr><name>STRINGS</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"FATAL: Memory allocation failed! Exiting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>reset_per_client_regex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>clientID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>num_regex_tot</name> <init>= <expr><call><name>get_num_regex</name><argument_list>(<argument><expr><name>REGEX_MAX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// total number</comment>
	<for>for<control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0u</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_regex_tot</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="line">// Zero-initialize/reset (= false) all regex (white + black)</comment>
		<expr_stmt><expr><call><name>set_per_client_regex</name><argument_list>(<argument><expr><name>clientID</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>add_per_client_regex</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>clientID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>num_regex_tot</name> <init>= <expr><call><name>get_num_regex</name><argument_list>(<argument><expr><name>REGEX_MAX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// total number</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>size</name> <init>= <expr><call><name>get_optimal_object_size</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>counters</name><operator>-&gt;</operator><name>clients</name></name> <operator>*</operator> <name>num_regex_tot</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>size</name> <operator>&gt;</operator> <name><name>shm_per_client_regex</name><operator>.</operator><name>size</name></name> <operator>&amp;&amp;</operator>
	   <call><name>realloc_shm</name><argument_list>(<argument><expr><operator>&amp;</operator><name>shm_per_client_regex</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>reset_per_client_regex</name><argument_list>(<argument><expr><name>clientID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counters</name><operator>-&gt;</operator><name>per_client_regex_MAX</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>get_per_client_regex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>clientID</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>regexID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>num_regex_tot</name> <init>= <expr><call><name>get_num_regex</name><argument_list>(<argument><expr><name>REGEX_MAX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// total number</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>id</name> <init>= <expr><name>clientID</name> <operator>*</operator> <name>num_regex_tot</name> <operator>+</operator> <name>regexID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>maxval</name> <init>= <expr><name><name>shm_per_client_regex</name><operator>.</operator><name>size</name></name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>id</name> <operator>&gt;</operator> <name>maxval</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"ERROR: get_per_client_regex(%d, %d): Out of bounds (%d &gt; %d * %d, shm_per_client_regex.size = %zd)!"</literal></expr></argument>,
		     <argument><expr><name>clientID</name></expr></argument>, <argument><expr><name>regexID</name></expr></argument>,
		     <argument><expr><name>id</name></expr></argument>, <argument><expr><name><name>counters</name><operator>-&gt;</operator><name>clients</name></name></expr></argument>, <argument><expr><name>num_regex_tot</name></expr></argument>, <argument><expr><name>maxval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><operator>(</operator><operator>(</operator><name>bool</name><operator>*</operator><operator>)</operator> <name><name>shm_per_client_regex</name><operator>.</operator><name>ptr</name></name><operator>)</operator><index>[<expr><name>id</name></expr>]</index></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>set_per_client_regex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>clientID</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>regexID</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>bool</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>num_regex_tot</name> <init>= <expr><call><name>get_num_regex</name><argument_list>(<argument><expr><name>REGEX_MAX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// total number</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name>id</name> <init>= <expr><name>clientID</name> <operator>*</operator> <name>num_regex_tot</name> <operator>+</operator> <name>regexID</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>maxval</name> <init>= <expr><name><name>shm_per_client_regex</name><operator>.</operator><name>size</name></name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if<condition>(<expr><name>id</name> <operator>&gt;</operator> <name>maxval</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"ERROR: set_per_client_regex(%d, %d, %s): Out of bounds (%d &gt; %d * %d, shm_per_client_regex.size = %zd)!"</literal></expr></argument>,
		     <argument><expr><name>clientID</name></expr></argument>, <argument><expr><name>regexID</name></expr></argument>, <argument><expr><ternary><condition><expr><name>value</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>,
		     <argument><expr><name>id</name></expr></argument>, <argument><expr><name><name>counters</name><operator>-&gt;</operator><name>clients</name></name></expr></argument>, <argument><expr><name>num_regex_tot</name></expr></argument>, <argument><expr><name>maxval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>bool</name><operator>*</operator><operator>)</operator> <name><name>shm_per_client_regex</name><operator>.</operator><name>ptr</name></name><operator>)</operator><index>[<expr><name>id</name></expr>]</index> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>check_range</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ID</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>MAXID</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Check bounds</comment>
	<if_stmt><if>if<condition>(<expr><name><name>ID</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>ID</name></expr></argument> &gt;</argument_list></name> <name>MAXID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"ERROR: Trying to access %s ID %i, but maximum is %i"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>ID</name></expr></argument>, <argument><expr><name>MAXID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"       found in %s() (%s:%i)"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><call><name>short_path</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Everything okay</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>check_magic</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ID</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>checkMagic</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>magic</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// Check magic only if requested (skipped for new entries which are uninitialized)</comment>
	<if_stmt><if>if<condition>(<expr><name>checkMagic</name> <operator>&amp;&amp;</operator> <name>magic</name> <operator>!=</operator> <name>MAGICBYTE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"ERROR: Trying to access %s ID %i, but magic byte is %x"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>ID</name></expr></argument>, <argument><expr><name>magic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"       found in %s() (%s:%i)"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><call><name>short_path</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="line">// Everything okay</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>queriesData</name><modifier>*</modifier></type> <name>_getQuery</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>queryID</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>checkMagic</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// This does not exist, return a NULL pointer</comment>
	<if_stmt><if>if<condition>(<expr><name>queryID</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// We are not in a locked situation, return a NULL pointer</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_LOCKS</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_our_lock</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"ERROR: Tried to obtain query pointer without lock in %s() (%s:%i)!"</literal></expr></argument>,
		     <argument><expr><name>func</name></expr></argument>, <argument><expr><call><name>short_path</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>generate_backtrace</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>check_range</name><argument_list>(<argument><expr><name>queryID</name></expr></argument>, <argument><expr><name><name>counters</name><operator>-&gt;</operator><name>queries_MAX</name></name></expr></argument>, <argument><expr><literal type="string">"query"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	   <call><name>check_magic</name><argument_list>(<argument><expr><name>queryID</name></expr></argument>, <argument><expr><name>checkMagic</name></expr></argument>, <argument><expr><name><name>queries</name><index>[<expr><name>queryID</name></expr>]</index></name><operator>.</operator><name>magic</name></expr></argument>, <argument><expr><literal type="string">"query"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>&amp;</operator><name><name>queries</name><index>[<expr><name>queryID</name></expr>]</index></name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>clientsData</name><modifier>*</modifier></type> <name>_getClient</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>clientID</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>checkMagic</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// This does not exist, we return a NULL pointer</comment>
	<if_stmt><if>if<condition>(<expr><name>clientID</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// We are not in a locked situation, return a NULL pointer</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_LOCKS</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_our_lock</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"ERROR: Tried to obtain client pointer without lock in %s() (%s:%i)!"</literal></expr></argument>,
		     <argument><expr><name>func</name></expr></argument>, <argument><expr><call><name>short_path</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>generate_backtrace</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>check_range</name><argument_list>(<argument><expr><name>clientID</name></expr></argument>, <argument><expr><name><name>counters</name><operator>-&gt;</operator><name>clients_MAX</name></name></expr></argument>, <argument><expr><literal type="string">"client"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	   <call><name>check_magic</name><argument_list>(<argument><expr><name>clientID</name></expr></argument>, <argument><expr><name>checkMagic</name></expr></argument>, <argument><expr><name><name>clients</name><index>[<expr><name>clientID</name></expr>]</index></name><operator>.</operator><name>magic</name></expr></argument>, <argument><expr><literal type="string">"client"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>&amp;</operator><name><name>clients</name><index>[<expr><name>clientID</name></expr>]</index></name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>domainsData</name><modifier>*</modifier></type> <name>_getDomain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>domainID</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>checkMagic</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// This does not exist, we return a NULL pointer</comment>
	<if_stmt><if>if<condition>(<expr><name>domainID</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// We are not in a locked situation, return a NULL pointer</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_LOCKS</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_our_lock</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"ERROR: Tried to obtain domain pointer without lock in %s() (%s:%i)!"</literal></expr></argument>,
		     <argument><expr><name>func</name></expr></argument>, <argument><expr><call><name>short_path</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>generate_backtrace</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>check_range</name><argument_list>(<argument><expr><name>domainID</name></expr></argument>, <argument><expr><name><name>counters</name><operator>-&gt;</operator><name>domains_MAX</name></name></expr></argument>, <argument><expr><literal type="string">"domain"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	   <call><name>check_magic</name><argument_list>(<argument><expr><name>domainID</name></expr></argument>, <argument><expr><name>checkMagic</name></expr></argument>, <argument><expr><name><name>domains</name><index>[<expr><name>domainID</name></expr>]</index></name><operator>.</operator><name>magic</name></expr></argument>, <argument><expr><literal type="string">"domain"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>&amp;</operator><name><name>domains</name><index>[<expr><name>domainID</name></expr>]</index></name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>upstreamsData</name><modifier>*</modifier></type> <name>_getUpstream</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>upstreamID</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>checkMagic</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// This does not exist, we return a NULL pointer</comment>
	<if_stmt><if>if<condition>(<expr><name>upstreamID</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// We are not in a locked situation, return a NULL pointer</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_LOCKS</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_our_lock</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"ERROR: Tried to obtain upstream pointer without lock in %s() (%s:%i)!"</literal></expr></argument>,
		     <argument><expr><name>func</name></expr></argument>, <argument><expr><call><name>short_path</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>generate_backtrace</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>check_range</name><argument_list>(<argument><expr><name>upstreamID</name></expr></argument>, <argument><expr><name><name>counters</name><operator>-&gt;</operator><name>upstreams_MAX</name></name></expr></argument>, <argument><expr><literal type="string">"upstream"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	   <call><name>check_magic</name><argument_list>(<argument><expr><name>upstreamID</name></expr></argument>, <argument><expr><name>checkMagic</name></expr></argument>, <argument><expr><name><name>upstreams</name><index>[<expr><name>upstreamID</name></expr>]</index></name><operator>.</operator><name>magic</name></expr></argument>, <argument><expr><literal type="string">"upstream"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>&amp;</operator><name><name>upstreams</name><index>[<expr><name>upstreamID</name></expr>]</index></name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>DNSCacheData</name><modifier>*</modifier></type> <name>_getDNSCache</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cacheID</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>checkMagic</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// This does not exist, we return a NULL pointer</comment>
	<if_stmt><if>if<condition>(<expr><name>cacheID</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="line">// We are not in a locked situation, return a NULL pointer</comment>
	<if_stmt><if>if<condition>(<expr><name><name>config</name><operator>.</operator><name>debug</name></name> <operator>&amp;</operator> <name>DEBUG_LOCKS</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_our_lock</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>logg</name><argument_list>(<argument><expr><literal type="string">"ERROR: Tried to obtain cache pointer without lock in %s() (%s:%i)!"</literal></expr></argument>,
		     <argument><expr><name>func</name></expr></argument>, <argument><expr><call><name>short_path</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>generate_backtrace</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if<condition>(<expr><call><name>check_range</name><argument_list>(<argument><expr><name>cacheID</name></expr></argument>, <argument><expr><name><name>counters</name><operator>-&gt;</operator><name>dns_cache_MAX</name></name></expr></argument>, <argument><expr><literal type="string">"dns_cache"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	   <call><name>check_magic</name><argument_list>(<argument><expr><name>cacheID</name></expr></argument>, <argument><expr><name>checkMagic</name></expr></argument>, <argument><expr><name><name>dns_cache</name><index>[<expr><name>cacheID</name></expr>]</index></name><operator>.</operator><name>magic</name></expr></argument>, <argument><expr><literal type="string">"dns_cache"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>&amp;</operator><name><name>dns_cache</name><index>[<expr><name>cacheID</name></expr>]</index></name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
